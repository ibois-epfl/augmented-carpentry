{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Augmented Carpentry Research","text":"<p>Welcome to Augmented Carpentry Research documentation page.</p>"},{"location":"installation/","title":"Getting started","text":"<p>AC can only be only compiled from source for now and runs only on Debian-based systems. The software is built with C++ and compiled with CMake into an executable. You can either download the source code and its GitHub submodules like this.</p> <pre><code>git clone --recurse-submodules https://github.com/ibois-epfl/augmented-carpentry.git\n</code></pre>"},{"location":"installation/#dependecies","title":"Dependecies","text":"<p>First refresh the package list and install the necessary dependencies: <pre><code>apt-get -qq update &amp;&amp; apt-get -qq -y install g++ cmake git git-lfs\n</code></pre> And here's the system dependecies for the project: <pre><code>apt-get -qq update &amp;&amp; apt-get -qq -y install \\\nwget \\\ncurl \\\nunzip \\\nxvfb \\\nfreeglut3-dev \\\nlibfreetype-dev \\\nlibassimp-dev \\\nlibboost-all-dev \\\nlibeigen3-dev \\\nlibglew-dev \\\nlibglfw3-dev \\\nlibglm-dev \\\nlibgmp-dev \\\nlibgoogle-glog-dev \\\nlibmpfr-dev \\\nlibimgui-dev \\\nlibopencv-dev\n</code></pre></p> <p>The rest of the other dependecies will be automatically downloaded and installed by the CMake build system in the next steps.</p>"},{"location":"installation/#config-and-build","title":"Config and Build","text":"Wearable\u00a0\u00a0 Laptop <pre><code>cd augmented-carpentry\ncmake -S . -B build -DDEPLOY_ON_TOUCH=ON\ncmake --build build\n</code></pre> <pre><code>cd augmented-carpentry\ncmake -S . -B build\ncmake --build build\n</code></pre> <p>Tip</p> <p> <code>default_config.ini</code></p> <p>While running the code, make sure that <code>config.ini</code> and <code>assets/</code> exists in the current directory. If errors related to config present, please reconfigure the <code>config.ini</code> by copy-pasting the content from <code>/assets/default_config.ini</code>.</p>"},{"location":"installation/#run","title":"Run","text":"<p>To run the code be sure that your USB-Camera is connected and run the following command:</p> <pre><code>./build/bin/AC\n</code></pre> <p>That's it your are running Augmented Carpentry\ud83e\ude9a!</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2016-2024 Martin Donath</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"motivation/","title":"Motivation","text":""},{"location":"motivation/#timber-construction-landscape","title":"Timber Construction Landscape","text":"<p>The sustainability of timber construction depends not only on material selection but also on efficient, adaptable, and locally responsive production processes. Effective use of digital fabrication enhances timber's ecological advantages, yet the prevalent reliance on centralized, high-tech manufacturing infrastructures remains a limitation. Leading companies offer advanced CNC machining centers for linear and surface elements, featuring automated cutting, drilling, milling, and profiling, significantly improving production speed and precision. Despite their capabilities, these systems typically favor large-scale, standardized production, making customization or small-batch manufacturing challenging. High investment costs, substantial maintenance requirements, workflow disruptions, and technical complexity further restrict their use to well-funded entities. In Switzerland, SMEs dominate the timber construction industry, comprising 99.9% of companies and employing 98.6% of the workforce<sup>1</sup>. This trend extends across the broader construction sector, where SMEs account for the majority of businesses and employment opportunities<sup>1</sup>. Promoting accessible and flexible digital fabrication technologies can empower SMEs and larger firms alike, significantly expanding sustainable timber construction's economic and ecological benefits. Democratizing digital fabrication could distribute knowledge, skills, and production capabilities more evenly, enhancing industry resilience, optimizing logistics, and encouraging widespread adoption of shared digital fabrication resources.</p> <p></p> (A) Number of timber companies and (B) number of employees by size in the Swiss timber construction sector, categorized by company size in 2022. Micro (1--9 employees), small (10--49), and medium (50--249) companies, black reports the large companies exceeding 250 employees."},{"location":"motivation/#research-in-timber-robotic-construction","title":"Research in Timber Robotic Construction","text":"<p>Current research in timber robotic construction primarily focuses on achieving full automation and replicating complex designs difficult to realize through traditional methods. However, significant initial investment and maintenance costs limit these advancements to larger companies, disadvantaging smaller enterprises. Emphasis is shifting towards adaptability and user-friendly interfaces through Human-Robot Collaboration (HRC), aiming to integrate human expertise within robotic workflows. Despite valuable ergonomic and interface improvements, widespread adoption remains hindered by expensive robotic infrastructure and proprietary firmware constraints. Additionally, reliance on technology-intensive solutions faces challenges due to semiconductor and material shortages, prompting the question of whether digital fabrication should expand to foster more inclusive, flexible, and accessible technologies.</p>"},{"location":"motivation/#digitalization-of-manual-tasks","title":"Digitalization of Manual Tasks","text":"<p>Digitizing manual tasks represents a viable strategy for broadening digital timber fabrication accessibility. The human workforce remains central to timber construction but increasingly disconnected from digital advancements in Architecture, Engineering, and Construction (AEC). Digital workflows integrating Building Information Modeling (BIM) facilitate seamless robotic and CNC manufacturing, whereas manual operations still rely on traditional 2D execution methods, interrupting digital continuity and risking future devaluation of human skills. By digitally visualizing, assisting, and monitoring manual tasks, the gap between traditional craftshumanship and modern technology can be bridged. This integration enhances precision, accuracy, and provides real-time assistance without disrupting established practices.</p> <p></p> The cyber approach of Augmented Carpentry is in the middle: profiting of human dexterity and digital logics of CNC machines."},{"location":"motivation/#augmented-workspace","title":"Augmented Workspace","text":"<p>Bridging manual labor and digital fabrication in timber construction can effectively occur through retrofitting, preserving existing workflows while selectively integrating digital enhancements. By augmenting conventional woodworking tools with sensors, microcontrollers, and open-source software, workers benefit from precise, real-time data without substantial infrastructure overhaul. This approach extends digital precision throughout manual fabrication stages, offering scalable, cost-effective, and resilient solutions. Particularly suited for portable woodworking equipment, retrofitting enables Small and Medium-sized Enterprises (SMEs) and larger companies to mitigate resource dependencies and sustainably adopt new fabrication practices. Recent advancements demonstrate the potential of augmented tools; however, significant technical and conceptual challenges remain to achieve broader deployment.</p>"},{"location":"motivation/#augmented-carpentry","title":"<code>Augmented Carpentry</code>","text":"<p>All these considerations led to the development of the Augmented Carpentry system, a digital fabrication framework that aims to enhance manual woodworking processes by providing real-time feedback and assistance to operators. The system is designed to be user-friendly, cost-effective, and adaptable to various woodworking tasks, making it suitable for both small-scale and large-scale applications in the timber construction industry. This can be achieved by embedding ordinary tools with sensors and replacing conventional 2D execution drawings, manual markings, and physical jigs in timber fabrication with a design-to-production digital visual guidance system. Powered by a low-cost monocular camera, familiar interfaces, and a single 3D execution model, the system is designed to integrate with standard woodworking power tools, thus enabling operators to perform manual tasks with digital assistance. The produced augmented framework is named Augmented Carpentry. The development leading to this release is the result of a research carried on 4 years. The result is a functioning prototype that has been tested in the lab and in the field, and is now available for public use. The system is designed to be used with a variety of woodworking power tools, including chainsaws, circular saws, and routers. It is intended to be used by carpenters, builders, and other professionals in the construction industry and serve as a base for future research and development in the field of augmented reality in open-source digital fabrication.</p> <p></p> <p></p> <ol> <li> <p>Reference: Number of timber construction employees by company size in Switzerland in 2022. Data from the Federal Statistical Office STATENT 2022 (Vers. 22.08.2024), NOGA categories: 162303 (manufacture of other builders' carpentry and joinery of wood) and 439101 (carpentry, construction framing and joinery work).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"augmented-woodworking/cut-chainsaw/","title":"Chainsaw","text":"<p>Here's the step-by-step guide on how to use augmented-carpentry with any circular saw to realize basic woodworking operations.</p> <p></p>","tags":["acim","UI","cut","chainsaw-blade","fab"]},{"location":"augmented-woodworking/cut-chainsaw/#step-by-step","title":"Step-by-step","text":"<p>The assistance interface for the chainsaw is composed by the following elements:</p> <p>a - Feedback for balde position (in cm). The goal is to diminish the line length corresponding to the position error, to zero (green).</p> <p>b - Feedback for blade rotation (in degrees). The goal is to diminish the line length corresponding to the angle error, to zero (green).</p> <p>c - This is particular to the chainsaw feedback system. In order to obtain straight cuts both the base and tip of the chain needs to have equal heights. The yellow lines represent the distance to the bottom faces of bottom and tip blade. The idea is to have equidistant heights so that the two lines become green. The value <code>d:00</code> represents the shortest distances of both.</p> <p>d - The blade projection on the bottom face.</p> <p>Adjust now the position (a) until the indicator becomes green.</p> <p>Adjust now the rotation (b) until the indicator becomes green.</p> <p>You can now start the cut. Adjust the two ends (c) so that the blade is straight. Watch out the <code>d:00</code> when it gets to zero, the cut is done.</p> <p>Now you can do the other side of the cut and the multiple cuts in between the two ends without augmented feedback.</p> <p>Once done, you can inspect the full cut with the augmented overlay.</p> <p></p> <p>Once you are done hit the button Done to set the joint as done (*).</p> <p>Butt joint</p> <p>  For end half-lap joints, the feedback elements are the same as for cross-lap joints. The difference is that the blade will be guided to the end of the cut, and the cut will be done only on one side of the timber. <p>a - bounding box boundaries</p> <p>b - chainsaw blade's axis</p> <p>c - chainsaw blade's thickness</p> <p>d - joint 3D visualization. This can be particularly useful for having a better understanding of the joint's geometry and the blade's position during the cut.</p> <p>e - move the 3D view</p> <p>f - zoom the 3D view</p> <p>g - selected fix orthographic view  </p> <p>  The system guides you to the end of the single one-face cut. Make sure to keep the position and rotation values green all along.  </p> <p>Double inclined cuts</p> <p>  For double inclined cuts, the rotation feedback will not guide all degrees of freedom. The two degrees of freedom for the rotation will be merged into the same feedback. React intuitivly to the feedback and adjust the rotation until the indicator becomes green.  </p>","tags":["acim","UI","cut","chainsaw-blade","fab"]},{"location":"augmented-woodworking/cut-circularsaw/","title":"Circular saw","text":"<p>Here's the step-by-step guide on how to use augmented-carpentry with any circular saw to realize basic joints (cross-lap, half-lap, and butt joints).</p> <p></p>","tags":["acim","UI","cut","circular-blade","fab"]},{"location":"augmented-woodworking/cut-circularsaw/#step-by-step","title":"Step-by-step","text":"<p>This is the overview of the feedback and widget system to assist you during the cut.</p> <p>a - Feedback for balde position (in cm). The goal is to diminish the line length corresponding to the position error, to zero (green).</p> <p>b - Feedback for blade rotation (in degrees). The goal is to diminish the line length corresponding to the angle error, to zero (green).</p> <p>c - Feedback for balde depth (in mm). The goal is to to get to a value close to zero (green). In <code>00|00</code>, the first tow digit represent the distance of the projected blade to the bottom face of the cut, and the last two digits represent the closest distance from the blade to the bottom face of the cut (two purple-magenta points).</p> <p>d - Unselected face.</p> <p>e - The current label name of the cut.</p> <p>f - Auto-selected face to be cut. Face is auto-selected based on the blade position and orientation.</p> <p>g - Projection of the blade thickness on the face to be cut.</p> <p>Adjust first the height of the blade (c) until the indicator becomes green.</p> <p>Adjust now the position (a) until the indicator becomes green.</p> <p>Adjust now the rotation (b) until the indicator becomes green.</p> <p>Now you can start cutting. During the cut make sure to keep the position and rotation values green, and push through the end of the cut.</p> <p>Now you can start cutting. During the cut make sure to keep the position and rotation values green, and push through the end of the cut.</p> <p>Now you can do the other side of the cut. Make sure to keep the position and rotation values green, and push through the end of the cut as the first one. Now you can do multiple cuts in between the two ends without augmented feedback.</p> <p></p> <p>Once you are done hit the button Done to set the joint as done (*).</p> <p>Once you cleaned out the joint, you can inspect the full cut with the augmented overlay.</p> <p>End half-lap joints</p> <p>  For end half-lap joints, the feedback elements are the same as for cross-lap joints. The difference is that the blade will be guided to the end of the cut, and the cut will be done only on one side of the timber. <p>a - position feedback (see above)</p> <p>b - rotation feedback (see above)</p> <p>c - <code>00|00</code> (as above). For this specific cut, follow the last two digits representing the closest distance from the blade to the bottom face of the cut (two purple-magenta points).</p> <p>d - intersection of the blade with the timber element.</p> <p>e - blade thickness projection to the closest and bottom face of the half-lap joint.  </p> <p>  The system guides you to the end of the cut. Make sure to keep the position and rotation values green, and stop when the depth value touches 0 (the blade is now touching the opposite face).  </p> <p>Double inclined cuts</p> <p>  For double inclined cuts, the rotation feedback will not guide all degrees of freedom. The two degrees of freedom for the rotation will be merged into the same feedback. React intuitivly to the feedback and adjust the rotation until the indicator becomes green.  </p>","tags":["acim","UI","cut","circular-blade","fab"]},{"location":"augmented-woodworking/cut-mitersaw/","title":"Miter saw","text":"<p>Here's the step-by-step guide on how to use augmented-carpentry with any miter saw to realize basic joints (cross-lap, half-lap, and butt joints). The guidance system is similar to the one for circular saws.</p> <p></p>","tags":["acim","UI","cut","circular-blade","fab"]},{"location":"augmented-woodworking/cut-mitersaw/#step-by-step","title":"Step-by-step","text":"<p>This is the overview of the feedback and widget system to assist you during the cut.</p> <p>a - Feedback for balde position (in cm). The goal is to diminish the line length corresponding to the position error, to zero (green).</p> <p>b - Feedback for blade rotation (in degrees). The goal is to diminish the line length corresponding to the angle error, to zero (green).</p> <p>c - Feedback for balde depth (in mm). The goal is to to get to a value close to zero (green). In <code>00|00</code>, the first tow digit represent the distance of the projected blade to the bottom face of the cut, and the last two digits represent the closest distance from the blade to the bottom face of the cut (two purple-magenta points).</p> <p>d - Projection of the blade thickness on the face to be cut.</p> <p>Adjust the rotation (b) until the indicator becomes green.</p> <p>Adjust now the position (a) until the indicator becomes green.</p> <p>With miter saws the adjustement of the depth can be done on the go. Lower the blade and stop to the right height (d <code>00|00</code> first value is 0).</p> <p>Push through the end of the cut. With the miter saw it is easier than the circular saw since you have a mechanical fixed guide.</p> <p>As for the circular saw, do the second cut and slots of the joints.</p> <p>You can inspect the cuts if the overlay matches the cut. If not, you can adjust the cut by repeating the steps above.</p> <p></p> <p>Once you are done hit the button Done to set the joint as done (*).</p> <p>End half-lap joints</p> <p>  For butt joints with the miter saw the feedback interface is greatly simplified. Basically there is only one visual cue to follow, resuming position and rotation. The depth is not relevant for this type of joint. <p>a - execution model bounding box</p> <p>b - selected butt joint face</p> <p>c - position and rotation feedback</p> <p>d - projection of the blade thickness on the timber volume</p> <p>e - scanned model bounding box  </p> <p>  Follow the only visual cue to adjust the position and rotation of the blade. Once the indicator is green, you can proceed to the cut.  </p> <p>  Inspect the butt joint. If the overlay does not match the cut, you can adjust the cut by repeating the steps above.  </p>","tags":["acim","UI","cut","circular-blade","fab"]},{"location":"augmented-woodworking/cut-swordsaw/","title":"Sword saw","text":"<p>Here's the step-by-step guide on how to use augmented-carpentry with a sword saw to realize basic joints: half-lap, and mainly butt joints. The feedback system is similar to the one for chainsaws.</p> <p></p>","tags":["acim","UI","cut","chainsaw-blade","fab"]},{"location":"augmented-woodworking/cut-swordsaw/#step-by-step","title":"Step-by-step","text":"<p>This is the overview of the feedback and widget system to assist you during the cut.</p> <p>a - Feedback for blade rotation (in degrees). The goal is to diminish the line length corresponding to the angle error, to zero (green).</p> <p>b - Feedback for balde position (in cm). The goal is to diminish the line length corresponding to the position error, to zero (green).</p> <p>c,e - This is particular to the chainsaw feedback system. In order to obtain straight cuts both the base and tip of the chain needs to have equal heights. The yellow lines represent the distance to the bottom faces of bottom and tip blade. The idea is to have equidistant heights so that the two lines become green. The value <code>d:00</code> represents the shortest distances of both.</p> <p>d - The blade projection on the bottom face.</p> <p>Adjust now the position until the indicator becomes green.</p> <p>Adjust now the rotation until the indicator becomes green.</p> <p>Now you can start cutting. During the cut make sure to keep the position and rotation values green, and push through the end of the cut. Stop before the value <code>d:00</code> is 0. This means that the blade reached the opposite joint face. In this case we stop a bit before.</p> <p>Now you can start cutting. During the cut make sure to keep the position and rotation values green, and push through the end of the cut. If good, you can mark it as Done just like the chainsaw.</p> <p>Butt joints</p> <p>  Just as the chainsaw, this tool can be used to cut butt joints. The feedback system is simplified here too: the blade's position and rotation are the only feedbacks. The goal is to have both values green. <p>a - position feedback</p> <p>b - rotation feedback</p> <p>c - blade's axis projection on the timber volume</p> <p>d - blade's thickness projection on the timber volume</p> <p>e - active cutting face</p> <p>f - 3D model bounding box limits</p> <p>g - timber piece bounding box limits  </p> <p>  The system guides you to the end of the cut. Make sure to keep the position and rotation values green, and stop when the depth value touches 0 (the blade is now touching the opposite face). <p> </p>","tags":["acim","UI","cut","chainsaw-blade","fab"]},{"location":"augmented-woodworking/draw/","title":"Draw","text":"<p>To operate machines with AC, you need to export a <code>.acim</code> file from your 3D modeling software. This file contains all the information required for the fabrication process, such as geometric information (e.g., joints and holes) and fabrication metadata (e.g., ID, fabrication status).</p> <p></p>","tags":["design","acim","UI","fab"]},{"location":"augmented-woodworking/drill/","title":"Drill","text":"<p>Here's the step-by-step guide on how to use augmented-carpentry with a drill. You can use any drill bits, provided that they are integrated in the dataset.</p> <p></p>","tags":["acim","UI","drill","fab"]},{"location":"augmented-woodworking/drill/#step-by-step","title":"Step-by-step","text":"<p>Illustration of the guidance provided by AC throughout the drilling procedure. The user needs to adjust first the position and rotation of the drill bit.</p> <p>a the camera feed is zoomed twice</p> <p>b orientation visual guide, where the correct starting positioning is a line connecting c and d</p> <p>c tip of the toolhead</p> <p>d the start of the drill hole</p> <p>e rotation error in degrees. It corresponds to the angle between the drill bit and the hole.</p> <p>f position error in mm. It corresponds to the distance between the tip of the drill bit and the start of the hole.</p> <p>g depth error in mm. It corresponds to the distance between the tip of the drill bit and the bottom face of the hole.</p> <p>Take the drill bit and adjust the position to match the first value to zero.</p> <p>Adjust the rotation until the indicator becomes green and its value is as close as possible to zero. Once both position and rotation are correct, the drilling can start.</p> <p></p> <p>Once the position and rotation are in place the drilling can start and the user needs to follow the depth feedback. The user needs to stop when the depth error is zero.</p> <p>Keep the values of rotation in check especially at the beginning of the drilling. The user needs to stop when the depth error is zero or close to it at the end of the hole. The yellow color indicates that the deviation is in the limit of tolerance and the drilling should stop.</p> <p>Mark as done and inspect the holes and see if you missed any.</p>","tags":["acim","UI","drill","fab"]},{"location":"augmented-woodworking/examples/","title":"Built works","text":"<p>Here's a collection of joints, mock-ups and structures made with the Augmented Woodworking system. Augmented Carpentry has been extensively tested and refined in laboratory and real timber construction scenarios. All the pieces are fabricated via AC, from a 3D model, without the production of 2D execution drawings, and assembled with traditional methods.</p>","tags":["fab","application","woodworking","examples","acim"]},{"location":"augmented-woodworking/examples/#post-and-beam","title":"Post-and-beam","text":"","tags":["fab","application","woodworking","examples","acim"]},{"location":"augmented-woodworking/examples/#roof-truss","title":"Roof truss","text":"","tags":["fab","application","woodworking","examples","acim"]},{"location":"augmented-woodworking/examples/#facade-system","title":"Facade system","text":"","tags":["fab","application","woodworking","examples","acim"]},{"location":"augmented-woodworking/execution-model/","title":"Execution model","text":"<p>Once you mapped the piece, you can load the <code>.acim</code> model to lock the execution model to the current timber element. This will allow you to visualize directly in 3D all the augmented cuts, drills and other information directly on the timber piece.</p> <p></p>","tags":["acim","UI","fab"]},{"location":"augmented-woodworking/execution-model/#step-by-step","title":"Step-by-step","text":"<p>To operate machines with AC, you need to export a <code>.acim</code> file from your 3D modeling software. This file contains all the information required for the fabrication process, such as geometric information (e.g., joints and holes) and fabrication metadata (e.g., ID, fabrication status). For now we only support <code>.acim</code> files generated from Grasshopper.</p> <p></p> <p>Install <code>augmented-carpentry</code> via the Package Manager and export your structure via the component <code>acpy-acim-exporter</code>.</p> <p>Once the mapping is processed and saved, you can load the <code>.acim</code> model to lock the execution model to the current piece.</p> <p>The execution model is now locked to the timber element and it can now be visualized in 3D.</p> <p>Since the model is referenced to the timber element, moving the piece will not affect the tracking.</p> <p></p> <p>Let's start by looking at the different elements of the ACIM interface when the model is loaded.</p> <p>a - a selected hole</p> <p>b - a lap-joint in the unselected state</p> <p>c - a hole in the unselected state</p> <p>d - a selected lap-joint</p> <p>e - a UI panel for execution model controls (<code>acim</code>)</p> <p>f - dimension lines (cotas) that can be toggled on or off</p> <p>g - basic I/O controls for ACIM</p> <p>h - visual cues indicating the bounding box</p> <p>i - a widget delineating the outer boundaries of the imported execution model</p> <p>o - controls for adjusting the model's position and orientation</p> <p>p - tools to navigate and designate holes or cuts as current</p> <p>q - additional options specific to holes or cuts.</p> <p></p> <p>To select the current cut or drill, use the list selector (b) or the arrows (c). The selected cut or drill will be highlighted in green (a). Based on the selected cut or drill, the corresponding UI will automatically appear for the right tool.</p> <p></p> <p>You are now ready to do some augmented woodworking.</p> <p>Measurements and cotas</p> <p>  Cotas and measurements can be toggled on or off.  They are useful to double check the dimensions of cuts if needed.For a single element select <code>Show Cotas</code>, for the whole model select <code>Show All Cotas</code>.  </p> <p>Multiple models</p> <p>  You can also subdivide your fabrication in multiple <code>acim</code>s and load them differently. This can be useful if you have a complex piece with multiple parts like in this example of multiple perforations for a glulam beam.  </p> <p>Troubleshooting out-of-scale model</p> <p>  If you notice that the model is slightly bended or the boundaries are off, you can try to adjust the model's scaling. This can occur if your markers are not perfectly printed or if the camera calibration is not precise. Take a meter and measure the length between the purple limits of the beam (a). Insert the value with the slider in the <code>Scaling Factor Adjustements</code> section (b).  </p>","tags":["acim","UI","fab"]},{"location":"augmented-woodworking/inspect/","title":"Inspect","text":"<p>Placeholder</p>"},{"location":"augmented-woodworking/map/","title":"Map","text":"<p>Print the tags and stick them to the timber piece. Cover the middle of each face of the timber beam with the tags. Once it is done, mapping can start. The mapping is the process of capturing the tags with the camera to create a 3D model of the timber piece. By doing this, the system will be able to track the timber piece in real-time during the fabrication.</p> <p></p>","tags":["map","UI","fab"]},{"location":"augmented-woodworking/map/#step-by-step","title":"Step-by-step","text":"<p>Click the button Start Mapping (*) to start the mapping process.</p> <p></p> <p>The mapping is now started.</p> <p>a - landmark feature points used to facilitate camera localization</p> <p>b - tags already acquired (yellow)</p> <p>c - newly detected tags pending acquisition (blue)</p> <p>d - map-building overview</p> <p>e - optimization parameters</p> <p>f - reconstruction parameters for generating a mesh box from the registered tags</p> <p>g - commands to save or discard the current mapping recording</p> <p>Go around the timber piece, turn it when needed, and capture as many tags as possible. Start from the middle of the beam and go on the extremities, this will help redistribute the error of the tags detection uniformly.</p> <p></p> <p>Click on the Save &amp; Exit button to save the mapping and start the processing.</p> <p>Once the map is loaded together with the <code>.acim</code> model, you can visualize if the piece is correctly reconstructed (black lines) and if the model is correctly aligned with the piece.</p> <p></p> <p>Troubleshooting a failed reconstruction</p> <p>  In case the reconstruction fails, follow this procedure. You can try to reconstruct the piece with different parameters. We have several presets available to try based on the element's dimensions.  </p> <p>Limit to 3 meters elements for stable mapping</p> <p>  For now if the beam exceeds <code>3 m</code>, the system will sometimes fail to map the piece. In this case, you can try to reduce the number of tags in e.g., the middle of the beam.  </p>","tags":["map","UI","fab"]},{"location":"augmented-woodworking/replay/","title":"Replay","text":"<p>Placeholder</p>"},{"location":"augmented-woodworking/tool-calib/","title":"Tool calibration","text":"<p>Here we describe the calibration process of the tool heads. This is a crucial step to ensure the correct tracking of the inserted tool. This procedure needs to be done every time a tool is changed.</p> <p></p>","tags":["calibration","acit","UI","fab"]},{"location":"augmented-woodworking/tool-calib/#step-by-step","title":"Step-by-step","text":"<p>Open the Toolhead pane and select the tool you want to calibrate from the list of available tool heads:</p> <p>a - rough projection of the selected tool head</p> <p>b - library of selectable tool heads models</p> <p>c - current selected tool head</p> <p></p> <p>If you want to add new tools follow the instructions in the section contributing: add a new tool.</p> <p></p> <p>Once you have adjusted the camera to have the tool occupying the first half of the screen, you can input the initial pose of the tool head via the sliders (q r p l o n) first and then refine it (f):</p> <p>d - machine-refined tool head position and orientation</p> <p>e - confirm the pose</p> <p>f - stop the refiner</p> <p>g - reload the latest saved pose</p> <p>h - hide the 3D model silhouette widget</p> <p>i - reset the pose to the default value</p> <p>q r p - sliders to input the 3D model's location</p> <p>l o n - sliders to input the 3D model's rotation</p> <p>Use the sliders to estimate an initial position. It does not need to be precise, but it should be as close as possible to the real position and orientation of the tool head. Once you are satisfied, hit the button Save pose.</p> <p>Now you can refine the pose by hitting the button Start refine. The model will turn blue and try to optimize your initial position. Move the tool around to help the system refine the pose.</p> <p>Once you are satisfied, hit the button Stop refine and Save pose, and Hide silhouette.</p> <p> </p> <p>Your tool head is not calibrated.</p> <p>Troubleshooting blades with symbols</p> <p>  Especially blades, like large circular saws, lack often geometric features to help the tool calibration. To help the system, you can add a logos or recognizable symbols to the blade (in this case the EPFL logo). The system will use these symbols to calibrate the tool head.  </p>","tags":["calibration","acit","UI","fab"]},{"location":"blog/","title":"Blog","text":""},{"location":"changelog/","title":"Index","text":"<p>\u00ff\u00fe&lt;\u0000a\u0000 \u0000i\u0000d\u0000=\u0000\"\u0000v\u00000\u0000.\u00004\u0000.\u00000\u0000\"\u0000&gt;\u0000&lt;\u0000/\u0000a\u0000&gt;\u0000 \u0000 \u0000#\u0000 \u0000[\u0000v\u00000\u0000.\u00004\u0000.\u00000\u0000:\u0000 \u0000r\u0000e\u0000f\u0000o\u0000r\u0000m\u0000a\u0000t\u0000 \u0000U\u0000I\u0000 \u0000+\u0000 \u0000p\u0000a\u0000t\u0000h\u0000 \u0000r\u0000e\u0000c\u0000o\u0000r\u0000d\u0000e\u0000r\u0000]\u0000(\u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000i\u0000b\u0000o\u0000i\u0000s\u0000-\u0000e\u0000p\u0000f\u0000l\u0000/\u0000a\u0000u\u0000g\u0000m\u0000e\u0000n\u0000t\u0000e\u0000d\u0000-\u0000c\u0000a\u0000r\u0000p\u0000e\u0000n\u0000t\u0000r\u0000y\u0000/\u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000s\u0000/\u0000t\u0000a\u0000g\u0000/\u0000v\u00000\u0000.\u00004\u0000.\u00000\u0000)\u0000 \u0000-\u0000 \u00002\u00000\u00002\u00004\u0000-\u00001\u00001\u0000-\u00002\u00000\u0000 \u0000 \u0000 \u0000 \u0000T\u0000h\u0000i\u0000s\u0000 \u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000 \u0000i\u0000n\u0000t\u0000r\u0000o\u0000d\u0000u\u0000c\u0000e\u0000 \u0000a\u0000 \u0000n\u0000e\u0000w\u0000 \u0000l\u0000i\u0000g\u0000h\u0000t\u0000e\u0000r\u0000 \u0000a\u0000n\u0000d\u0000 \u0000m\u0000o\u0000r\u0000e\u0000 \u0000c\u0000o\u0000m\u0000f\u0000o\u0000r\u0000t\u0000a\u0000b\u0000l\u0000e\u0000 \u0000U\u0000I\u0000 \u0000f\u0000o\u0000r\u0000 \u0000A\u0000C\u0000.\u0000 \u0000 \u0000I\u0000t\u0000 \u0000a\u0000l\u0000s\u0000o\u0000 \u0000a\u0000d\u0000d\u0000 \u0000a\u0000 \u0000p\u0000r\u0000e\u0000l\u0000i\u0000m\u0000i\u0000n\u0000a\u0000r\u0000y\u0000 \u0000v\u0000e\u0000r\u0000s\u0000i\u0000o\u0000n\u0000 \u0000o\u0000f\u0000 \u0000a\u0000 \u00003\u0000D\u0000 \u0000r\u0000e\u0000c\u0000o\u0000r\u0000d\u0000e\u0000r\u0000 \u0000t\u0000o\u0000 \u0000r\u0000e\u0000p\u0000l\u0000a\u0000y\u0000 \u0000t\u0000h\u0000e\u0000 \u0000f\u0000a\u0000b\u0000r\u0000i\u0000c\u0000a\u0000t\u0000i\u0000o\u0000n\u0000 \u0000l\u0000a\u0000t\u0000e\u0000r\u0000 \u0000o\u0000n\u0000 \u0000R\u0000h\u0000i\u0000n\u0000o\u0000.\u0000 \u0000 \u0000 \u0000 \u0000[\u0000C\u0000h\u0000a\u0000n\u0000g\u0000e\u0000s\u0000]\u0000[\u0000v\u00000\u0000.\u00004\u0000.\u00000\u0000]\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000&lt;\u0000a\u0000 \u0000i\u0000d\u0000=\u0000\"\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000\"\u0000&gt;\u0000&lt;\u0000/\u0000a\u0000&gt;\u0000 \u0000 \u0000#\u0000 \u0000[\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000]\u0000(\u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000i\u0000b\u0000o\u0000i\u0000s\u0000-\u0000e\u0000p\u0000f\u0000l\u0000/\u0000a\u0000u\u0000g\u0000m\u0000e\u0000n\u0000t\u0000e\u0000d\u0000-\u0000c\u0000a\u0000r\u0000p\u0000e\u0000n\u0000t\u0000r\u0000y\u0000/\u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000s\u0000/\u0000t\u0000a\u0000g\u0000/\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000)\u0000 \u0000-\u0000 \u00002\u00000\u00002\u00003\u0000-\u00000\u00009\u0000-\u00002\u00001\u0000 \u0000 \u0000 \u0000 \u0000T\u0000h\u0000i\u0000s\u0000 \u0000i\u0000s\u0000 \u0000a\u0000 \u0000s\u0000t\u0000a\u0000b\u0000l\u0000e\u0000 \u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000 \u0000w\u0000i\u0000t\u0000h\u0000 \u0000a\u0000 \u0000r\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000i\u0000n\u0000g\u0000 \u0000o\u0000f\u0000 \u0000t\u0000h\u0000e\u0000 \u0000e\u0000n\u0000t\u0000i\u0000r\u0000e\u0000 \u0000C\u0000M\u0000a\u0000k\u0000e\u0000 \u0000p\u0000r\u0000o\u0000j\u0000e\u0000c\u0000t\u0000.\u0000 \u0000 \u0000 \u0000T\u0000h\u0000e\u0000 \u0000r\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000o\u0000n\u0000s\u0000i\u0000s\u0000t\u0000s\u0000 \u0000i\u0000n\u0000:\u0000 \u0000 \u0000-\u0000 \u0000b\u0000e\u0000t\u0000t\u0000e\u0000r\u0000 \u0000d\u0000e\u0000p\u0000e\u0000n\u0000d\u0000e\u0000n\u0000c\u0000y\u0000 \u0000s\u0000y\u0000s\u0000t\u0000e\u0000m\u0000 \u0000 \u0000-\u0000 \u0000l\u0000e\u0000s\u0000s\u0000 \u0000s\u0000e\u0000l\u0000f\u0000-\u0000c\u0000o\u0000n\u0000t\u0000a\u0000i\u0000n\u0000e\u0000d\u0000 \u0000d\u0000e\u0000p\u0000e\u0000n\u0000d\u0000e\u0000n\u0000c\u0000i\u0000e\u0000s\u0000 \u0000 \u0000-\u0000 \u0000g\u0000e\u0000n\u0000e\u0000r\u0000a\u0000l\u0000 \u0000i\u0000m\u0000p\u0000r\u0000o\u0000v\u0000e\u0000m\u0000e\u0000n\u0000t\u0000s\u0000 \u0000i\u0000n\u0000 \u0000t\u0000h\u0000e\u0000 \u0000C\u0000M\u0000a\u0000k\u0000e\u0000 \u0000p\u0000r\u0000o\u0000j\u0000e\u0000c\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000[\u0000C\u0000h\u0000a\u0000n\u0000g\u0000e\u0000s\u0000]\u0000[\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000]\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000&lt;\u0000a\u0000 \u0000i\u0000d\u0000=\u0000\"\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000\"\u0000&gt;\u0000&lt;\u0000/\u0000a\u0000&gt;\u0000 \u0000 \u0000#\u0000 \u0000[\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000:\u0000 \u0000H\u0000o\u0000l\u0000e\u0000 \u0000i\u0000n\u0000t\u0000e\u0000g\u0000r\u0000a\u0000t\u0000e\u0000d\u0000 \u0000t\u0000o\u0000 \u0000f\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000 \u0000s\u0000y\u0000s\u0000t\u0000e\u0000m\u0000]\u0000(\u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000i\u0000b\u0000o\u0000i\u0000s\u0000-\u0000e\u0000p\u0000f\u0000l\u0000/\u0000a\u0000u\u0000g\u0000m\u0000e\u0000n\u0000t\u0000e\u0000d\u0000-\u0000c\u0000a\u0000r\u0000p\u0000e\u0000n\u0000t\u0000r\u0000y\u0000/\u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000s\u0000/\u0000t\u0000a\u0000g\u0000/\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000)\u0000 \u0000-\u0000 \u00002\u00000\u00002\u00003\u0000-\u00000\u00008\u0000-\u00002\u00001\u0000 \u0000 \u0000 \u0000 \u0000T\u0000h\u0000e\u0000 \u0000 \u0000p\u0000a\u0000t\u0000c\u0000h\u0000 \u0000r\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000s\u0000 \u0000a\u0000n\u0000d\u0000 \u0000f\u0000i\u0000x\u0000 \u0000b\u0000u\u0000g\u0000s\u0000 \u0000i\u0000n\u0000 \u0000t\u0000h\u0000e\u0000 \u0000f\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000 \u0000f\u0000o\u0000r\u0000 \u0000t\u0000h\u0000e\u0000 \u0000d\u0000r\u0000i\u0000l\u0000l\u0000i\u0000n\u0000g\u0000.\u0000 \u0000T\u0000h\u0000i\u0000s\u0000 \u0000i\u0000s\u0000 \u0000a\u0000 \u0000s\u0000t\u0000a\u0000b\u0000l\u0000e\u0000 \u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000 \u0000t\u0000h\u0000a\u0000t\u0000 \u0000c\u0000o\u0000m\u0000p\u0000l\u0000e\u0000t\u0000e\u0000s\u0000 \u0000t\u0000h\u0000e\u0000 \u0000f\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000 \u0000s\u0000y\u0000s\u0000t\u0000e\u0000m\u0000 \u0000f\u0000o\u0000r\u0000 \u0000A\u0000C\u0000.\u0000 \u0000 \u0000 \u0000 \u0000[\u0000C\u0000h\u0000a\u0000n\u0000g\u0000e\u0000s\u0000]\u0000[\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000]\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000[\u0000v\u00000\u0000.\u00004\u0000.\u00000\u0000]\u0000:\u0000 \u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000i\u0000b\u0000o\u0000i\u0000s\u0000-\u0000e\u0000p\u0000f\u0000l\u0000/\u0000a\u0000u\u0000g\u0000m\u0000e\u0000n\u0000t\u0000e\u0000d\u0000-\u0000c\u0000a\u0000r\u0000p\u0000e\u0000n\u0000t\u0000r\u0000y\u0000/\u0000c\u0000o\u0000m\u0000p\u0000a\u0000r\u0000e\u0000/\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000.\u0000.\u0000.\u0000v\u00000\u0000.\u00004\u0000.\u00000\u0000 \u0000 \u0000[\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000]\u0000:\u0000 \u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000i\u0000b\u0000o\u0000i\u0000s\u0000-\u0000e\u0000p\u0000f\u0000l\u0000/\u0000a\u0000u\u0000g\u0000m\u0000e\u0000n\u0000t\u0000e\u0000d\u0000-\u0000c\u0000a\u0000r\u0000p\u0000e\u0000n\u0000t\u0000r\u0000y\u0000/\u0000c\u0000o\u0000m\u0000p\u0000a\u0000r\u0000e\u0000/\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000.\u0000.\u0000.\u0000v\u00000\u0000.\u00003\u0000.\u00000\u0000\u0000C\u0000M\u0000a\u0000k\u0000e\u0000R\u0000e\u0000f\u0000a\u0000c\u0000t\u0000o\u0000r\u0000 \u0000 \u0000[\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000]\u0000:\u0000 \u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000i\u0000b\u0000o\u0000i\u0000s\u0000-\u0000e\u0000p\u0000f\u0000l\u0000/\u0000a\u0000u\u0000g\u0000m\u0000e\u0000n\u0000t\u0000e\u0000d\u0000-\u0000c\u0000a\u0000r\u0000p\u0000e\u0000n\u0000t\u0000r\u0000y\u0000/\u0000t\u0000r\u0000e\u0000e\u0000/\u0000v\u00000\u0000.\u00002\u0000.\u00001\u0000\u0000F\u0000e\u0000e\u0000d\u0000b\u0000a\u0000c\u0000k\u0000P\u0000a\u0000t\u0000c\u0000h\u0000 \u0000 \u0000 \u0000 \u0000&lt;\u0000!\u0000-\u0000-\u0000 \u0000G\u0000e\u0000n\u0000e\u0000r\u0000a\u0000t\u0000e\u0000d\u0000 \u0000b\u0000y\u0000 \u0000h\u0000t\u0000t\u0000p\u0000s\u0000:\u0000/\u0000/\u0000g\u0000i\u0000t\u0000h\u0000u\u0000b\u0000.\u0000c\u0000o\u0000m\u0000/\u0000r\u0000h\u0000y\u0000s\u0000d\u0000/\u0000c\u0000h\u0000a\u0000n\u0000g\u0000e\u0000l\u0000o\u0000g\u0000-\u0000f\u0000r\u0000o\u0000m\u0000-\u0000r\u0000e\u0000l\u0000e\u0000a\u0000s\u0000e\u0000 \u0000v\u00003\u0000.\u00008\u0000.\u00000\u0000 \u0000-\u0000-\u0000&gt;\u0000 \u0000 \u0000</p>"},{"location":"contributing/","title":"Guide for contributors","text":"<p>Here's you can find some documentations and guidelines to contribute to augmented_carpentry.</p>"},{"location":"contributing/#github-commit-convetion","title":"GitHub commit convetion","text":"<p>All commits need to be labeled with a tag among these: <pre><code>git commit -m \"ADD:&lt;description&gt;\"         &lt;--- for adding new elements\ngit commit -m \"FIX:&lt;description&gt;\"         &lt;--- for fixing (errors, typos)\ngit commit -m \"FLASH:&lt;description&gt;\"       &lt;--- quick checkpoint before refactoring\ngit commit -m \"MILESTONE:&lt;description&gt;\"   &lt;--- for capping moment in development\ngit commit -m \"CAP:&lt;description&gt;\"         &lt;--- for for less important milestones\ngit commit -m \"UPDATE:&lt;description&gt;\"      &lt;--- for moddification to the same file\ngit commit -m \"MISC:&lt;description&gt;\"        &lt;--- for any other reasons to be described\ngit commit -m \"WIP:&lt;description&gt;\"         &lt;--- for not finished work\ngit commit -m \"REFACTOR:&lt;description&gt;\"    &lt;--- for refactored code\ngit commit -m \"MERGE:&lt;description&gt;\"       &lt;--- for merging operations\n</code></pre> You can merge few tags e.g.: <pre><code>git commit -m \"WIP-CAP:&lt;description&gt;      &lt;--- for cap moment in not finished work \n</code></pre></p>"},{"location":"contributing/#python","title":"Python","text":"<p>DiffCheck is distributed as a Python Grasshopperr plug-in via yak and its source code via PyPI. The plug-in is composed by a series of <code>.ghuser</code> components.</p> <p>There are 3 ways you can contribute to the Python GH plug-in: 1. By adding new components to the plug-in. 2. By fixing bugs of existing components in the plug-in. 3. By adding new functionalities to existing components in the plug-in.</p> <p>Before committing to the repository you need to have tested the components in the Grasshopper environment and be sure that this is working correctly. Also, provide a sufficient documentation in the PR (for now) please.</p> <p>Follow these steps to develop and test the Python GH plug-in: - GHPy: A) preparation - GHPy: B) development/debug - GHPy: C) Release - GHPy: D) Documentation</p>"},{"location":"contributing/#ghpy-a-preparation","title":"GHPy: A) preparation","text":"<p>Download this repo if you haven't already.</p> <p>Next, if you used ACPy (AugmentedCarpentryPython) before as an end-user clean all the <code>ACPy folders</code> in the following directory (the last name will change): <pre><code>C:\\Users\\&lt;user-name&gt;\\.rhinocode\\py39-rh8\\site-envs\\default-wMh5LZL3\n</code></pre></p> <p>note that if you drop an official released ACPy component from yak, this one will have the <code>#r : ACPy==&lt;version_number&gt;</code> notation at the top of the script. Get rid of all these release components before to start and be sur to erase again the previous folders (they recreated each time <code>#r : ACPy</code> is called).</p> <p>Build the package from the py source code's directory: <pre><code>python setup.py sdist bdist_wheel\n</code></pre></p> <p>Lastly, install the pip pacakge from the repository in editable mode. This way, all the modifications made to the source code of the repository will be reflected in the installed package. Open a terminal and run the following command (replace the path with where you download the repository): <pre><code>C:\\Users\\&lt;your-username&gt;\\.rhinocode\\py39-rh8\\python.exe -m pip install -e \"&lt;path-to-repository-root&gt;\\src\\gh\\ACPy\"\n</code></pre></p> <p>For your info the packages is installed in <code>C:\\Users\\andre\\.rhinocode\\py39-rh8\\Lib\\site-packages</code>.</p> <p>That's it you are now a contributor to the ACPy! We raccomand to not download anymore from yak package but rather use the source code in the repository. If you want the latest ACPy, checkout and pull the main.</p>"},{"location":"contributing/#ghpy-b-developmentdebug","title":"GHPy: B) development/debug","text":""},{"location":"contributing/#b1-code-structure","title":"B.1) Code structure","text":"<p>For DiffCheck there are 2 main folders in the repository: * <code>src/gh/ACPy/components</code> here you can add new components or modify existing ones (for more info on how to create one we point you to this documentation). Here we call the  * <code>src/gh/ACPy/ACPy</code> this is our package where the core functionalities are implemented.</p>"},{"location":"contributing/#b2-developing-components-content","title":"B.2) Developing component's content","text":"<p>The idea is to start by developing the content of the component in the file <code>src/gh/ACPy/diffCgeck_app.py</code>. This would be a simple script that contains the logic of the component. Once the script <code>ACPy_app.py</code> is working correctly, you can move the code to the component file in the <code>src/gh/ACPy/components</code> folder. This is because the component file is the one that will be componentized and distributed via yak.</p> <p>We reccomand to use <code>VSCode</code> as IDE for developing the components. This is because it has a good integration with the <code>Grasshopper</code> environment and it is easy to debug the components. To set up the IDE follow these steps: 1. Install the <code>ScriptSync</code> extension for <code>VSCode</code>. 2. Install the <code>ScriptSync</code> from the yak manager in Rhino. 3. Open the <code>ACPyApp.py</code> from the <code>src/gh/ACPy/components</code> folder you are working on in <code>VSCode</code>, and set its path to the ScriptSync ghcomponent. 4. If you modify the code in <code>VSCode</code>, the changes will be reflected in the Grasshopper component as soon as you save in <code>VSCode</code> again the <code>code.py</code>. 5. Once your code is working, prepare the code and componentize it.</p> <p>If you want to use the GHEditor it's ok but everytime you modify the pakcage or the component's code, after any modifications you need to restart the Python interpreter from the ScriptEditor (<code>Tools &gt; Reload Python3 (CPython) Engine</code>) and recompute the solution in Grasshopper.</p>"},{"location":"contributing/#b3-componentize-the-code","title":"B.3) Componentize the code","text":"<p>Prepare your component as explained here. You can componentize it locally and test it in Grasshopper. Here's how to componentize: <pre><code>python f:\\ACPy\\src\\gh\\util\\componentizer_cpy.py --ghio \"C:\\Users\\andre\\.nuget\\packages\\grasshopper\\8.2.23346.13001\\lib\\net48\\\" .\\src\\gh\\components\\ .\\build\\gh\n</code></pre></p> <p>Note that you need to find the path to your GHIO folder. This is the folder where the <code>Grasshopper.dll</code> is located. E.g. You can find it in the <code>nuget</code> folder in the Rhino installation directory.</p> <p>Once you are sure that the component is working correctly, you can push the changes to the repository.</p>"},{"location":"contributing/#ghpy-c-release","title":"GHPy: C) Release","text":"<p>The release will be made via CI from main. As a contributor you don't need to worry about this. The plug-in is componentized, pushed to yak/PyPI and the user can download the latest version from yak.</p>"},{"location":"contributing/#ghpy-d-documentation","title":"GHPy: D) Documentation","text":"<p>To generate the MkDocs documentation first install the conda environment from the <code>environment.yml</code> file. Then run the following command from root: <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"contributing/#c","title":"C++","text":""},{"location":"contributing/#naming-synthax-convention","title":"Naming &amp; synthax convention","text":"<p>Here's the naming convention for this project: - <code>localVariable</code>: lowerCamelCase. - <code>type PrivateVariable</code>: public member of a class - <code>type m_PrivateVariable</code>: Hungarian notation with UpperCamelCase for private class members. - <code>static type s_StaticVariable</code>: Hungarian notation with UpperCamelCase for static members of class. - <code>APP_SPEC</code>: Constants with SNAKE_UPPER_CASE. - All the other naming uses UpperCamelCase.</p> <p>Here's an example: <pre><code>// do not use using namespace std; we specify the namespace everytime\nstd::foo()\n\n// next line graph style\nvoid Foo()\n{\n    /* content */\n}\n\n// structure name uses UpperCamelCase\nstruct AnExampleStruct\n{\n    // structure attribute uses UpperCamelCase\n    const char* Name;\n};\n\n// class name uses UpperCamelCase\nclass AnExampleClass\n{\npublic:\n    AnExampleClass(const int&amp; init);\n    virtual ~AnExampleClass();\n\n    // member functions use UpperCamelCase\n    void PublicMemberFunction()\n    {\n        // local variable uses lowerCamelCase\n        int localVariable = 0;\n    }\n\n// A field indicator to separate the functions and attributes\npublic:\n    int PublicVariable;\n\n// Private member function block\nprivate:\n    // member functions use UpperCamelCase\n    void PrivateMemberFunction(); \n\n// Also a field indicator to separate the functions and attributes\nprivate:\n    // private variables uses Hungarian notation with UpperCamelCase\n    int m_PrivateVariable; // m_VariableName for normal variable\n    static int s_Instance; // s_VariableName for static variable\n};\n\n// Start headers with \n#pragma once\n\n// Start declarations with precompiled headers\n#include \"aiacpch.h\"\n</code></pre></p>"},{"location":"contributing/#doxygen","title":"Doxygen","text":"<p>For documentation we use the *JavaDoc\" convention. Follow this guide for documenting the code. <pre><code>/**\n * @brief fill a vector of TSPlanes from a yaml file containing their corners data\n * @param filename path to the map.yaml file\n * @param planes vector of TSPlane objects\n */\n</code></pre></p>"},{"location":"contributing/#config","title":"Config","text":"<p>We use an .ini file to store the config parameters of the application. The parser is derived from this project but with some modification. Here's an example:</p>"},{"location":"contributing/#declaration","title":"Declaration","text":"<pre><code>// Just include this header\n#include \"AIAC/Config.h\"\n\n// Open file \"config.ini\".\n// The second param indicate if the file need to be update when \n// InsertEntry() and UpdateEntry() is called.\n// The initialization happens in the very beginning of `ACApp.cpp`.\ninih::Ini config(\"config.ini\", true);\n</code></pre>"},{"location":"contributing/#usage","title":"Usage","text":"<p>In order to get rid of plain text, where an typo can cause unexpected error, we strongly suggest you to declare a static const string variable in <code>config.h</code> and call it in your code. For each data entry, \"section\" and \"name\" are combined as the primary key. Here's an example:</p> <p>In <code>Config.h</code>, declare the variable for key: <pre><code>inline static const std::string SEC_TEST = \"SectionTest\";\ninline static const std::string VALUE_NAME_1 = \"ValueName1\";\ninline static const std::string VALUE_NAME_2 = \"ValueName2\";\n</code></pre> Usage: <pre><code>// Get&lt;type&gt;(section, key, default value if not exist)\nAIAC::Config::Get&lt;int&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::VALUE_NAME_1, 10);\n\n// InsertEntry(section, key, value)\nAIAC::Config::InsertEntry(AIAC::Config::SEC_AIAC, AIAC::Config::VALUE_NAME_2, -1);\n\n// Insert a vector\nvector&lt;int&gt; primeVector = {2, 3, 5, 7, 11};\nAIAC::Config::InsertEntry(\"SectionTestVector\", \"PrimeNumber\", primeVector);\n\n\n// Get&lt;T&gt;(section, key, default_value)\n// The entry will be created if not exist.\ncout &lt;&lt; AIAC::Config::Get&lt;int&gt;(\"SectionTest\", \"ValueName1\", -1) &lt;&lt; endl;\ncout &lt;&lt; AIAC::Config::Get&lt;string&gt;(\"SectionTest\", \"ValueName2\", \"I'm a string!\") &lt;&lt; endl;\n\n// With vector, use GetVector() instead of Get(),\nfor(auto n: AIAC::Config::GetVector&lt;int&gt;(\"SectionTestVector\", \"PrimeNumber\", primeVector)){\n    cout &lt;&lt; n &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n\n// Update an Entry\nAIAC::Config::UpdateEntry(\"SectionTest\", \"key1\", 999);\ncout &lt;&lt; AIAC::Config::Get(\"SectionTest\", \"key1\", -1) &lt;&lt; endl;\n\n// For update an vector entry, call the same function as normal\nprimeVector.push_back(13);\nAIAC::Config::UpdateEntry(\"SectionTestVector\", \"PrimeNumber\", primeVector);\n\n// Write the ini to the original file\nAIAC::Config::WriteToFile();\n// Write to another file\nAIAC::Config::WriteToFile(\"another_config_file.ini\");\n</code></pre> After running thie code above, you gets the following output: <pre><code>-1\nI'm a string!\n2 3 5 7 11 \n999\n</code></pre> with two identical <code>.ini</code> file contains: <pre><code>[SectionTest]\nkey1 = 999\nkey2 = I'm a string!\n\n[SectionTestVector]\nPrimeNumber = 2 3 5 7 11 13\n</code></pre></p>"},{"location":"contributing/#pre-compiled-headers","title":"Pre-Compiled headers","text":"<p>AC uses a precompile header <code>aiacpch.h</code> to the project to shorten compilation time for headers that you rarely modify such as stdb library, opencv etc.. Add to <code>aiacpch.h</code> every big header you do not use often. Include at the very top <code>#include \"aiacpch.h\"</code> of every <code>.cpp</code> file.</p>"},{"location":"contributing/#layers","title":"Layers","text":"<p>Layers are the main component of the framework. Each layer gets stacked and executed in that order. Each layer represents a different unit e.g. TSLAM, camera access, 3Drender, etc. Each layer has events where code can be injected in the loop and custom events. <pre><code>namespace AIAC\n{\n    class Layer\n    {\n    public:\n        virtual ~Layer() = default;\n\n        /// Is called when the layer is attached to the application.\n        virtual void OnAttach() {}\n\n        /// Is calle before GLFW poll events, GL frame and Imgui Frame\n        virtual void OnFrameAwake() {}\n\n        /// Is called when frame starts\n        virtual void OnFrameStart() {}\n\n        /// Is called when frame ends\n        virtual void OnFrameEnd() {}\n\n        /// Is called when the GLFW, GL and Imgui frame is updated and rendered\n        virtual void OnFrameFall() {}\n\n        /// Is called when the layer is detached from the application (~app).\n        virtual void OnDetach() {}\n    };\n}\n</code></pre> Next, you need to add it to the stack call in the main file CApp where it fits most:</p> <pre><code>...\nacApp_ptr-&gt;GetWindow()-&gt;Init();\n\nacApp_ptr-&gt;GetGORegistry()-&gt;Init();\n\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerCamera&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerCameraCalib&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerSlam&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::NewLayer1&gt;();  // &lt;---------- e.g.: your new layer 1\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerModel&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerToolhead&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerFeedback&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerUI&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::NewLayer2&gt;();  // &lt;---------- e.g.: your new layer 2\n\nacApp_ptr-&gt;GetRenderer()-&gt;Init();\n\nacApp_ptr-&gt;GetEventBus()-&gt;Init();\n\nacApp_ptr-&gt;Run();\n</code></pre>"},{"location":"contributing/#getting-the-main-app","title":"Getting the main app","text":"<p>There is one only app and it can be accessed from layers with: <pre><code>AIAC::Application&amp; app = AIAC::Application::GetInstance();\n</code></pre> or easier with a macro <pre><code>AIAC_APP\n</code></pre></p>"},{"location":"contributing/#getting-other-layers-variables","title":"Getting other layers' variables","text":"<p>To get other layers' variables use a small query function from the Application class. In the case of accessing test_a of layerA from e.g. layerB: <pre><code>AIAC_APP.GetLayer&lt;AIAC::LayerA&gt;()-&gt;test_a\n</code></pre></p>"},{"location":"contributing/#ui","title":"UI","text":"<p>UI is mainly built in ImGui. We wrap some of the functions and add custom functionalities.</p>"},{"location":"contributing/#logos","title":"Logos","text":"<p>Logos addresses/data is store in <code>CustomLogos.h</code>. As an example: <pre><code>#define AIAC_LOGO_LIGHT_GRAY \"assets/images/logos/logo_linux_gray_light.png\"\n</code></pre> E.g. to consume it: <pre><code>m_LogoBlack = AIAC::Image(AIAC_LOGO_BLACK);\n</code></pre></p>"},{"location":"contributing/#colors","title":"Colors","text":"<p>Colors macros can be found/add in the header <code>ClrPalette.h</code> with the following definition style: <pre><code>#define AIAC_UI_DARK_GREY ImVec4(0.2f, 0.2f, 0.2f, 1.0f)\n</code></pre></p>"},{"location":"contributing/#panes","title":"Panes","text":"<p>For every new layer you can create a new collapsable pannel in the main UI. To do so follow the next steps.</p> <p>Create a new function (declare it in <code>LayerUI.h &gt; Class LayerUI</code> and implement it in <code>LayerUI.cpp</code>) and start calling <code>ImGui</code> methods from there, put everythin you need for the UI there. This is the only place where you will write UI for your pane, like so: <pre><code>void LayerUI::SetPaneUICamera()\n    {\n        ImGui::Text(\"This layer is responsible for the physical camera.\");\n        AIAC::Camera&amp; camera = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera;\n        ImGui::Text(\"Camera is %s\", camera.IsOpened() ? \"open\" : \"closed\");\n        ImGui::Text(\"Camera resolution: %d x %d\", camera.GetWidth(), camera.GetHeight());\n    }\n</code></pre> Next copy past the template function in <code>LayerUI.cpp</code> and reference the function you created: <pre><code>//                 Label               Collapse              PaneContent\nStackPane(PaneUI(\"Example\",              true,       AIAC_BIND_EVENT_FN(SetPaneUIExample)         ));\nStackPane(PaneUI(\"Camera\",               true,       AIAC_BIND_EVENT_FN(SetPaneUICamera)          ));\nStackPane(PaneUI(\"Slam\",                 true,       AIAC_BIND_EVENT_FN(SetPaneUISlam)            ));\nStackPane(PaneUI(\"&lt;your-new-name&gt;\",      true,       AIAC_BIND_EVENT_FN(YourNewContainerMethod)   ));\n</code></pre></p>"},{"location":"contributing/#file-dialog","title":"File Dialog","text":"<p>The file dialog widget we use is implemented as singleton from this repo. This means that only one file dialog widget can be opened at once (it is possible to implement it as multiple instance if needed). If you need to select a file from local system, here's the snippet: <pre><code>if (ImGui::Button(\"Open 3dModel\"))\n            ImGuiFileDialog::Instance()-&gt;OpenDialog(\"Choose3dModel\", \"Open 3dModel\", \".ply, .obj\", \".\");\n\n        if (ImGuiFileDialog::Instance()-&gt;Display(\"Choose3dModel\")) \n        {\n            if (ImGuiFileDialog::Instance()-&gt;IsOk())\n            {\n            std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n            std::string filePath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n            // action\n            /* write here what to do with the file path */\n            }\n            ImGuiFileDialog::Instance()-&gt;Close();\n        }\n</code></pre></p>"},{"location":"contributing/#event-system","title":"Event System","text":"<p>We implement a bus-like event system based on the observer pattern and the tppevent repo. It is not multi-threaded but it can be modified as such. All the event files are contained in the dir <code>AIAC/EventSys</code>.</p>"},{"location":"contributing/#how-to-raise-events","title":"How to raise events","text":"<p>The event bus is stored in the Application. You can raise events from other files in two ways, either synchronusly, the event will be fired immediately with: <pre><code>AIAC_EBUS-&gt;DispatchEvent(std::make_shared&lt;SmtHappenedEvent&gt;(param))\n</code></pre> Or a-synchronusly, the event will be stored in the bus queue and executed in the main loop, before any layer frame calls: <pre><code>IAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;CameraCalibrationLoadedEvent&gt;(filePathName));\n</code></pre></p> <p>Note that you need to pass a <code>std::shared_ptr&lt;Event&gt;</code> to the event raisers.</p>"},{"location":"contributing/#how-to-add-events","title":"How to add events","text":"<p>First Add the event type in <code>Event.h</code> if it does not exist already: <pre><code>enum class EventType\n    {\n        None = 0,\n        AppClose,\n        SLAMMapLoaded, SLAMVocabularyLoaded,\n        CameraCalibrationLoaded,\n        ExampleCalled  // &lt;-- example\n        /* add types of events here */\n    };\n</code></pre> And a category in the same file: <pre><code>enum EventCategory\n    {\n        None = 0,\n        EventCategoryApplication =              BIT(0),\n        EventCategorySLAM =                     BIT(1),\n        EventCategoryCamera =                   BIT(2),\n        EventCategoryExample =                  BIT(3)  // &lt;-- example\n        /* add event category here */\n    };\n</code></pre> Next, create a new event file with a class that inherits from <code>class Event</code>, as an example <code>ExampleEvent.h</code>. Remeber to add to the parent constructor (a) EventType, (b) EventCategory and \u00a9 (accessory, by default 0) the prority at which the event needs to be executed, the bigger the number the sooner in the queue it will be fired: <pre><code>namespace AIAC\n{\n    class ExampleCalledEvent : public Event\n    {\n    public:\n        explicit ExampleCalledEvent(const std::string param)\n            : Event(EventType::ExampleCalled, EventCategory::EventCategoryExample, 100), m_Param(param)\n        {}\n\n        void OnExampleCalled();\n\n    private:\n        std::string m_Param;\n    };\n}\n</code></pre> Do not forget to add the header to <code>AIAC.h</code> in the correct order. <pre><code>#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/ExampleEvent.h\"\n/* &gt;&gt; add types of events here &lt;&lt; */\n#include \"AIAC/EventSys/EventBus.h\"\n</code></pre> In the declaration you can access layers via <code>AIAC_APP</code> as usual: <pre><code>namespace AIAC\n{\n    void ExampleCalledEvent::OnExampleCalled()\n    {\n        AIAC_APP.GetLayer&lt;LayerName&gt;()-&gt;Func(m_Param);\n    }\n}\n</code></pre> Finally you just need to add a listener to the <code>Init()</code> function of <code>EventBus.h</code>: <pre><code>#include \"AIAC/EventSys/ExampleEvent.h\"\n\nm_EventQueue.appendListener(EventType::ExampleCalled, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;ExampleCalledEvent&amp;&gt;(*event);\n                slamEvent.OnExampleCalled();\n            });\n</code></pre></p>"},{"location":"contributing/#logging","title":"Logging","text":"<p>To log use the following MACROS. All the code is contained in <code>Log.hpp</code> and <code>Log.cpp</code>.  <pre><code>AIAC_INFO(\"test_core_info\");\nAIAC_WARN(\"test_core_warn\");\nAIAC_CRITICAL(\"test_core_critical\");\nAIAC_DEBUG(\"test_core_debug\");\nAIAC_ERROR(\"test_core_error\");\n</code></pre> The output is like so: <pre><code>[source main.cpp] [function main] [line 32] [16:30:05] APP: test\n</code></pre> The logging can be silenced by setting OFF the option in the main <code>CMakeLists.txt</code> and do clean reconfiguration. <pre><code>option(SILENT_LOGGING \"Do not log messages in the terminal of on.\" ON)\n</code></pre></p>"},{"location":"contributing/#go-system","title":"GO System","text":"<p>To add, remove or get Geometric Objects (GO) from any layer: <pre><code>#include \"AIAC/GOSys/GO.h\"\n\nstd::shared_ptr&lt;GOPoint&gt; pt1 = GOPoint::Add(1, 1, 1);             // create a point\n\nstd::shared_ptr&lt;GOPoint&gt; pt1copy = GOPoint::Get(pt1.GetId());     // get the point elsewhere\nfloat x = pt1copy-&gt;X();                                 // access GO properties\nauto pts = GOPoint::GetAll();                           // access all GO of one type\nGOPoint::Remove(pt1copy.GetId());                                 // remove the point from registry\n</code></pre> Note the the Constructor for each GO is private, the only way to instance it is to use the <code>Add()</code> static function. The reason why we decided to adopt this \"registry\" pattern is because all GO object need to be created as a smart pointer to be copied into a GOregistry. We must be sure that every GOObject is subscribed to the GORegistry. A normal c++ constructor cannot create the smart pointer of the create object, hence the Add() function does this for us.  All the next layers will retrive those smart pointers from the GOregistry and eventually modify them. And finally the render will go through the GOregistry and \"bake\" (render) all the GO geometries.</p> <p>The **G**eometric **O**bject System allows to add objects to the 3D scene before to render them. Having a geometric entity prior to the OpenGL Render allows to calculates relations between geometries to obtain live feedbacks (e.g. drilling depth). Files can be found in <code>/GOSys</code>.</p> <p>The GOSystem is composed of two components: - <code>GOPrimitives.h/cpp</code> (a library which stores <code>GOPoint</code>, <code>GOLine</code>, <code>GOText</code>, etc) - <code>GORegistry.h/cpp</code> (an API which interacts with the map. Note that it has to recive only smart pointers to avoid object slicing since we pass heirs of <code>GOPrimitive</code>.)</p>"},{"location":"contributing/#renderer-api","title":"Renderer API","text":"<p>The renderer API is separated into two parts: 1. <code>GlUtils.h</code>: Provides a direct interface to draw the 3 basic material of OpenGL, i.e. <code>Point</code>, <code>Line</code>, and <code>Triangle (mesh)</code>. By calling the function, it creates an object, render it and delete instantly. These functions should only be used when GO system doesn't fit the scenrio. 2. <code>RenderAPI.h</code>: To render the already exist GO Primitives. When a GO is initialized or update, it creates an OpenGL object and stores in the memory. The functions in this file takes the GO object as the parameter and renders the corresponding OpenGL objects.</p>"},{"location":"contributing/#glutilsh","title":"GlUtils.h","text":"<p><code>GlUtils.h</code> contains the function to draw the 3 basic material of OpenGL, i.e. point, line, and triangle (mesh). By calling the function, it creates an OpenGL object, render it, and delete instantly. Since calling these functions continuesly add/delete OpenGL objects, which is not efficient, they should only be used when GO system doesn't fit the scenrio. (e.g. drawing SLAM tags while mapping, since it changes every frame)</p>"},{"location":"contributing/#point","title":"Point","text":"<p><pre><code>void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize);\nvoid glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const glm::vec4 &amp;color, GLfloat pointSize);\n</code></pre> - <code>vertices</code>: A vector of 3d points, indicate the position of the vertices. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the <code>vertices</code>.  - <code>pointSize</code>: The size of the point.</p>"},{"location":"contributing/#line","title":"Line","text":"<p><pre><code>void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const std::vector&lt;glm::vec4&gt; &amp;colors);\nvoid glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const glm::vec4 &amp;color);\n\n/* \n * (0, 1, 0) --- (1, 0, 0)\n *     |             |\n *     |             |\n *     |             |\n * (0, 0, 0) --- (0, 0, 1)\n * \n * If you want to draw a square like this, you should construct the `edges` as:\n * [\n *    (0, 0, 0), (0, 0, 1),\n *    (0, 0, 1), (1, 0, 0),\n *    (1, 0, 0), (0, 1, 0),\n *    (0, 1, 0), (0, 0, 0)\n * ]\n * \n * */\n</code></pre> - <code>edges</code>: A vector of the edge's end-points. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the <code>edges</code>.</p>"},{"location":"contributing/#triangle","title":"Triangle","text":"<p><pre><code>void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const std::vector&lt;glm::vec4&gt; &amp;colors);\nvoid glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const glm::vec4 &amp;colors);\n/* \n * P2(0, 1, 0) --- P3(1, 0, 0)\n *     |            /    |\n *     |          /      |\n *     |        /        |\n *     |      /          |\n *     |    /            |\n * P0(0, 0, 0) --- P1(0, 0, 1)\n * \n * If you want to draw a mesh of square like this, you should construct the `edges` as:\n * [\n *    (0, 0, 0), // P0\n *    (0, 0, 1), // P1\n *    (1, 0, 0), // P2\n *    (0, 1, 0), // P3\n * ]\n * with `indices`:\n * [\n *     0, 1, 3, // Right-bottom triangle\n *     3, 2, 0  // Left-top triangle\n * ]\n * */\n</code></pre> - <code>vertices</code>: A vector of 3d points, indicate the position of the vertices. - <code>indices</code>: A vector of all triangle's indices. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the vertices.</p>"},{"location":"contributing/#renderapih","title":"RenderAPI.h","text":"<p>Render API is a collection of functions that are used for rendering 3D objects (GO primitives and the map). These functions can be call directly as long as <code>RenderAPI.h</code>is included.</p>"},{"location":"contributing/#go","title":"GO","text":"<p>An implicit type casting is implemented, simply call the <code>DrawGO</code> function in the <code>Render.cpp</code>'s function <code>OnRender()</code>: <pre><code>void DrawGO(const shared_ptr&lt;GOPrimitive&gt;&amp; goPrimitive);\nvoid DrawGOs(const std::vector&lt;shared_ptr&lt;GOPrimitive&gt;&gt;&amp; goPrimitive);\n</code></pre></p>"},{"location":"contributing/#textrendererh","title":"TextRenderer.h","text":"<p>Rendering text through OpenGL is quite tricky. The <code>TextRenderer.h</code> is here to handle this. The <code>TextRenderer</code> has to be initialized, after that, static functions can be call for rendering texts. <pre><code>void Renderer::Init() {\n    ...\n    TextRenderer::Init()\n    ...\n}\n\nvoid myFunction() {\n    // First setting the current projection matrix\n    TextRenderer::SetProjection(projection); // The MVP projection of the scene\n\n    // Rendering text at (0, 3, 0)\n    TextRenderer::RenderTextIn3DSpace(\n                \"center\",                           // Text to show\n                glm::vec3(0.0f, 3.0f, 0.0f),        // Position in 3D space\n                glm::vec4(0.0f, 0.0f, 0.0f, 0.7f)); // Color\n\n    // Rendering the text on a fixed position on the screen.\n    // (0, 0) is the left-bottom corner and (windowWidth, windowHeight) is the right-top corner\n    TextRenderer::RenderText(\n            \"center\",                               // Text to show\n            150.0f, 150.0f,                         // Position on the screen\n            glm::vec4(0.0f, 0.0f, 0.0f, 0.7f));     // Color\n}\n</code></pre></p>"},{"location":"contributing/#slam-map","title":"Slam Map","text":"<p><pre><code>void DrawSlamMap(const shared_ptr&lt;tslam::Map&gt; &amp;map, const glm::vec4 &amp;color, float pointSize);\n</code></pre> - <code>map</code>: The map itself. - <code>color</code>: The color of the point clouds. - <code>pointSize</code>: The point cloud's size.</p> <p><code>other shapes</code></p>"},{"location":"contributing/#ctesting","title":"CTesting","text":"<p>When necessary, c++ testing is done by using CTest. Important/critical features (e.g., correcting functioning of graphics with OpenGL and Glfw) needs testing to be written (this is usefull for e.g., GitHub Actions). Such tests can be extracted from the main source code and integrated in a seperate section: cmake testing.</p> <p>To add a new test do as follow.</p> <p>First create a new sub-folder in the folder <code>./test</code> as <code>./test/exampletest</code>. Here add a console cpp file called <code>tester.cpp</code> which returns 0 or 1 and add a new <code>CMakeLists.txt</code> as such: <pre><code>add_executable(example_test tester.cpp)\n\n/* &lt;-- \nInsert here linking necessary for the executable\nNote that if you already found packages in the head CMakeLists file\nyou can simply use the macros here.\n--&gt; */\n\nadd_test(NAME \"ExampleTest\" COMMAND \"example_test\" &lt;argv-here&gt; WORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\")\n</code></pre> In the <code>./test</code>'s <code>CMakeLists.txt</code> add the created sub-directory: <pre><code>if (TEST_EXAMPLE)\n    add_subdirectory(exampletest)\nendif()\n</code></pre> Finally add an option in the main <code>CMakeLists.txt</code> describing the test: <pre><code>include(CTest)\n# ...\noption(TEST_EXAMPLE \"Test to test something important.\" ON)\n# ...\nif(TEST_EXAMPLE)\n    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests/exampletest)\nendif()\n</code></pre></p> <p>Next, <code>./configure.sh -c</code> and <code>./build.sh</code> and: <pre><code>cd ./build\nctest -N    # &lt;--- to see how many tests there are\nctest -V    # &lt;--- run the tests\n</code></pre></p>"},{"location":"contributing/add-new-tool/","title":"Add new tools or mounts","text":"<p>You may end up in a situation where your wood working tool has no mount () already available or its toolhead () is not digitized and present in the AC datasets. In this case you can contribute to the existing datasets of both by following first these instructions.</p>"},{"location":"contributing/add-new-tool/#3d-model-your-items","title":"3D Model your items","text":"<p>Chances are that you will be needing to acquire the 3D model of our mount () or toolhead ().</p> \u00a0\u00a0 tool mount\u00a0\u00a0 toolhead <p></p> <p>For the mount, you can do this by using a 3D scanner or by modeling it yourself. If you are modeling it yourself, you can use Blender or FreeCAD to create the model. Then you can export the model as a <code>.stl</code> file with the following naming convention: <code>toolhead_mount_name.stl</code>.</p> <p>Each STL file follows the naming convention:</p> <p><code>&lt;type&gt;_&lt;brand&gt;_&lt;model-name&gt;_part.stl</code></p> <ul> <li> <p> <code>type</code>: Indicates the type of mount or the tool category (e.g., \"mount\", \"sensor-holder\").</p> </li> <li> <p> <code>brand</code>: The woodworking tool brand (e.g., \"Makita\", \"Bosch\", \"Dewalt\").</p> </li> <li> <p> <code>model-name</code>: The specific model identification of the tool (e.g., \"M3700\", \"1617EVS\").</p> </li> <li> <p> <code>part</code>: Optional additional descriptor if multiple parts are required for a single mount assembly (e.g., \"base\", \"clip\", \"insert\").</p> </li> </ul> <p>For example, a mount designed for a Makita M3700 router might be named:</p> <p><code>mount_makita_m3700_base.stl</code></p> <p><code>mount_makita_m3700_clip.stl</code></p> <p></p>"},{"location":"contributing/add-new-tool/#photogrammetry","title":"Photogrammetry","text":"<p>Obtain a 3D model from a physical tool can be complicated. The idea of photogrammetry is to secure images of the tool from different angels and reconstruct the 3D model from that. Hence, 2 crucial steps need to be done. 1. Acquiring the photos - at IBOIS, we use 2 different methods depending on the size of the physical objects.   1.1 When the size is small enough we use the foldio   1.2 When the size is too large to fit in the studio, we use the custom made stone scanner. 2. 3D reconstruction - we use the metashape program and the way we do it can be followed by this link</p> <p> By this approach, you should have. Please not that we name the final 3D object as \"model\" as a convention</p> <ol> <li><code>model.obj</code> - 3D model of the physical tool head.</li> <li><code>model.mtl</code>optional - complimentary file for the model.obj</li> <li><code>model_occlusion.jpg</code>optional - occlusion texture of the object from the 3D model reconstruction</li> <li><code>model_normal.jpg</code>optional - occlusion texture of the object from the 3D model reconstruction</li> <li><code>model.jpg</code>optional - diffuse map texture of the object from the 3D model reconstruction</li> </ol>"},{"location":"contributing/add-new-tool/#re-scale","title":"Re-scale","text":"<p>Once the 3D model is obtained, we must re-scale it to the correct size. This can be done in the blender.</p> <ol> <li>Use the measure tool to measure the reference part of the object and physical object. Here the diameter of the circle is measured, which is 1.5681m.  ]</li> <li>Scale the 3D model to to same size as the physical tool head. The physical object is measured to be 0.020m. Hence, the scale factor is 0.020/1.5681 = 0.0127. To do this, press <code>s</code> and type in the scale factor. Then, press <code>enter</code>. </li> <li>Check the scale by measuring the reference part of the object and physical object again. Here the diameter of the circle is measured, which is 0.020m.  By this step, you should have.</li> <li><code>model.obj</code> - 3D model that is re-scaled to the precise size of the physical tool head.</li> <li><code>model.mtl</code>optional - complimentary file for the <code>model.obj</code></li> </ol>"},{"location":"contributing/add-new-tool/#adding-metadata-acit","title":"Adding metadata (<code>ACIT</code>)","text":"<p>We use the circle mesh to do the reference points. Depending on the 3D model, there are specific information points you need to add see the toolhead documentation. <code>ACIT</code> is the information to be parsed by Augmented Carpentry who uses them to derive all the essential information for fabrication process.</p> <p>Let's do the auger_drill_bit_20_235: <pre><code>&lt;acit version=\"0.1.0\"&gt;\n  &lt;toolhead name=\"auger_drill_bit_20_235\" type=\"drillbit\"&gt;\n    &lt;toolbase&gt; 0 0 0 &lt;/toolbase&gt;\n    &lt;tooltip&gt; 0 0 0.235 &lt;/tooltip&gt;\n    &lt;eattip&gt; 0 0 0.228 &lt;/eattip&gt;\n    &lt;chucktip&gt; 0 0 0.075 &lt;/chucktip&gt;\n    &lt;radius&gt; 0.02 &lt;/radius&gt;\n  &lt;/toolhead&gt;\n&lt;/acit&gt;\n</code></pre></p> <p>To derive these information, we need <code>toolbase</code>, <code>tooltip</code>, <code>eattip</code>, <code>chucktip</code>, and <code>radius</code>.</p> <ol> <li>Open the reformatter util.</li> <li>Import the 3D model obj file to a new collection. </li> <li><code>toolbase</code> should be at <code>&lt;0, 0, 0&gt;</code>. <code>tooltip</code> is the length of the tool head from the base which from factory is 235mm. With these two reference points, we can align our model with the tip at <code>&lt;0, 0, 0.235&gt;</code>. The references points are represented by the circle mesh [Layout &gt; Object Model &gt; Add &gt; Mesh &gt; Circle], or you can just copy it from the other existing collection. </li> <li>Adding the <code>eattip</code> and <code>chucktip</code> </li> <li>Export the mesh of the tool in the collection individually as a new obj file [Select the model, then File &gt; Export &gt; Wavefront (obj), select \"selection only\" and name it to <code>model</code>]. This will be the final 3D model of the tool head which has the corresponding ACIT information. </li> <li>Create a new file named <code>metadata.acit</code> and copy the ACIT metadata to the file. Then, fill in the information you have derived in the \"Object Property\" &gt; Transform &gt; Location Z. Additionally, adding the <code>radius</code> of the tool head. This is the radius of the tool head. In this case, it is 0.02m.</li> <li>Create another file name 'model.initpose' and give it initial pose of the model. Be careful of the indentation and the spacing. This will be used for automatic \"config.yml\" generation of the python script.</li> </ol> <p></p>"},{"location":"contributing/add-new-tool/#putting-everything-together","title":"Putting everything together","text":"<p>Once everything is done, you should have:</p> <ol> <li><code>model.obj</code> - 3D model that is re-scaled to the precise size of the physical tool head.</li> <li><code>model.mtl</code>optional - complimentary file for the model.obj</li> <li><code>model_occlusion.jpg</code>optional - occlusion texture of the object from the 3D model reconstruction</li> <li><code>model_normal.jpg</code>optional - occlusion texture of the object from the 3D model reconstruction</li> <li><code>model.jpg</code>optional - diffuse map texture of the object from the 3D model reconstruction</li> <li><code>metadata.acit</code> - xml formatted file with all the information crucial for the fabrication.</li> <li><code>model.initpose</code> - you can copy paste any other <code>model.initpose</code> file. Just make sure to change the name of the model to the correct one.</li> </ol> <p>Put them to the file named by the tool head and zip it.</p>"},{"location":"contributing/add-new-tool/#dataset-integration","title":"Dataset integration","text":"<p>The way your tool will be inserted in the AC dataset is by creating first an issue in the issue tracker. This will be used to discuss the model and its integration in the AC datasets. Once the model is validated, it will be added to the datasets by creating a pull request.</p> <ul> <li>Add new tools or mounts</li> <li>3D Model your items</li> <li>Dataset integration<ul> <li>Title</li> <li>External link to downloadable data</li> <li>Model data</li> </ul> </li> </ul>"},{"location":"contributing/add-new-tool/#title","title":"Title","text":"<p>A good title should be a short, one-sentence description of the issue, contain all relevant information and, in particular, keywords to simplify the search in our issue tracker.</p> Example Clear Clarify social cards setup on Windows Unclear Missing information in the docs Useless Help"},{"location":"contributing/add-new-tool/#external-link-to-downloadable-data","title":"External link to downloadable data","text":"<p>Include a link to the 3D model and its data of the toolhead or mount as a <code>.zip</code> file. This will be used to validate the model and its integration in the AC datasets.</p> <p>Why we need this: providing an external link to the 3D model and its data will help us understand the model and its integration in the AC datasets without overloading the github repository.</p>"},{"location":"contributing/add-new-tool/#model-data","title":"Model data","text":"<p>Provide a the toolhead or mount model. Possibly with links to existing references from brands.</p> <p>Why we need this: describing the model clearly, with references and data is a prerequisite for improving AC's dataset \u2013 we need to understand what's available and what's missing, maybe your tool already exists.</p>"},{"location":"contributing/community/","title":"Contributing","text":"<p>Augmented Carpentry is currently a prototype that requires multiple contributions and fixes before to be used by a large pool of users. This is why we set up an infrastructure to allow users to make contributions, suggestions, or simply fork the repo and create your own version of Augmented Carpentry.</p> <p>Augmented Carpentry is an actively growing and constantly evolving project mainly maintained by Andrea Settimi at the Laboratory for Timber Construction (IBOIS, EPFL) in Lausanne, Switzerland. <sup>1</sup></p>"},{"location":"contributing/community/#how-you-can-contribute","title":"How you can contribute","text":"<p>We understand that reporting bugs, raising change requests, as well as engaging in discussions can be time-consuming, which is why we've carefully optimized our issue templates and defined guidelines to improve the overall interaction within the project. The [issue tracker] is for now our main interface to report bugs and exchange over possible implementations.</p> <p>Our goal is to ensure that our documentation, as well as issue tracker and discussion board, are well-structured, easy to navigate, and searchable, so you can find what you need quickly and efficiently. Thus, when you follow our guidelines, we can help you much faster.</p> <p>In this section, we guide your through AC processes.</p>"},{"location":"contributing/community/#creating-an-issue","title":"Creating an issue","text":"<ul> <li> <p> Something is not working?</p> <p>Report a bug for AC by creating an issue with a reproduction and all the necessary information</p> <p> Report a bug</p> </li> <li> <p> Missing information in our docs?</p> <p>Report missing information or potential inconsistencies in our documentation</p> <p> Report a docs issue</p> </li> <li> <p> Want to add new tools or mounts?</p> <p>Propose new tools or mounts to enlarge the AC dataset</p> <p> Add a new tool or mount</p> </li> <li> <p> Have a question or want to submit an idea?</p> <p>Ask a question or propose a change</p> <p> Ask a question</p> </li> <li> <p> Want to create a pull request?</p> <p>Learn how to create a comprehensive and useful pull request (PR)</p> <p> Create a pull request</p> </li> </ul>"},{"location":"contributing/community/#code-of-conduct","title":"Code of Conduct","text":"<p>Our [Code of Conduct] outlines the expectation for all community members to treat one another with respect, employing inclusive and welcoming language. Our commitment is to foster a positive and supportive environment, free of inappropriate, offensive, or harmful behavior.</p> <p>We take any violations seriously and will take appropriate action in response to uphold these values.<sup>2</sup></p> <p>Please also note that AC is provided \"as-is\" as a prototype, without any warranties, express or implied, including but not limited to fitness for a particular purpose or non-infringement. The user assumes full responsibility for the use of the software, and we are not liable for any damages, losses, or misuse arising from its use or its modifications. By using or contributing to this software, you agree to these terms.</p> <ol> <li> <p>The following open-source project guidelines and structures are based one the ones by the Material project.\u00a0\u21a9</p> </li> <li> <p>Warning and blocking policy: Given the increasing popularity of our project and our commitment to a healthy community, we've defined clear guidelines on how we proceed with violations:</p> <p>2.1. First warning: If a user repeatedly violates community standards, they receive a formal, permanent first warning.</p> <p>2.2. Second warning and opportunity for resolution: Continued misconduct leads to a second warning. The user is then granted five days to publicly respond and clarify or apologize for their actions.</p> <p>2.3. Blocking: If there is no improvement after the second warning, the user may be blocked to safeguard the community\u2019s positive environment. Blocking is rarely necessary, reflecting the community\u2019s emphasis on constructive dialogue and respect.\u00a0\u21a9</p> </li> </ol>"},{"location":"contributing/making-a-pull-request/","title":"Pull Requests","text":"<p>You can contribute to Material for MkDocs by making a pull request that will be reviewed by maintainers and integrated into the main repository when the changes made are approved. You can contribute bug fixes, changes to the documentation, new functionality you have developed, or new toolheads and mounts.</p> <p>Considering a pull request</p> <p>Before deciding to spend effort on making changes and creating a pull request, please discuss what you intend to do. If you are responding to what you think might be a bug, please issue a bug report first. If you intend to work on documentation, create a documentation issue. If you want to work on a new toolhead or mount, please read the add new tool.</p>"},{"location":"contributing/making-a-pull-request/#preparing-changes-and-draft-pr","title":"Preparing changes and draft PR","text":"<p>Follow these steps to work on PR for AC:</p> <ol> <li>Fork the AC repository by clicking the Fork button on the AC repository. Initially, create the pull request as a draft. You do this [through the various interfaces that GitHub provides]. Which one you use is entirely up to you. We do not provide specific instructions for using the interfaces as GitHub provide all the information that should be necessary.</li> </ol> <p>[through the various interfaces that GitHub provides]: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-requestClone the repository to your local machine:</p> <pre><code>```console\ngit clone --recurse-submodules https://github.com/ibois-epfl/augmented-carpentry.git\ncd augmented-carpentry\n```\n</code></pre> <ol> <li> <p>Create a new branch for your feature:</p> <pre><code>git checkout -b my-feature\n</code></pre> </li> <li> <p>Add the AC repository as a remote for convinience:</p> <pre><code>git remote add upstream https://github.com/ibois-epfl/augmented-carpentry\n</code></pre> </li> <li> <p>Next you will need to set up your development environment.</p> </li> <li> <p>Work on your featurev by following our contribution guidelines. Next, commit your changes:</p> <pre><code>git add .\ngit commit -m \"WIP: Add my feature\"\ngit push origin my-feature\n</code></pre> </li> </ol>"},{"location":"contributing/making-a-pull-request/#testing-and-reviewing-changes","title":"Testing and reviewing changes","text":"<p>Before you commit any changes, you should make sure that they work as expected and do not create any unintended side effects. You should test them on at least these three smoke tests:</p> <ul> <li> <p>Test by running AC locally, a laptop run it's fine. This test will run anyways in the CI/CD pipeline.</p> </li> <li> <p>Test with relevant examples in your fabrication scenario.</p> </li> </ul>"},{"location":"contributing/making-a-pull-request/#dos-and-donts","title":"Dos and Don'ts","text":"<ol> <li> <p>Don't just create a pull request with changes that are not explained.</p> </li> <li> <p>Do discuss what you intend to do with people in the discussions so that the    rational for any changes is clear before you write or modify code.</p> </li> <li> <p>Do link to the discussion or any issues to provide the context for a pull    request.</p> </li> <li> <p>Do ask questions if you are uncertain about anything.</p> </li> <li> <p>Do ask yourself if what you are doing benefits the wider community and    makes Material for MkDocs a better product.</p> </li> <li> <p>Do ask yourself if the cost of making the changes stands in a good    relation to the benefits they will bring. Some otherwise sensible changes can    add complexity for comparatively little gain, might break existing behaviour    or might be brittle when other changes need to be made.</p> </li> <li> <p>Do merge in concurrent changes frequently to minimize the chance of    conflicting changes that may be difficult to resolve.</p> </li> </ol>"},{"location":"contributing/reporting-a-bug/","title":"Bug reports","text":"<p>Augmented Carpentry is an actively maintained project that we constantly strive to improve. With a prototype of this size and complexity, bugs may occur. If you think you have discovered a bug, you can help us by submitting an issue in our public issue tracker, following this guide.</p> <p>A clear, detailed bug report helps everyone in the Augmented Carpentry community work more efficiently. By providing thorough steps to reproduce, clear descriptions, and helpful logs or screenshots, you ensure that issues are addressed and resolved faster\u2014leading to a better experience for all users.</p> <p>But first, please do the following things before creating an issue.</p>"},{"location":"contributing/reporting-a-bug/#upgrade-to-latest-version","title":"Upgrade to latest version","text":"<p>Chances are that the bug you discovered was already fixed in a subsequent version. Thus, before reporting an issue, ensure that you're running the latest version of AC. Please consult our [upgrade guide] to learn how to upgrade to the latest version.</p> <p>Bug fixes are not backported</p> <p>Please understand that only bugs that occur in the latest version of AC will be addressed. AC is a living prototype that can only be supported to its bleeding edge version.</p> <p>[upgrade guide] : ../installation.md</p>"},{"location":"contributing/reporting-a-bug/#search-for-solutions","title":"Search for solutions","text":"<p>Now, before you go through the trouble of creating a bug report that is answered and closed right away with a link to the relevant documentation section or another already reported or closed issue or discussion, you can save time for us and yourself by doing some research:</p> <ol> <li> <p>Search our documentation and look for the relevant sections that could     be related to your problem. If found, make sure that you configured     everything correctly.</p> </li> <li> <p>Search our issue tracker, as another user might already     have reported the same problem, and there might even be a known workaround     or fix for it. Thus, no need to create a new issue.</p> </li> </ol> <p>Keep track of all search terms and relevant links, you'll need them in the bug report.<sup>1</sup></p> <p>At this point, when you still haven't found a solution to your problem, we encourage you to create an issue because it's now very likely that you stumbled over something we don't know yet. Read the following section to learn how to create a complete and helpful bug report.</p>"},{"location":"contributing/reporting-a-bug/#issue-template","title":"Issue template","text":"<p>We have created issue templates to make the bug reporting process as simple as possible and more efficient. Just pick up the one that fits your needs.</p> <ul> <li>Bug reports<ul> <li>Upgrade to latest version</li> <li>Search for solutions</li> </ul> </li> <li>Issue template<ul> <li>Title</li> <li>Context optional { #context }</li> <li>Bug description</li> <li>Steps to reproduce</li> <li>New machines { #machine }</li> </ul> </li> </ul>"},{"location":"contributing/reporting-a-bug/#title","title":"Title","text":"<p>A good title is short and descriptive. It should be a one-sentence executive summary of the issue, so the impact and severity of the bug you want to report can be inferred from the title.</p> Example Clear Built-in <code>typeset</code> plugin changes precedence of nav title over <code>h1</code> Wordy The built-in <code>typeset</code> plugin changes the precedence of the nav title over the document headline Unclear Title does not work Useless Help"},{"location":"contributing/reporting-a-bug/#context","title":"Context optional","text":"<p>Before describing the bug, you can provide additional context for us to understand what you were trying to achieve. Explain the circumstances in which you're using Augmented Carpentry, and what you think might be relevant. Don't write about the bug here.</p> <p>Why this might be helpful: some errors only manifest in specific settings, environments or edge cases, for example, when your are trying to realize a joint whose shape is not integrated in AC yet.</p>"},{"location":"contributing/reporting-a-bug/#bug-description","title":"Bug description","text":"<p>Now, to the bug you want to report. Provide a clear, focused, specific, and concise summary of the bug you encountered and your scenario of fabrication.</p> <ul> <li> <p>Keep it short and concise \u2013 if the bug can be precisely explained in one     or two sentences, perfect. Don't inflate it \u2013 maintainers and future users     will be grateful for having to read less.</p> </li> <li> <p>Give the most important details \u2013 include the model of your woodworking or tools' models.</p> </li> <li> <p>One bug at a time \u2013 if you encounter several unrelated bugs, please     create separate issues for them. Don't report them in the same issue, as     this makes attribution difficult.</p> </li> </ul> <p> Stretch goal \u2013 if you found a workaround or a way to fix the bug, you can help other users temporarily mitigate the problem before we maintainers can fix the bug in our code base.</p> <p>Why we need this: in order for us to understand the problem, we need a clear description of it and quantify its impact, which is essential for triage and prioritization.</p>"},{"location":"contributing/reporting-a-bug/#steps-to-reproduce","title":"Steps to reproduce","text":"<p>At this point, you provided us with enough information to understand the bug and provided us with a reproduction that we could run and inspect. However, when we run your reproduction, it might not be immediately apparent how we can see the bug in action.</p> <p>Thus, please list the specific steps we should follow when running your reproduction to observe the bug. Keep the steps short and concise, and make sure not to leave anything out. Use simple language as you would explain it to a five-year-old, and focus on continuity.</p> <p>Why we need this: we must know how to navigate your reproduction in order to observe the bug, as some bugs only occur at certain viewports or in specific conditions.</p>"},{"location":"contributing/reporting-a-bug/#machine","title":"New machines","text":"<p>If you're reporting a bug that only occurs in a specific computing unit that is not documented or tested in AC in the section Getting started</p> <ol> <li> <p>We might be using terminology in our documentation different from yours, but we mean the same. When you include the search terms and related links in your bug report, you help us to adjust and improve the documentation.\u00a0\u21a9</p> </li> </ol>"},{"location":"contributing/reporting-a-docs-issue/","title":"Documentation issues","text":"<p>Our documentation is constantly growing with information on features, configurations, customizations, and much more. If you have found an inconsistency or see room for improvement, please follow this guide to submit an issue on our issue tracker.</p>"},{"location":"contributing/reporting-a-docs-issue/#issue-template","title":"Issue template","text":"<p>Reporting a documentation issue is usually less involved than reporting a bug, as we don't need a reproduction. Please thoroughly read this guide before creating a new documentation issue, and provide the following information as part of the issue:</p> <ul> <li>Documentation issues</li> <li>Issue template<ul> <li>Title</li> <li>Description</li> <li>Related links</li> <li>Proposed change optional { #proposed-change }</li> </ul> </li> </ul>"},{"location":"contributing/reporting-a-docs-issue/#title","title":"Title","text":"<p>A good title should be a short, one-sentence description of the issue, contain all relevant information and, in particular, keywords to simplify the search in our issue tracker.</p> Example Clear Clarify social cards setup on Windows Unclear Missing information in the docs Useless Help"},{"location":"contributing/reporting-a-docs-issue/#description","title":"Description","text":"<p>Provide a clear and concise summary of the inconsistency or issue you encountered in the documentation or the documentation section that needs improvement. Explain why you think the documentation should be adjusted and describe the severity of the issue:</p> <ul> <li> <p>Keep it short and concise \u2013 if the inconsistency or issue can be     precisely explained in one or two sentences, perfect. Maintainers and future     users will be grateful for having to read less.</p> </li> <li> <p>One issue at a time \u2013 if you encounter several unrelated inconsistencies,     please create separate issues for them. Don't report them in the same issue     \u2013 it makes attribution difficult.</p> </li> </ul> <p>Why we need this: describing the problem clearly and concisely is a prerequisite for improving our documentation \u2013 we need to understand what's wrong, so we can fix it.</p>"},{"location":"contributing/reporting-a-docs-issue/#related-links","title":"Related links","text":"<p>After you described the documentation section that needs to be adjusted above, we now ask you to share the link to this specific documentation section and other possibly related sections. Make sure to use anchor links (permanent links) where possible, as it simplifies discovery.</p> <p>Why we need this: providing the links to the documentation help us understand which sections of our documentation need to be adjusted, extended, or overhauled.</p>"},{"location":"contributing/reporting-a-docs-issue/#proposed-change","title":"Proposed change optional","text":"<p>Now that you have provided us with the description and links to the documentation sections, you can help us, maintainers, and the community by proposing an improvement. You can sketch out rough ideas or write a concrete proposal. This field is optional but very helpful.</p> <p>Why we need this: an improvement proposal can be beneficial for other users who encounter the same issue, as they offer solutions before we maintainers can update the documentation.</p>"},{"location":"cpp-docs/","title":"C++ docs","text":"<p>Welcome to the C++ documentation for AC. This documentation is auto-generated using mkDoxy for generating documentation from annotated C++ source code.</p> <p>The main entry point of the project is the AIAC.h file. Here you can find all the major headers for the project.</p> src/AIAC.h<pre><code>#pragma once\n\n#include \"AIAC/GlHeader.h\"\n\n#include \"AIAC/Config.h\"\n\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb/stb_image.h\"\n\n#include \"AIAC/Base.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Assert.h\"\n\n#include \"AIAC/TouchMonitor.h\"\n#include \"AIAC/Window.h\"\n\n#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n\n#include \"AIAC/Image.h\"\n#include \"AIAC/Camera.h\"\n#include \"AIAC/DLoader.h\"\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/LayerCamera.h\"\n#include \"AIAC/LayerCameraCalib.h\"\n#include \"AIAC/LayerSlam.h\"\n#include \"AIAC/LayerUI.h\"\n#include \"AIAC/LayerModel.h\"\n#include \"AIAC/LayerToolhead.h\"\n#include \"AIAC/LayerFeedback.h\"\n#include \"AIAC/LayerUtils.h\"\n#include \"AIAC/LayerLogRecorder.h\"\n\n#include \"AIAC/Render/Renderer.h\"\n#include \"AIAC/GOSys/GO.h\"\n\n#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n#include \"AIAC/EventSys/CameraEvent.h\"\n#include \"AIAC/EventSys/ApplicationEvent.h\"\n\n/* &gt;&gt; add types of events here &lt;&lt; */\n#include \"AIAC/EventSys/EventBus.h\"\n\n#include \"AIAC/Application.h\"\n</code></pre> <p>The documentation is organized into several sections to help you navigate through the different components of the project. Each section provides detailed information about classes, functions, variables, and other elements of the codebase. Below is a high-level overview of the structure of the code base documentation:</p> Section Description Files Contains detailed information about the files in the project, including file-level documentation and references to classes and functions defined within each file. Functions A list of all global functions in the project, detailing their signatures, parameters, and return types. Class List A comprehensive list of all classes in the project, providing quick access to class documentation. Class Hierarchy A hierarchical view of the class inheritance structure, showing the relationships between base and derived classes. Class Members Detailed information about the members of each class, including functions, variables, typedefs, and enumerations. Typedefs A list of all typedefs in the project, providing type aliases used throughout the codebase. Namespace List A list of all namespaces in the project, providing an overview of the namespace structure. Namespace Members Detailed information about the members of each namespace, including functions, variables, typedefs, and enumerations. Variables A list of all global variables in the project, including their types and descriptions. Macros A list of all macros in the project, providing preprocessor definitions used throughout the codebase."},{"location":"developer-guide/","title":"Index","text":"<p>Placeholder for sub index</p>"},{"location":"developer-guide/CONTRIBUTING/","title":"Guide for contributors","text":"<p>Here's you can find some documentations and guidelines to contribute to augmented_carpentry.</p>"},{"location":"developer-guide/CONTRIBUTING/#github-commit-convetion","title":"GitHub commit convetion","text":"<p>All commits need to be labeled with a tag among these: <pre><code>git commit -m \"ADD:&lt;description&gt;\"         &lt;--- for adding new elements\ngit commit -m \"FIX:&lt;description&gt;\"         &lt;--- for fixing (errors, typos)\ngit commit -m \"FLASH:&lt;description&gt;\"       &lt;--- quick checkpoint before refactoring\ngit commit -m \"MILESTONE:&lt;description&gt;\"   &lt;--- for capping moment in development\ngit commit -m \"CAP:&lt;description&gt;\"         &lt;--- for for less important milestones\ngit commit -m \"UPDATE:&lt;description&gt;\"      &lt;--- for moddification to the same file\ngit commit -m \"MISC:&lt;description&gt;\"        &lt;--- for any other reasons to be described\ngit commit -m \"WIP:&lt;description&gt;\"         &lt;--- for not finished work\ngit commit -m \"REFACTOR:&lt;description&gt;\"    &lt;--- for refactored code\ngit commit -m \"MERGE:&lt;description&gt;\"       &lt;--- for merging operations\n</code></pre> You can merge few tags e.g.: <pre><code>git commit -m \"WIP-CAP:&lt;description&gt;      &lt;--- for cap moment in not finished work \n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#python","title":"Python","text":"<p>DiffCheck is distributed as a Python Grasshopperr plug-in via yak and its source code via PyPI. The plug-in is composed by a series of <code>.ghuser</code> components.</p> <p>There are 3 ways you can contribute to the Python GH plug-in: 1. By adding new components to the plug-in. 2. By fixing bugs of existing components in the plug-in. 3. By adding new functionalities to existing components in the plug-in.</p> <p>Before committing to the repository you need to have tested the components in the Grasshopper environment and be sure that this is working correctly. Also, provide a sufficient documentation in the PR (for now) please.</p> <p>Follow these steps to develop and test the Python GH plug-in: - GHPy: A) preparation - GHPy: B) development/debug - GHPy: C) Release - GHPy: D) Documentation</p>"},{"location":"developer-guide/CONTRIBUTING/#ghpy-a-preparation","title":"GHPy: A) preparation","text":"<p>Download this repo if you haven't already.</p> <p>Next, if you used ACPy (AugmentedCarpentryPython) before as an end-user clean all the <code>ACPy folders</code> in the following directory (the last name will change): <pre><code>C:\\Users\\&lt;user-name&gt;\\.rhinocode\\py39-rh8\\site-envs\\default-wMh5LZL3\n</code></pre></p> <p>note that if you drop an official released ACPy component from yak, this one will have the <code>#r : ACPy==&lt;version_number&gt;</code> notation at the top of the script. Get rid of all these release components before to start and be sur to erase again the previous folders (they recreated each time <code>#r : ACPy</code> is called).</p> <p>Build the package from the py source code's directory: <pre><code>python setup.py sdist bdist_wheel\n</code></pre></p> <p>Lastly, install the pip pacakge from the repository in editable mode. This way, all the modifications made to the source code of the repository will be reflected in the installed package. Open a terminal and run the following command (replace the path with where you download the repository): <pre><code>C:\\Users\\&lt;your-username&gt;\\.rhinocode\\py39-rh8\\python.exe -m pip install -e \"&lt;path-to-repository-root&gt;\\src\\gh\\ACPy\"\n</code></pre></p> <p>For your info the packages is installed in <code>C:\\Users\\andre\\.rhinocode\\py39-rh8\\Lib\\site-packages</code>.</p> <p>That's it you are now a contributor to the ACPy! We raccomand to not download anymore from yak package but rather use the source code in the repository. If you want the latest ACPy, checkout and pull the main.</p>"},{"location":"developer-guide/CONTRIBUTING/#ghpy-b-developmentdebug","title":"GHPy: B) development/debug","text":""},{"location":"developer-guide/CONTRIBUTING/#b1-code-structure","title":"B.1) Code structure","text":"<p>For DiffCheck there are 2 main folders in the repository: * <code>src/gh/ACPy/components</code> here you can add new components or modify existing ones (for more info on how to create one we point you to this documentation). Here we call the  * <code>src/gh/ACPy/ACPy</code> this is our package where the core functionalities are implemented.</p>"},{"location":"developer-guide/CONTRIBUTING/#b2-developing-components-content","title":"B.2) Developing component's content","text":"<p>The idea is to start by developing the content of the component in the file <code>src/gh/ACPy/diffCgeck_app.py</code>. This would be a simple script that contains the logic of the component. Once the script <code>ACPy_app.py</code> is working correctly, you can move the code to the component file in the <code>src/gh/ACPy/components</code> folder. This is because the component file is the one that will be componentized and distributed via yak.</p> <p>We reccomand to use <code>VSCode</code> as IDE for developing the components. This is because it has a good integration with the <code>Grasshopper</code> environment and it is easy to debug the components. To set up the IDE follow these steps: 1. Install the <code>ScriptSync</code> extension for <code>VSCode</code>. 2. Install the <code>ScriptSync</code> from the yak manager in Rhino. 3. Open the <code>ACPyApp.py</code> from the <code>src/gh/ACPy/components</code> folder you are working on in <code>VSCode</code>, and set its path to the ScriptSync ghcomponent. 4. If you modify the code in <code>VSCode</code>, the changes will be reflected in the Grasshopper component as soon as you save in <code>VSCode</code> again the <code>code.py</code>. 5. Once your code is working, prepare the code and componentize it.</p> <p>If you want to use the GHEditor it's ok but everytime you modify the pakcage or the component's code, after any modifications you need to restart the Python interpreter from the ScriptEditor (<code>Tools &gt; Reload Python3 (CPython) Engine</code>) and recompute the solution in Grasshopper.</p>"},{"location":"developer-guide/CONTRIBUTING/#b3-componentize-the-code","title":"B.3) Componentize the code","text":"<p>Prepare your component as explained here. You can componentize it locally and test it in Grasshopper. Here's how to componentize: <pre><code>python f:\\ACPy\\src\\gh\\util\\componentizer_cpy.py --ghio \"C:\\Users\\andre\\.nuget\\packages\\grasshopper\\8.2.23346.13001\\lib\\net48\\\" .\\src\\gh\\components\\ .\\build\\gh\n</code></pre></p> <p>Note that you need to find the path to your GHIO folder. This is the folder where the <code>Grasshopper.dll</code> is located. E.g. You can find it in the <code>nuget</code> folder in the Rhino installation directory.</p> <p>Once you are sure that the component is working correctly, you can push the changes to the repository.</p>"},{"location":"developer-guide/CONTRIBUTING/#ghpy-c-release","title":"GHPy: C) Release","text":"<p>The release will be made via CI from main. As a contributor you don't need to worry about this. The plug-in is componentized, pushed to yak/PyPI and the user can download the latest version from yak.</p>"},{"location":"developer-guide/CONTRIBUTING/#ghpy-d-documentation","title":"GHPy: D) Documentation","text":"<p>To generate the MkDocs documentation first install the conda environment from the <code>environment.yml</code> file. Then run the following command from root: <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#c","title":"C++","text":""},{"location":"developer-guide/CONTRIBUTING/#naming-synthax-convention","title":"Naming &amp; synthax convention","text":"<p>Here's the naming convention for this project: - <code>localVariable</code>: lowerCamelCase. - <code>type PrivateVariable</code>: public member of a class - <code>type m_PrivateVariable</code>: Hungarian notation with UpperCamelCase for private class members. - <code>static type s_StaticVariable</code>: Hungarian notation with UpperCamelCase for static members of class. - <code>APP_SPEC</code>: Constants with SNAKE_UPPER_CASE. - All the other naming uses UpperCamelCase.</p> <p>Here's an example: <pre><code>// do not use using namespace std; we specify the namespace everytime\nstd::foo()\n\n// next line graph style\nvoid Foo()\n{\n    /* content */\n}\n\n// structure name uses UpperCamelCase\nstruct AnExampleStruct\n{\n    // structure attribute uses UpperCamelCase\n    const char* Name;\n};\n\n// class name uses UpperCamelCase\nclass AnExampleClass\n{\npublic:\n    AnExampleClass(const int&amp; init);\n    virtual ~AnExampleClass();\n\n    // member functions use UpperCamelCase\n    void PublicMemberFunction()\n    {\n        // local variable uses lowerCamelCase\n        int localVariable = 0;\n    }\n\n// A field indicator to separate the functions and attributes\npublic:\n    int PublicVariable;\n\n// Private member function block\nprivate:\n    // member functions use UpperCamelCase\n    void PrivateMemberFunction(); \n\n// Also a field indicator to separate the functions and attributes\nprivate:\n    // private variables uses Hungarian notation with UpperCamelCase\n    int m_PrivateVariable; // m_VariableName for normal variable\n    static int s_Instance; // s_VariableName for static variable\n};\n\n// Start headers with \n#pragma once\n\n// Start declarations with precompiled headers\n#include \"aiacpch.h\"\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#doxygen","title":"Doxygen","text":"<p>For documentation we use the *JavaDoc\" convention. Follow this guide for documenting the code. <pre><code>/**\n * @brief fill a vector of TSPlanes from a yaml file containing their corners data\n * @param filename path to the map.yaml file\n * @param planes vector of TSPlane objects\n */\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#config","title":"Config","text":"<p>We use an .ini file to store the config parameters of the application. The parser is derived from this project but with some modification. Here's an example:</p>"},{"location":"developer-guide/CONTRIBUTING/#declaration","title":"Declaration","text":"<pre><code>// Just include this header\n#include \"AIAC/Config.h\"\n\n// Open file \"config.ini\".\n// The second param indicate if the file need to be update when \n// InsertEntry() and UpdateEntry() is called.\n// The initialization happens in the very beginning of `ACApp.cpp`.\ninih::Ini config(\"config.ini\", true);\n</code></pre>"},{"location":"developer-guide/CONTRIBUTING/#usage","title":"Usage","text":"<p>In order to get rid of plain text, where an typo can cause unexpected error, we strongly suggest you to declare a static const string variable in <code>config.h</code> and call it in your code. For each data entry, \"section\" and \"name\" are combined as the primary key. Here's an example:</p> <p>In <code>Config.h</code>, declare the variable for key: <pre><code>inline static const std::string SEC_TEST = \"SectionTest\";\ninline static const std::string VALUE_NAME_1 = \"ValueName1\";\ninline static const std::string VALUE_NAME_2 = \"ValueName2\";\n</code></pre> Usage: <pre><code>// Get&lt;type&gt;(section, key, default value if not exist)\nAIAC::Config::Get&lt;int&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::VALUE_NAME_1, 10);\n\n// InsertEntry(section, key, value)\nAIAC::Config::InsertEntry(AIAC::Config::SEC_AIAC, AIAC::Config::VALUE_NAME_2, -1);\n\n// Insert a vector\nvector&lt;int&gt; primeVector = {2, 3, 5, 7, 11};\nAIAC::Config::InsertEntry(\"SectionTestVector\", \"PrimeNumber\", primeVector);\n\n\n// Get&lt;T&gt;(section, key, default_value)\n// The entry will be created if not exist.\ncout &lt;&lt; AIAC::Config::Get&lt;int&gt;(\"SectionTest\", \"ValueName1\", -1) &lt;&lt; endl;\ncout &lt;&lt; AIAC::Config::Get&lt;string&gt;(\"SectionTest\", \"ValueName2\", \"I'm a string!\") &lt;&lt; endl;\n\n// With vector, use GetVector() instead of Get(),\nfor(auto n: AIAC::Config::GetVector&lt;int&gt;(\"SectionTestVector\", \"PrimeNumber\", primeVector)){\n    cout &lt;&lt; n &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n\n// Update an Entry\nAIAC::Config::UpdateEntry(\"SectionTest\", \"key1\", 999);\ncout &lt;&lt; AIAC::Config::Get(\"SectionTest\", \"key1\", -1) &lt;&lt; endl;\n\n// For update an vector entry, call the same function as normal\nprimeVector.push_back(13);\nAIAC::Config::UpdateEntry(\"SectionTestVector\", \"PrimeNumber\", primeVector);\n\n// Write the ini to the original file\nAIAC::Config::WriteToFile();\n// Write to another file\nAIAC::Config::WriteToFile(\"another_config_file.ini\");\n</code></pre> After running thie code above, you gets the following output: <pre><code>-1\nI'm a string!\n2 3 5 7 11 \n999\n</code></pre> with two identical <code>.ini</code> file contains: <pre><code>[SectionTest]\nkey1 = 999\nkey2 = I'm a string!\n\n[SectionTestVector]\nPrimeNumber = 2 3 5 7 11 13\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#pre-compiled-headers","title":"Pre-Compiled headers","text":"<p>AC uses a precompile header <code>aiacpch.h</code> to the project to shorten compilation time for headers that you rarely modify such as stdb library, opencv etc.. Add to <code>aiacpch.h</code> every big header you do not use often. Include at the very top <code>#include \"aiacpch.h\"</code> of every <code>.cpp</code> file.</p>"},{"location":"developer-guide/CONTRIBUTING/#layers","title":"Layers","text":"<p>Layers are the main component of the framework. Each layer gets stacked and executed in that order. Each layer represents a different unit e.g. TSLAM, camera access, 3Drender, etc. Each layer has events where code can be injected in the loop and custom events. <pre><code>namespace AIAC\n{\n    class Layer\n    {\n    public:\n        virtual ~Layer() = default;\n\n        /// Is called when the layer is attached to the application.\n        virtual void OnAttach() {}\n\n        /// Is calle before GLFW poll events, GL frame and Imgui Frame\n        virtual void OnFrameAwake() {}\n\n        /// Is called when frame starts\n        virtual void OnFrameStart() {}\n\n        /// Is called when frame ends\n        virtual void OnFrameEnd() {}\n\n        /// Is called when the GLFW, GL and Imgui frame is updated and rendered\n        virtual void OnFrameFall() {}\n\n        /// Is called when the layer is detached from the application (~app).\n        virtual void OnDetach() {}\n    };\n}\n</code></pre> Next, you need to add it to the stack call in the main file CApp where it fits most:</p> <pre><code>...\nacApp_ptr-&gt;GetWindow()-&gt;Init();\n\nacApp_ptr-&gt;GetGORegistry()-&gt;Init();\n\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerCamera&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerCameraCalib&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerSlam&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::NewLayer1&gt;();  // &lt;---------- e.g.: your new layer 1\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerModel&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerToolhead&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerFeedback&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerUI&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::NewLayer2&gt;();  // &lt;---------- e.g.: your new layer 2\n\nacApp_ptr-&gt;GetRenderer()-&gt;Init();\n\nacApp_ptr-&gt;GetEventBus()-&gt;Init();\n\nacApp_ptr-&gt;Run();\n</code></pre>"},{"location":"developer-guide/CONTRIBUTING/#getting-the-main-app","title":"Getting the main app","text":"<p>There is one only app and it can be accessed from layers with: <pre><code>AIAC::Application&amp; app = AIAC::Application::GetInstance();\n</code></pre> or easier with a macro <pre><code>AIAC_APP\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#getting-other-layers-variables","title":"Getting other layers' variables","text":"<p>To get other layers' variables use a small query function from the Application class. In the case of accessing test_a of layerA from e.g. layerB: <pre><code>AIAC_APP.GetLayer&lt;AIAC::LayerA&gt;()-&gt;test_a\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#ui","title":"UI","text":"<p>UI is mainly built in ImGui. We wrap some of the functions and add custom functionalities.</p>"},{"location":"developer-guide/CONTRIBUTING/#logos","title":"Logos","text":"<p>Logos addresses/data is store in <code>CustomLogos.h</code>. As an example: <pre><code>#define AIAC_LOGO_LIGHT_GRAY \"assets/images/logos/logo_linux_gray_light.png\"\n</code></pre> E.g. to consume it: <pre><code>m_LogoBlack = AIAC::Image(AIAC_LOGO_BLACK);\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#colors","title":"Colors","text":"<p>Colors macros can be found/add in the header <code>ClrPalette.h</code> with the following definition style: <pre><code>#define AIAC_UI_DARK_GREY ImVec4(0.2f, 0.2f, 0.2f, 1.0f)\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#panes","title":"Panes","text":"<p>For every new layer you can create a new collapsable pannel in the main UI. To do so follow the next steps.</p> <p>Create a new function (declare it in <code>LayerUI.h &gt; Class LayerUI</code> and implement it in <code>LayerUI.cpp</code>) and start calling <code>ImGui</code> methods from there, put everythin you need for the UI there. This is the only place where you will write UI for your pane, like so: <pre><code>void LayerUI::SetPaneUICamera()\n    {\n        ImGui::Text(\"This layer is responsible for the physical camera.\");\n        AIAC::Camera&amp; camera = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera;\n        ImGui::Text(\"Camera is %s\", camera.IsOpened() ? \"open\" : \"closed\");\n        ImGui::Text(\"Camera resolution: %d x %d\", camera.GetWidth(), camera.GetHeight());\n    }\n</code></pre> Next copy past the template function in <code>LayerUI.cpp</code> and reference the function you created: <pre><code>//                 Label               Collapse              PaneContent\nStackPane(PaneUI(\"Example\",              true,       AIAC_BIND_EVENT_FN(SetPaneUIExample)         ));\nStackPane(PaneUI(\"Camera\",               true,       AIAC_BIND_EVENT_FN(SetPaneUICamera)          ));\nStackPane(PaneUI(\"Slam\",                 true,       AIAC_BIND_EVENT_FN(SetPaneUISlam)            ));\nStackPane(PaneUI(\"&lt;your-new-name&gt;\",      true,       AIAC_BIND_EVENT_FN(YourNewContainerMethod)   ));\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#file-dialog","title":"File Dialog","text":"<p>The file dialog widget we use is implemented as singleton from this repo. This means that only one file dialog widget can be opened at once (it is possible to implement it as multiple instance if needed). If you need to select a file from local system, here's the snippet: <pre><code>if (ImGui::Button(\"Open 3dModel\"))\n            ImGuiFileDialog::Instance()-&gt;OpenDialog(\"Choose3dModel\", \"Open 3dModel\", \".ply, .obj\", \".\");\n\n        if (ImGuiFileDialog::Instance()-&gt;Display(\"Choose3dModel\")) \n        {\n            if (ImGuiFileDialog::Instance()-&gt;IsOk())\n            {\n            std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n            std::string filePath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n            // action\n            /* write here what to do with the file path */\n            }\n            ImGuiFileDialog::Instance()-&gt;Close();\n        }\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#event-system","title":"Event System","text":"<p>We implement a bus-like event system based on the observer pattern and the tppevent repo. It is not multi-threaded but it can be modified as such. All the event files are contained in the dir <code>AIAC/EventSys</code>.</p>"},{"location":"developer-guide/CONTRIBUTING/#how-to-raise-events","title":"How to raise events","text":"<p>The event bus is stored in the Application. You can raise events from other files in two ways, either synchronusly, the event will be fired immediately with: <pre><code>AIAC_EBUS-&gt;DispatchEvent(std::make_shared&lt;SmtHappenedEvent&gt;(param))\n</code></pre> Or a-synchronusly, the event will be stored in the bus queue and executed in the main loop, before any layer frame calls: <pre><code>IAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;CameraCalibrationLoadedEvent&gt;(filePathName));\n</code></pre></p> <p>Note that you need to pass a <code>std::shared_ptr&lt;Event&gt;</code> to the event raisers.</p>"},{"location":"developer-guide/CONTRIBUTING/#how-to-add-events","title":"How to add events","text":"<p>First Add the event type in <code>Event.h</code> if it does not exist already: <pre><code>enum class EventType\n    {\n        None = 0,\n        AppClose,\n        SLAMMapLoaded, SLAMVocabularyLoaded,\n        CameraCalibrationLoaded,\n        ExampleCalled  // &lt;-- example\n        /* add types of events here */\n    };\n</code></pre> And a category in the same file: <pre><code>enum EventCategory\n    {\n        None = 0,\n        EventCategoryApplication =              BIT(0),\n        EventCategorySLAM =                     BIT(1),\n        EventCategoryCamera =                   BIT(2),\n        EventCategoryExample =                  BIT(3)  // &lt;-- example\n        /* add event category here */\n    };\n</code></pre> Next, create a new event file with a class that inherits from <code>class Event</code>, as an example <code>ExampleEvent.h</code>. Remeber to add to the parent constructor (a) EventType, (b) EventCategory and \u00a9 (accessory, by default 0) the prority at which the event needs to be executed, the bigger the number the sooner in the queue it will be fired: <pre><code>namespace AIAC\n{\n    class ExampleCalledEvent : public Event\n    {\n    public:\n        explicit ExampleCalledEvent(const std::string param)\n            : Event(EventType::ExampleCalled, EventCategory::EventCategoryExample, 100), m_Param(param)\n        {}\n\n        void OnExampleCalled();\n\n    private:\n        std::string m_Param;\n    };\n}\n</code></pre> Do not forget to add the header to <code>AIAC.h</code> in the correct order. <pre><code>#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/ExampleEvent.h\"\n/* &gt;&gt; add types of events here &lt;&lt; */\n#include \"AIAC/EventSys/EventBus.h\"\n</code></pre> In the declaration you can access layers via <code>AIAC_APP</code> as usual: <pre><code>namespace AIAC\n{\n    void ExampleCalledEvent::OnExampleCalled()\n    {\n        AIAC_APP.GetLayer&lt;LayerName&gt;()-&gt;Func(m_Param);\n    }\n}\n</code></pre> Finally you just need to add a listener to the <code>Init()</code> function of <code>EventBus.h</code>: <pre><code>#include \"AIAC/EventSys/ExampleEvent.h\"\n\nm_EventQueue.appendListener(EventType::ExampleCalled, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;ExampleCalledEvent&amp;&gt;(*event);\n                slamEvent.OnExampleCalled();\n            });\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#logging","title":"Logging","text":"<p>To log use the following MACROS. All the code is contained in <code>Log.hpp</code> and <code>Log.cpp</code>.  <pre><code>AIAC_INFO(\"test_core_info\");\nAIAC_WARN(\"test_core_warn\");\nAIAC_CRITICAL(\"test_core_critical\");\nAIAC_DEBUG(\"test_core_debug\");\nAIAC_ERROR(\"test_core_error\");\n</code></pre> The output is like so: <pre><code>[source main.cpp] [function main] [line 32] [16:30:05] APP: test\n</code></pre> The logging can be silenced by setting OFF the option in the main <code>CMakeLists.txt</code> and do clean reconfiguration. <pre><code>option(SILENT_LOGGING \"Do not log messages in the terminal of on.\" ON)\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#go-system","title":"GO System","text":"<p>To add, remove or get Geometric Objects (GO) from any layer: <pre><code>#include \"AIAC/GOSys/GO.h\"\n\nstd::shared_ptr&lt;GOPoint&gt; pt1 = GOPoint::Add(1, 1, 1);             // create a point\n\nstd::shared_ptr&lt;GOPoint&gt; pt1copy = GOPoint::Get(pt1.GetId());     // get the point elsewhere\nfloat x = pt1copy-&gt;X();                                 // access GO properties\nauto pts = GOPoint::GetAll();                           // access all GO of one type\nGOPoint::Remove(pt1copy.GetId());                                 // remove the point from registry\n</code></pre> Note the the Constructor for each GO is private, the only way to instance it is to use the <code>Add()</code> static function. The reason why we decided to adopt this \"registry\" pattern is because all GO object need to be created as a smart pointer to be copied into a GOregistry. We must be sure that every GOObject is subscribed to the GORegistry. A normal c++ constructor cannot create the smart pointer of the create object, hence the Add() function does this for us.  All the next layers will retrive those smart pointers from the GOregistry and eventually modify them. And finally the render will go through the GOregistry and \"bake\" (render) all the GO geometries.</p> <p>The **G**eometric **O**bject System allows to add objects to the 3D scene before to render them. Having a geometric entity prior to the OpenGL Render allows to calculates relations between geometries to obtain live feedbacks (e.g. drilling depth). Files can be found in <code>/GOSys</code>.</p> <p>The GOSystem is composed of two components: - <code>GOPrimitives.h/cpp</code> (a library which stores <code>GOPoint</code>, <code>GOLine</code>, <code>GOText</code>, etc) - <code>GORegistry.h/cpp</code> (an API which interacts with the map. Note that it has to recive only smart pointers to avoid object slicing since we pass heirs of <code>GOPrimitive</code>.)</p>"},{"location":"developer-guide/CONTRIBUTING/#renderer-api","title":"Renderer API","text":"<p>The renderer API is separated into two parts: 1. <code>GlUtils.h</code>: Provides a direct interface to draw the 3 basic material of OpenGL, i.e. <code>Point</code>, <code>Line</code>, and <code>Triangle (mesh)</code>. By calling the function, it creates an object, render it and delete instantly. These functions should only be used when GO system doesn't fit the scenrio. 2. <code>RenderAPI.h</code>: To render the already exist GO Primitives. When a GO is initialized or update, it creates an OpenGL object and stores in the memory. The functions in this file takes the GO object as the parameter and renders the corresponding OpenGL objects.</p>"},{"location":"developer-guide/CONTRIBUTING/#glutilsh","title":"GlUtils.h","text":"<p><code>GlUtils.h</code> contains the function to draw the 3 basic material of OpenGL, i.e. point, line, and triangle (mesh). By calling the function, it creates an OpenGL object, render it, and delete instantly. Since calling these functions continuesly add/delete OpenGL objects, which is not efficient, they should only be used when GO system doesn't fit the scenrio. (e.g. drawing SLAM tags while mapping, since it changes every frame)</p>"},{"location":"developer-guide/CONTRIBUTING/#point","title":"Point","text":"<p><pre><code>void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize);\nvoid glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const glm::vec4 &amp;color, GLfloat pointSize);\n</code></pre> - <code>vertices</code>: A vector of 3d points, indicate the position of the vertices. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the <code>vertices</code>.  - <code>pointSize</code>: The size of the point.</p>"},{"location":"developer-guide/CONTRIBUTING/#line","title":"Line","text":"<p><pre><code>void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const std::vector&lt;glm::vec4&gt; &amp;colors);\nvoid glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const glm::vec4 &amp;color);\n\n/* \n * (0, 1, 0) --- (1, 0, 0)\n *     |             |\n *     |             |\n *     |             |\n * (0, 0, 0) --- (0, 0, 1)\n * \n * If you want to draw a square like this, you should construct the `edges` as:\n * [\n *    (0, 0, 0), (0, 0, 1),\n *    (0, 0, 1), (1, 0, 0),\n *    (1, 0, 0), (0, 1, 0),\n *    (0, 1, 0), (0, 0, 0)\n * ]\n * \n * */\n</code></pre> - <code>edges</code>: A vector of the edge's end-points. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the <code>edges</code>.</p>"},{"location":"developer-guide/CONTRIBUTING/#triangle","title":"Triangle","text":"<p><pre><code>void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const std::vector&lt;glm::vec4&gt; &amp;colors);\nvoid glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const glm::vec4 &amp;colors);\n/* \n * P2(0, 1, 0) --- P3(1, 0, 0)\n *     |            /    |\n *     |          /      |\n *     |        /        |\n *     |      /          |\n *     |    /            |\n * P0(0, 0, 0) --- P1(0, 0, 1)\n * \n * If you want to draw a mesh of square like this, you should construct the `edges` as:\n * [\n *    (0, 0, 0), // P0\n *    (0, 0, 1), // P1\n *    (1, 0, 0), // P2\n *    (0, 1, 0), // P3\n * ]\n * with `indices`:\n * [\n *     0, 1, 3, // Right-bottom triangle\n *     3, 2, 0  // Left-top triangle\n * ]\n * */\n</code></pre> - <code>vertices</code>: A vector of 3d points, indicate the position of the vertices. - <code>indices</code>: A vector of all triangle's indices. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the vertices.</p>"},{"location":"developer-guide/CONTRIBUTING/#renderapih","title":"RenderAPI.h","text":"<p>Render API is a collection of functions that are used for rendering 3D objects (GO primitives and the map). These functions can be call directly as long as <code>RenderAPI.h</code>is included.</p>"},{"location":"developer-guide/CONTRIBUTING/#go","title":"GO","text":"<p>An implicit type casting is implemented, simply call the <code>DrawGO</code> function in the <code>Render.cpp</code>'s function <code>OnRender()</code>: <pre><code>void DrawGO(const shared_ptr&lt;GOPrimitive&gt;&amp; goPrimitive);\nvoid DrawGOs(const std::vector&lt;shared_ptr&lt;GOPrimitive&gt;&gt;&amp; goPrimitive);\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#textrendererh","title":"TextRenderer.h","text":"<p>Rendering text through OpenGL is quite tricky. The <code>TextRenderer.h</code> is here to handle this. The <code>TextRenderer</code> has to be initialized, after that, static functions can be call for rendering texts. <pre><code>void Renderer::Init() {\n    ...\n    TextRenderer::Init()\n    ...\n}\n\nvoid myFunction() {\n    // First setting the current projection matrix\n    TextRenderer::SetProjection(projection); // The MVP projection of the scene\n\n    // Rendering text at (0, 3, 0)\n    TextRenderer::RenderTextIn3DSpace(\n                \"center\",                           // Text to show\n                glm::vec3(0.0f, 3.0f, 0.0f),        // Position in 3D space\n                glm::vec4(0.0f, 0.0f, 0.0f, 0.7f)); // Color\n\n    // Rendering the text on a fixed position on the screen.\n    // (0, 0) is the left-bottom corner and (windowWidth, windowHeight) is the right-top corner\n    TextRenderer::RenderText(\n            \"center\",                               // Text to show\n            150.0f, 150.0f,                         // Position on the screen\n            glm::vec4(0.0f, 0.0f, 0.0f, 0.7f));     // Color\n}\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING/#slam-map","title":"Slam Map","text":"<p><pre><code>void DrawSlamMap(const shared_ptr&lt;tslam::Map&gt; &amp;map, const glm::vec4 &amp;color, float pointSize);\n</code></pre> - <code>map</code>: The map itself. - <code>color</code>: The color of the point clouds. - <code>pointSize</code>: The point cloud's size.</p> <p><code>other shapes</code></p>"},{"location":"developer-guide/CONTRIBUTING/#ctesting","title":"CTesting","text":"<p>When necessary, c++ testing is done by using CTest. Important/critical features (e.g., correcting functioning of graphics with OpenGL and Glfw) needs testing to be written (this is usefull for e.g., GitHub Actions). Such tests can be extracted from the main source code and integrated in a seperate section: cmake testing.</p> <p>To add a new test do as follow.</p> <p>First create a new sub-folder in the folder <code>./test</code> as <code>./test/exampletest</code>. Here add a console cpp file called <code>tester.cpp</code> which returns 0 or 1 and add a new <code>CMakeLists.txt</code> as such: <pre><code>add_executable(example_test tester.cpp)\n\n/* &lt;-- \nInsert here linking necessary for the executable\nNote that if you already found packages in the head CMakeLists file\nyou can simply use the macros here.\n--&gt; */\n\nadd_test(NAME \"ExampleTest\" COMMAND \"example_test\" &lt;argv-here&gt; WORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\")\n</code></pre> In the <code>./test</code>'s <code>CMakeLists.txt</code> add the created sub-directory: <pre><code>if (TEST_EXAMPLE)\n    add_subdirectory(exampletest)\nendif()\n</code></pre> Finally add an option in the main <code>CMakeLists.txt</code> describing the test: <pre><code>include(CTest)\n# ...\noption(TEST_EXAMPLE \"Test to test something important.\" ON)\n# ...\nif(TEST_EXAMPLE)\n    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests/exampletest)\nendif()\n</code></pre></p> <p>Next, <code>./configure.sh -c</code> and <code>./build.sh</code> and: <pre><code>cd ./build\nctest -N    # &lt;--- to see how many tests there are\nctest -V    # &lt;--- run the tests\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/","title":"Guide for contributors","text":"<p>Here's you can find some documentations and guidelines to contribute to augmented_carpentry.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#github-commit-convetion","title":"GitHub commit convetion","text":"<p>All commits need to be labeled with a tag among these: <pre><code>git commit -m \"ADD:&lt;description&gt;\"         &lt;--- for adding new elements\ngit commit -m \"FIX:&lt;description&gt;\"         &lt;--- for fixing (errors, typos)\ngit commit -m \"FLASH:&lt;description&gt;\"       &lt;--- quick checkpoint before refactoring\ngit commit -m \"MILESTONE:&lt;description&gt;\"   &lt;--- for capping moment in development\ngit commit -m \"CAP:&lt;description&gt;\"         &lt;--- for for less important milestones\ngit commit -m \"UPDATE:&lt;description&gt;\"      &lt;--- for moddification to the same file\ngit commit -m \"MISC:&lt;description&gt;\"        &lt;--- for any other reasons to be described\ngit commit -m \"WIP:&lt;description&gt;\"         &lt;--- for not finished work\ngit commit -m \"REFACTOR:&lt;description&gt;\"    &lt;--- for refactored code\ngit commit -m \"MERGE:&lt;description&gt;\"       &lt;--- for merging operations\n</code></pre> You can merge few tags e.g.: <pre><code>git commit -m \"WIP-CAP:&lt;description&gt;      &lt;--- for cap moment in not finished work \n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#python","title":"Python","text":"<p>DiffCheck is distributed as a Python Grasshopperr plug-in via yak and its source code via PyPI. The plug-in is composed by a series of <code>.ghuser</code> components.</p> <p>There are 3 ways you can contribute to the Python GH plug-in: 1. By adding new components to the plug-in. 2. By fixing bugs of existing components in the plug-in. 3. By adding new functionalities to existing components in the plug-in.</p> <p>Before committing to the repository you need to have tested the components in the Grasshopper environment and be sure that this is working correctly. Also, provide a sufficient documentation in the PR (for now) please.</p> <p>Follow these steps to develop and test the Python GH plug-in: - GHPy: A) preparation - GHPy: B) development/debug - GHPy: C) Release - GHPy: D) Documentation</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#ghpy-a-preparation","title":"GHPy: A) preparation","text":"<p>Download this repo if you haven't already.</p> <p>Next, if you used ACPy (AugmentedCarpentryPython) before as an end-user clean all the <code>ACPy folders</code> in the following directory (the last name will change): <pre><code>C:\\Users\\&lt;user-name&gt;\\.rhinocode\\py39-rh8\\site-envs\\default-wMh5LZL3\n</code></pre></p> <p>note that if you drop an official released ACPy component from yak, this one will have the <code>#r : ACPy==&lt;version_number&gt;</code> notation at the top of the script. Get rid of all these release components before to start and be sur to erase again the previous folders (they recreated each time <code>#r : ACPy</code> is called).</p> <p>Build the package from the py source code's directory: <pre><code>python setup.py sdist bdist_wheel\n</code></pre></p> <p>Lastly, install the pip pacakge from the repository in editable mode. This way, all the modifications made to the source code of the repository will be reflected in the installed package. Open a terminal and run the following command (replace the path with where you download the repository): <pre><code>C:\\Users\\&lt;your-username&gt;\\.rhinocode\\py39-rh8\\python.exe -m pip install -e \"&lt;path-to-repository-root&gt;\\src\\gh\\ACPy\"\n</code></pre></p> <p>For your info the packages is installed in <code>C:\\Users\\andre\\.rhinocode\\py39-rh8\\Lib\\site-packages</code>.</p> <p>That's it you are now a contributor to the ACPy! We raccomand to not download anymore from yak package but rather use the source code in the repository. If you want the latest ACPy, checkout and pull the main.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#ghpy-b-developmentdebug","title":"GHPy: B) development/debug","text":""},{"location":"developer-guide/CONTRIBUTING_copy/#b1-code-structure","title":"B.1) Code structure","text":"<p>For DiffCheck there are 2 main folders in the repository: * <code>src/gh/ACPy/components</code> here you can add new components or modify existing ones (for more info on how to create one we point you to this documentation). Here we call the  * <code>src/gh/ACPy/ACPy</code> this is our package where the core functionalities are implemented.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#b2-developing-components-content","title":"B.2) Developing component's content","text":"<p>The idea is to start by developing the content of the component in the file <code>src/gh/ACPy/diffCgeck_app.py</code>. This would be a simple script that contains the logic of the component. Once the script <code>ACPy_app.py</code> is working correctly, you can move the code to the component file in the <code>src/gh/ACPy/components</code> folder. This is because the component file is the one that will be componentized and distributed via yak.</p> <p>We reccomand to use <code>VSCode</code> as IDE for developing the components. This is because it has a good integration with the <code>Grasshopper</code> environment and it is easy to debug the components. To set up the IDE follow these steps: 1. Install the <code>ScriptSync</code> extension for <code>VSCode</code>. 2. Install the <code>ScriptSync</code> from the yak manager in Rhino. 3. Open the <code>ACPyApp.py</code> from the <code>src/gh/ACPy/components</code> folder you are working on in <code>VSCode</code>, and set its path to the ScriptSync ghcomponent. 4. If you modify the code in <code>VSCode</code>, the changes will be reflected in the Grasshopper component as soon as you save in <code>VSCode</code> again the <code>code.py</code>. 5. Once your code is working, prepare the code and componentize it.</p> <p>If you want to use the GHEditor it's ok but everytime you modify the pakcage or the component's code, after any modifications you need to restart the Python interpreter from the ScriptEditor (<code>Tools &gt; Reload Python3 (CPython) Engine</code>) and recompute the solution in Grasshopper.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#b3-componentize-the-code","title":"B.3) Componentize the code","text":"<p>Prepare your component as explained here. You can componentize it locally and test it in Grasshopper. Here's how to componentize: <pre><code>python f:\\ACPy\\src\\gh\\util\\componentizer_cpy.py --ghio \"C:\\Users\\andre\\.nuget\\packages\\grasshopper\\8.2.23346.13001\\lib\\net48\\\" .\\src\\gh\\components\\ .\\build\\gh\n</code></pre></p> <p>Note that you need to find the path to your GHIO folder. This is the folder where the <code>Grasshopper.dll</code> is located. E.g. You can find it in the <code>nuget</code> folder in the Rhino installation directory.</p> <p>Once you are sure that the component is working correctly, you can push the changes to the repository.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#ghpy-c-release","title":"GHPy: C) Release","text":"<p>The release will be made via CI from main. As a contributor you don't need to worry about this. The plug-in is componentized, pushed to yak/PyPI and the user can download the latest version from yak.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#ghpy-d-documentation","title":"GHPy: D) Documentation","text":"<p>More to come.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#c","title":"C++","text":""},{"location":"developer-guide/CONTRIBUTING_copy/#naming-synthax-convention","title":"Naming &amp; synthax convention","text":"<p>Here's the naming convention for this project: - <code>localVariable</code>: lowerCamelCase. - <code>type PrivateVariable</code>: public member of a class - <code>type m_PrivateVariable</code>: Hungarian notation with UpperCamelCase for private class members. - <code>static type s_StaticVariable</code>: Hungarian notation with UpperCamelCase for static members of class. - <code>APP_SPEC</code>: Constants with SNAKE_UPPER_CASE. - All the other naming uses UpperCamelCase.</p> <p>Here's an example: <pre><code>// do not use using namespace std; we specify the namespace everytime\nstd::foo()\n\n// next line graph style\nvoid Foo()\n{\n    /* content */\n}\n\n// structure name uses UpperCamelCase\nstruct AnExampleStruct\n{\n    // structure attribute uses UpperCamelCase\n    const char* Name;\n};\n\n// class name uses UpperCamelCase\nclass AnExampleClass\n{\npublic:\n    AnExampleClass(const int&amp; init);\n    virtual ~AnExampleClass();\n\n    // member functions use UpperCamelCase\n    void PublicMemberFunction()\n    {\n        // local variable uses lowerCamelCase\n        int localVariable = 0;\n    }\n\n// A field indicator to separate the functions and attributes\npublic:\n    int PublicVariable;\n\n// Private member function block\nprivate:\n    // member functions use UpperCamelCase\n    void PrivateMemberFunction(); \n\n// Also a field indicator to separate the functions and attributes\nprivate:\n    // private variables uses Hungarian notation with UpperCamelCase\n    int m_PrivateVariable; // m_VariableName for normal variable\n    static int s_Instance; // s_VariableName for static variable\n};\n\n// Start headers with \n#pragma once\n\n// Start declarations with precompiled headers\n#include \"aiacpch.h\"\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#doxygen","title":"Doxygen","text":"<p>For documentation we use the *JavaDoc\" convention. Follow this guide for documenting the code. <pre><code>/**\n * @brief fill a vector of TSPlanes from a yaml file containing their corners data\n * @param filename path to the map.yaml file\n * @param planes vector of TSPlane objects\n */\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#config","title":"Config","text":"<p>We use an .ini file to store the config parameters of the application. The parser is derived from this project but with some modification. Here's an example:</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#declaration","title":"Declaration","text":"<pre><code>// Just include this header\n#include \"AIAC/Config.h\"\n\n// Open file \"config.ini\".\n// The second param indicate if the file need to be update when \n// InsertEntry() and UpdateEntry() is called.\n// The initialization happens in the very beginning of `ACApp.cpp`.\ninih::Ini config(\"config.ini\", true);\n</code></pre>"},{"location":"developer-guide/CONTRIBUTING_copy/#usage","title":"Usage","text":"<p>In order to get rid of plain text, where an typo can cause unexpected error, we strongly suggest you to declare a static const string variable in <code>config.h</code> and call it in your code. For each data entry, \"section\" and \"name\" are combined as the primary key. Here's an example:</p> <p>In <code>Config.h</code>, declare the variable for key: <pre><code>inline static const std::string SEC_TEST = \"SectionTest\";\ninline static const std::string VALUE_NAME_1 = \"ValueName1\";\ninline static const std::string VALUE_NAME_2 = \"ValueName2\";\n</code></pre> Usage: <pre><code>// Get&lt;type&gt;(section, key, default value if not exist)\nAIAC::Config::Get&lt;int&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::VALUE_NAME_1, 10);\n\n// InsertEntry(section, key, value)\nAIAC::Config::InsertEntry(AIAC::Config::SEC_AIAC, AIAC::Config::VALUE_NAME_2, -1);\n\n// Insert a vector\nvector&lt;int&gt; primeVector = {2, 3, 5, 7, 11};\nAIAC::Config::InsertEntry(\"SectionTestVector\", \"PrimeNumber\", primeVector);\n\n\n// Get&lt;T&gt;(section, key, default_value)\n// The entry will be created if not exist.\ncout &lt;&lt; AIAC::Config::Get&lt;int&gt;(\"SectionTest\", \"ValueName1\", -1) &lt;&lt; endl;\ncout &lt;&lt; AIAC::Config::Get&lt;string&gt;(\"SectionTest\", \"ValueName2\", \"I'm a string!\") &lt;&lt; endl;\n\n// With vector, use GetVector() instead of Get(),\nfor(auto n: AIAC::Config::GetVector&lt;int&gt;(\"SectionTestVector\", \"PrimeNumber\", primeVector)){\n    cout &lt;&lt; n &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n\n// Update an Entry\nAIAC::Config::UpdateEntry(\"SectionTest\", \"key1\", 999);\ncout &lt;&lt; AIAC::Config::Get(\"SectionTest\", \"key1\", -1) &lt;&lt; endl;\n\n// For update an vector entry, call the same function as normal\nprimeVector.push_back(13);\nAIAC::Config::UpdateEntry(\"SectionTestVector\", \"PrimeNumber\", primeVector);\n\n// Write the ini to the original file\nAIAC::Config::WriteToFile();\n// Write to another file\nAIAC::Config::WriteToFile(\"another_config_file.ini\");\n</code></pre> After running thie code above, you gets the following output: <pre><code>-1\nI'm a string!\n2 3 5 7 11 \n999\n</code></pre> with two identical <code>.ini</code> file contains: <pre><code>[SectionTest]\nkey1 = 999\nkey2 = I'm a string!\n\n[SectionTestVector]\nPrimeNumber = 2 3 5 7 11 13\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#pre-compiled-headers","title":"Pre-Compiled headers","text":"<p>AC uses a precompile header <code>aiacpch.h</code> to the project to shorten compilation time for headers that you rarely modify such as stdb library, opencv etc.. Add to <code>aiacpch.h</code> every big header you do not use often. Include at the very top <code>#include \"aiacpch.h\"</code> of every <code>.cpp</code> file.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#layers","title":"Layers","text":"<p>Layers are the main component of the framework. Each layer gets stacked and executed in that order. Each layer represents a different unit e.g. TSLAM, camera access, 3Drender, etc. Each layer has events where code can be injected in the loop and custom events. <pre><code>namespace AIAC\n{\n    class Layer\n    {\n    public:\n        virtual ~Layer() = default;\n\n        /// Is called when the layer is attached to the application.\n        virtual void OnAttach() {}\n\n        /// Is calle before GLFW poll events, GL frame and Imgui Frame\n        virtual void OnFrameAwake() {}\n\n        /// Is called when frame starts\n        virtual void OnFrameStart() {}\n\n        /// Is called when frame ends\n        virtual void OnFrameEnd() {}\n\n        /// Is called when the GLFW, GL and Imgui frame is updated and rendered\n        virtual void OnFrameFall() {}\n\n        /// Is called when the layer is detached from the application (~app).\n        virtual void OnDetach() {}\n    };\n}\n</code></pre> Next, you need to add it to the stack call in the main file CApp where it fits most:</p> <pre><code>...\nacApp_ptr-&gt;GetWindow()-&gt;Init();\n\nacApp_ptr-&gt;GetGORegistry()-&gt;Init();\n\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerCamera&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerCameraCalib&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerSlam&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::NewLayer1&gt;();  // &lt;---------- e.g.: your new layer 1\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerModel&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerToolhead&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerFeedback&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::LayerUI&gt;();\nacApp_ptr-&gt;PushLayer&lt;AIAC::NewLayer2&gt;();  // &lt;---------- e.g.: your new layer 2\n\nacApp_ptr-&gt;GetRenderer()-&gt;Init();\n\nacApp_ptr-&gt;GetEventBus()-&gt;Init();\n\nacApp_ptr-&gt;Run();\n</code></pre>"},{"location":"developer-guide/CONTRIBUTING_copy/#getting-the-main-app","title":"Getting the main app","text":"<p>There is one only app and it can be accessed from layers with: <pre><code>AIAC::Application&amp; app = AIAC::Application::GetInstance();\n</code></pre> or easier with a macro <pre><code>AIAC_APP\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#getting-other-layers-variables","title":"Getting other layers' variables","text":"<p>To get other layers' variables use a small query function from the Application class. In the case of accessing test_a of layerA from e.g. layerB: <pre><code>AIAC_APP.GetLayer&lt;AIAC::LayerA&gt;()-&gt;test_a\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#ui","title":"UI","text":"<p>UI is mainly built in ImGui. We wrap some of the functions and add custom functionalities.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#logos","title":"Logos","text":"<p>Logos addresses/data is store in <code>CustomLogos.h</code>. As an example: <pre><code>#define AIAC_LOGO_LIGHT_GRAY \"assets/images/logos/logo_linux_gray_light.png\"\n</code></pre> E.g. to consume it: <pre><code>m_LogoBlack = AIAC::Image(AIAC_LOGO_BLACK);\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#colors","title":"Colors","text":"<p>Colors macros can be found/add in the header <code>ClrPalette.h</code> with the following definition style: <pre><code>#define AIAC_UI_DARK_GREY ImVec4(0.2f, 0.2f, 0.2f, 1.0f)\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#panes","title":"Panes","text":"<p>For every new layer you can create a new collapsable pannel in the main UI. To do so follow the next steps.</p> <p>Create a new function (declare it in <code>LayerUI.h &gt; Class LayerUI</code> and implement it in <code>LayerUI.cpp</code>) and start calling <code>ImGui</code> methods from there, put everythin you need for the UI there. This is the only place where you will write UI for your pane, like so: <pre><code>void LayerUI::SetPaneUICamera()\n    {\n        ImGui::Text(\"This layer is responsible for the physical camera.\");\n        AIAC::Camera&amp; camera = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera;\n        ImGui::Text(\"Camera is %s\", camera.IsOpened() ? \"open\" : \"closed\");\n        ImGui::Text(\"Camera resolution: %d x %d\", camera.GetWidth(), camera.GetHeight());\n    }\n</code></pre> Next copy past the template function in <code>LayerUI.cpp</code> and reference the function you created: <pre><code>//                 Label               Collapse              PaneContent\nStackPane(PaneUI(\"Example\",              true,       AIAC_BIND_EVENT_FN(SetPaneUIExample)         ));\nStackPane(PaneUI(\"Camera\",               true,       AIAC_BIND_EVENT_FN(SetPaneUICamera)          ));\nStackPane(PaneUI(\"Slam\",                 true,       AIAC_BIND_EVENT_FN(SetPaneUISlam)            ));\nStackPane(PaneUI(\"&lt;your-new-name&gt;\",      true,       AIAC_BIND_EVENT_FN(YourNewContainerMethod)   ));\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#file-dialog","title":"File Dialog","text":"<p>The file dialog widget we use is implemented as singleton from this repo. This means that only one file dialog widget can be opened at once (it is possible to implement it as multiple instance if needed). If you need to select a file from local system, here's the snippet: <pre><code>if (ImGui::Button(\"Open 3dModel\"))\n            ImGuiFileDialog::Instance()-&gt;OpenDialog(\"Choose3dModel\", \"Open 3dModel\", \".ply, .obj\", \".\");\n\n        if (ImGuiFileDialog::Instance()-&gt;Display(\"Choose3dModel\")) \n        {\n            if (ImGuiFileDialog::Instance()-&gt;IsOk())\n            {\n            std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n            std::string filePath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n            // action\n            /* write here what to do with the file path */\n            }\n            ImGuiFileDialog::Instance()-&gt;Close();\n        }\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#event-system","title":"Event System","text":"<p>We implement a bus-like event system based on the observer pattern and the tppevent repo. It is not multi-threaded but it can be modified as such. All the event files are contained in the dir <code>AIAC/EventSys</code>.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#how-to-raise-events","title":"How to raise events","text":"<p>The event bus is stored in the Application. You can raise events from other files in two ways, either synchronusly, the event will be fired immediately with: <pre><code>AIAC_EBUS-&gt;DispatchEvent(std::make_shared&lt;SmtHappenedEvent&gt;(param))\n</code></pre> Or a-synchronusly, the event will be stored in the bus queue and executed in the main loop, before any layer frame calls: <pre><code>IAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;CameraCalibrationLoadedEvent&gt;(filePathName));\n</code></pre></p> <p>Note that you need to pass a <code>std::shared_ptr&lt;Event&gt;</code> to the event raisers.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#how-to-add-events","title":"How to add events","text":"<p>First Add the event type in <code>Event.h</code> if it does not exist already: <pre><code>enum class EventType\n    {\n        None = 0,\n        AppClose,\n        SLAMMapLoaded, SLAMVocabularyLoaded,\n        CameraCalibrationLoaded,\n        ExampleCalled  // &lt;-- example\n        /* add types of events here */\n    };\n</code></pre> And a category in the same file: <pre><code>enum EventCategory\n    {\n        None = 0,\n        EventCategoryApplication =              BIT(0),\n        EventCategorySLAM =                     BIT(1),\n        EventCategoryCamera =                   BIT(2),\n        EventCategoryExample =                  BIT(3)  // &lt;-- example\n        /* add event category here */\n    };\n</code></pre> Next, create a new event file with a class that inherits from <code>class Event</code>, as an example <code>ExampleEvent.h</code>. Remeber to add to the parent constructor (a) EventType, (b) EventCategory and \u00a9 (accessory, by default 0) the prority at which the event needs to be executed, the bigger the number the sooner in the queue it will be fired: <pre><code>namespace AIAC\n{\n    class ExampleCalledEvent : public Event\n    {\n    public:\n        explicit ExampleCalledEvent(const std::string param)\n            : Event(EventType::ExampleCalled, EventCategory::EventCategoryExample, 100), m_Param(param)\n        {}\n\n        void OnExampleCalled();\n\n    private:\n        std::string m_Param;\n    };\n}\n</code></pre> Do not forget to add the header to <code>AIAC.h</code> in the correct order. <pre><code>#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/ExampleEvent.h\"\n/* &gt;&gt; add types of events here &lt;&lt; */\n#include \"AIAC/EventSys/EventBus.h\"\n</code></pre> In the declaration you can access layers via <code>AIAC_APP</code> as usual: <pre><code>namespace AIAC\n{\n    void ExampleCalledEvent::OnExampleCalled()\n    {\n        AIAC_APP.GetLayer&lt;LayerName&gt;()-&gt;Func(m_Param);\n    }\n}\n</code></pre> Finally you just need to add a listener to the <code>Init()</code> function of <code>EventBus.h</code>: <pre><code>#include \"AIAC/EventSys/ExampleEvent.h\"\n\nm_EventQueue.appendListener(EventType::ExampleCalled, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;ExampleCalledEvent&amp;&gt;(*event);\n                slamEvent.OnExampleCalled();\n            });\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#logging","title":"Logging","text":"<p>To log use the following MACROS. All the code is contained in <code>Log.hpp</code> and <code>Log.cpp</code>.  <pre><code>AIAC_INFO(\"test_core_info\");\nAIAC_WARN(\"test_core_warn\");\nAIAC_CRITICAL(\"test_core_critical\");\nAIAC_DEBUG(\"test_core_debug\");\nAIAC_ERROR(\"test_core_error\");\n</code></pre> The output is like so: <pre><code>[source main.cpp] [function main] [line 32] [16:30:05] APP: test\n</code></pre> The logging can be silenced by setting OFF the option in the main <code>CMakeLists.txt</code> and do clean reconfiguration. <pre><code>option(SILENT_LOGGING \"Do not log messages in the terminal of on.\" ON)\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#go-system","title":"GO System","text":"<p>To add, remove or get Geometric Objects (GO) from any layer: <pre><code>#include \"AIAC/GOSys/GO.h\"\n\nstd::shared_ptr&lt;GOPoint&gt; pt1 = GOPoint::Add(1, 1, 1);             // create a point\n\nstd::shared_ptr&lt;GOPoint&gt; pt1copy = GOPoint::Get(pt1.GetId());     // get the point elsewhere\nfloat x = pt1copy-&gt;X();                                 // access GO properties\nauto pts = GOPoint::GetAll();                           // access all GO of one type\nGOPoint::Remove(pt1copy.GetId());                                 // remove the point from registry\n</code></pre> Note the the Constructor for each GO is private, the only way to instance it is to use the <code>Add()</code> static function. The reason why we decided to adopt this \"registry\" pattern is because all GO object need to be created as a smart pointer to be copied into a GOregistry. We must be sure that every GOObject is subscribed to the GORegistry. A normal c++ constructor cannot create the smart pointer of the create object, hence the Add() function does this for us.  All the next layers will retrive those smart pointers from the GOregistry and eventually modify them. And finally the render will go through the GOregistry and \"bake\" (render) all the GO geometries.</p> <p>The **G**eometric **O**bject System allows to add objects to the 3D scene before to render them. Having a geometric entity prior to the OpenGL Render allows to calculates relations between geometries to obtain live feedbacks (e.g. drilling depth). Files can be found in <code>/GOSys</code>.</p> <p>The GOSystem is composed of two components: - <code>GOPrimitives.h/cpp</code> (a library which stores <code>GOPoint</code>, <code>GOLine</code>, <code>GOText</code>, etc) - <code>GORegistry.h/cpp</code> (an API which interacts with the map. Note that it has to recive only smart pointers to avoid object slicing since we pass heirs of <code>GOPrimitive</code>.)</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#renderer-api","title":"Renderer API","text":"<p>The renderer API is separated into two parts: 1. <code>GlUtils.h</code>: Provides a direct interface to draw the 3 basic material of OpenGL, i.e. <code>Point</code>, <code>Line</code>, and <code>Triangle (mesh)</code>. By calling the function, it creates an object, render it and delete instantly. These functions should only be used when GO system doesn't fit the scenrio. 2. <code>RenderAPI.h</code>: To render the already exist GO Primitives. When a GO is initialized or update, it creates an OpenGL object and stores in the memory. The functions in this file takes the GO object as the parameter and renders the corresponding OpenGL objects.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#glutilsh","title":"GlUtils.h","text":"<p><code>GlUtils.h</code> contains the function to draw the 3 basic material of OpenGL, i.e. point, line, and triangle (mesh). By calling the function, it creates an OpenGL object, render it, and delete instantly. Since calling these functions continuesly add/delete OpenGL objects, which is not efficient, they should only be used when GO system doesn't fit the scenrio. (e.g. drawing SLAM tags while mapping, since it changes every frame)</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#point","title":"Point","text":"<p><pre><code>void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize);\nvoid glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const glm::vec4 &amp;color, GLfloat pointSize);\n</code></pre> - <code>vertices</code>: A vector of 3d points, indicate the position of the vertices. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the <code>vertices</code>.  - <code>pointSize</code>: The size of the point.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#line","title":"Line","text":"<p><pre><code>void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const std::vector&lt;glm::vec4&gt; &amp;colors);\nvoid glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const glm::vec4 &amp;color);\n\n/* \n * (0, 1, 0) --- (1, 0, 0)\n *     |             |\n *     |             |\n *     |             |\n * (0, 0, 0) --- (0, 0, 1)\n * \n * If you want to draw a square like this, you should construct the `edges` as:\n * [\n *    (0, 0, 0), (0, 0, 1),\n *    (0, 0, 1), (1, 0, 0),\n *    (1, 0, 0), (0, 1, 0),\n *    (0, 1, 0), (0, 0, 0)\n * ]\n * \n * */\n</code></pre> - <code>edges</code>: A vector of the edge's end-points. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the <code>edges</code>.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#triangle","title":"Triangle","text":"<p><pre><code>void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const std::vector&lt;glm::vec4&gt; &amp;colors);\nvoid glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const glm::vec4 &amp;colors);\n/* \n * P2(0, 1, 0) --- P3(1, 0, 0)\n *     |            /    |\n *     |          /      |\n *     |        /        |\n *     |      /          |\n *     |    /            |\n * P0(0, 0, 0) --- P1(0, 0, 1)\n * \n * If you want to draw a mesh of square like this, you should construct the `edges` as:\n * [\n *    (0, 0, 0), // P0\n *    (0, 0, 1), // P1\n *    (1, 0, 0), // P2\n *    (0, 1, 0), // P3\n * ]\n * with `indices`:\n * [\n *     0, 1, 3, // Right-bottom triangle\n *     3, 2, 0  // Left-top triangle\n * ]\n * */\n</code></pre> - <code>vertices</code>: A vector of 3d points, indicate the position of the vertices. - <code>indices</code>: A vector of all triangle's indices. - <code>colors</code>: A RGBA(0~1.0) color, can be either a single <code>glm::vec4</code> or a vector with the same size of the vertices.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#renderapih","title":"RenderAPI.h","text":"<p>Render API is a collection of functions that are used for rendering 3D objects (GO primitives and the map). These functions can be call directly as long as <code>RenderAPI.h</code>is included.</p>"},{"location":"developer-guide/CONTRIBUTING_copy/#go","title":"GO","text":"<p>An implicit type casting is implemented, simply call the <code>DrawGO</code> function in the <code>Render.cpp</code>'s function <code>OnRender()</code>: <pre><code>void DrawGO(const shared_ptr&lt;GOPrimitive&gt;&amp; goPrimitive);\nvoid DrawGOs(const std::vector&lt;shared_ptr&lt;GOPrimitive&gt;&gt;&amp; goPrimitive);\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#textrendererh","title":"TextRenderer.h","text":"<p>Rendering text through OpenGL is quite tricky. The <code>TextRenderer.h</code> is here to handle this. The <code>TextRenderer</code> has to be initialized, after that, static functions can be call for rendering texts. <pre><code>void Renderer::Init() {\n    ...\n    TextRenderer::Init()\n    ...\n}\n\nvoid myFunction() {\n    // First setting the current projection matrix\n    TextRenderer::SetProjection(projection); // The MVP projection of the scene\n\n    // Rendering text at (0, 3, 0)\n    TextRenderer::RenderTextIn3DSpace(\n                \"center\",                           // Text to show\n                glm::vec3(0.0f, 3.0f, 0.0f),        // Position in 3D space\n                glm::vec4(0.0f, 0.0f, 0.0f, 0.7f)); // Color\n\n    // Rendering the text on a fixed position on the screen.\n    // (0, 0) is the left-bottom corner and (windowWidth, windowHeight) is the right-top corner\n    TextRenderer::RenderText(\n            \"center\",                               // Text to show\n            150.0f, 150.0f,                         // Position on the screen\n            glm::vec4(0.0f, 0.0f, 0.0f, 0.7f));     // Color\n}\n</code></pre></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#slam-map","title":"Slam Map","text":"<p><pre><code>void DrawSlamMap(const shared_ptr&lt;tslam::Map&gt; &amp;map, const glm::vec4 &amp;color, float pointSize);\n</code></pre> - <code>map</code>: The map itself. - <code>color</code>: The color of the point clouds. - <code>pointSize</code>: The point cloud's size.</p> <p><code>other shapes</code></p>"},{"location":"developer-guide/CONTRIBUTING_copy/#ctesting","title":"CTesting","text":"<p>When necessary, c++ testing is done by using CTest. Important/critical features (e.g., correcting functioning of graphics with OpenGL and Glfw) needs testing to be written (this is usefull for e.g., GitHub Actions). Such tests can be extracted from the main source code and integrated in a seperate section: cmake testing.</p> <p>To add a new test do as follow.</p> <p>First create a new sub-folder in the folder <code>./test</code> as <code>./test/exampletest</code>. Here add a console cpp file called <code>tester.cpp</code> which returns 0 or 1 and add a new <code>CMakeLists.txt</code> as such: <pre><code>add_executable(example_test tester.cpp)\n\n/* &lt;-- \nInsert here linking necessary for the executable\nNote that if you already found packages in the head CMakeLists file\nyou can simply use the macros here.\n--&gt; */\n\nadd_test(NAME \"ExampleTest\" COMMAND \"example_test\" &lt;argv-here&gt; WORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\")\n</code></pre> In the <code>./test</code>'s <code>CMakeLists.txt</code> add the created sub-directory: <pre><code>if (TEST_EXAMPLE)\n    add_subdirectory(exampletest)\nendif()\n</code></pre> Finally add an option in the main <code>CMakeLists.txt</code> describing the test: <pre><code>include(CTest)\n# ...\noption(TEST_EXAMPLE \"Test to test something important.\" ON)\n# ...\nif(TEST_EXAMPLE)\n    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests/exampletest)\nendif()\n</code></pre></p> <p>Next, <code>./configure.sh -c</code> and <code>./build.sh</code> and: <pre><code>cd ./build\nctest -N    # &lt;--- to see how many tests there are\nctest -V    # &lt;--- run the tests\n</code></pre></p>"},{"location":"developer-guide/acim/","title":"Execution model","text":"<p>The <code>.acim</code> file represents the execution model in the AC system. An execution model is needed to provide the necessary information for the fabrication process. It can be produced with any 3D modeling software.</p> <p><code>.acim</code> is the AC's XML-based format, similar to standard exchange formats such as BTLx, and contains both geometric information (e.g., joints and holes) and fabrication metadata (e.g., ID, fabrication status).</p> <p>During our prototyping phase, we use Rhinoceros 3D with a custom script that automatically detects joints and holes in the 3D model. With a single click, each element (e.g., beam, panel) can be exported to an <code>.acim</code> file without manually creating additional 2D documentation.</p> <p> </p>","tags":["acim","I/O","backend","Rhino"]},{"location":"developer-guide/acim/#acim-file-structure","title":"<code>.acim</code> file structure","text":"<p>The <code>.acim</code> file is currently storing all the information required for the fabrication process. The file parse and store the geometries in 3 components:</p> <ul> <li><code>&lt;timber&gt;</code>: as the main container object</li> <li><code>&lt;hole&gt;</code>: represents all perforations in the model</li> <li><code>&lt;cut&gt;</code>: represents all the cuts in the model</li> </ul>","tags":["acim","I/O","backend","Rhino"]},{"location":"developer-guide/acim/#timber","title":"<code>&lt;timber&gt;</code>","text":"<p>The <code>&lt;timber&gt;</code> tag represents the main component of the model. It contains the ID, the fabrication status, the current cut, and the bounding box of the component.</p> <p>The <code>&lt;bbox&gt;</code> tag contains the coordinates of the corners of the object oriented bounding box in which the timber element is exported. The corners are represented by their coordinates in the 3D space. This is a fundamental element that we already include in the <code>.acim</code> file that will be later used by AC for registering the model to the map (see <code>void LayerModel::AlignModels()</code>)</p> <p> <code>example.acim</code> <pre><code>&lt;timber id=\"C003\"&gt;\n  &lt;executed&gt;NotDone&lt;/executed&gt;\n  &lt;current&gt;Cut#1&lt;/current&gt;\n  &lt;bbox&gt;\n    &lt;corner id=\"0\"&gt;-0.0010000377932458662 9.996989965467265e-05 9.989726472193752e-05&lt;/corner&gt;\n    &lt;corner id=\"1\"&gt;2.296127411397951 9.996989965467265e-05 9.989726472193752e-05&lt;/corner&gt;\n    &lt;corner id=\"2\"&gt;2.296127411397951 0.13990003039836885 9.989726472193752e-05&lt;/corner&gt;\n    &lt;corner id=\"3\"&gt;-0.0010000377932458662 0.13990003039836885 9.989726472193752e-05&lt;/corner&gt;\n    &lt;corner id=\"4\"&gt;-0.0010000377932458662 9.996989965467265e-05 0.13990000059604646&lt;/corner&gt;\n    &lt;corner id=\"5\"&gt;2.296127411397951 9.996989965467265e-05 0.13990000059604646&lt;/corner&gt;\n    &lt;corner id=\"6\"&gt;2.296127411397951 0.13990003039836885 0.13990000059604646&lt;/corner&gt;\n    &lt;corner id=\"7\"&gt;-0.0010000377932458662 0.13990003039836885 0.13990000059604646&lt;/corner&gt;\n  &lt;/bbox&gt;\n</code></pre></p>","tags":["acim","I/O","backend","Rhino"]},{"location":"developer-guide/acim/#hole","title":"<code>&lt;hole&gt;</code>","text":"<p>Holes are represented by their vector and radius and have the <code>&lt;state&gt;</code> tag to indicate their fabrication status. The <code>&lt;neighbors&gt;</code> tag indicates the number of neighboring holes for composite holes (e.g. a hole and a washer). The two following highlighted holes are neighbors, whereas the third hole is not.^(<code>&lt;neighbors&gt;-1&lt;/neighbors&gt;</code>)</p> <p> <code>example.acim</code> <pre><code>&lt;hole id=\"Hole#1\"&gt;\n  &lt;state&gt;Done&lt;/state&gt;\n  &lt;neighbors&gt;2&lt;/neighbors&gt;\n  &lt;start&gt;\n    &lt;exposed&gt;False&lt;/exposed&gt;\n    &lt;coordinates&gt;1.60538 0.07 8.34301e-16&lt;/coordinates&gt;\n  &lt;/start&gt;\n  &lt;end&gt;\n    &lt;exposed&gt;False&lt;/exposed&gt;\n    &lt;coordinates&gt;1.60538 0.07 0.12&lt;/coordinates&gt;\n  &lt;/end&gt;\n  &lt;radius&gt;0.01&lt;/radius&gt;\n&lt;/hole&gt;\n&lt;hole id=\"Hole#2\"&gt;\n  &lt;state&gt;Done&lt;/state&gt;\n  &lt;neighbors&gt;1&lt;/neighbors&gt;\n  &lt;start&gt;\n    &lt;exposed&gt;False&lt;/exposed&gt;\n    &lt;coordinates&gt;1.605380574691806 0.06999999999999534 0.14000000000000057&lt;/coordinates&gt;\n  &lt;/start&gt;\n  &lt;end&gt;\n    &lt;exposed&gt;False&lt;/exposed&gt;\n    &lt;coordinates&gt;1.605380574691806 0.06999999999999536 0.1200000000000006&lt;/coordinates&gt;\n  &lt;/end&gt;\n  &lt;radius&gt;0.025&lt;/radius&gt;\n&lt;/hole&gt;\n&lt;hole id=\"Hole#3\"&gt;\n  &lt;state&gt;Done&lt;/state&gt;\n  &lt;neighbors&gt;-1&lt;/neighbors&gt;\n  &lt;start&gt;\n    &lt;exposed&gt;False&lt;/exposed&gt;\n    &lt;coordinates&gt;0.544337 0.0700887 8.99337e-16&lt;/coordinates&gt;\n  &lt;/start&gt;\n  &lt;end&gt;\n    &lt;exposed&gt;False&lt;/exposed&gt;\n    &lt;coordinates&gt;0.544337 0.0700887 0.07&lt;/coordinates&gt;\n  &lt;/end&gt;\n  &lt;radius&gt;0.017&lt;/radius&gt;\n&lt;/hole&gt;\n</code></pre></p>","tags":["acim","I/O","backend","Rhino"]},{"location":"developer-guide/acim/#cut","title":"<code>&lt;cut&gt;</code>","text":"<p>Cuts are represented by their center, faces, and edges. The <code>&lt;state&gt;</code> tag indicates the fabrication status as well. For faces, the <code>&lt;exposed&gt;</code> tag indicates whether the face is exposed or not. The <code>&lt;edges&gt;</code> tag contains the IDs of the edges that form the face. The <code>&lt;corners&gt;</code> tag contains the coordinates of the corners that form the face. All the elements, as for the holes, are composed by simple primitive points.</p> <p> <code>example.acim</code> <pre><code>&lt;cut id=\"Cut#1\"&gt;\n  &lt;state&gt;NotDone&lt;/state&gt;\n  &lt;center&gt;0.06949998110337721 0.07000000000000012 0.07000000000000067&lt;/center&gt;\n  &lt;faces&gt;\n    &lt;face id=\"0\"&gt;\n      &lt;state&gt;NotDone&lt;/state&gt;\n      &lt;exposed&gt;True&lt;/exposed&gt;\n      &lt;edges&gt;0 2 4 6 10 11&lt;/edges&gt;\n      &lt;corners&gt;\n        &lt;corner id=\"0\"&gt;0.14000000000000012 0.0 0.07000000000000117&lt;/corner&gt;\n        &lt;corner id=\"1\"&gt;0.14000000000000012 9.977733010676742e-16 0.13990000059604646&lt;/corner&gt;\n        &lt;corner id=\"2\"&gt;-0.0010000377932458662 9.996989965467265e-05 0.13990000059604646&lt;/corner&gt;\n        &lt;corner id=\"3\"&gt;-0.0010000377932458662 9.996989965467265e-05 9.989726472193752e-05&lt;/corner&gt;\n        &lt;corner id=\"4\"&gt;0.0 9.992007221626409e-16 9.989726472193751e-05&lt;/corner&gt;\n        &lt;corner id=\"5\"&gt;0.0 9.992007221626409e-16 0.07000000000000117&lt;/corner&gt;\n      &lt;/corners&gt;\n    &lt;/face&gt;\n    ..\n  &lt;/faces&gt;\n  &lt;edges&gt;\n    &lt;edge id=\"0\"&gt;\n      &lt;start&gt;-0.0010000377932458662 9.996989965467265e-05 9.989726472193752e-05&lt;/start&gt;\n      &lt;end&gt;0.0 9.992007221626409e-16 9.989726472193751e-05&lt;/end&gt;\n    &lt;/edge&gt;\n    ..\n  &lt;/edges&gt;\n&lt;/cut&gt;\n</code></pre></p>","tags":["acim","I/O","backend","Rhino"]},{"location":"developer-guide/acim/#acim-parsing","title":"<code>.acim</code> parsing","text":"<p>In AC the responsible layer is the <code>LayerModel</code> that is in charge of parsing the <code>.acim</code> file.</p> <p>The<code>m_ACInfoModel</code> (Augmented Carpentry Informed Model) object is responsible for parsing the <code>.acim</code> file and add all the corresponding *GO*s objects in the scene by using the <code>TimberInfo</code> class. The <code>m_ACInfoModel</code> object is a singleton that is accessible from all the layers of the system.</p>","tags":["acim","I/O","backend","Rhino"]},{"location":"developer-guide/tags/","title":"Conventions","text":"<p>This section explains several conventions used for tags in this documentation.</p>","tags":["HTML5","JavaScript","CSS","8.2.0"]},{"location":"developer-guide/tags/#version","title":"Version","text":"<p>The tag symbol in conjunction with a version number denotes when a specific feature or behavior was added. Make sure you're at least on this version if you want to use it. \u2192</p>","tags":["HTML5","JavaScript","CSS","8.2.0"]},{"location":"developer-guide/toolhead/","title":"Toolheads","text":"<p>3D models of each toolhead is needed to feed to our 6DoF pose detector. But in the AR instructions we are not using the mesh model of the toolhead itself but rather only points of interest (POIs) on this model. These POIs are used as a convinient data to generate fabrication instructions easly, and they define base points, tips, axis, thickness, etc. Depending on the toolhead type, the file contains different point coordinates important to simplify the digital representation of the toolhead.</p> <p>In the current version of AC, these POIs are manually defined in the codebase via the addition of a xml-base file <code>.acit</code> (Augmented Carpentry Instruction Toolhead).</p> <p></p>  POIs of drillbits, chainsaw bars, and circular saw blades integrated in the AC system: drillbit (a) base, (b) chuck, (d) eating, and (e) tool tips; chainsaw bar (f) base, (g) normal, sawchain's (h) start, mid and end points; circular saw blade (i) center, (r) normal and (p) radial point.","tags":["acit","I/O","backend"]},{"location":"developer-guide/toolhead/#acit-file-structure","title":"<code>.acit</code> file structure","text":"<p>Each type of toolhead has its own specific POIs. For now the following toolheads are supported:</p> <ul> <li><code>drillbit</code>: the bit is represented by the base, chuck, eating, and tool tips</li> <li><code>circular saw blade</code>: the blade is represented by the center </li> <li><code>chainsaw bar</code>: we track the bottom perimeter of the bar and add the thickness of the sawchain</li> </ul> <p>Let's have a look at the <code>drillbit</code> toolhead as an exampel that has <code>tooltip</code>, <code>eattip</code>, <code>chucktip</code>, and <code>radius</code> POIs. The <code>.acit</code> file is used to store these POIs in a structured way. Example of a drillbit toolhead <code>.acit</code> file: <pre><code>&lt;acit version=\"0.1.0\"&gt;\n  &lt;toolhead name=\"auger_drill_bit_20_235\" type=\"drillbit\"&gt;\n    &lt;toolbase&gt; 0 0 0 &lt;/toolbase&gt;\n    &lt;tooltip&gt; 0 0 0.235 &lt;/tooltip&gt;\n    &lt;eattip&gt; 0 0 0.228 &lt;/eattip&gt;\n    &lt;chucktip&gt; 0 0 0.075 &lt;/chucktip&gt;\n    &lt;radius&gt; 0.02 &lt;/radius&gt;\n  &lt;/toolhead&gt;\n&lt;/acit&gt;\n</code></pre></p>","tags":["acit","I/O","backend"]},{"location":"developer-guide/toolhead/#acit-parsing","title":"<code>.acit</code> parsing","text":"<p>When imported in AC, <code>.acit</code> files are parsed into corresponding tool types data classes here in the <code>LayerToolhead.h</code>. </p> <p>DrillBit data class: <pre><code>std::string NameACIT;\nfloat RadiusACIT;\nglm::vec3 ToolbaseACIT;\nglm::vec3 TooltipACIT;\nglm::vec3 EattipACIT;\nglm::vec3 ChucktipACIT;\n</code></pre></p> <p>All the tools are held in the <code>ACInfoToolheadManager</code>. The current toolhead can be retrieved from everywhere in the system by calling the <code>AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()</code> function.</p> <p>Note</p> <p>The <code>.acit</code> is also used together with another file <code>.initpose</code> indicating the initial pose of all the parsed POIs: <pre><code>  [ -7.73640037e-01, 4.15423065e-01, -4.78431463e-01, -5.23223341e-01,\n      -8.44716668e-01, 1.12603128e-01, -3.57363552e-01, 3.37440640e-01,\n      8.70876431e-01, 0., 0., 2.20000029e-01 ]\n</code></pre></p>","tags":["acit","I/O","backend"]},{"location":"developer-guide/AR-engine/AR-rendering/","title":"AR rendering","text":"","tags":["AREngine","render"]},{"location":"developer-guide/AR-engine/AR-rendering/#rendering-system","title":"Rendering system","text":"<p>The rendering system renders the main AR view and multiple sub-viewports during different phases. The system consists of the following key components:</p> <ol> <li><code>Renderer.h</code>: Defines the core logic of the rendering pipeline and manages essential attributes.</li> <li><code>Viewport.h</code>: Handles the sub-frame buffer. The renderer calls <code>Activate()</code> to switch the buffer for rendering.</li> <li><code>GLObject.h</code>: Helps GO manage OpenGL resources, allocating memory and buffering data for rendering. Each GO may contain one or multiple GLObjects stored in a list. By invoking Draw(), the content will be rendered to the currently active frame buffer.</li> </ol> <p>Tip</p> <p><code>GOText</code> does not contains any <code>GLObject</code>, and its <code>Draw()</code> function does nothing. Instead, the rendering of <code>GOText</code> is handled separately through <code>TextRenderer.h</code>. Since we want to make the text always facing the screen instead of floating in the 3D space, a special projection method and shader program is required. As a result, the rendering of text is performed separately after all the other <code>GO</code>s are rendered.</p>","tags":["AREngine","render"]},{"location":"developer-guide/AR-engine/AR-rendering/#rendering-pipeline","title":"Rendering pipeline","text":"<p>The <code>Renderer::OnRender()</code> function is executed after all layers are processed. It is the entry point of the rendering pipeline, which calls the corresponding functions to render different views depend on the current status.</p> src/AIAC/Render/Renderer.cpp<pre><code>void Renderer::OnRender()\n{\n    // During mapping, an overlay panel is opened, so we only render things on it\n    // and stop updating the main scene.\n    // TODO: mapping has some problem when calib file is switched (with slam map)\n    if(AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;IsMapping()) {\n        // RenderGlobalView();\n        RenderMappingView();\n        return;\n    }\n\n    if(AIAC_APP.GetLayer&lt;LayerCameraCalib&gt;()-&gt;IsCalibrating()) {\n        RenderCamCalibView();\n        return;\n    }\n\n    // Default, render the main scene\n    RenderMainView();\n    RenderGlobalView();\n}\n</code></pre>","tags":["AREngine","render"]},{"location":"developer-guide/AR-engine/AR-rendering/#sub-view-rendering","title":"Sub-view Rendering","text":"<p>While in the mapping phase or performing camera calibration, the main view is blocked, so it will not be rendered. Instead, the corresponding sub-view will be rendered through <code>RenderMappingView()</code> or <code>RenderCamCalibView()</code>.</p>","tags":["AREngine","render"]},{"location":"developer-guide/AR-engine/AR-rendering/#main-view-rendering","title":"Main-view Rendering","text":"<p>During the fabrication phase, there're two viewports that needed to be rendered: The AR view and the global 3D view. The AR view combines captured images with virtual objects, such as CAD models and feedback graphics, to provide clear and intuitive instructions. The global 3D view serves as an interface for navigating through the entire scene, enabling users to easily inspect different components. The rendering of the two viewports are handled by two separate functions:</p> <ol> <li><code>RenderMainView()</code> renders the main AR view by calculating the projection matrix using the estimated position from <code>LayerSLAM</code> and overlays all geometry from the <code>GORegistry</code> onto the captured image.</li> <li><code>RenderGlobalView()</code> switches the frame buffer to the 3D viewport and renders the geometry with a projection based on the user's navigation.</li> </ol>","tags":["AREngine","render"]},{"location":"developer-guide/AR-engine/feedback-system/","title":"Feedback system","text":"<p>The <code>LayerFeedback.h</code> module handles the computation of all essential data required to deliver visual guidance to the user during the fabrication process. To compute feedback, information is primarily retrieved from two preceding layers: </p> <ol> <li><code>LayerModel.h</code>: Contains the execution model and the geometries associated with the currently active hole or cut (via <code>AC_FF_COMP</code> macro).</li> <li><code>LayerToolhead.h</code>: Provides similar information, but specific to the current toolhead attached to the tool (via <code>AC_FF_TOOL</code> macro).</li> </ol> <p>The LayerFeedback::OnFrameStart() from the <code>LayerFeedback.h</code> simply activates the feedback set based on the correct toolhead based on the current fabrication element.</p> Toolhead Hole Cut Chainsaw \u274c \u2705 Circualr Saw \u274c \u2705 Drill meshes \u2705 \u274c <p>Once the correct feedback is indetified, we have all the geometries of the joint or hole we are working on, as well as the geometries of the toolhead attached to the tool, we can compute all the relevant computations to build the feedback set: starting distance, depth, orientation, etc. In the layer <code>LayerFeedback.h</code> not only we calculate these values but we generate all the necessary GOs to visualize them in the AR scene.</p>","tags":["AREngine","feedback-system"]},{"location":"developer-guide/AR-engine/feedback-system/#fabfeedback-interface","title":"<code>FabFeedback</code> interface","text":"<p>Feedback is categorized by similar operations:</p> <ul> <li>drilling (<code>HoleFeedback.h</code>),</li> <li>circular cutting (<code>CutCircularSawFeedback.h</code>),</li> <li>and chainsaw cutting (<code>CutChainSawFeedback.h</code>).</li> </ul> <p>Each feedback category inherits from an interface class (<code>AIAC/Feedback/FabFeedback.h</code>), which provides top-level control functions such as <code>Update()</code>, <code>Activate()</code>, and <code>Deactivate()</code>.</p> src/AIAC/Feedback/FabFeedback.h<pre><code>#pragma once\n\n#include \"AIAC/Config.h\"\n\n#define AC_FF_COMP AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()\n#define AC_FF_TOOL AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()\n\nnamespace AIAC {\n    class FabFeedback {\n    public:\n        FabFeedback() {\n            this-&gt;m_ScaleFactor = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n        };\n        ~FabFeedback() = default;\n\n        virtual void Update() {};\n        virtual void Activate() {};\n        virtual void Deactivate() {};\n\n    protected:\n        float m_ScaleFactor = 0.0f;\n    };\n}\n</code></pre> <p>Tip</p> <p>The <code>Update()</code> function is called at each frame to update the feedback data, while <code>Activate()</code> and <code>Deactivate()</code> are used to enable/disable the feedback visualization.</p>","tags":["AREngine","feedback-system"]},{"location":"developer-guide/AR-engine/feedback-system/#feedbackvisualizer-widgets","title":"<code>FeedbackVisualizer</code> widgets","text":"<p>Each tool's visual guidance might consists of multiple visual cues, most of which are built on the template <code>FeedbackVisualizer.h</code>. All the feedback values are computed but also visualized as GOs, and stored inside (<code>m_AllPrimitives</code>). This is convinient as we can easily toggle the visibility of the feedback by calling the <code>Activate()</code>/<code>Deactivate()</code> functions.</p> src/AIAC/Feedback/FeedbackVisualizer.h<pre><code>#ifndef AC_FEEDBACKVISUALIZER_H\n#define AC_FEEDBACKVISUALIZER_H\n\n#include \"vector\"\n#include \"memory\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/Config.h\"\n\nnamespace AIAC{\n    class FeedbackVisualizer {\n    public:\n        FeedbackVisualizer() = default;\n        ~FeedbackVisualizer() = default;\n\n        inline virtual void Activate() {\n            for (auto &amp;p : m_AllPrimitives) {\n                p-&gt;SetVisibility(true);\n            }\n        }\n\n        inline virtual void Deactivate() {\n            for (auto &amp;p : m_AllPrimitives) {\n                p-&gt;SetVisibility(false);\n            }\n        }\n\n        // ...\n\n    protected:\n        std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; m_AllPrimitives;\n    };\n\n}\n</code></pre> <p>Example</p> <p>As an example, the circular saw feedback has several <code>VisualFeedback</code> classes that inherit from <code>FeedbackVisualizer</code> to manage the visualization of the feedback. In the case of the circular saw, we have the following <code>VisualFeedback</code> classes:</p> VisualFeedback class Description <code>class CutCircularSawDepthVisualizer</code> it visualizes the height of the blade in relation to the lap joint <code>class CutCircularSawPositionStartVisualizer</code> it visualizes the starting position of the cut as a text in millimeters and as a green line for graphical correction <code>class CutCircularOrientationVisualizer</code> it visualizes the correct orientation of the cut as a text in millimeters and as a green line for graphical correction <code>class CircularSawCutPlaneVisualizer : public CutPlaneVisualizer</code> in this case it still inherits from <code>FeedbackVisualizer</code> the <code>CutPlaneVisualizer</code>, but since it is employed also by other tools (e.g. chainsaw), the sub-class already presents some common parameters and visual cues for the plane corresponding to the blade <code>class CircularSawCutBladeThicknessVisualizer</code> it visualizes the thickness of the blade as two red lines <p>All the <code>VisualFeedback</code> are not active all the time at the same time during a fabrication. Depending on which scenario is detected, they are activated (visible) or deactivated (not visible).</p> <p>Here's an example of the <code>CutCircularSawFeedback</code> class in action for a typical circular saw cutting sequence:</p> <p></p> <p>This composite system allows for a flexible and modular feedback system that can be easily extended with new feedback types and visualizations.</p>","tags":["AREngine","feedback-system"]},{"location":"developer-guide/AR-engine/geometry-framework/","title":"Geometry Framework","text":"<p>The geometry framework provides a unified infrastructure for handling all 3D objects in the scene, including CAD models, scanned models, and fabrication instructions. This framework enables easy interaction between application layers and 3D objects while being tightly integrated with the rendering system, which implicitly manages OpenGL resources, simplifying the workload for application layers.</p>","tags":["AREngine","go"]},{"location":"developer-guide/AR-engine/geometry-framework/#usage-of-geometry-framework","title":"Usage of Geometry Framework","text":"<p>The geometry framework is defined in <code>GOPrimitive.h</code>. The geometry is organized into the following primitive shapes: point, line, circle, cylinder, polyline, triangle, mesh, and text. Each of them is a class (e.g., <code>GOPoint</code>, <code>GOLine</code>, <code>GOCircle</code>, etc.) that inherits the base class <code>GOPrimitive</code>, where \"GO\" stands for Geometry Object. The base class manages general attributes and provides interfaces such as visibility and transformation, while the subclasses handle their specific data and functions.</p> src/AIAC/GOSys/GOPrimitive.h<pre><code>class GOPrimitive\n{\npublic:\n    inline uint32_t GetId() { return m_Id; }\n    inline GOTypeFlags GetType() { return m_Type; }\n\n    inline void SetVisibility(bool isVisible) { m_IsVisible = isVisible; }\n    inline bool GetVisibility() { return m_IsVisible; }\n    inline void SetColor(glm::vec4 color) { m_Color = color; InitGLObject();}\n    inline glm::vec4 GetColor() const { return m_Color; }\n    inline void SetName(std::string name) { m_Name = std::move(name); }\n    inline std::string GetName() const { return m_Name; }\n\n    virtual void Transform(const glm::mat4x4&amp; transformMat) {};\n    virtual void Translate(const glm::vec3&amp; translation) {};\n\n    inline void Draw() { for(auto glObject : m_GLObjects) glObject-&gt;Draw(); }\n\nprotected:\n    uint32_t m_Id;\n    std::string m_Name;\n    bool m_IsVisible;\n    glm::vec4 m_Color;\n    GOTypeFlags m_Type;\n    std::vector&lt;std::shared_ptr&lt;GLObject&gt; &gt; m_GLObjects;\n};\n</code></pre> <p>Tip</p> <p>The <code>m_Id</code> would be generated automatically when a new <code>GO</code> is initialized and is ensured to be unique in the system. <code>m_Type</code> can be used to easily determine the sub-class while the object is held as a <code>GOPrimitive</code> pointer. <code>Draw()</code> and <code>m_GLObjects</code> are used for rendering, which will be introduced in AR-rendering.</p> src/AIAC/GOSys/GOPrimitive.h<pre><code>class GOLine : public GOPrimitive\n{\nprivate:\n    GOLine();\n    GOLine(GOPoint p1, GOPoint p2, float weight = GOWeight::Default);\n\npublic:\n    static std::shared_ptr&lt;GOLine&gt; Add();\n    /**\n        * @brief Add GOLine to the scene.\n        *\n        * @param p1 First point of the line.\n        * @param p2 Second point of the line.\n        * @param weight Weight of the line.\n        * @return uint32_t Id of the line.\n        */\n    static std::shared_ptr&lt;GOLine&gt; Add(GOPoint p1, GOPoint p2, float weight = GOWeight::Default);\n\n    /**\n        * @brief Compute the angle between the current line object and another one with a sign\n        *\n        * @param ptrGO2 the second line\n        * @return float the angle in degrees\n        */\n    float ComputeSignedAngle(std::shared_ptr&lt;GOLine&gt; ptrGO2);\n\nprivate:\n    GOPoint m_PStart;\n    GOPoint m_PEnd;\n\nfriend class GOPoint;\n};\n</code></pre> <p>Tip</p> <p>To initialize a <code>GO</code> object, instead of calling the constructor, one must use the static function <code>Add()</code> of the corresponding class to create an object. This is due to the design of the <code>GORegistry</code>, which manages all GOs, ensuring them accessible across the system.</p>","tags":["AREngine","go"]},{"location":"developer-guide/AR-engine/geometry-framework/#creating-a-go","title":"Creating a GO","text":"<p>The <code>GO</code> needed to be initialized using <code>Add()</code> function, which returns a <code>std::shared_ptr&lt;GO&gt;</code>. For example, to create a point at the origin: <pre><code>std::shared_ptr&lt;GOPoint&gt; origin = GOPoint::Add(0, 0, 0);\n</code></pre></p> <p>The only exception that you can create without using the <code>Add()</code> function is <code>GOPoint</code>, as they are used as parameters in other <code>GO</code>s. For example, to create a <code>GOLine</code>: <pre><code>GOPoint p1 = GOPoint(0, 0, 0);\nGOPoint p2 = GOPoint(1, 1, 1);\nstd::shared_ptr&lt;GOLine&gt; line = GOLine::Add(p1, p2);\n</code></pre></p>","tags":["AREngine","go"]},{"location":"developer-guide/AR-engine/geometry-framework/#go-registry","title":"GO Registry","text":"<p>The system maintains a global registry, <code>GORegistry</code>, to keep track of all GOs. When the <code>Add()</code> function of the <code>GO</code> is called, it acquires a unique UUID(<code>m_Id</code>) and registers itself in the global hash table. Since this table is accessible throughout the entire system, it maximize the accessbility of GOs.</p>","tags":["AREngine","go"]},{"location":"developer-guide/AR-engine/geometry-framework/#interact-with-go-registry","title":"Interact with GO Registry","text":"<p>To access the global registry, one can use the macro <code>AIAC_GOREG</code> to get the instance. It provides two APIs to retrive GO(s): either getting one by its UUID or all objects registered in the system.</p> <p>To retrieve a <code>GO</code> by its id: <pre><code>std::shared_ptr&lt;GOPoint&gt; obj = AIAC_GOREG-&gt;GetGO&lt;GOPoint&gt;(id);\n</code></pre></p> <p>To get all <code>GO</code>s in the registry: <pre><code>std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; gos;\nAIAC_GOREG-&gt;GetAllGOs(gos);\n</code></pre></p>","tags":["AREngine","go"]},{"location":"developer-guide/AR-engine/layer-stack/","title":"Layer stack","text":"<p>At the core of every AR engine there is a main loop where 1) you get your sensor data, 2) you process it, 3) you render it, and 4) you display it, 5) you start over or stop. </p> <p>And Augmented Carpentry makes no difference. Now, the way you decide to structure your code and the way you decide to manage the flow of this main loop makes the difference. We went for a light weight and expandable architecture called layer-stack flow.</p> <p>Here on the left you can find its illustration of the layer-stack design and the main loop for our AR engine. In the this page we will delve into the details of this architecture.</p>","tags":["AREngine","layer-stack"]},{"location":"developer-guide/AR-engine/layer-stack/#layer-stack-flow","title":"Layer stack flow","text":"<p>The layer stack is primarily responsible for managing the flow control of the AR engine. Designed as a modular system, each layer encapsulates the code for a specific domain of the AR application, such as camera processing, object tracking, UI, rendering, etc. The general order and expansion of these layers can be configured in the top-level main file <code>ACApp.cpp</code>, which is also our main entry point for the application:</p> src/ACApp.cpp<pre><code>#include \"aiacpch.h\"\n#include \"AIAC.h\"\n\nint main(int argc, char* argv[]) {\n#ifdef __linux__\n    AIAC::Log::Init();\n\n    [...]\n\n    std::unique_ptr&lt;AIAC::Application&gt; acApp_ptr =\n        std::unique_ptr&lt;AIAC::Application&gt;(new AIAC::Application(appSpec));\n\n    acApp_ptr-&gt;GetWindow()-&gt;Init();\n\n    acApp_ptr-&gt;GetGORegistry()-&gt;Init();\n\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerCamera&gt;();       // sensor input\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerCameraCalib&gt;();  // calibration\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerSlam&gt;();         // self-localization\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerModel&gt;();        // execution model\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerToolhead&gt;();     // tools attachement\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerFeedback&gt;();     // instructions\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerUI&gt;();           // UI\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerUtils&gt;();        // extra\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerLogRecorder&gt;();  // trajectory recorder\n\n    acApp_ptr-&gt;GetRenderer()-&gt;Init();\n\n    acApp_ptr-&gt;GetEventBus()-&gt;Init();\n    acApp_ptr-&gt;Run();\n\n    return 0;\n#else\n    return -1;\n#endif\n\n}\n</code></pre>","tags":["AREngine","layer-stack"]},{"location":"developer-guide/AR-engine/layer-stack/#layer-structure","title":"Layer structure","text":"<p>Each layer in the stack inherits from a superclass interface defined in <code>Layer.h</code>, which includes event-like methods triggered at various points during frame processing (e.g., <code>OnFrameAwake()</code>, <code>OnFrameStart()</code>, etc.). These methods are invoked by the main <code>Run()</code> function in the singleton application loop from <code>Application.h</code>. This design allows application tasks to be containerized and executed sequentially and in a temporal fashion.</p> src/AIAC/Layer.h<pre><code>#pragma once\n\n#include \"AIAC/Log.h\"\n\nnamespace AIAC\n{\n    class Layer\n    {\n    public:\n        virtual ~Layer() = default;\n\n        /// Is called when the layer is attached to the application.\n        virtual void OnAttach() {}\n\n        /// Is calle before GLFW poll events, GL frame and Imgui Frame\n        virtual void OnFrameAwake() {}\n\n        /// Is called when frame starts\n        virtual void OnFrameStart() {}\n\n        /// Is called when frame ends\n        virtual void OnFrameEnd() {}\n\n        /// Is called when the GLFW, GL and Imgui frame is updated and rendered\n        virtual void OnFrameFall() {}\n\n        /// Is called when the layer is detached from the application (~app).\n        virtual void OnDetach() {}\n    };\n}\n</code></pre> <p>So, if you were to add a new layer to the stack, you would need to create a new class that inherits from the <code>Layer</code> class and implement the necessary methods. Then, you would push this new layer to the stack in the main file <code>ACApp.cpp</code>.</p>","tags":["AREngine","layer-stack"]},{"location":"developer-guide/AR-engine/layer-stack/#sequential-execution","title":"Sequential execution","text":"<p>The <code>Run()</code> function in the <code>Application</code> class is the main loop of the application. It is responsible for executing the layers in the order they were pushed to the stack. This design allows for a sequential execution of the layers, which is crucial for the correct functioning of the AR engine.</p> src/AIAC/Application.cpp<pre><code>void Application::Run() {\n    m_IsRunning = true;\n\n    while (m_Window-&gt;IsOpen())\n    {\n        if(!m_EventBus-&gt;IsEventQueueEmpty())\n            m_EventBus-&gt;ProcessQueue();\n\n        for (auto&amp; layer : m_LayerStack)\n            layer-&gt;OnFrameAwake();\n\n        for (auto&amp; layer : m_LayerStack)\n            layer-&gt;OnFrameStart(); \n\n        m_Window-&gt;OnUpdate();\n        m_Renderer-&gt;OnRender();\n\n        GetLayer&lt;AIAC::LayerUI&gt;()-&gt;OnUIRender();\n\n        for (auto&amp; layer : m_LayerStack)\n            layer-&gt;OnFrameEnd();\n\n        m_Window-&gt;OnBufferSwap();\n\n        for (auto&amp; layer : m_LayerStack)\n            layer-&gt;OnFrameFall();\n    }\n}\n</code></pre>","tags":["AREngine","layer-stack"]},{"location":"developer-guide/AR-engine/layer-stack/#layers-communication","title":"Layers communication","text":"<p>Data exchange between specific layers is possible through the use of the <code>AIAC_APP</code> macro, enabling the retrieval of any particular layer member or function. It can be called from any layer at any moment after the <code>Run()</code> is called. For example, the <code>LayerCamera</code> can access the <code>LayerSlam</code> data by calling:</p> <pre><code>AIAC_APP-&gt;GetLayer&lt;LayerSlam&gt;()-&gt;GetCameraPose();\n</code></pre> <p>Info</p> <p>The <code>AIAC_APP</code> macro is defined in <code>Application.h</code> and is a singleton instance of the <code>Application</code> class. It returns a copy to the reference of the application instance.</p> <pre><code>inline static Application&amp; GetInstance() { return *s_Instance; }\n</code></pre> <p>Tip</p> <p>Exchange between layers can also take place in a more structured way with the integrated event system (<code>ApplicationEvent.h</code>), which is capable of queuing events from layers and trigger them in the next main loop. Have a look at the developer guide for event system.</p>","tags":["AREngine","layer-stack"]},{"location":"guides/creating-a-reproduction/","title":"Creating a reproduction","text":"<p>A reproduction is a simplified version of a bug that demonstrates the specific scenario in which the bug occurred. It includes all necessary minimal settings and instructions and should be as simple as possible while still demonstrating the issue.</p>"},{"location":"guides/creating-a-reproduction/#guide","title":"Guide","text":""},{"location":"guides/creating-a-reproduction/#environment","title":"Environment optional","text":"<p>We recommend using a virtual environment, which is an isolated Python runtime. If you are in a virtual environment, any packages that you install or upgrade will be local to the environment. If you run into problems, you can just delete and recreate the environment. It's trivial to set up:</p> <ul> <li> <p>Create a new virtual environment with:</p> <pre><code>python3 -m venv venv\n</code></pre> </li> <li> <p>Activate the environment with:</p>  macOS Windows Linux <pre><code>. venv/bin/activate\n</code></pre> <pre><code>. venv/Scripts/activate\n</code></pre> <pre><code>. venv/bin/activate\n</code></pre> <p>Your terminal should now print <code>(venv)</code> before the prompt, which is how you know that you are inside the virtual environment that you just created.</p> </li> <li> <p>Exit the environment with:</p> <pre><code>deactivate\n</code></pre> </li> </ul>"},{"location":"guides/creating-a-reproduction/#minimal-reproduction","title":"Minimal reproduction","text":"<p>Following the instructions below, you will set up a skeleton project to create a reproduction. As mentioned above, we recommend using a virtual environment, so create a new folder in your working directory and a new virtual environment inside it. Next:</p> <ol> <li> <p>As mentioned in our bug reporting guide, ensure that you're running the     latest version of Material for MkDocs, which might already include a fix for     the bug:</p> <pre><code>pip install --upgrade --force-reinstall mkdocs-material\n</code></pre> </li> <li> <p>Bootstrap a new documentation project using the <code>mkdocs</code> executable,     which you use as a basis for the reproduction. It's essential to create a     new, empty project for this:</p> <pre><code>mkdocs new .\n</code></pre> <p>Start by adding the minimal configuration in <code>mkdocs.yml</code>:</p> <pre><code>theme:\n  name: material\n</code></pre> </li> <li> <p>Now, only add the necessary settings to <code>mkdocs.yml</code> to keep the     reproduction minimal. If you are creating a reproduction for a rendering     bug, create only the necessary amount of Markdown documents. Repeat this     step until the bug you want to report can be observed.</p> </li> <li> <p>As a last step, before packing everything into a <code>.zip</code> file, double-check     all settings and documents if they are essential to the reproduction, which     means that the bug does not occur when they are omitted. Remove all     non-essential lines and files.</p> </li> </ol>"},{"location":"guides/creating-a-reproduction/#creating-a-zip-file","title":"Creating a <code>.zip</code> file","text":"<p>Material for MkDocs 9.0.0 includes a new plugin solely intended to create reproductions for bug reports. When the built-in info plugin is enabled, MkDocs will add all relevant files to a <code>.zip</code>, print a summary to the terminal and exit. Add the following lines to <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - info\n</code></pre> <p>Now, when running <code>mkdocs build</code>, a file called <code>example.zip</code> is automatically created, containing the minimal reproduction you can directly attach to your bug report.</p> <pre><code>INFO     -  Started archive creation for bug report\nINFO     -  Archive successfully created:\n\n  example/.dependencies.json 859.0 B\n  example/.versions.log 83.0 B\n  example/docs/index.md 282.0 B\n  example/mkdocs.yml 56.0 B\n\n  example.zip 1.8 kB\n</code></pre>"},{"location":"hardware/","title":"Hardware overview","text":"<p>This section provides an overview of the hardware requirements for the AC system. AC can run with a simple laptop () and connected sensor or as a wearable system (). We include instructions for both layouts. The major XR hardware components for AC are:</p> <ul> <li>A : the computing unit</li> <li>B : the woodworking electric powertool</li> <li>C : a tool mount</li> <li>D : a digitized toolhead</li> <li>E : an interface</li> <li>F : a monocular camera</li> <li>*: Additionally you will also require to print stickers to tag the beams.</li> </ul> <p>In the current state of our prototype, we have opted not to use off-the-shelf or commercial XR devices. Several factors influenced this decision. We wanted to maintain complete control over our XR prototype and make it fully open-srouce and free.</p> <p>To reduce manufacturing tolerances and achieve higher precision, we limited the number of tracking devices to a single sensor\u2014a simple monocular camera used by AC. Monocular cameras are rich in information, lightweight, and economically accessible, making them an attractive choice for open-source, distributed systems like AC. Additionally, we aimed to avoid the proprietary barriers often found in low-level XR software components (e.g., the inability to replace a particular SLAM of a device) during development. As a result, we assembled a minimal yet highly customized demonstrator specifically adapted for woodworking, giving us greater freedom in refining and improving our XR setup.</p>"},{"location":"hardware/computing/","title":"Computing unit","text":"<p>AC's prototype is built for x64 machines running on Ubuntu 22.04 LTS. The system does not exploit GPU acceleration and can run on a laptop, a portable computing unit or a desktop.</p> \u00a0\u00a0 Wearable\u00a0\u00a0 Laptop <p></p> <p>In our current prototype we wanted to develop a computing unit that could be easily transported and used in construction sites and shops. For this reason we decided to use a x64 machine of type NUC with these specifics:</p> <pre><code>OS: Ubuntu 22.04.3 LTS x86_64 \nHost: NUC13ANHi7 M89903-203 \nKernel: 6.8.0-40-generic \nUptime: 8 mins \nPackages: 2299 (dpkg), 17 (snap) \nShell: bash 5.1.16 \nResolution: 1024x600 \nDE: GNOME 42.9 \nWM: Mutter \nWM Theme: Adwaita \nTheme: Yaru [GTK2/3] \nIcons: Yaru [GTK2/3] \nTerminal: gnome-terminal \nCPU: 13th Gen Intel i7-1360P (16) @ 5.000GHz \nGPU: Intel Device a7a0 \nMemory: 1622MiB / 31645MiB\n</code></pre> <p>We decided such machine for our wearable AR system for the following reasons:</p> <code>x64 target machine</code> More importantly, it has the same architecture as a laptop or a desktop, which streamlines the development process (e.g. no <code>.apk</code> files to generate and deploy on the device). Additionally, being on UNIX x64 machines, we could leverage all the top notch libraries and dependecies available from robotics and computer vision communities. <code>Small factor</code> It is a small form factor computer that can be easily transported. <code>Low power consumption</code> It is energy efficient and can be powered by a 18v (5.0Ah) battery for power tools. <code>Ordinary Sensor Interface</code> It has a USB interface which is common and can be used to connect the camera as well as any other device (e.g. touch screen). <p>If you are using a laptop or a desktop, you just need at least<sup>2</sup> Ubuntu 22.04.3 LTS x86_64 installed on your machine and you are good to go.</p> <ol> <li> <p>printed on a Pruse MK3d+ on PLA.\u00a0\u21a9</p> </li> <li> <p>AC has not been tested on more recent LTS versions other than 22.04.3.\u00a0\u21a9</p> </li> </ol>"},{"location":"hardware/computing/#components-list","title":"Components list","text":"<p>Parts</p> <p></p> <p>The battery is a 18v (5.0Ah) battery that can be used for power tools. The battery is connected to the NUC via a 5v regulator (LM785) to ensure a stable power supply. The battery is also connected to a buzzer that will beep when the battery voltage is below a certain threshold (circa 15%). This will inform the user to change the battery. Here's the list of the parts you will need to obtain or realize:</p> <ul> <li> \u00a0\u00a0 (C) NUC</li> <li> \u00a0\u00a0 (B) Protective case for the NUC:<ul> <li>x1  <code>assets/hardware_parts/nuc/nucpoite2.stl</code></li> </ul> </li> <li> \u00a0\u00a0 (L) 1x Power tool battery 18v (5.0Ah)</li> <li> \u00a0\u00a0 (I) Battery adapter</li> <li> \u00a0\u00a0 (B) 1x Metal support to connect NUC case, battery adapter, and belt clip</li> <li> \u00a0\u00a0 (G) 1x 5v regulator (LM785)</li> <li> \u00a0\u00a0 (E) 1x USB 2.0 input and alimentation for touch screen</li> <li> \u00a0\u00a0 (D) 1x USB 3.0 camera connection</li> <li> \u00a0\u00a0 (F) 1x HDMI for touch screen</li> <li> \u00a0\u00a0 (H) 1x Battery monitor</li> </ul> Battery monitor blueprint <p>As a bonus, here's the diagram and code snippet shows how to monitor the battery voltage connected to a NUC using a buzzer. The buzzer will inform when needs to be changed.</p> <p>To realize this schematic, you will need the following components:</p> <ul> <li> \u00a0\u00a0 1x Arduino Nano</li> <li> \u00a0\u00a0 1x DIY cable sleeve</li> <li> \u00a0\u00a0 1x piezo buzzer</li> <li> \u00a0\u00a0 6x resistors 200ohm</li> </ul> <p></p> assets/arduino_scripts/battmonitor.ino<pre><code>/*\n  Battmonitor\n\n  Measures the voltage of a battery and activates a buzzer if the voltage drops below a certain voltage.\n\n  A0  seria -5       A1 seria -4        A2 seria -3      A3 seria -2         A4 seria -1\n  A5 seria -0       A6 seria 1          A7 seria 2\n*/\n\n#include &lt;avr/io.h&gt;\nint val = 610;  //validated value: 610\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n\n  pinMode(9, OUTPUT);\n  pinMode(-4, INPUT);\n  pinMode(LED_BUILTIN, OUTPUT);\n\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  // read the input on analog pin 1:\n  int sensorValue = analogRead(-4);\n\n  if(sensorValue &lt; val) {\n\n    analogWrite(9, 300);\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(3000);\n    analogWrite(9, 127);\n    digitalWrite(LED_BUILTIN, LOW);\n  }\n  else {\n    analogWrite(9, 0);\n    digitalWrite(LED_BUILTIN, LOW);\n  }\n\n\n  delay(3000);\n\n}\n</code></pre>"},{"location":"hardware/interface/","title":"Interface","text":"<p>AC is designed as a console app with a GUI. This means that it can work with a touch screen (via HDMI) or a laptop. The interface is designed to be simple and intuitive. The main goal is to provide a quick and familiar way to interact with the system where every touch operations is in reality a click operation. This way we can develop our AR software without bodering for dedicated development on more complex HMDs or advanced AR interfaces that would offer more ergonomic value to the cost of an increase complexity during the deployement and a steeper learning curve for the users.</p> \u00a0\u00a0 Wearable\u00a0\u00a0 Laptop <p></p> <p>You can use the WaveShare WS170120 as in the current AC prototype and follow the instructions below. To config the touch screen on the pc follow these steps first. Be sure to switch the display on, plug the mini-USB and finally plug the HDMI cable.</p> <p>In case you use a laptop or a desktop, you can use the touchpad or a mouse to interact with the system as you would do for any other desktop application.</p>"},{"location":"hardware/interface/#components-list","title":"Components list","text":"<p>Parts</p> <p></p> <p>Here's the list of the parts you will need to obtain or realize:</p> <ul> <li> \u00a0\u00a0 (C) WaveShare WS170120</li> <li> \u00a0\u00a0 Support and tool-side attach for the screen<ul> <li> \u00a0\u00a0 (A) locline (\u00bd\" - passage 12 mm)</li> <li> \u00a0\u00a0 (D) 3D printed parts<ul> <li>x1  <code>assets/hardware_parts/touchscreen/nuts_ecran.stl</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/reinforce_attachusb.stl</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/screen_board_3.stl</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/locline_attach.stl</code></li> </ul> </li> <li> \u00a0\u00a0 Screen rigs to CNC cut<ul> <li>x1  <code>assets/hardware_parts/touchscreen/back_screen.pdf</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/back_screen.dxf</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/screen_board_1.dxf</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/screen_board_2.dxf</code></li> </ul> </li> <li> \u00a0\u00a0 Magnet attachement to the tool<ul> <li>x1  <code>assets/hardware_parts/touchscreen/magnet_screenside.pdf</code></li> <li>x1  <code>assets/hardware_parts/touchscreen/nucpoite2.stl</code></li> </ul> </li> <li> x10 M3x10 threaded inserts</li> <li> x10 M3x10 nuts</li> </ul> </li> <li> \u00a0\u00a0 (E) USB 2.0 cable (length: 1.5m)</li> <li> \u00a0\u00a0 (F) HDMI (length: cable 1.5m)</li> <li> \u00a0\u00a0 Cable protections and fixations</li> <li> <code>assets/hardware_parts/nucpoite2.stl</code></li> </ul> <p>Set the display properties in the <code>config.ini</code> properties (to find them run the commands <code>xinput</code>  for the name and <code>xrandr</code> for the connection type).</p> <p>The following specs works on the X11 display server also, but you can use any other touch screen, just make sure to set the correct specs in the <code>config.ini</code> file:</p> config.ini<pre><code>[MonitorSpecs]\nmonitor_name = WaveShare WS170120\nmonitor_link_t = HDMI\nmonitor_resolution = 1280 x 720\n</code></pre> XWayland <p>Wayland display and touchscreen are not compatible yet as the touchscreen register for the main display and not the small display.</p> config.ini<pre><code>[MonitorSpecs]\nLinkMode = XWAYLAND1\nName = Virtual core pointer\nResolution = 1280 x 720\n</code></pre>"},{"location":"hardware/sensors/","title":"Sensors","text":"<p>AC functions on a unique simple moncoular camera.</p> <p>We decided to take up the challange to build the entire sensing system to boost the accessibility and the portability of the sensing system. Through the raster feed from the camera, AC is capable of providing all the computed information necessary for the fabrication. Plus, it is compact, lightweight and easy to install on any tool. Finally, we believe that this can ensure a better future-proofing of any AR system.</p> <p></p> <p>The camera is installed on the tool itself with a locline and an articulated arm. This ensures to follows the tool movements and adapt the camera's view for each tool. This is a key feature to ensure that the tool head can be robustly tracked while detecting also the background features.</p> <p>For the AC prototype we integrated a monocular camera specifically developed for drone applications: RunCam 2 4K<sup>1</sup>. Here are the features of the camera we were interested in given the constraints during the fabrication. If you pick another camera we recommend you to pick one with similar specifics:</p> <code>Resolution (HD)</code> The hgiher the resolution the more refined and accurate your computed information will be. Nonetheless, the higher the resolution the more computational power you will need to process the feed. We recommend a resolution of 1280x720 pixels. <code>Frame rate (30 fps)</code> As long as it does not drop below ~23 fps human eye cannot catch the difference. Nevertheless, this value important to have a smooth tracking and a reactive system. <code>Large field of view (170\u00b0)</code> A large fish-eye lens is recommended to have a large field of view. This is important to have a better understanding of the environment and to have a better tracking of the tool at the same time. The larger the view the more information e.g., pixels, to work with. <code>Low weight (49g)</code> The lighter the camera the less it will impact the tool balance and the less it will be a burden for the user of course. <code>Shock and vibration resistant</code> The tool is a vibrating machine and the camera will be exposed to a lot of vibrations. We found monocular sensors designed for drones to be the most adapted to this scenario. <code>Capture distance</code> This is a key feature that monocular camera offers: they are able to capture information about both close and far subjects at once. Range finding or laser-based systems although providing distance information, often struggle to provide information about close subjects and their capture distance is very high."},{"location":"hardware/sensors/#calibration","title":"Calibration","text":"<p>No matter the monocular camera you choose, you will need to calibrate it. A calibration is a process to determine the intrinsic and extrinsic parameters of the camera and it undistort the image feed. This is a fundamental step to ensure the accuracy of the system. The better the calibration, the better the precision you will get from the AR system.</p> <p>Before you start print this chessboard and follow the instructions below.</p> \u00a0\u00a0 Wearable\u00a0\u00a0 Laptop <p>You can move forward with the calibration and do it once the AC executable is running. Just follow the instructions in the camera calibration section.</p> <p>Download our python-made calibration tool from:</p> <pre><code>git clone https://github.com/ibois-epfl/rgb-camera-calibration.git\n</code></pre> <p>Install opencv and capture all the images needed for the calibration:</p> <pre><code>pip install opencv-python\ncd rgb-camera-calibration\npython ./capture_img.py -I 0\n</code></pre> <p>Then run the calibration:</p> <pre><code>python ./calibrate_camera.py -H 19 -V 13 -S 20\n</code></pre> <p>Now save the values of the output <code>camera_calibration.json</code> in the AC format.</p> <p>AC reads and saves the calibration in a <code>.yml</code> file. Here is an example of the calibration file.</p> assets/tslam/calibration_orange_A_1280_720_000B.yml<pre><code>%YAML:1.0\n---\nimage_width: 1280\nimage_height: 720\ncamera_matrix: !!opencv-matrix\n   rows: 3\n   cols: 3\n   dt: d\n   data: [ 562.120361, 0., 640.797729, 0.,\n       562.737671, 346.069397, 0., 0., 1. ]\ndistortion_coefficients: !!opencv-matrix\n   rows: 1\n   cols: 5\n   dt: d\n   data: [ -0.25688748402037903, 0.089453678964044672,\n       -0.00030771674818804194, 0.00017539880556521496,\n       -0.016307368788539566 ]\n</code></pre> <p>The calibration file can be found and set manually from the <code>config.ini</code> file.</p> assets/default_config.ini<pre><code>[AIAC]\nACInfoModel = assets/ACModel/test.acim\nAlignFlip = 0\nAlignOffset = 0\nAlignRotation = 0\nCamFlipHorizontal = 0\nCamFlipVertical = 0\nCamID = 0\nCamParamsFile = assets/tslam/calibration_orange_A_1280_720_000B.yml\nSaveDirMaps = 5\nScaleFactor = 50\nScannedModel = ./scanned_map/map-2024-08-19-15-43-17.ply\n\n[TSlam]\nMapFile = scanned_map/map-2024-08-19-15-43-17.map\nReconstructConfigDefaultFile = assets/tslam/reconstruct_default.ini\nSaveDirMaps = scanned_map/\nVocFile = assets/tslam/orb.fbow\n\n[TTool]\nCachedToolhead = auger_drill_bit_20_235\nConfigFile = deps/TTool/assets/config.yml\nDatasetDir = deps/TTool/assets/toolheads\nTToolRootPath = deps/TTool\n\n[TouchMonitorSpecs]\nLinkMode = HDMI\nName = WaveShare WS170120\nResolution = 1024x600\n\n[Utils]\nUtilsPath = ./temp\n</code></pre>"},{"location":"hardware/sensors/#components-list","title":"Components list","text":"<p>Parts</p> <p></p> <p>Here's the list of the parts you will need to obtain or realize:</p> <ul> <li> \u00a0\u00a0 RunCam 2 4K</li> <li> \u00a0\u00a0 USB 2.0 cable (length: 1.5m)</li> <li> \u00a0\u00a0 Articulated camera arm \u00bc\" screw</li> <li> \u00a0\u00a0 Metal locline (\u00bc\" - passage 6 mm)</li> <li> \u00a0\u00a0 Locline-\u00bc\" adapter</li> </ul> <ol> <li> <p>the camera is discontinued since 2024.\u00a0\u21a9</p> </li> </ol>"},{"location":"hardware/stickers/","title":"Stickers","text":"<p>The last thing you need is a set of STags. These are the markers that help the camera understand its position and orientation to the timber beam. You can find them as 450 stripes for a total of 21149 tags are available in batches of 50 stripes with an A0 format, ready to print (better as stickers) and can be downloaded here. They are made to be print as stickers, but if you want to generate your own you can find a script here.</p>"},{"location":"hardware/stickers/#components-list","title":"Components list","text":"<p>Parts</p> <p>Here's the list of the parts you will need to obtain or realize:</p> <ul> <li> \u00a0\u00a0 xN Printed tags stripes</li> </ul>"},{"location":"hardware/woodworking-tools/","title":"Woodworking tools","text":"<p>AC is designed to seamlessly integrate with virtually any woodworking tool, new or old, provided you can:</p> <ul> <li> securely mount the AC camera and display unit onto the tool itself</li> <li> having a 3D model digital twin of the tool head you want to use</li> </ul> <p>For the first one we provide a set of 3D printable mounts that you can download and print.</p> <p>For the second one, you can find a list of the available toolheads here that we already have in our database.</p> <p>If you want to add your own 3d-printable mount or tool head model and share it with the community, follow the instructions in the section contributing.</p>"},{"location":"hardware/woodworking-tools/#available-toolheads","title":"Available Toolheads","text":"<p>The following is a list of the available toolheads that are already integrated into the AC system. You will need to use or acquire the corresponding physical toolhead to use the AC system. Each toolhead is digitize and integrated to the dataset, the digital model is necessary to allow AC to detect the 3D position of the toolhead from the sensor stream. The Zenodo repository containing the dataset is here.</p> <p>Toolhead integration</p> <p>If you want to know more about the details of the integration and how toolhead are managed in the AC system, you can read the developer guide.</p> <p>Want to add a new toolhead?</p> <p>If you want to add your own toolhead to the AC system, follow the instructions in the section contributing.</p> <p></p> Toolhead type size (MB) Download brad_point_drill_bit_20_150 <code>drill</code> 5.34 saber_saw_blade_makita_t_300 <code>saber saw</code> 0.07 self_feeding_bit_40_90 <code>drill</code> 1.95 self_feeding_bit_50_90 <code>drill</code> 1.78 spade_drill_bit_25_150 <code>drill</code> 0.82 twist_drill_bit_32_165 <code>drill</code> 4.16 auger_drill_bit_34_235 <code>drill</code> 0.10 chain_saw_blade_f_250 <code>chain saw</code> 0.04 circular_saw_blade_festool_260 <code>circular saw</code> 0.04 circular_saw_blade_makita_190 <code>circular saw</code> 0.02 chain_swordsaw_blade_200 <code>chain saw</code> 0.07 circular_saw_blade_makita_190B <code>circular saw</code> 0.03 auger_drill_bit_20_235 <code>drill</code> 2.42 circular_saw_blade_mafel_237 <code>circular saw</code> 0.09 circular_saw_blade_makita_355 <code>circular saw</code> 0.06 circular_saw_blade_mafel_225 <code>circular saw</code> 0.14"},{"location":"hardware/woodworking-tools/#available-3d-mounts","title":"Available 3D mounts","text":"<p>Each mount is designed with a flexible integration mechanism, allowing for the attachment of various clipping solutions. Our reference implementation utilizes magnetic clips and a loc-line arm to ensure secure, tool-safe mounting of the sensors and interfaces and easy removal. However, the design files allow users to incorporate their preferred fastening methods\u2014ranging from simple clips to more complex spring-loaded solutions\u2014enabling adaptation to a broad range of tool geometries.</p> <ul> <li>Identify the corresponding mount file that matches your tool brand and model.</li> <li>Download and 3D print the STL file(s).</li> <li>Integrate your desired clipping mechanism.</li> <li>Attach the completed mount to your woodworking tool.</li> </ul> <p>The Zenodo repository containing the dataset is here.</p> <p>Want to add a new mount?</p> <p>If you want to add your own toolhead to the AC system, follow the instructions in the section contributing.</p> Model name Mount parts Brand type size (MB) Download ks120reb a festool <code>miter saw</code> 0.73 ks120reb b festool <code>miter saw</code> 0.93 ksp85 a mafel <code>circular saw</code> 1.16 ksp85 b mafel <code>circular saw</code> 1.32 k85e a mafel <code>circular saw</code> 0.23 k85e b mafel <code>circular saw</code> 0.85 jr3070ct 0a makita <code>saber saw</code> 0.54 jr3070ct 0b makita <code>saber saw</code> 0.47 jr3070ct 1a makita <code>saber saw</code> 0.57 jr3070ct 1b makita <code>saber saw</code> 0.71 5143r a makita <code>circular saw</code> 1.17 dp400 a makita <code>drill</code> 0.20 hs7601j a makita <code>circular saw</code> 0.23 hs7601j b makita <code>circular saw</code> 0.20 dhp484 a makita <code>drill</code> 3.91 msa70cb a stihl <code>chain saw</code> 0.58 msa70cb b stihl <code>chain saw</code> 0.38"},{"location":"hardware/woodworking-tools/#components-list","title":"Components list","text":"<p>Parts</p> <p></p> <p>Here's the list of the parts you will need to obtain or realize for this section:</p> <ul> <li> \u00a0\u00a0 electric woodworking tool</li> <li> \u00a0\u00a0 (C) 3D-printed mount compatible with the tool</li> <li> \u00a0\u00a0 (D) digitized toolhead</li> <li> \u00a0\u00a0 (B) clipping mechanism to interchange the camera and interface quickly from tool to tool</li> <li> \u00a0\u00a0 (A) metal magnet-clipping plate ( <code>assets/hardware_parts/mount/metal_magnet_slot.pdf</code>)</li> <li> lock-line adaptor for magnet-clipping plate</li> </ul>"},{"location":"publications/","title":"Publications","text":"<p>This is a list of scientific publications related to the Augmented Carpentry research thesis. During the developing of the research project we publish and contenarize each component independently and share it with the community together with as agnostic code as possible. Here you can find the list of publications and the related code repositories.</p>"},{"location":"publications/#tslam-a-tag-based-object-centered-monocular-navigation-system-for-augmented-manual-woodworking","title":"TSlam: a tag-based object-centered monocular navigation system for augmented manual woodworking","text":"<p>Andrea Settimi , Hong-Bin Yang , Julien Gamerro , Yves Weinand </p> <p> Source Code</p> <p>Content: If you are interested in the self-localization system and the tag system we developer for Augmented Carpentry, have a look at this paper.</p> <p>Abstract: TimberSLAM (TSLAM) is an object-centered, tag-based visual self-localization and mapping (SLAM) system for monocular RGB cameras. It was specifically developed to support a robust and augmented reality pipeline for close-range, noisy, and cluttered fabrication sequences that involve woodworking operations, such as cutting, drilling, sawing, and screwing with multiple tools and end-effectors. By leveraging and combining multiple open-source projects, we obtain a functional pipeline that can map, three-dimensionally reconstruct, and finally provide a robust camera pose stream during fabrication time to overlay an execution model with its digital-twin model, even under close-range views, dynamic environments, and heavy scene obstructions. To benchmark the proposed navigation system under real fabrication scenarios, we produce a data set of 1344 closeups of different woodworking operations with multiple tools, tool heads, and varying parameters (e.g., tag layout and density). The evaluation campaign indicates that TSLAM is satisfyingly capable of detecting the camera\u2019s millimeter position and subangular rotation during the majority of fabrication sequences. The reconstruction algorithm\u2019s accuracy is also gauged and yields results that demonstrate its capacity to acquire shapes of timber beams with up to two preexisting joints. We have made the entire source code, evaluation pipeline, and data set open to the public for reproducibility and the benefit of the community.</p> <p>     If your browser does not support PDFs. Please download the PDF to view it: Download PDF. </p>"},{"location":"publications/#ttool-a-supervised-artificial-intelligence-assisted-visual-pose-detector-for-tool-heads-in-augmented-reality-woodworking","title":"TTool: A Supervised Artificial Intelligence-Assisted Visual Pose Detector for Tool Heads in Augmented Reality Woodworking","text":"<p>Andrea Settimi , Naravich Chutisilp , Florian Aymanns , Julien Gamerro , Yves Weinand </p> <p> Source Code</p> <p>Content: This paper and publication presents the object-tracking system we developed for tracking tool heads in Augmented Carpentry.</p> <p>Abstract: We present TimberTool (TTool v2.1.1), a software designed for woodworking tasks assisted by augmented reality (AR), emphasizing its essential function of the real-time localization of a tool head\u2019s poses within camera frames. The localization process, a fundamental aspect of AR-assisted tool operations, enables informed integration with contextual tracking, facilitating the computation of meaningful feedback for guiding users during tasks on the target object. In the context of timber construction, where object pose tracking has been predominantly explored in additive processes, TTool addresses a noticeable gap by focusing on subtractive tasks with manual tools. The proposed methodology utilizes a machine learning (ML) classifier to detect tool heads, offering users the capability to input a global pose and utilizing an automatic pose refiner for final pose detection and model alignment. Notably, TTool boasts adaptability through a customizable platform tailored to specific tool sets, and its open accessibility encourages widespread utilization. To assess the effectiveness of TTool in AR-assisted woodworking, we conducted a preliminary experimental campaign using a set of tools commonly employed in timber carpentry. The findings suggest that TTool can effectively contribute to AR-assisted woodworking tasks by detecting the six-degrees-of-freedom (6DoF) pose of tool heads to a satisfactory level, with a millimetric positional error of 3.9 \u00b1 1 mm with possible large room for improvement and 1.19 \u00b1 0.6\u00b0 for what concerns the angular accuracy.</p> <p></p>"},{"location":"publications/#augmented-reality-assisted-timber-drilling-with-smart-retrofitted-tools","title":"Augmented-reality-assisted timber drilling with smart retrofitted tools","text":"<p>Andrea Settimi , Julien Gamerro , Yves Weinand </p> <p>Content: In this publication you will find the very first faisability study that lead to the beggining of Augmented Carpentry. Thee pilot study consisted in exploring augmented-reality-assisted fabrication for one of the most simple operations in timber carpentry: drilling.</p> <p>Abstract: An ordinary electric drill was integrated into a context-aware augmented reality (AR) framework to assist in timber-drilling tasks. This study is a preliminary evaluation to detail technical challenges, potential bottlenecks, and accuracy of the proposed object- and tool-aware AR-assisted fabrication systems. In the designed workflow, computer vision tools and sensors are used to implement an inside-out tracking technique for retrofitted drills based on a reverse engineering approach. The approach allows workers to perform complex drilling angle operations according to computer-processed feedback instead of drawing, marking, or jigs. First, the developed methodology was presented, and its various devices and functioning phases were detailed. Second, this first proof of concept was evaluated by experimentally scanning produced drillings and comparing the discrepancies with their respective three-dimensional execution models. This study outlined improvements in the proposed tool-aware fabrication process and clarified the potential role of augmented carpentry in the digital fabrication landscape.</p> <p>     If your browser does not support PDFs. Please download the PDF to view it: Download PDF. </p>"},{"location":"team/research_team/","title":"Research team","text":""},{"location":"team/research_team/#thesis-group","title":"Thesis Group","text":"<p>Augmented Carpentry is the outcome of a thesis from the Laboratory of Timber Constructions (IBOIS) at the \u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL) from 2021 to 2025. The software and the documentation are currently maintained by Andrea Settimi.</p> <p>For questions send an email either here or here.</p> Role Name Contact Affiliation PhD Researcher Andrea Settimi  andrea.settimi@epfl.ch IBOIS, EPFL PhD Co-director Dr. Julien Gamerro  julien.gamerro@epfl.ch Indipendent Researcher PhD &amp; Laboratory Director Prof. Yves Weinand  yves.weinand@epfl.ch IBOIS, EPFL"},{"location":"team/research_team/#contributors","title":"Contributors","text":"<p>Augmented Carpentry was also possible thanks to the numerous contributions across multiple disciplines of many talented programmers, software engineers, imaging specialist, roboticists, construction assistants and techniciens:</p> Role Name Contact Affiliation Software developer Hong-Bin Yang  hongbin.yang@epfl.ch IBOIS, EPFL Software developer Naravich Chutisilp  namkang_chutisilp@hotmail.com IBOIS, EPFL Software developer Nazgul Zholmagambetova nazgul.zh333@gmail.com IBOIS, EPFL Image Analyst Dr. Florian Aymanns  florian.aymanns@epfl.ch Center For Imaging, EPFL Image Scientist Dr. Edward And\u00f2  edward.ando@epfl.ch Center For Imaging, EPFL Software engineer Nicolas Richard nicolas.richard@epfl.ch SCITAS, EPFL Construction Assistant Arthur Billotte arthur.billotte@epfl.ch IBOIS, EPFL Roboticist Gregory Spirlet gregory.spirlet@epfl.ch GIS, EPFL Carpenter Technicien Fran\u00e7ois Perrin francois.perrin@epfl.ch GIS, EPFL Technicien Krkic Armin armin.krkic@epfl.ch GIS, EPFL"},{"location":"acdoxygen/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace AIAC <ul> <li>class ACInfoModel </li> <li>class ACInfoToolhead the class holding the information of the toolhead (GOs, metadata, etc) </li> <li>class ACInfoToolheadManager </li> <li>class AppCloseEvent </li> <li>class Application </li> <li>struct ApplicationSpecification </li> <li>class Camera </li> <li>class CameraCalibrationLoadedEvent </li> <li>class CameraCalibrator </li> <li>class ChainSawCutPlaneVisualizer </li> <li>struct ChainSawData </li> <li>struct Character </li> <li>class CircularSawCutBladeThicknessVisualizer This is an inherited class to show the thickness of the blade on circular saws. </li> <li>class CircularSawCutPlaneVisualizer </li> <li>struct CircularSawData </li> <li>class Config </li> <li>class CutBladeThicknessVisualizer The idea behind the CutBladeThicknessVisualizer is to give a visual feedback on the thickness of the blade. We do this by intersecting the two neighbours faces of the current highlighted face. </li> <li>class CutChainSawAngleFeedVisualizer </li> <li>class CutChainSawDepthFeedVisualizer </li> <li>class CutChainSawFeedVisualizer </li> <li>class CutChainSawFeedback </li> <li>class CutCircularOrientationVisualizer This visualizer ggdb ives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. </li> <li>class CutCircularSawDepthVisualizer Visualizer for showing the depth of the cut. </li> <li>class CutCircularSawFeedback </li> <li>class CutCircularSawPositionStartVisualizer This visualizer gives guidance on the start position of the lateral cuts for the circular saw. </li> <li>class CutOrientationVisualizer This visualizer gives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. </li> <li>class CutPlaneVisualizer </li> <li>struct CylinderPole </li> <li>class DLoader </li> <li>struct DrillBitData </li> <li>class Event </li> <li>class EventBus </li> <li>struct EventCompare </li> <li>struct EventPolicy </li> <li>class FabFeedback </li> <li>class FeedbackVisualizer </li> <li>class GLLineObject </li> <li>class GLMeshObject </li> <li>class GLObject </li> <li>class GLPointObject </li> <li>class GOCircle </li> <li>struct GOColor </li> <li>class GOCylinder </li> <li>class GOLine </li> <li>class GOMesh </li> <li>class GOPoint </li> <li>class GOPolyline </li> <li>class GOPrimitive </li> <li>class GORegistry </li> <li>class GOText </li> <li>struct GOTextSize </li> <li>class GOTriangle </li> <li>struct GOWeight </li> <li>class HoleFeedback The UI widget for providing feedback on orientation Feeds (in chronological order): </li> <li>class HoleFeedbackPosition The UI widget for providing feedback on position. </li> <li>class HoleFeedbackRotation The UI widget for providing feedback on rotation. </li> <li>class HoleFeedbackText The general visualizer for the info displayed as text. </li> <li>struct ImTexture Structure representing an ImGui texture. </li> <li>class Image Class representing the main iamge object for AC. </li> <li>class Layer </li> <li>class LayerCamera </li> <li>class LayerCameraCalib </li> <li>class LayerFeedback </li> <li>class LayerLogRecorder </li> <li>class LayerModel </li> <li>class LayerSlam </li> <li>class LayerToolhead </li> <li>class LayerUI </li> <li>class LayerUtils </li> <li>class Log </li> <li>class PaneUI </li> <li>struct Position </li> <li>class Renderer </li> <li>class SLAMCombineMapEvent </li> <li>class SLAMMapLoadedEvent </li> <li>class SLAMStartMappingEvent </li> <li>class SLAMStopMappingEvent </li> <li>class SLAMVocabularyLoadedEvent </li> <li>struct SaberSawData </li> <li>class ScannedModel </li> <li>class TextRenderer </li> <li>class TimberInfo <ul> <li>class Component </li> <li>class Cut <ul> <li>class Edge </li> <li>class Face </li> </ul> </li> <li>class Hole </li> </ul> </li> <li>class ToolHeadData Class holding and parse and create data from the .acit file of the toolhead. </li> <li>class TouchMonitor </li> <li>namespace Utils <ul> <li>class HoleToolheadAxisExporter </li> <li>class Screenshot </li> <li>class VideoRecorder </li> </ul> </li> <li>class Viewport </li> <li>class Window </li> <li>struct WindowProps </li> </ul> </li> <li>struct CombineMapParams </li> <li>struct MappingParams </li> <li>struct ReconstructParams </li> <li>struct WindowData </li> <li>class CircularBuffer </li> <li>struct BufferIterator </li> <li>struct IGFD_Selection </li> <li>struct IGFD_Selection_Pair </li> <li>namespace glob <ul> <li>class glob </li> <li>class glob_impl </li> </ul> </li> <li>namespace glob </li> <li>namespace inih <ul> <li>class INIReader </li> <li>class INIWriter </li> </ul> </li> </ul>"},{"location":"acdoxygen/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>file ACApp.cpp </li> <li>file AIAC.h </li> <li>file aiacpch.cpp </li> <li>file aiacpch.h </li> <li>dir AIAC <ul> <li>file ACInfoModel.cpp </li> <li>file ACInfoModel.h </li> <li>file ACInfoToolhead.cpp </li> <li>file ACInfoToolhead.h </li> <li>file ACInfoToolheadManager.cpp </li> <li>file ACInfoToolheadManager.h </li> <li>file Application.cpp </li> <li>file Application.h </li> <li>file Assert.h </li> <li>file Base.h </li> <li>file Camera.cpp </li> <li>file Camera.h </li> <li>file CameraCalibrator.cpp </li> <li>file CameraCalibrator.h </li> <li>file Config.cpp </li> <li>file Config.h </li> <li>file DLoader.cpp </li> <li>file DLoader.h </li> <li>file GeometryUtils.cpp </li> <li>file GeometryUtils.h </li> <li>file GlHeader.h </li> <li>file Image.cpp </li> <li>file Image.h </li> <li>file Layer.h </li> <li>file LayerCamera.cpp </li> <li>file LayerCamera.h </li> <li>file LayerCameraCalib.cpp </li> <li>file LayerCameraCalib.h </li> <li>file LayerFeedback.cpp </li> <li>file LayerFeedback.h </li> <li>file LayerLogRecorder.cpp </li> <li>file LayerLogRecorder.h </li> <li>file LayerModel.cpp </li> <li>file LayerModel.h </li> <li>file LayerSlam.cpp </li> <li>file LayerSlam.h </li> <li>file LayerToolhead.cpp </li> <li>file LayerToolhead.h </li> <li>file LayerUI.cpp </li> <li>file LayerUI.h </li> <li>file LayerUtils.cpp </li> <li>file LayerUtils.h </li> <li>file Log.cpp </li> <li>file Log.h </li> <li>file ScannedModel.cpp </li> <li>file ScannedModel.h </li> <li>file TouchMonitor.cpp </li> <li>file TouchMonitor.h </li> <li>file Window.cpp </li> <li>file Window.h </li> <li>dir EventSys <ul> <li>file ApplicationEvent.cpp </li> <li>file ApplicationEvent.h </li> <li>file CameraEvent.cpp </li> <li>file CameraEvent.h </li> <li>file Event.h </li> <li>file EventBus.h </li> <li>file SLAMEvent.cpp </li> <li>file SLAMEvent.h </li> </ul> </li> <li>dir Feedback <ul> <li>file CutBladeThicknessVisualizer.cpp </li> <li>file CutBladeThicknessVisualizer.h </li> <li>file CutChainSawFeedback.cpp </li> <li>file CutChainSawFeedback.h </li> <li>file CutCircularSawFeedback.cpp </li> <li>file CutCircularSawFeedback.h </li> <li>file CutPlaneVisualizer.cpp </li> <li>file CutPlaneVisualizer.h </li> <li>file FabFeedback.h </li> <li>file FeedbackVisualizer.cpp </li> <li>file FeedbackVisualizer.h </li> <li>file HoleFeedback.cpp </li> <li>file HoleFeedback.h </li> </ul> </li> <li>dir GOSys <ul> <li>file GO.h </li> <li>file GOPrimitive.cpp </li> <li>file GOPrimitive.h </li> <li>file GORegistry.h </li> </ul> </li> <li>dir Render <ul> <li>file GLObject.cpp </li> <li>file GLObject.h </li> <li>file GlUtils.cpp </li> <li>file GlUtils.h </li> <li>file RenderAPI.cpp </li> <li>file RenderAPI.h </li> <li>file Renderer.cpp </li> <li>file Renderer.h </li> <li>file Shader.cpp </li> <li>file Shader.hpp </li> <li>file TextRenderer.cpp </li> <li>file TextRenderer.h </li> <li>file Viewport.cpp </li> <li>file Viewport.h </li> </ul> </li> <li>dir UI <ul> <li>file ClrPalette.h </li> <li>file CustomLogos.h </li> <li>file ImGuiFileDialog.cpp </li> <li>file ImGuiFileDialog.h </li> <li>file ImGuiFileDialogConfig.h </li> </ul> </li> </ul> </li> <li>dir utils <ul> <li>file CircularBuffer.h </li> <li>file GeometryUtils.h </li> <li>file HoleToolheadAxisExporter.cpp </li> <li>file HoleToolheadAxisExporter.h </li> <li>file Ini.h </li> <li>file MatrixUtils.h </li> <li>file Screenshot.cpp </li> <li>file Screenshot.h </li> <li>file SystemUtils.h </li> <li>file VideoRecorder.cpp </li> <li>file VideoRecorder.h </li> <li>file glob.cpp </li> <li>file glob.h </li> <li>file utils.h </li> </ul> </li> </ul> </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/","title":"Namespace AIAC","text":"<p>Namespace List &gt; AIAC</p>"},{"location":"acdoxygen/namespaceAIAC/#namespaces","title":"Namespaces","text":"Type Name namespace Utils"},{"location":"acdoxygen/namespaceAIAC/#classes","title":"Classes","text":"Type Name class ACInfoModel class ACInfoToolhead the class holding the information of the toolhead (GOs, metadata, etc) class ACInfoToolheadManager class AppCloseEvent class Application struct ApplicationSpecification class Camera class CameraCalibrationLoadedEvent class CameraCalibrator class ChainSawCutPlaneVisualizer struct ChainSawData struct Character class CircularSawCutBladeThicknessVisualizer This is an inherited class to show the thickness of the blade on circular saws. class CircularSawCutPlaneVisualizer struct CircularSawData class Config class CutBladeThicknessVisualizer The idea behind the CutBladeThicknessVisualizer is to give a visual feedback on the thickness of the blade. We do this by intersecting the two neighbours faces of the current highlighted face. class CutChainSawAngleFeedVisualizer class CutChainSawDepthFeedVisualizer class CutChainSawFeedVisualizer class CutChainSawFeedback class CutCircularOrientationVisualizer This visualizer ggdb ives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. class CutCircularSawDepthVisualizer Visualizer for showing the depth of the cut. class CutCircularSawFeedback class CutCircularSawPositionStartVisualizer This visualizer gives guidance on the start position of the lateral cuts for the circular saw. class CutOrientationVisualizer This visualizer gives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. class CutPlaneVisualizer struct CylinderPole class DLoader struct DrillBitData class Event class EventBus struct EventCompare struct EventPolicy class FabFeedback class FeedbackVisualizer class GLLineObject class GLMeshObject class GLObject class GLPointObject class GOCircle struct GOColor class GOCylinder class GOLine class GOMesh class GOPoint class GOPolyline class GOPrimitive class GORegistry class GOText struct GOTextSize class GOTriangle struct GOWeight class HoleFeedback The UI widget for providing feedback on orientation Feeds (in chronological order): class HoleFeedbackPosition The UI widget for providing feedback on position. class HoleFeedbackRotation The UI widget for providing feedback on rotation. class HoleFeedbackText The general visualizer for the info displayed as text. struct ImTexture Structure representing an ImGui texture. class Image Class representing the main iamge object for AC. class Layer class LayerCamera class LayerCameraCalib class LayerFeedback class LayerLogRecorder class LayerModel class LayerSlam class LayerToolhead class LayerUI class LayerUtils class Log class PaneUI struct Position class Renderer class SLAMCombineMapEvent class SLAMMapLoadedEvent class SLAMStartMappingEvent class SLAMStopMappingEvent class SLAMVocabularyLoadedEvent struct SaberSawData class ScannedModel class TextRenderer class TimberInfo class ToolHeadData Class holding and parse and create data from the .acit file of the toolhead. class TouchMonitor class Viewport class Window struct WindowProps"},{"location":"acdoxygen/namespaceAIAC/#public-types","title":"Public Types","text":"Type Name enum ACIMState enum ACToolHeadType All the possible types of the toolheads in AC. typedef eventpp::EventQueue&lt; EventType, void(const EventPointer &amp;), EventPolicy &gt; EQ enum EventCategory typedef std::shared_ptr&lt; Event &gt; EventPointer enum EventType enum GLObjectType enum GOTypeFlags enum ImageFormat Enum representing different image formats. typedef std::shared_ptr&lt; T &gt; Ref typedef std::unique_ptr&lt; T &gt; Scope"},{"location":"acdoxygen/namespaceAIAC/#public-attributes","title":"Public Attributes","text":"Type Name GLuint VertexArrayID"},{"location":"acdoxygen/namespaceAIAC/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::map&lt; ACIMState, glm::vec4 &gt; CUT_EDGE_COLOR   = <code>/* multi line expression */</code> std::map&lt; ACIMState, glm::vec4 &gt; CUT_FACE_COLOR   = <code>/* multi line expression */</code> std::map&lt; ACIMState, glm::vec4 &gt; HOLE_AXIS_COLOR   = <code>/* multi line expression */</code> std::map&lt; ACIMState, glm::vec4 &gt; HOLE_CYLINDER_COLOR   = <code>/* multi line expression */</code> const glm::vec4 OGL_BLACK   = <code>glm::vec4(0, 0, 0, 1)</code> const glm::vec4 OGL_BLUE   = <code>glm::vec4(0, 0, 1, 1)</code> const glm::vec4 OGL_CYAN   = <code>glm::vec4(0, 1, 1, 1)</code> const glm::vec4 OGL_GREEN   = <code>glm::vec4(0, 1, 0, 1)</code> const glm::vec4 OGL_MAGENTA   = <code>glm::vec4(1, 0, 1, 1)</code> const glm::vec4 OGL_RED   = <code>glm::vec4(1, 0, 0, 1)</code> const glm::vec4 OGL_WHITE   = <code>glm::vec4(1, 1, 1, 1)</code> const glm::vec4 OGL_YELLOW   = <code>glm::vec4(1, 1, 0, 1)</code> const float WEIGHT_TO_CYLINDER_RADIUS_RATE   = <code>1.0f / 64.0f</code> struct AIAC::Position s_CursorPos uint8_t s_GLFWWindowCount   = <code>0</code> bool s_IsMouseButtonPressed   = <code>false</code>"},{"location":"acdoxygen/namespaceAIAC/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; GLubyte &gt; CaptureFramePixels (const ApplicationSpecification &amp; appSpec)  std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; CreateCircle (glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum)  std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; CreateCylinder (const glm::vec3 &amp; baseCenter, const glm::vec3 &amp; topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum)  std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; CreatePolyline (std::vector&lt; glm::vec3 &gt; vertices, bool isClosed, glm::vec4 color, float lineWidth)  constexpr Ref&lt; T &gt; CreateRef (Args &amp;&amp;... args)  constexpr Scope&lt; T &gt; CreateScope (Args &amp;&amp;... args)  void CvtCvMat2GlTextureObj (cv::Mat &amp; cvMat, GLuint &amp; glTextureObj, GLint glInternalFormat=GL_RGB) Convert OpenCV matrix to OpenGL texture object. void CvtCvMat2ImTexture (cv::Mat &amp; cvMat, ImTexture &amp; imTexture, GLuint &amp; glTextureObj, GLint glInternalFormat) Convert cv::Mat to ImTexture , a glTextureObj is required as a texture holder. void CvtGlTextureObj2ImTexture (GLuint glTextureID, ImTexture &amp; imTexture, ImVec2 size=ImVec2(0, 0)) Convert OpenGL texture object to ImGui texture. void DrawAllGOs (glm::mat4 projection=glm::mat4(1.0f), float textScale=1.0f) Draw all the GOs present in the GORegistry . void DrawCircle (glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum=24) Draw a single circle. void DrawCircle (const GOCircle &amp; goCircle)  void DrawCircles (const std::vector&lt; std::shared_ptr&lt; GOCircle &gt; &gt; &amp; goCircles)  void DrawCylinder (const glm::vec3 &amp; baseCenter, const glm::vec3 &amp; topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum=24) Draw a Cylinder, this is also used for drawing lines with heavy weight (&gt;1.0f). void DrawCylinder (const GOCylinder &amp; goCylinder)  void DrawCylinders (const std::vector&lt; std::shared_ptr&lt; GOCylinder &gt; &gt; &amp; goCylinders)  void DrawGO (const shared_ptr&lt; GOPrimitive &gt; &amp; goPrimitive) Draw a GOPrimitive . (This function neglects the \"isVisible\" attribute of the object and will draw it anyway) void DrawLine (const glm::vec3 &amp; p1, const glm::vec3 &amp; p2, float weight=GOWeight::Default, const glm::vec4 &amp; color=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f)) Draw a line on two glm::vec3. void DrawLine (const GOLine &amp; goLine)  void DrawLines (const vector&lt; glm::vec3 &gt; &amp; vertices, float weight, const glm::vec4 &amp; color) Draw multiple lines. void DrawLines (const std::vector&lt; std::shared_ptr&lt; GOLine &gt; &gt; &amp; goLines)  void DrawMesh (const GOMesh &amp; goMesh)  void DrawMeshes (const std::vector&lt; std::shared_ptr&lt; GOMesh &gt; &gt; &amp; goMeshes)  void DrawPoint (const GOPoint &amp; goPoint) Draw a GOPoint . void DrawPoints (const std::vector&lt; std::shared_ptr&lt; GOPoint &gt; &gt; &amp; goPoints)  void DrawPolyline (const GOPolyline &amp; goPolyline)  void DrawPolylines (const std::vector&lt; std::shared_ptr&lt; GOPolyline &gt; &gt; &amp; goPolylines)  void DrawSlamMap (const std::shared_ptr&lt; tslam::Map &gt; &amp; map, const glm::vec4 &amp; color, float pointSize=1) Draw TSlam map. void DrawSlamMap (const shared_ptr&lt; tslam::Map &gt; &amp; map, const glm::vec4 &amp; color, float pointSize) Render Slam map on the current frame. void DrawText (const GOText &amp; goText, float scale, const glm::mat4 &amp; projection)  void DrawTexts (const std::vector&lt; std::shared_ptr&lt; GOText &gt; &gt; &amp; goTexts, float scale, const glm::mat4 &amp; projection)  void DrawTexts (std::vector&lt; GOText &gt; goTexts, float scale=1.0f, const glm::mat4 &amp; projection=glm::mat4(1.0f))  void DrawTriangle (const GOTriangle &amp; goTriangle)  void DrawTriangles (const std::vector&lt; std::shared_ptr&lt; GOTriangle &gt; &gt; &amp; goTriangles)  glm::mat4x4 GetRigidTransformationMatrix (std::vector&lt; glm::vec3 &gt; srcPts, std::vector&lt; glm::vec3 &gt; dstPts) Get the rigid transformation matrix from two correlated set of 3D points @praam srcPts The source points. glm::mat3x3 GetRotationMatrix (glm::vec3 axis, float theta) Get the rotation matrix associated with counterclockwise rotation about the given axis by theta radians. int GetSectorNum (float radius)  glm::vec3 GetTransformed (glm::mat4 transformMat, float x, float y, float z) Combine 3 points into a glm::vec3 and transform it based on the given transformation matrix. glm::mat4x4 GetTranslationMatrix (glm::vec3 translationVector) Get the translation matrix associated with the given translation vector. bool StringToBool (std::string str) Convert a string to bool. std::set&lt; std::string &gt; StringToSet (std::string str) Convert a string separated by space to a set of tokens. ACIMState StringToState (std::string m_State) Convert string m_State to ACIMState. std::vector&lt; std::string &gt; StringToTokens (std::string str) Convert a string separated by space to a list of string. glm::vec3 StringToVec3 (std::string str) Convert a string separated by space to glm::vec3. std::string Vec3ToString (glm::vec3 vec3) Convert a vec3 to String. void glDrawLines3d (const std::vector&lt; glm::vec3 &gt; &amp; edges, const std::vector&lt; glm::vec4 &gt; &amp; colors) Draw multiple points. void glDrawLines3d (const std::vector&lt; glm::vec3 &gt; &amp; edges, const glm::vec4 &amp; color) Draw multiple points. void glDrawPoints3d (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors, GLfloat pointSize=1.0f) Draw multiple points. void glDrawPoints3d (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const glm::vec4 &amp; color, GLfloat pointSize=1.0f) Draw multiple points. void glDrawTriangles3d (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; uint32_t &gt; &amp; indices, const std::vector&lt; glm::vec4 &gt; &amp; colors) Draw multiple Triangles. void glDrawTriangles3d (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; uint32_t &gt; &amp; indices, const glm::vec4 &amp; colors) Draw multiple Triangles. void operator&gt;&gt; (cv::VideoCapture cap, AIAC::Image &amp; img)"},{"location":"acdoxygen/namespaceAIAC/#public-static-functions","title":"Public Static Functions","text":"Type Name void GLFWErrorCallback (int error, const char * description)  void GLFWMonitorCallback (GLFWmonitor * monitor, int event)  bool IsGlfwInitialized ()"},{"location":"acdoxygen/namespaceAIAC/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/namespaceAIAC/#enum-acimstate","title":"enum ACIMState","text":"<pre><code>enum AIAC::ACIMState {\n    NOT_DONE,\n    CURRENT,\n    DONE\n};\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#enum-actoolheadtype","title":"enum ACToolHeadType","text":"<p>All the possible types of the toolheads in AC. <pre><code>enum AIAC::ACToolHeadType {\n    DRILLBIT,\n    CIRCULARSAW,\n    SABERSAW,\n    CHAINSAW\n};\n</code></pre></p>"},{"location":"acdoxygen/namespaceAIAC/#holding-the-data-of-the-toolheads-from-acit-and-the-corresponding-gos","title":"holding the data of the toolheads from .acit and the corresponding GOs","text":""},{"location":"acdoxygen/namespaceAIAC/#typedef-eq","title":"typedef EQ","text":"<pre><code>using AIAC::EQ = typedef eventpp::EventQueue&lt;EventType, void(const EventPointer&amp;), EventPolicy&gt;;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#enum-eventcategory","title":"enum EventCategory","text":"<pre><code>enum AIAC::EventCategory {\n    None = 0,\n    EventCategoryApplication =              BIT(0),\n    EventCategorySLAM =                     BIT(1),\n    EventCategoryCamera =                   BIT(2)\n};\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#typedef-eventpointer","title":"typedef EventPointer","text":"<pre><code>using AIAC::EventPointer = typedef std::shared_ptr&lt;Event&gt;;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#enum-eventtype","title":"enum EventType","text":"<pre><code>enum AIAC::EventType {\n    None = 0,\n    AppClose,\n    SLAMMapLoaded,\n    SLAMVocabularyLoaded,\n    SLAMStartMapping,\n    SLAMStopMapping,\n    SLAMCombineMapEvent,\n    CameraCalibrationLoaded\n};\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#enum-globjecttype","title":"enum GLObjectType","text":"<pre><code>enum AIAC::GLObjectType {\n    POINTS,\n    LINES,\n    TRIANGLES\n};\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#enum-gotypeflags","title":"enum GOTypeFlags","text":"<pre><code>enum AIAC::GOTypeFlags {\n    _GOPrimitive = 0,\n    _GOPoint,\n    _GOLine,\n    _GOCircle,\n    _GOCylinder,\n    _GOPolyline,\n    _GOTriangle,\n    _GOMesh,\n    _GOText\n};\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#enum-imageformat","title":"enum ImageFormat","text":"<p>Enum representing different image formats. <pre><code>enum AIAC::ImageFormat {\n    None = 0,\n    RGB,\n    RGBA,\n    GRAYSCALE\n};\n</code></pre></p>"},{"location":"acdoxygen/namespaceAIAC/#typedef-ref","title":"typedef Ref","text":"<pre><code>using AIAC::Ref = typedef std::shared_ptr&lt;T&gt;;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#typedef-scope","title":"typedef Scope","text":"<pre><code>using AIAC::Scope = typedef std::unique_ptr&lt;T&gt;;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/namespaceAIAC/#variable-vertexarrayid","title":"variable VertexArrayID","text":"<pre><code>GLuint AIAC::VertexArrayID;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"acdoxygen/namespaceAIAC/#variable-cut_edge_color","title":"variable CUT_EDGE_COLOR","text":"<pre><code>std::map&lt;ACIMState, glm::vec4&gt; AIAC::CUT_EDGE_COLOR;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-cut_face_color","title":"variable CUT_FACE_COLOR","text":"<pre><code>std::map&lt;ACIMState, glm::vec4&gt; AIAC::CUT_FACE_COLOR;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-hole_axis_color","title":"variable HOLE_AXIS_COLOR","text":"<pre><code>std::map&lt;ACIMState, glm::vec4&gt; AIAC::HOLE_AXIS_COLOR;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-hole_cylinder_color","title":"variable HOLE_CYLINDER_COLOR","text":"<pre><code>std::map&lt;ACIMState, glm::vec4&gt; AIAC::HOLE_CYLINDER_COLOR;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_black","title":"variable OGL_BLACK","text":"<pre><code>const glm::vec4 AIAC::OGL_BLACK;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_blue","title":"variable OGL_BLUE","text":"<pre><code>const glm::vec4 AIAC::OGL_BLUE;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_cyan","title":"variable OGL_CYAN","text":"<pre><code>const glm::vec4 AIAC::OGL_CYAN;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_green","title":"variable OGL_GREEN","text":"<pre><code>const glm::vec4 AIAC::OGL_GREEN;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_magenta","title":"variable OGL_MAGENTA","text":"<pre><code>const glm::vec4 AIAC::OGL_MAGENTA;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_red","title":"variable OGL_RED","text":"<pre><code>const glm::vec4 AIAC::OGL_RED;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_white","title":"variable OGL_WHITE","text":"<pre><code>const glm::vec4 AIAC::OGL_WHITE;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-ogl_yellow","title":"variable OGL_YELLOW","text":"<pre><code>const glm::vec4 AIAC::OGL_YELLOW;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-weight_to_cylinder_radius_rate","title":"variable WEIGHT_TO_CYLINDER_RADIUS_RATE","text":"<pre><code>const float AIAC::WEIGHT_TO_CYLINDER_RADIUS_RATE;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-s_cursorpos","title":"variable s_CursorPos","text":"<pre><code>struct AIAC::Position AIAC::s_CursorPos;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-s_glfwwindowcount","title":"variable s_GLFWWindowCount","text":"<pre><code>uint8_t AIAC::s_GLFWWindowCount;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#variable-s_ismousebuttonpressed","title":"variable s_IsMouseButtonPressed","text":"<pre><code>bool AIAC::s_IsMouseButtonPressed;\n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/namespaceAIAC/#function-captureframepixels","title":"function CaptureFramePixels","text":"<pre><code>std::vector&lt; GLubyte &gt; AIAC::CaptureFramePixels (\n    const ApplicationSpecification &amp; appSpec\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-createcircle","title":"function CreateCircle","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; AIAC::CreateCircle (\n    glm::vec3 center,\n    glm::vec3 normal,\n    float radius,\n    glm::vec4 color,\n    glm::vec4 edgeColor,\n    float edgeWeight,\n    int sectorNum\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-createcylinder","title":"function CreateCylinder","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; AIAC::CreateCylinder (\n    const glm::vec3 &amp; baseCenter,\n    const glm::vec3 &amp; topCenter,\n    GLfloat radius,\n    glm::vec4 color,\n    glm::vec4 edgeColor,\n    int sectorNum\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-createpolyline","title":"function CreatePolyline","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; AIAC::CreatePolyline (\n    std::vector&lt; glm::vec3 &gt; vertices,\n    bool isClosed,\n    glm::vec4 color,\n    float lineWidth\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-createref","title":"function CreateRef","text":"<pre><code>template&lt;typename T, typename ... Args&gt;\nconstexpr Ref&lt; T &gt; AIAC::CreateRef (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-createscope","title":"function CreateScope","text":"<pre><code>template&lt;typename T, typename ... Args&gt;\nconstexpr Scope&lt; T &gt; AIAC::CreateScope (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-cvtcvmat2gltextureobj","title":"function CvtCvMat2GlTextureObj","text":"<p>Convert OpenCV matrix to OpenGL texture object. <pre><code>void AIAC::CvtCvMat2GlTextureObj (\n    cv::Mat &amp; cvMat,\n    GLuint &amp; glTextureObj,\n    GLint glInternalFormat=GL_RGB\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cvMat</code> OpenCV matrix. </li> <li><code>glTextureObj</code> OpenGL texture object. </li> <li><code>glInternalFormat</code> Internal format of the OpenGL texture. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-cvtcvmat2imtexture","title":"function CvtCvMat2ImTexture","text":"<p>Convert cv::Mat to ImTexture , a glTextureObj is required as a texture holder. <pre><code>void AIAC::CvtCvMat2ImTexture (\n    cv::Mat &amp; cvMat,\n    ImTexture &amp; imTexture,\n    GLuint &amp; glTextureObj,\n    GLint glInternalFormat\n) \n</code></pre></p> <p>Convert OpenCV matrix to ImGui texture.</p> <p>Parameters:</p> <ul> <li><code>imTexture</code> The output ImTexture. </li> <li><code>glTextureObj</code> The texture holder. Remember to delete it with <code>glDeleteTextures(1, &amp;glTextureObj)</code></li> <li><code>cvMat</code> OpenCV matrix. </li> <li><code>imTexture</code> ImGui texture. </li> <li><code>glTextureObj</code> OpenGL texture object. </li> <li><code>glInternalFormat</code> Internal format of the OpenGL texture. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-cvtgltextureobj2imtexture","title":"function CvtGlTextureObj2ImTexture","text":"<p>Convert OpenGL texture object to ImGui texture. <pre><code>void AIAC::CvtGlTextureObj2ImTexture (\n    GLuint glTextureID,\n    ImTexture &amp; imTexture,\n    ImVec2 size=ImVec2(0, 0)\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>glTextureID</code> OpenGL texture ID. </li> <li><code>imTexture</code> ImGui texture. </li> <li><code>size</code> Size of the texture. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawallgos","title":"function DrawAllGOs","text":"<p>Draw all the GOs present in the GORegistry . <pre><code>void AIAC::DrawAllGOs (\n    glm::mat4 projection=glm::mat4(1.0f),\n    float textScale=1.0f\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>projection</code> OpenGL projection matrix. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawcircle","title":"function DrawCircle","text":"<p>Draw a single circle. <pre><code>void AIAC::DrawCircle (\n    glm::vec3 center,\n    glm::vec3 normal,\n    float radius,\n    glm::vec4 color,\n    glm::vec4 edgeColor,\n    float edgeWeight,\n    int sectorNum=24\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>center</code> Center of the circle. </li> <li><code>normal</code> The normal of plane on which the circle lays. </li> <li><code>radius</code> Radius of the circle. </li> <li><code>color</code> RGBA Color of the face. </li> <li><code>edgeColor</code> RGBA Color of the edge. </li> <li><code>edgeWeight</code> Weight of the edge. </li> <li><code>sectorNum</code> Number of sectors, can be derived from GetSectorNum(radius). </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawcircle_1","title":"function DrawCircle","text":"<pre><code>void AIAC::DrawCircle (\n    const GOCircle &amp; goCircle\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawcircles","title":"function DrawCircles","text":"<pre><code>void AIAC::DrawCircles (\n    const std::vector&lt; std::shared_ptr&lt; GOCircle &gt; &gt; &amp; goCircles\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawcylinder","title":"function DrawCylinder","text":"<p>Draw a Cylinder, this is also used for drawing lines with heavy weight (&gt;1.0f). <pre><code>void AIAC::DrawCylinder (\n    const glm::vec3 &amp; baseCenter,\n    const glm::vec3 &amp; topCenter,\n    GLfloat radius,\n    glm::vec4 color,\n    glm::vec4 edgeColor,\n    int sectorNum=24\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>baseCenter</code> Base center (bottom) of the cylinder. </li> <li><code>topCenter</code> Top center (top) of the cylinder. </li> <li><code>radius</code> Radius of the cylinder; For drawing line, radius = weight * WEIGHT_TO_CYLINDER_RADIUS_RATE. </li> <li><code>color</code> Color of the cylinder. </li> <li><code>edgeColor</code> The color of the edges of the caps. </li> <li><code>sectorNum</code> Number of sectors of the cylinder. Can call <code>GetSectorNum(radius)</code> to get the default value. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawcylinder_1","title":"function DrawCylinder","text":"<pre><code>void AIAC::DrawCylinder (\n    const GOCylinder &amp; goCylinder\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawcylinders","title":"function DrawCylinders","text":"<pre><code>void AIAC::DrawCylinders (\n    const std::vector&lt; std::shared_ptr&lt; GOCylinder &gt; &gt; &amp; goCylinders\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawgo","title":"function DrawGO","text":"<p>Draw a GOPrimitive . (This function neglects the \"isVisible\" attribute of the object and will draw it anyway) <pre><code>void AIAC::DrawGO (\n    const shared_ptr&lt; GOPrimitive &gt; &amp; goPrimitive\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>goPrimitive</code> Object to draw. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawline","title":"function DrawLine","text":"<p>Draw a line on two glm::vec3. <pre><code>void AIAC::DrawLine (\n    const glm::vec3 &amp; p1,\n    const glm::vec3 &amp; p2,\n    float weight=GOWeight::Default,\n    const glm::vec4 &amp; color=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f)\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p1</code> First point. </li> <li><code>p2</code> Second point. </li> <li><code>weight</code> Weight of the line. </li> <li><code>color</code> RGBA Color of the line. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawline_1","title":"function DrawLine","text":"<pre><code>void AIAC::DrawLine (\n    const GOLine &amp; goLine\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawlines","title":"function DrawLines","text":"<p>Draw multiple lines. <pre><code>void AIAC::DrawLines (\n    const vector&lt; glm::vec3 &gt; &amp; vertices,\n    float weight,\n    const glm::vec4 &amp; color\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of glm::vec3. If you have line [p1, p2] and [p2, p3], the vector should be construct as [p1, p2, p2, p3, ...] </li> <li><code>weight</code> Weight of the line. </li> <li><code>color</code> RGBA Color of the line. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawlines_1","title":"function DrawLines","text":"<pre><code>void AIAC::DrawLines (\n    const std::vector&lt; std::shared_ptr&lt; GOLine &gt; &gt; &amp; goLines\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawmesh","title":"function DrawMesh","text":"<pre><code>void AIAC::DrawMesh (\n    const GOMesh &amp; goMesh\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawmeshes","title":"function DrawMeshes","text":"<pre><code>void AIAC::DrawMeshes (\n    const std::vector&lt; std::shared_ptr&lt; GOMesh &gt; &gt; &amp; goMeshes\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawpoint","title":"function DrawPoint","text":"<p>Draw a GOPoint . <pre><code>void AIAC::DrawPoint (\n    const GOPoint &amp; goPoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>goPoint</code> The point to draw. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawpoints","title":"function DrawPoints","text":"<pre><code>void AIAC::DrawPoints (\n    const std::vector&lt; std::shared_ptr&lt; GOPoint &gt; &gt; &amp; goPoints\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawpolyline","title":"function DrawPolyline","text":"<pre><code>void AIAC::DrawPolyline (\n    const GOPolyline &amp; goPolyline\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawpolylines","title":"function DrawPolylines","text":"<pre><code>void AIAC::DrawPolylines (\n    const std::vector&lt; std::shared_ptr&lt; GOPolyline &gt; &gt; &amp; goPolylines\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawslammap","title":"function DrawSlamMap","text":"<p>Draw TSlam map. <pre><code>void AIAC::DrawSlamMap (\n    const std::shared_ptr&lt; tslam::Map &gt; &amp; map,\n    const glm::vec4 &amp; color,\n    float pointSize=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>map</code> A TSlam map </li> <li><code>color</code> The color of the point cloud </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawslammap_1","title":"function DrawSlamMap","text":"<p>Render Slam map on the current frame. <pre><code>void AIAC::DrawSlamMap (\n    const shared_ptr&lt; tslam::Map &gt; &amp; map,\n    const glm::vec4 &amp; color,\n    float pointSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>map</code> A tslam map to be rendered. </li> <li><code>color</code> PointCloud's color. </li> <li><code>pointSize</code> PointCloud's size. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-drawtext","title":"function DrawText","text":"<pre><code>void AIAC::DrawText (\n    const GOText &amp; goText,\n    float scale,\n    const glm::mat4 &amp; projection\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawtexts","title":"function DrawTexts","text":"<pre><code>void AIAC::DrawTexts (\n    const std::vector&lt; std::shared_ptr&lt; GOText &gt; &gt; &amp; goTexts,\n    float scale,\n    const glm::mat4 &amp; projection\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawtexts_1","title":"function DrawTexts","text":"<pre><code>void AIAC::DrawTexts (\n    std::vector&lt; GOText &gt; goTexts,\n    float scale=1.0f,\n    const glm::mat4 &amp; projection=glm::mat4(1.0f)\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawtriangle","title":"function DrawTriangle","text":"<pre><code>void AIAC::DrawTriangle (\n    const GOTriangle &amp; goTriangle\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-drawtriangles","title":"function DrawTriangles","text":"<pre><code>void AIAC::DrawTriangles (\n    const std::vector&lt; std::shared_ptr&lt; GOTriangle &gt; &gt; &amp; goTriangles\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-getrigidtransformationmatrix","title":"function GetRigidTransformationMatrix","text":"<p>Get the rigid transformation matrix from two correlated set of 3D points @praam srcPts The source points. <pre><code>glm::mat4x4 AIAC::GetRigidTransformationMatrix (\n    std::vector&lt; glm::vec3 &gt; srcPts,\n    std::vector&lt; glm::vec3 &gt; dstPts\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dstPts</code> The destination points </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-getrotationmatrix","title":"function GetRotationMatrix","text":"<p>Get the rotation matrix associated with counterclockwise rotation about the given axis by theta radians. <pre><code>glm::mat3x3 AIAC::GetRotationMatrix (\n    glm::vec3 axis,\n    float theta\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>axis</code> The axis of rotation. </li> <li><code>theta</code> The angle of rotation in radians.</li> </ul> <p>Returns:</p> <p>The rotation matrix. </p>"},{"location":"acdoxygen/namespaceAIAC/#function-getsectornum","title":"function GetSectorNum","text":"<pre><code>int AIAC::GetSectorNum (\n    float radius\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-gettransformed","title":"function GetTransformed","text":"<p>Combine 3 points into a glm::vec3 and transform it based on the given transformation matrix. <pre><code>glm::vec3 AIAC::GetTransformed (\n    glm::mat4 transformMat,\n    float x,\n    float y,\n    float z\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transformMat</code> A 4x4 transformation matrix. </li> <li><code>x</code> X coordinate. </li> <li><code>y</code> Y coordinate. </li> <li><code>z</code> Z coordinate. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-gettranslationmatrix","title":"function GetTranslationMatrix","text":"<p>Get the translation matrix associated with the given translation vector. <pre><code>glm::mat4x4 AIAC::GetTranslationMatrix (\n    glm::vec3 translationVector\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>translationVector</code> The translation vector</li> </ul> <p>Returns:</p> <p>The translation matrix </p>"},{"location":"acdoxygen/namespaceAIAC/#function-stringtobool","title":"function StringToBool","text":"<p>Convert a string to bool. <pre><code>bool AIAC::StringToBool (\n    std::string str\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> string </li> </ul> <p>Returns:</p> <p>bool </p>"},{"location":"acdoxygen/namespaceAIAC/#function-stringtoset","title":"function StringToSet","text":"<p>Convert a string separated by space to a set of tokens. <pre><code>std::set&lt; std::string &gt; AIAC::StringToSet (\n    std::string str\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> string separated by space </li> </ul> <p>Returns:</p> <p>a std::set&lt;std::string&gt; </p>"},{"location":"acdoxygen/namespaceAIAC/#function-stringtostate","title":"function StringToState","text":"<p>Convert string m_State to ACIMState. <pre><code>ACIMState AIAC::StringToState (\n    std::string m_State\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>m_State</code> ACIMState </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-stringtotokens","title":"function StringToTokens","text":"<p>Convert a string separated by space to a list of string. <pre><code>std::vector&lt; std::string &gt; AIAC::StringToTokens (\n    std::string str\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> string separated by space </li> </ul> <p>Returns:</p> <p>a std::vector&lt;std::string&gt; </p>"},{"location":"acdoxygen/namespaceAIAC/#function-stringtovec3","title":"function StringToVec3","text":"<p>Convert a string separated by space to glm::vec3. <pre><code>glm::vec3 AIAC::StringToVec3 (\n    std::string str\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> string separated by space </li> </ul> <p>Returns:</p> <p>glm::vec3 </p>"},{"location":"acdoxygen/namespaceAIAC/#function-vec3tostring","title":"function Vec3ToString","text":"<p>Convert a vec3 to String. <pre><code>std::string AIAC::Vec3ToString (\n    glm::vec3 vec3\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vec3</code> vec3 </li> </ul> <p>Returns:</p> <p>string </p>"},{"location":"acdoxygen/namespaceAIAC/#function-gldrawlines3d","title":"function glDrawLines3d","text":"<p>Draw multiple points. <pre><code>void AIAC::glDrawLines3d (\n    const std::vector&lt; glm::vec3 &gt; &amp; edges,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors\n) \n</code></pre></p> <p>Draw multiple lines</p> <p>(0, 1, 0)  (1, 0, 0)  || |-----| ||</p> <p>(0, 0, 0)  (0, 0, 1)</p> <p>If you want to draw a square like this, you should construct the <code>edges</code> as: [ (0, 0, 0), (0, 0, 1), (0, 0, 1), (1, 0, 0), (1, 0, 0), (0, 1, 0), (0, 1, 0), (0, 0, 0) ]</p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of 3d points, indicate the position of the vertices. </li> <li><code>colors</code> A RGBA(0~1.0) color, a vector with the same size of the <code>vertices</code>. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-gldrawlines3d_1","title":"function glDrawLines3d","text":"<p>Draw multiple points. <pre><code>void AIAC::glDrawLines3d (\n    const std::vector&lt; glm::vec3 &gt; &amp; edges,\n    const glm::vec4 &amp; color\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of 3d points, indicate the position of the vertices. </li> <li><code>colors</code> A RGBA(0~1.0) color. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-gldrawpoints3d","title":"function glDrawPoints3d","text":"<p>Draw multiple points. <pre><code>void AIAC::glDrawPoints3d (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors,\n    GLfloat pointSize=1.0f\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of 3d points, indicate the position of the vertices. </li> <li><code>colors</code> A RGBA(0~1.0) color, a vector with the same size of the <code>vertices</code>. </li> <li><code>pointSize</code> The size of the point. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-gldrawpoints3d_1","title":"function glDrawPoints3d","text":"<p>Draw multiple points. <pre><code>void AIAC::glDrawPoints3d (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const glm::vec4 &amp; color,\n    GLfloat pointSize=1.0f\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of 3d points, indicate the position of the vertices. </li> <li><code>colors</code> A RGBA(0~1.0) color. </li> <li><code>pointSize</code> The size of the point. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-gldrawtriangles3d","title":"function glDrawTriangles3d","text":"<p>Draw multiple Triangles. <pre><code>void AIAC::glDrawTriangles3d (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; uint32_t &gt; &amp; indices,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors\n) \n</code></pre></p> <p>P2(0, 1, 0)  P3(1, 0, 0) | / | | / | | / | | / | | / | P0(0, 0, 0)  P1(0, 0, 1)</p> <p>If you want to draw a mesh of square like this, you should construct the <code>edges</code> as: [ (0, 0, 0), // P0 (0, 0, 1), // P1 (1, 0, 0), // P2 (0, 1, 0), // P3 ] with <code>indices</code>: [ 0, 1, 3, // Right-bottom triangle 3, 2, 0 // Left-top triangle ]</p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of 3d points, indicate the position of the vertices. </li> <li><code>indices</code> A vector of all triangle's indices. </li> <li><code>colors</code> A RGBA(0~1.0) color, a vector with the same size of the vertices. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-gldrawtriangles3d_1","title":"function glDrawTriangles3d","text":"<p>Draw multiple Triangles. <pre><code>void AIAC::glDrawTriangles3d (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; uint32_t &gt; &amp; indices,\n    const glm::vec4 &amp; colors\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vertices</code> A vector of 3d points, indicate the position of the vertices. </li> <li><code>indices</code> A vector of all triangle's indices. </li> <li><code>colors</code> A RGBA(0~1.0) color, a vector with the same size of the vertices. </li> </ul>"},{"location":"acdoxygen/namespaceAIAC/#function-operator","title":"function operator&gt;&gt;","text":"<pre><code>void AIAC::operator&gt;&gt; (\n    cv::VideoCapture cap,\n    AIAC::Image &amp; img\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/namespaceAIAC/#function-glfwerrorcallback","title":"function GLFWErrorCallback","text":"<pre><code>static void AIAC::GLFWErrorCallback (\n    int error,\n    const char * description\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-glfwmonitorcallback","title":"function GLFWMonitorCallback","text":"<pre><code>static void AIAC::GLFWMonitorCallback (\n    GLFWmonitor * monitor,\n    int event\n) \n</code></pre>"},{"location":"acdoxygen/namespaceAIAC/#function-isglfwinitialized","title":"function IsGlfwInitialized","text":"<pre><code>static bool AIAC::IsGlfwInitialized () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.cpp</code></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/","title":"Class AIAC::ACInfoModel","text":"<p>ClassList &gt; AIAC &gt; ACInfoModel</p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#public-functions","title":"Public Functions","text":"Type Name ACInfoModel ()  void AddMeasuredBboxLength (const float diff)  void AdjustScale () Utils. void Clear () Clear the loaded data. pugi::xml_document &amp; GetDoc () Get the pugi::xml_document object. const std::string &amp; GetFilePath () constGet the filepath to the loaded ACInfoModel . float GetLength () Get the length of the acim, which is calculated by averaging the four long edges of the bounding box. float GetMeasuredBboxLength () const const std::string GetName () constGet the name of the loaded ACInfoModel without the extension. float GetRealWorldLength () Get the length of the acim, which is calculated by averaging the four long edges of the bounding box. TimberInfo &amp; GetTimberInfo () Get the TimberInfo object. bool Load (std::string path) Load a .acim model from a file. void Save () Save the current state to the loaded .acim file. void SetBboxVisibility (bool visible)  void Transform (glm::mat4x4 transformMat) transform all the GOPrimitive belonging to theACInfoModel __ void UpdateBboxGOLine () Update the bounding box of the timber (use the current Active TimberInfo ) ~ACInfoModel ()"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-acinfomodel","title":"function ACInfoModel","text":"<pre><code>inline AIAC::ACInfoModel::ACInfoModel () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-addmeasuredbboxlength","title":"function AddMeasuredBboxLength","text":"<pre><code>void AIAC::ACInfoModel::AddMeasuredBboxLength (\n    const float diff\n) \n</code></pre> <p>Increase / decrease real world length based on the measurement </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-adjustscale","title":"function AdjustScale","text":"<p>Utils. <pre><code>void AIAC::ACInfoModel::AdjustScale () \n</code></pre></p> <p>Adjust the scale of the model based on the measured result </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-clear","title":"function Clear","text":"<p>Clear the loaded data. <pre><code>void AIAC::ACInfoModel::Clear () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-getdoc","title":"function GetDoc","text":"<p>Get the pugi::xml_document object. <pre><code>inline pugi::xml_document &amp; AIAC::ACInfoModel::GetDoc () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-getfilepath","title":"function GetFilePath","text":"<p>Get the filepath to the loaded ACInfoModel . <pre><code>inline const std::string &amp; AIAC::ACInfoModel::GetFilePath () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-getlength","title":"function GetLength","text":"<p>Get the length of the acim, which is calculated by averaging the four long edges of the bounding box. <pre><code>float AIAC::ACInfoModel::GetLength () \n</code></pre></p> <p>Returns:</p> <p>The length of the acim bounding box. (in TSLAM unit) </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-getmeasuredbboxlength","title":"function GetMeasuredBboxLength","text":"<pre><code>inline float AIAC::ACInfoModel::GetMeasuredBboxLength () const\n</code></pre> <p>Get the real world length of the bounding box (in Real World unit, meter) </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-getname","title":"function GetName","text":"<p>Get the name of the loaded ACInfoModel without the extension. <pre><code>inline const std::string AIAC::ACInfoModel::GetName () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-getrealworldlength","title":"function GetRealWorldLength","text":"<p>Get the length of the acim, which is calculated by averaging the four long edges of the bounding box. <pre><code>inline float AIAC::ACInfoModel::GetRealWorldLength () \n</code></pre></p> <p>Returns:</p> <p>The length of the acim bounding box. (in Real World unit, meter) </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-gettimberinfo","title":"function GetTimberInfo","text":"<p>Get the TimberInfo object. <pre><code>inline TimberInfo &amp; AIAC::ACInfoModel::GetTimberInfo () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-load","title":"function Load","text":"<p>Load a .acim model from a file. <pre><code>bool AIAC::ACInfoModel::Load (\n    std::string path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> Path to the model file. </li> </ul> <p>Returns:</p> <p>true if the file is loaded successfully, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-save","title":"function Save","text":"<p>Save the current state to the loaded .acim file. <pre><code>void AIAC::ACInfoModel::Save () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-setbboxvisibility","title":"function SetBboxVisibility","text":"<pre><code>void AIAC::ACInfoModel::SetBboxVisibility (\n    bool visible\n) \n</code></pre> <p>Set the visibility of bbox to true or false </p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-transform","title":"function Transform","text":"<p>transform all the GOPrimitive belonging to theACInfoModel __ <pre><code>void AIAC::ACInfoModel::Transform (\n    glm::mat4x4 transformMat\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transformMat</code> transformation matrix </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-updatebboxgoline","title":"function UpdateBboxGOLine","text":"<p>Update the bounding box of the timber (use the current Active TimberInfo ) <pre><code>void AIAC::ACInfoModel::UpdateBboxGOLine () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoModel/#function-acinfomodel_1","title":"function ~ACInfoModel","text":"<pre><code>inline AIAC::ACInfoModel::~ACInfoModel () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/","title":"Class AIAC::ACInfoToolhead","text":"<p>ClassList &gt; AIAC &gt; ACInfoToolhead</p> <p>the class holding the information of the toolhead (GOs, metadata, etc) </p> <ul> <li><code>#include &lt;ACInfoToolhead.h&gt;</code></li> </ul>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#public-functions","title":"Public Functions","text":"Type Name ACInfoToolhead () = default ACInfoToolhead (std::string acitPath, std::string meshObjPath, int id)  void AddGOsInfo (ToolHeadData &amp; data) From the parse data acit, create the corresponding geometries (e.g. GOPoint for tooltip, toolbase, etc) void AddGOsInfoChainSaw (ToolHeadData &amp; data)  void AddGOsInfoCircularSaw (ToolHeadData &amp; data)  void AddGOsInfoDrillBit (ToolHeadData &amp; data)  void AddGOsInfoSaberSaw (ToolHeadData &amp; data)  void CopyGOsInfoOriginal () copy the original transform of the GO infos T GetData () constaccess the data of the toolheads int GetId () constGet the id of the toolhead. std::string GetName () constGet the name of the toolhead. __always_inline ACToolHeadType GetType () constRetrieve the type of the toolhead. std::string GetTypeString () constRetrieve the type of the toolhead as a string. void SetVisibility (bool visible) Set the visibility of the geometries and widgets of the toolhead. __always_inline std::string ToString () constconvert to a string byy getting the name void Transform (glm::mat4 transform) transform all the geometries, widgets and mesh contained in the ACInfoToolhead object void TransformGO (std::shared_ptr&lt; GOPrimitive &gt; goPtr, std::shared_ptr&lt; GOPrimitive &gt; goOriginalPtr, glm::mat4 transform) transform a specific geometry void TransformSync () rotate around local x axis of the toolhead 90 degrees to match the AC coordinate system with the TTool coordinate system Should only be called once at loading time"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-acinfotoolhead-12","title":"function ACInfoToolhead [\u00bd]","text":"<pre><code>AIAC::ACInfoToolhead::ACInfoToolhead () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-acinfotoolhead-22","title":"function ACInfoToolhead [2/2]","text":"<pre><code>AIAC::ACInfoToolhead::ACInfoToolhead (\n    std::string acitPath,\n    std::string meshObjPath,\n    int id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-addgosinfo","title":"function AddGOsInfo","text":"<p>From the parse data acit, create the corresponding geometries (e.g. GOPoint for tooltip, toolbase, etc) <pre><code>void AIAC::ACInfoToolhead::AddGOsInfo (\n    ToolHeadData &amp; data\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-addgosinfochainsaw","title":"function AddGOsInfoChainSaw","text":"<pre><code>void AIAC::ACInfoToolhead::AddGOsInfoChainSaw (\n    ToolHeadData &amp; data\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-addgosinfocircularsaw","title":"function AddGOsInfoCircularSaw","text":"<pre><code>void AIAC::ACInfoToolhead::AddGOsInfoCircularSaw (\n    ToolHeadData &amp; data\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-addgosinfodrillbit","title":"function AddGOsInfoDrillBit","text":"<pre><code>void AIAC::ACInfoToolhead::AddGOsInfoDrillBit (\n    ToolHeadData &amp; data\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-addgosinfosabersaw","title":"function AddGOsInfoSaberSaw","text":"<pre><code>void AIAC::ACInfoToolhead::AddGOsInfoSaberSaw (\n    ToolHeadData &amp; data\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-copygosinfooriginal","title":"function CopyGOsInfoOriginal","text":"<p>copy the original transform of the GO infos <pre><code>void AIAC::ACInfoToolhead::CopyGOsInfoOriginal () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-getdata","title":"function GetData","text":"<p>access the data of the toolheads <pre><code>template&lt;typename T&gt;\ninline T AIAC::ACInfoToolhead::GetData () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-getid","title":"function GetId","text":"<p>Get the id of the toolhead. <pre><code>inline int AIAC::ACInfoToolhead::GetId () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-getname","title":"function GetName","text":"<p>Get the name of the toolhead. <pre><code>inline std::string AIAC::ACInfoToolhead::GetName () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-gettype","title":"function GetType","text":"<p>Retrieve the type of the toolhead. <pre><code>inline __always_inline ACToolHeadType AIAC::ACInfoToolhead::GetType () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-gettypestring","title":"function GetTypeString","text":"<p>Retrieve the type of the toolhead as a string. <pre><code>inline std::string AIAC::ACInfoToolhead::GetTypeString () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-setvisibility","title":"function SetVisibility","text":"<p>Set the visibility of the geometries and widgets of the toolhead. <pre><code>void AIAC::ACInfoToolhead::SetVisibility (\n    bool visible\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-tostring","title":"function ToString","text":"<p>convert to a string byy getting the name <pre><code>inline __always_inline std::string AIAC::ACInfoToolhead::ToString () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-transform","title":"function Transform","text":"<p>transform all the geometries, widgets and mesh contained in the ACInfoToolhead object <pre><code>void AIAC::ACInfoToolhead::Transform (\n    glm::mat4 transform\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-transformgo","title":"function TransformGO","text":"<p>transform a specific geometry <pre><code>void AIAC::ACInfoToolhead::TransformGO (\n    std::shared_ptr&lt; GOPrimitive &gt; goPtr,\n    std::shared_ptr&lt; GOPrimitive &gt; goOriginalPtr,\n    glm::mat4 transform\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolhead/#function-transformsync","title":"function TransformSync","text":"<p>rotate around local x axis of the toolhead 90 degrees to match the AC coordinate system with the TTool coordinate system Should only be called once at loading time <pre><code>void AIAC::ACInfoToolhead::TransformSync () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/","title":"Class AIAC::ACInfoToolheadManager","text":"<p>ClassList &gt; AIAC &gt; ACInfoToolheadManager</p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#public-functions","title":"Public Functions","text":"Type Name ACInfoToolheadManager ()  std::shared_ptr&lt; ACInfoToolhead &gt; GetActiveToolhead () constGet the active toolhead model. std::string GetActiveToolheadName () constGet the active toolhead model's name. ACToolHeadType GetActiveToolheadType () constGet the current active toolhead's type. std::shared_ptr&lt; ACInfoToolhead &gt; GetToolhead (const std::string &amp; toolheadName) constGet the toolhead model by its name. std::vector&lt; std::string &gt; GetToolheadNames () constReturn the list of names of the toolheads loaded. ACToolHeadType GetToolheadType (const std::string &amp; toolheadName) constGet the toolhead's type by its name. void LoadToolheadModels () Load each toolhead model acit/obj from the dataset dir. void SetActiveToolhead (const std::string &amp; toolheadName) Set a toolhead model as active by its name."},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-acinfotoolheadmanager","title":"function ACInfoToolheadManager","text":"<pre><code>inline AIAC::ACInfoToolheadManager::ACInfoToolheadManager () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-getactivetoolhead","title":"function GetActiveToolhead","text":"<p>Get the active toolhead model. <pre><code>inline std::shared_ptr&lt; ACInfoToolhead &gt; AIAC::ACInfoToolheadManager::GetActiveToolhead () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-getactivetoolheadname","title":"function GetActiveToolheadName","text":"<p>Get the active toolhead model's name. <pre><code>inline std::string AIAC::ACInfoToolheadManager::GetActiveToolheadName () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-getactivetoolheadtype","title":"function GetActiveToolheadType","text":"<p>Get the current active toolhead's type. <pre><code>inline ACToolHeadType AIAC::ACInfoToolheadManager::GetActiveToolheadType () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-gettoolhead","title":"function GetToolhead","text":"<p>Get the toolhead model by its name. <pre><code>inline std::shared_ptr&lt; ACInfoToolhead &gt; AIAC::ACInfoToolheadManager::GetToolhead (\n    const std::string &amp; toolheadName\n) const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-gettoolheadnames","title":"function GetToolheadNames","text":"<p>Return the list of names of the toolheads loaded. <pre><code>inline std::vector&lt; std::string &gt; AIAC::ACInfoToolheadManager::GetToolheadNames () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-gettoolheadtype","title":"function GetToolheadType","text":"<p>Get the toolhead's type by its name. <pre><code>inline ACToolHeadType AIAC::ACInfoToolheadManager::GetToolheadType (\n    const std::string &amp; toolheadName\n) const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-loadtoolheadmodels","title":"function LoadToolheadModels","text":"<p>Load each toolhead model acit/obj from the dataset dir. <pre><code>void AIAC::ACInfoToolheadManager::LoadToolheadModels () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ACInfoToolheadManager/#function-setactivetoolhead","title":"function SetActiveToolhead","text":"<p>Set a toolhead model as active by its name. <pre><code>void AIAC::ACInfoToolheadManager::SetActiveToolhead (\n    const std::string &amp; toolheadName\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolheadManager.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1AppCloseEvent/","title":"Class AIAC::AppCloseEvent","text":"<p>ClassList &gt; AIAC &gt; AppCloseEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1AppCloseEvent/#public-functions","title":"Public Functions","text":"Type Name AppCloseEvent ()  void OnAppClose ()"},{"location":"acdoxygen/classAIAC_1_1AppCloseEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1AppCloseEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1AppCloseEvent/#function-appcloseevent","title":"function AppCloseEvent","text":"<pre><code>inline explicit AIAC::AppCloseEvent::AppCloseEvent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1AppCloseEvent/#function-onappclose","title":"function OnAppClose","text":"<pre><code>void AIAC::AppCloseEvent::OnAppClose () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/ApplicationEvent.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Application/","title":"Class AIAC::Application","text":"<p>ClassList &gt; AIAC &gt; Application</p>"},{"location":"acdoxygen/classAIAC_1_1Application/#public-functions","title":"Public Functions","text":"Type Name Application (const ApplicationSpecification &amp; appSpec)  void Close ()  EventBus *&amp; GetEventBus ()  GORegistry * GetGORegistry ()  std::shared_ptr&lt; T &gt; GetLayer ()  Renderer *&amp; GetRenderer ()  const ApplicationSpecification &amp; GetSpecification () const AIAC::Window *&amp; GetWindow ()  void PushLayer ()  void Run ()  virtual ~Application ()"},{"location":"acdoxygen/classAIAC_1_1Application/#public-static-functions","title":"Public Static Functions","text":"Type Name Application &amp; GetInstance ()"},{"location":"acdoxygen/classAIAC_1_1Application/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Application/#function-application","title":"function Application","text":"<pre><code>AIAC::Application::Application (\n    const ApplicationSpecification &amp; appSpec\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-close","title":"function Close","text":"<pre><code>void AIAC::Application::Close () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-geteventbus","title":"function GetEventBus","text":"<pre><code>inline EventBus *&amp; AIAC::Application::GetEventBus () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-getgoregistry","title":"function GetGORegistry","text":"<pre><code>inline GORegistry * AIAC::Application::GetGORegistry () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-getlayer","title":"function GetLayer","text":"<pre><code>template&lt;typename T&gt;\ninline std::shared_ptr&lt; T &gt; AIAC::Application::GetLayer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-getrenderer","title":"function GetRenderer","text":"<pre><code>inline Renderer *&amp; AIAC::Application::GetRenderer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-getspecification","title":"function GetSpecification","text":"<pre><code>inline const ApplicationSpecification &amp; AIAC::Application::GetSpecification () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-getwindow","title":"function GetWindow","text":"<pre><code>inline AIAC::Window *&amp; AIAC::Application::GetWindow () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-pushlayer","title":"function PushLayer","text":"<pre><code>template&lt;typename T&gt;\ninline void AIAC::Application::PushLayer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-run","title":"function Run","text":"<pre><code>void AIAC::Application::Run () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#function-application_1","title":"function ~Application","text":"<pre><code>virtual AIAC::Application::~Application () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Application/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Application/#function-getinstance","title":"function GetInstance","text":"<pre><code>static inline Application &amp; AIAC::Application::GetInstance () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Application.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/","title":"Struct AIAC::ApplicationSpecification","text":"<p>ClassList &gt; AIAC &gt; ApplicationSpecification</p>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#public-attributes","title":"Public Attributes","text":"Type Name bool IsResizable const char * Name bool VSync uint32_t WinHeight uint32_t WinWidth ImVec4 WindowBackColor"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#variable-isresizable","title":"variable IsResizable","text":"<pre><code>bool AIAC::ApplicationSpecification::IsResizable;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#variable-name","title":"variable Name","text":"<pre><code>const char* AIAC::ApplicationSpecification::Name;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#variable-vsync","title":"variable VSync","text":"<pre><code>bool AIAC::ApplicationSpecification::VSync;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#variable-winheight","title":"variable WinHeight","text":"<pre><code>uint32_t AIAC::ApplicationSpecification::WinHeight;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#variable-winwidth","title":"variable WinWidth","text":"<pre><code>uint32_t AIAC::ApplicationSpecification::WinWidth;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ApplicationSpecification/#variable-windowbackcolor","title":"variable WindowBackColor","text":"<pre><code>ImVec4 AIAC::ApplicationSpecification::WindowBackColor;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Application.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Camera/","title":"Class AIAC::Camera","text":"<p>ClassList &gt; AIAC &gt; Camera</p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#public-attributes","title":"Public Attributes","text":"Type Name bool FlipHorizontal   = <code>false</code>Flag indicating if the captured image should be flipped. bool FlipVertical   = <code>false</code>"},{"location":"acdoxygen/classAIAC_1_1Camera/#public-functions","title":"Public Functions","text":"Type Name Camera ()  const std::string GetCalibrationFilePath () constGet the path to the camera calibration parameters. const cv::Mat GetCameraMatrix () Get the camera matrix. AIAC::Image &amp; GetCenterCroppedCurrentFrame (float ratioX=0.6f, float ratioY=0.75f) Get the raw current frame, but borders are set to black according to the specified ratio. AIAC::Image &amp; GetColorCurrentFrame () Get the current color (calibrated) frame from the camera. AIAC::Image &amp; GetCurrentFrame () Get the current grayscale (calibrated) frame from the camera. const cv::Mat GetDistortionCoef () Get the distortion coefficients matrix. const std::pair&lt; float, float &gt; GetFov () constGet the field of view (FOV) of the camera. const uint32_t GetHeight () constGet the calibrated height of the camera frame. const AIAC::Image GetNextFrame () Capture and preprocess the next frame from the camera. AIAC::Image &amp; GetRawCurrentFrame () Get the current raw (uncalibrated) frame from the camera. const uint32_t GetRawHeight () constGet the raw (uncalibrated) height of the camera frame. const uint32_t GetRawWidth () constGet the raw (uncalibrated) width of the camera frame. const uint32_t GetWidth () constGet the calibrated width of the camera frame. bool IsOpened () constCheck if the camera is opened. bool IsPhysicalAndParamWidthHeightMatched () constCheck if the physical and parameterized width and height match. bool LoadCameraParams (const std::string &amp; filePath) Loads camera parameters from a configuration file. void Open (int id) Open the camera with the specified id. void UpdateCameraParamFromFile (const std::string &amp; filePath) Force to update the default camera param. void UpdateCameraParamFromSlamMap (const int paramWidth, const int paramHeight, const cv::Mat &amp; cameraMatrix) Update the camera parameters from the SLAM-generated map. void UpdateFov () Update the field of view (FOV) values based on camera parameters. ~Camera ()"},{"location":"acdoxygen/classAIAC_1_1Camera/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Camera/#variable-fliphorizontal","title":"variable FlipHorizontal","text":"<p>Flag indicating if the captured image should be flipped. <pre><code>bool AIAC::Camera::FlipHorizontal;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#variable-flipvertical","title":"variable FlipVertical","text":"<pre><code>bool AIAC::Camera::FlipVertical;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Camera/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Camera/#function-camera","title":"function Camera","text":"<pre><code>AIAC::Camera::Camera () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getcalibrationfilepath","title":"function GetCalibrationFilePath","text":"<p>Get the path to the camera calibration parameters. <pre><code>inline const std::string AIAC::Camera::GetCalibrationFilePath () const\n</code></pre></p> <p>Returns:</p> <p>A constant reference to the camera calibration file path. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getcameramatrix","title":"function GetCameraMatrix","text":"<p>Get the camera matrix. <pre><code>inline const cv::Mat AIAC::Camera::GetCameraMatrix () \n</code></pre></p> <p>Returns:</p> <p>A constant reference to the camera matrix. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getcentercroppedcurrentframe","title":"function GetCenterCroppedCurrentFrame","text":"<p>Get the raw current frame, but borders are set to black according to the specified ratio. <pre><code>AIAC::Image &amp; AIAC::Camera::GetCenterCroppedCurrentFrame (\n    float ratioX=0.6f,\n    float ratioY=0.75f\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ratioX</code> How much of % the width of the image is kept. (default: 0.75, i.e. 75%). </li> <li><code>ratioY</code> How much of % the height of the image is kept. (default: 0.9, i.e. 90%). </li> </ul> <p>Returns:</p> <p>A reference to the center-cropped current frame image. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getcolorcurrentframe","title":"function GetColorCurrentFrame","text":"<p>Get the current color (calibrated) frame from the camera. <pre><code>inline AIAC::Image &amp; AIAC::Camera::GetColorCurrentFrame () \n</code></pre></p> <p>Returns:</p> <p>A reference to the current color frame image. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getcurrentframe","title":"function GetCurrentFrame","text":"<p>Get the current grayscale (calibrated) frame from the camera. <pre><code>inline AIAC::Image &amp; AIAC::Camera::GetCurrentFrame () \n</code></pre></p> <p>Returns:</p> <p>A reference to the current grayscale frame image. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getdistortioncoef","title":"function GetDistortionCoef","text":"<p>Get the distortion coefficients matrix. <pre><code>inline const cv::Mat AIAC::Camera::GetDistortionCoef () \n</code></pre></p> <p>Returns:</p> <p>A constant reference to the distortion coefficient matrix. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getfov","title":"function GetFov","text":"<p>Get the field of view (FOV) of the camera. <pre><code>inline const std::pair&lt; float, float &gt; AIAC::Camera::GetFov () const\n</code></pre></p> <p>Returns:</p> <p>A pair of floats representing the horizontal and vertical FOV of the camera. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getheight","title":"function GetHeight","text":"<p>Get the calibrated height of the camera frame. <pre><code>inline const uint32_t AIAC::Camera::GetHeight () const\n</code></pre></p> <p>Returns:</p> <p>The calibrated height of the camera frame as an unsigned 32-bit integer. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getnextframe","title":"function GetNextFrame","text":"<p>Capture and preprocess the next frame from the camera. <pre><code>const AIAC::Image AIAC::Camera::GetNextFrame () \n</code></pre></p> <p>Returns:</p> <p>A grayscale image representing the captured and processed frame. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getrawcurrentframe","title":"function GetRawCurrentFrame","text":"<p>Get the current raw (uncalibrated) frame from the camera. <pre><code>inline AIAC::Image &amp; AIAC::Camera::GetRawCurrentFrame () \n</code></pre></p> <p>Returns:</p> <p>A reference to the current raw frame image. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getrawheight","title":"function GetRawHeight","text":"<p>Get the raw (uncalibrated) height of the camera frame. <pre><code>inline const uint32_t AIAC::Camera::GetRawHeight () const\n</code></pre></p> <p>Returns:</p> <p>The raw height of the camera frame as an unsigned 32-bit integer. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getrawwidth","title":"function GetRawWidth","text":"<p>Get the raw (uncalibrated) width of the camera frame. <pre><code>inline const uint32_t AIAC::Camera::GetRawWidth () const\n</code></pre></p> <p>Returns:</p> <p>The raw width of the camera frame as an unsigned 32-bit integer. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-getwidth","title":"function GetWidth","text":"<p>Get the calibrated width of the camera frame. <pre><code>inline const uint32_t AIAC::Camera::GetWidth () const\n</code></pre></p> <p>Returns:</p> <p>The calibrated width of the camera frame as an unsigned 32-bit integer. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-isopened","title":"function IsOpened","text":"<p>Check if the camera is opened. <pre><code>inline bool AIAC::Camera::IsOpened () const\n</code></pre></p> <p>Returns:</p> <p>True if the camera is opened, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-isphysicalandparamwidthheightmatched","title":"function IsPhysicalAndParamWidthHeightMatched","text":"<p>Check if the physical and parameterized width and height match. <pre><code>inline bool AIAC::Camera::IsPhysicalAndParamWidthHeightMatched () const\n</code></pre></p> <p>Returns:</p> <p>True if the physical and parameterized width and height match, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-loadcameraparams","title":"function LoadCameraParams","text":"<p>Loads camera parameters from a configuration file. <pre><code>bool AIAC::Camera::LoadCameraParams (\n    const std::string &amp; filePath\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>filePath</code> The path to the camera parameter configuration file. </li> </ul> <p>Returns:</p> <p>True if the camera parameters are loaded successfully, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-open","title":"function Open","text":"<p>Open the camera with the specified id. <pre><code>void AIAC::Camera::Open (\n    int id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> The id of the camera to open. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-updatecameraparamfromfile","title":"function UpdateCameraParamFromFile","text":"<p>Force to update the default camera param. <pre><code>void AIAC::Camera::UpdateCameraParamFromFile (\n    const std::string &amp; filePath\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>filePath</code> The path to the camera param file. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-updatecameraparamfromslammap","title":"function UpdateCameraParamFromSlamMap","text":"<p>Update the camera parameters from the SLAM-generated map. <pre><code>void AIAC::Camera::UpdateCameraParamFromSlamMap (\n    const int paramWidth,\n    const int paramHeight,\n    const cv::Mat &amp; cameraMatrix\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>paramWidth</code> Image width for camera calibration. </li> <li><code>paramHeight</code> Image height for camera calibration. </li> <li><code>cameraMatrix</code> The camera matrix </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-updatefov","title":"function UpdateFov","text":"<p>Update the field of view (FOV) values based on camera parameters. <pre><code>inline void AIAC::Camera::UpdateFov () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Camera/#function-camera_1","title":"function ~Camera","text":"<pre><code>inline AIAC::Camera::~Camera () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Camera.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrationLoadedEvent/","title":"Class AIAC::CameraCalibrationLoadedEvent","text":"<p>ClassList &gt; AIAC &gt; CameraCalibrationLoadedEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrationLoadedEvent/#public-functions","title":"Public Functions","text":"Type Name CameraCalibrationLoadedEvent (const std::string filePath)  void OnCameraCalibrationFileLoaded ()"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrationLoadedEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrationLoadedEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CameraCalibrationLoadedEvent/#function-cameracalibrationloadedevent","title":"function CameraCalibrationLoadedEvent","text":"<pre><code>inline explicit AIAC::CameraCalibrationLoadedEvent::CameraCalibrationLoadedEvent (\n    const std::string filePath\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrationLoadedEvent/#function-oncameracalibrationfileloaded","title":"function OnCameraCalibrationFileLoaded","text":"<pre><code>void AIAC::CameraCalibrationLoadedEvent::OnCameraCalibrationFileLoaded () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/CameraEvent.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/","title":"Class AIAC::CameraCalibrator","text":"<p>ClassList &gt; AIAC &gt; CameraCalibrator</p>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#public-types","title":"Public Types","text":"Type Name enum Pattern"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#public-attributes","title":"Public Attributes","text":"Type Name float aspectRatio   = <code>0.0f</code> cv::Size boardSize   = <code>cv::Size(19, 13)</code> bool calibFixPrincipalPoint   = <code>false</code> bool calibZeroTangentDist   = <code>false</code> Pattern calibrationPattern   = <code>Pattern::CHESSBOARD</code> cv::Mat cameraMatrix cv::Mat distCoeffs bool fixDistortion   = <code>false</code> bool flipVertical   = <code>false</code> float gridWidth   = <code>squareSize \\* (boardSize.width - 1)</code> cv::Size imageSize std::vector&lt; float &gt; reprojErrs cv::Mat rvecs float squareSize   = <code>20.0f</code> double totalAvgErr cv::Mat tvecs bool useFisheye   = <code>false</code> bool useFixedPoint   = <code>false</code> int winSize   = <code>11</code> bool writeExtrinsics   = <code>true</code>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#public-functions","title":"Public Functions","text":"Type Name void AddImage (const cv::Mat &amp; image)  CameraCalibrator ()  void ClearImages ()  int GetImageAmount () const bool RunCalibration (cv::Mat * imgForDisplay=nullptr) [board_corners void Save (const std::string &amp; filename)  ~CameraCalibrator ()"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#enum-pattern","title":"enum Pattern","text":"<pre><code>enum AIAC::CameraCalibrator::Pattern {\n    NOT_EXISTING,\n    CHESSBOARD,\n    CIRCLES_GRID,\n    ASYMMETRIC_CIRCLES_GRID\n};\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-aspectratio","title":"variable aspectRatio","text":"<pre><code>float AIAC::CameraCalibrator::aspectRatio;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-boardsize","title":"variable boardSize","text":"<pre><code>cv::Size AIAC::CameraCalibrator::boardSize;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-calibfixprincipalpoint","title":"variable calibFixPrincipalPoint","text":"<pre><code>bool AIAC::CameraCalibrator::calibFixPrincipalPoint;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-calibzerotangentdist","title":"variable calibZeroTangentDist","text":"<pre><code>bool AIAC::CameraCalibrator::calibZeroTangentDist;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-calibrationpattern","title":"variable calibrationPattern","text":"<pre><code>Pattern AIAC::CameraCalibrator::calibrationPattern;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-cameramatrix","title":"variable cameraMatrix","text":"<pre><code>cv::Mat AIAC::CameraCalibrator::cameraMatrix;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-distcoeffs","title":"variable distCoeffs","text":"<pre><code>cv::Mat AIAC::CameraCalibrator::distCoeffs;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-fixdistortion","title":"variable fixDistortion","text":"<pre><code>bool AIAC::CameraCalibrator::fixDistortion;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-flipvertical","title":"variable flipVertical","text":"<pre><code>bool AIAC::CameraCalibrator::flipVertical;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-gridwidth","title":"variable gridWidth","text":"<pre><code>float AIAC::CameraCalibrator::gridWidth;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-imagesize","title":"variable imageSize","text":"<pre><code>cv::Size AIAC::CameraCalibrator::imageSize;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-reprojerrs","title":"variable reprojErrs","text":"<pre><code>std::vector&lt;float&gt; AIAC::CameraCalibrator::reprojErrs;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-rvecs","title":"variable rvecs","text":"<pre><code>cv::Mat AIAC::CameraCalibrator::rvecs;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-squaresize","title":"variable squareSize","text":"<pre><code>float AIAC::CameraCalibrator::squareSize;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-totalavgerr","title":"variable totalAvgErr","text":"<pre><code>double AIAC::CameraCalibrator::totalAvgErr;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-tvecs","title":"variable tvecs","text":"<pre><code>cv::Mat AIAC::CameraCalibrator::tvecs;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-usefisheye","title":"variable useFisheye","text":"<pre><code>bool AIAC::CameraCalibrator::useFisheye;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-usefixedpoint","title":"variable useFixedPoint","text":"<pre><code>bool AIAC::CameraCalibrator::useFixedPoint;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-winsize","title":"variable winSize","text":"<pre><code>int AIAC::CameraCalibrator::winSize;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#variable-writeextrinsics","title":"variable writeExtrinsics","text":"<pre><code>bool AIAC::CameraCalibrator::writeExtrinsics;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-addimage","title":"function AddImage","text":"<pre><code>void AIAC::CameraCalibrator::AddImage (\n    const cv::Mat &amp; image\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-cameracalibrator","title":"function CameraCalibrator","text":"<pre><code>inline AIAC::CameraCalibrator::CameraCalibrator () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-clearimages","title":"function ClearImages","text":"<pre><code>inline void AIAC::CameraCalibrator::ClearImages () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-getimageamount","title":"function GetImageAmount","text":"<pre><code>inline int AIAC::CameraCalibrator::GetImageAmount () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-runcalibration","title":"function RunCalibration","text":"<p>[board_corners <pre><code>bool AIAC::CameraCalibrator::RunCalibration (\n    cv::Mat * imgForDisplay=nullptr\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-save","title":"function Save","text":"<pre><code>void AIAC::CameraCalibrator::Save (\n    const std::string &amp; filename\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CameraCalibrator/#function-cameracalibrator_1","title":"function ~CameraCalibrator","text":"<pre><code>inline AIAC::CameraCalibrator::~CameraCalibrator () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/CameraCalibrator.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/","title":"Class AIAC::ChainSawCutPlaneVisualizer","text":"<p>ClassList &gt; AIAC &gt; ChainSawCutPlaneVisualizer</p> <p>Inherits the following classes: AIAC::CutPlaneVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#public-functions","title":"Public Functions","text":"Type Name ChainSawCutPlaneVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#public-functions-inherited-from-aiaccutplanevisualizer","title":"Public Functions inherited from AIAC::CutPlaneVisualizer","text":"<p>See AIAC::CutPlaneVisualizer</p> Type Name virtual void Activate () override CutPlaneVisualizer ()  virtual void Deactivate () override std::vector&lt; glm::vec3 &gt; Update (glm::vec3 faceNorm, glm::vec3 facePt) Update the intersection polyline and face, and return the intersection point."},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#protected-attributes-inherited-from-aiaccutplanevisualizer","title":"Protected Attributes inherited from AIAC::CutPlaneVisualizer","text":"<p>See AIAC::CutPlaneVisualizer</p> Type Name std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentA1 the intersection line of the blade indicating the thickness away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentA2 the intersection line of the blade indicating the thickness towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAppCenterA &lt; std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAppCenterB the intersection line of the blade indicating the thickness towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentB1 the intersection line of the blade indicating the thickness away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentB2"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#function-chainsawcutplanevisualizer","title":"function ChainSawCutPlaneVisualizer","text":"<pre><code>AIAC::ChainSawCutPlaneVisualizer::ChainSawCutPlaneVisualizer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#friends-documentation","title":"Friends Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ChainSawCutPlaneVisualizer/#friend-cutchainsawfeedback","title":"friend CutChainSawFeedback","text":"<pre><code>class AIAC::ChainSawCutPlaneVisualizer::CutChainSawFeedback (\n    CutChainSawFeedback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/","title":"Struct AIAC::ChainSawData","text":"<p>ClassList &gt; AIAC &gt; ChainSawData</p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 ChainBaseACIT point start of the basetool std::shared_ptr&lt; GOPoint &gt; ChainBaseGO GOPoints equivalent. std::shared_ptr&lt; GOPoint &gt; ChainEndGO glm::vec3 ChainMidACIT point in the middle of the chain std::shared_ptr&lt; GOPoint &gt; ChainMidGO glm::vec3 ChainNormEndACIT point end of the chain before the round tip std::string NameACIT name of the toolhead glm::vec3 NormEndACIT end of the normal of the plateau plane std::shared_ptr&lt; GOPoint &gt; NormEndGO glm::vec3 NormStartACIT start of the normal of the plateau plane std::shared_ptr&lt; GOPoint &gt; NormStartGO float OverhangACIT the overhang width of the teeth of the blade from one side float ThicknessACIT the overhaul thickness of the blade float WidthACIT width of the chain"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#public-functions","title":"Public Functions","text":"Type Name ChainSawData ()"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-chainbaseacit","title":"variable ChainBaseACIT","text":"<p>point start of the basetool <pre><code>glm::vec3 AIAC::ChainSawData::ChainBaseACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-chainbasego","title":"variable ChainBaseGO","text":"<p>GOPoints equivalent. <pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::ChainSawData::ChainBaseGO;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-chainendgo","title":"variable ChainEndGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::ChainSawData::ChainEndGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-chainmidacit","title":"variable ChainMidACIT","text":"<p>point in the middle of the chain <pre><code>glm::vec3 AIAC::ChainSawData::ChainMidACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-chainmidgo","title":"variable ChainMidGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::ChainSawData::ChainMidGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-chainnormendacit","title":"variable ChainNormEndACIT","text":"<p>point end of the chain before the round tip <pre><code>glm::vec3 AIAC::ChainSawData::ChainNormEndACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-nameacit","title":"variable NameACIT","text":"<p>name of the toolhead <pre><code>std::string AIAC::ChainSawData::NameACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-normendacit","title":"variable NormEndACIT","text":"<p>end of the normal of the plateau plane <pre><code>glm::vec3 AIAC::ChainSawData::NormEndACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-normendgo","title":"variable NormEndGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::ChainSawData::NormEndGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-normstartacit","title":"variable NormStartACIT","text":"<p>start of the normal of the plateau plane <pre><code>glm::vec3 AIAC::ChainSawData::NormStartACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-normstartgo","title":"variable NormStartGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::ChainSawData::NormStartGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-overhangacit","title":"variable OverhangACIT","text":"<p>the overhang width of the teeth of the blade from one side <pre><code>float AIAC::ChainSawData::OverhangACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-thicknessacit","title":"variable ThicknessACIT","text":"<p>the overhaul thickness of the blade <pre><code>float AIAC::ChainSawData::ThicknessACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#variable-widthacit","title":"variable WidthACIT","text":"<p>width of the chain <pre><code>float AIAC::ChainSawData::WidthACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1ChainSawData/#function-chainsawdata","title":"function ChainSawData","text":"<pre><code>inline AIAC::ChainSawData::ChainSawData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1Character/","title":"Struct AIAC::Character","text":"<p>ClassList &gt; AIAC &gt; Character</p>"},{"location":"acdoxygen/structAIAC_1_1Character/#public-attributes","title":"Public Attributes","text":"Type Name unsigned int Advance glm::ivec2 Bearing glm::ivec2 Size unsigned int TextureID"},{"location":"acdoxygen/structAIAC_1_1Character/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1Character/#variable-advance","title":"variable Advance","text":"<pre><code>unsigned int AIAC::Character::Advance;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Character/#variable-bearing","title":"variable Bearing","text":"<pre><code>glm::ivec2 AIAC::Character::Bearing;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Character/#variable-size","title":"variable Size","text":"<pre><code>glm::ivec2 AIAC::Character::Size;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Character/#variable-textureid","title":"variable TextureID","text":"<pre><code>unsigned int AIAC::Character::TextureID;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/TextRenderer.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/","title":"Class AIAC::CircularSawCutBladeThicknessVisualizer","text":"<p>ClassList &gt; AIAC &gt; CircularSawCutBladeThicknessVisualizer</p> <p>This is an inherited class to show the thickness of the blade on circular saws. </p> <ul> <li><code>#include &lt;CutCircularSawFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::CutBladeThicknessVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#public-attributes-inherited-from-aiaccutbladethicknessvisualizer","title":"Public Attributes inherited from AIAC::CutBladeThicknessVisualizer","text":"<p>See AIAC::CutBladeThicknessVisualizer</p> Type Name bool IsSegmenDetectToolPlaneVisible   = <code>false</code>&lt;"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#public-functions","title":"Public Functions","text":"Type Name CircularSawCutBladeThicknessVisualizer () = default virtual bool IntersectBladeWithNeighbours (TimberInfo::Cut * cut, TimberInfo::Cut::Face &amp; face, bool isTowardsCamera, bool isDetectToolPlane, std::shared_ptr&lt; GOLine &gt; &amp; lineIntersection) overrideThis function intersect the plane of the blade with the two(or one) neighbour faces. virtual void UpdateToolheadsData () overrideUpdate the current toolhead's data: normalStart, normEnd and center, as well the thickness. Since there could be multiple cutting toolheads (sawblade or chainsaw), we need to get the correct toolhead's type."},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#public-functions-inherited-from-aiaccutbladethicknessvisualizer","title":"Public Functions inherited from AIAC::CutBladeThicknessVisualizer","text":"<p>See AIAC::CutBladeThicknessVisualizer</p> Type Name CutBladeThicknessVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#protected-attributes-inherited-from-aiaccutbladethicknessvisualizer","title":"Protected Attributes inherited from AIAC::CutBladeThicknessVisualizer","text":"<p>See AIAC::CutBladeThicknessVisualizer</p> Type Name float m_BladeOverhangScaled the reference to the current toolhead's normal start float m_BladeTotalThicknessScaled the overhang distance of the blade's teeth from one side only glm::vec3 m_DisplacedCenterAwayFromCamera glm::vec3 m_DisplacedCenterTowardsCamera the displaced center of the face away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmenDetectToolPlane &lt; std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAwayFromCameraA the thickness A of the blade away from the camera on second neighbour side std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAwayFromCameraB the scaled thickness of the blade towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentTowardsCameraA the thickness of the blade towards the camera on second neighbour side std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentTowardsCameraB the thickness A of the blade away from the camera on first neighbour side glm::vec3 m_NormalOppositeUnitized the displaced center of the face towards the camera glm::vec3 m_NormalUnitized the opposite unitize value of the normal glm::vec3 m_ToolheadRefCenter the unitize value of the normal glm::vec3 m_ToolheadRefNormEnd the reference to the current toolhead's center glm::vec3 m_ToolheadRefNormStart the reference to the current toolhead's normal end"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#protected-functions-inherited-from-aiaccutbladethicknessvisualizer","title":"Protected Functions inherited from AIAC::CutBladeThicknessVisualizer","text":"<p>See AIAC::CutBladeThicknessVisualizer</p> Type Name virtual bool IntersectBladeWithNeighbours (AIAC::TimberInfo::Cut * cut, AIAC::TimberInfo::Cut::Face &amp; face, bool isTowardsCamera, bool isDetectToolPlane, std::shared_ptr&lt; GOLine &gt; &amp; lineIntersection) = 0This function intersect the plane of the blade with the two(or one) neighbour faces. virtual void UpdateToolheadsData () = 0Update the current toolhead's data: normalStart, normEnd and center, as well the thickness. Since there could be multiple cutting toolheads (sawblade or chainsaw), we need to get the correct toolhead's type."},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#function-circularsawcutbladethicknessvisualizer","title":"function CircularSawCutBladeThicknessVisualizer","text":"<pre><code>AIAC::CircularSawCutBladeThicknessVisualizer::CircularSawCutBladeThicknessVisualizer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#function-intersectbladewithneighbours","title":"function IntersectBladeWithNeighbours","text":"<p>This function intersect the plane of the blade with the two(or one) neighbour faces. <pre><code>virtual bool AIAC::CircularSawCutBladeThicknessVisualizer::IntersectBladeWithNeighbours (\n    TimberInfo::Cut * cut,\n    TimberInfo::Cut::Face &amp; face,\n    bool isTowardsCamera,\n    bool isDetectToolPlane,\n    std::shared_ptr&lt; GOLine &gt; &amp; lineIntersection\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cut</code> the TimberInfo::Cut object </li> <li><code>face</code> the face belonging to the cut to intersect with </li> <li><code>isTowardsCamera</code> the boolean to indicate if we intersect the blade's edge close to the camera </li> <li><code>isDetectToolPlane</code> the intersection is for the reference toolhead's plane </li> <li><code>lineIntersection</code> the reference to the line intersection</li> </ul> <p>Returns:</p> <p>bool true if the intersection is successful, false otherwise </p> <p>Implements AIAC::CutBladeThicknessVisualizer::IntersectBladeWithNeighbours</p>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#function-updatetoolheadsdata","title":"function UpdateToolheadsData","text":"<p>Update the current toolhead's data: normalStart, normEnd and center, as well the thickness. Since there could be multiple cutting toolheads (sawblade or chainsaw), we need to get the correct toolhead's type. <pre><code>virtual void AIAC::CircularSawCutBladeThicknessVisualizer::UpdateToolheadsData () override\n</code></pre></p> <p>Implements AIAC::CutBladeThicknessVisualizer::UpdateToolheadsData</p>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#friends-documentation","title":"Friends Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CircularSawCutBladeThicknessVisualizer/#friend-cutcircularsawfeedback","title":"friend CutCircularSawFeedback","text":"<pre><code>class AIAC::CircularSawCutBladeThicknessVisualizer::CutCircularSawFeedback (\n    CutCircularSawFeedback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/","title":"Class AIAC::CircularSawCutPlaneVisualizer","text":"<p>ClassList &gt; AIAC &gt; CircularSawCutPlaneVisualizer</p> <p>Inherits the following classes: AIAC::CutPlaneVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#public-functions","title":"Public Functions","text":"Type Name CircularSawCutPlaneVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#public-functions-inherited-from-aiaccutplanevisualizer","title":"Public Functions inherited from AIAC::CutPlaneVisualizer","text":"<p>See AIAC::CutPlaneVisualizer</p> Type Name virtual void Activate () override CutPlaneVisualizer ()  virtual void Deactivate () override std::vector&lt; glm::vec3 &gt; Update (glm::vec3 faceNorm, glm::vec3 facePt) Update the intersection polyline and face, and return the intersection point."},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#protected-attributes-inherited-from-aiaccutplanevisualizer","title":"Protected Attributes inherited from AIAC::CutPlaneVisualizer","text":"<p>See AIAC::CutPlaneVisualizer</p> Type Name std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentA1 the intersection line of the blade indicating the thickness away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentA2 the intersection line of the blade indicating the thickness towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAppCenterA &lt; std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAppCenterB the intersection line of the blade indicating the thickness towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentB1 the intersection line of the blade indicating the thickness away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentB2"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#function-circularsawcutplanevisualizer","title":"function CircularSawCutPlaneVisualizer","text":"<pre><code>AIAC::CircularSawCutPlaneVisualizer::CircularSawCutPlaneVisualizer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#friends-documentation","title":"Friends Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CircularSawCutPlaneVisualizer/#friend-cutcircularsawfeedback","title":"friend CutCircularSawFeedback","text":"<pre><code>class AIAC::CircularSawCutPlaneVisualizer::CutCircularSawFeedback (\n    CutCircularSawFeedback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/","title":"Struct AIAC::CircularSawData","text":"<p>ClassList &gt; AIAC &gt; CircularSawData</p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 CenterACIT center of the circle defining the circular blade std::shared_ptr&lt; GOPoint &gt; CenterGO GOPoints equivalent. std::string NameACIT name of the toolhead glm::vec3 NormEndACIT end of the normal of the blade plane std::shared_ptr&lt; GOPoint &gt; NormEndGO glm::vec3 NormStartACIT start of the normal of the blade plane std::shared_ptr&lt; GOPoint &gt; NormStartGO float OverhangACIT the overhang width of the teeth of the blade from one side float RadiusACIT radius of the circular blade float ThicknessACIT the overhaul thickness of the blade"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#public-functions","title":"Public Functions","text":"Type Name CircularSawData ()"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-centeracit","title":"variable CenterACIT","text":"<p>center of the circle defining the circular blade <pre><code>glm::vec3 AIAC::CircularSawData::CenterACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-centergo","title":"variable CenterGO","text":"<p>GOPoints equivalent. <pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::CircularSawData::CenterGO;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-nameacit","title":"variable NameACIT","text":"<p>name of the toolhead <pre><code>std::string AIAC::CircularSawData::NameACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-normendacit","title":"variable NormEndACIT","text":"<p>end of the normal of the blade plane <pre><code>glm::vec3 AIAC::CircularSawData::NormEndACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-normendgo","title":"variable NormEndGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::CircularSawData::NormEndGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-normstartacit","title":"variable NormStartACIT","text":"<p>start of the normal of the blade plane <pre><code>glm::vec3 AIAC::CircularSawData::NormStartACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-normstartgo","title":"variable NormStartGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::CircularSawData::NormStartGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-overhangacit","title":"variable OverhangACIT","text":"<p>the overhang width of the teeth of the blade from one side <pre><code>float AIAC::CircularSawData::OverhangACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-radiusacit","title":"variable RadiusACIT","text":"<p>radius of the circular blade <pre><code>float AIAC::CircularSawData::RadiusACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#variable-thicknessacit","title":"variable ThicknessACIT","text":"<p>the overhaul thickness of the blade <pre><code>float AIAC::CircularSawData::ThicknessACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1CircularSawData/#function-circularsawdata","title":"function CircularSawData","text":"<pre><code>inline AIAC::CircularSawData::CircularSawData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Config/","title":"Class AIAC::Config","text":"<p>ClassList &gt; AIAC &gt; Config</p>"},{"location":"acdoxygen/classAIAC_1_1Config/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::string AC_INFO_MODEL   = <code>\"ACInfoModel\"</code> const std::string ALIGN_FLIP   = <code>\"AlignFlip\"</code> const std::string ALIGN_OFFSET   = <code>\"AlignOffset\"</code> const std::string ALIGN_ROTATION   = <code>\"AlignRotation\"</code> const std::string CACHED_TOOLHEAD   = <code>\"CachedToolhead\"</code> const std::string CAM_FLIP_HORIZONTAL   = <code>\"CamFlipHorizontal\"</code> const std::string CAM_FLIP_VERTICAL   = <code>\"CamFlipVertical\"</code> const std::string CAM_ID   = <code>\"CamID\"</code> const std::string CAM_PARAMS_FILE   = <code>\"CamParamsFile\"</code> const std::string CONFIG_FILE   = <code>\"ConfigFile\"</code> const std::string DATASET_DIR   = <code>\"DatasetDir\"</code> const std::string LINK_MODE   = <code>\"LinkMode\"</code> const std::string MAP_FILE   = <code>\"MapFile\"</code> const std::string NAME   = <code>\"Name\"</code> const std::string RECONSTRUCT_CONFIG_DEFAULT_FILE   = <code>\"ReconstructConfigDefaultFile\"</code> const std::string RESOLUTION   = <code>\"Resolution\"</code> const std::string SAVE_DIR_MAPS   = <code>\"SaveDirMaps\"</code> const std::string SCALE_FACTOR   = <code>\"ScaleFactor\"</code> const std::string SCANNED_MODEL   = <code>\"ScannedModel\"</code> const std::string SEC_AIAC   = <code>\"AIAC\"</code> const std::string SEC_TEST   = <code>\"Test\"</code> const std::string SEC_TOUCH_MONITOR_SPECS   = <code>\"TouchMonitorSpecs\"</code> const std::string SEC_TSLAM   = <code>\"TSlam\"</code> const std::string SEC_TTOOL   = <code>\"TTool\"</code> const std::string SEC_UTILS   = <code>\"Utils\"</code> const std::string STABILIZATION_FRAME_COUNT   = <code>\"SaveDirMaps\"</code> const std::string TTOOL_ROOT_PATH   = <code>\"TToolRootPath\"</code> const std::string UTILS_PATH   = <code>\"UtilsPath\"</code> const std::string VIDEO_PATH   = <code>\"VideoPath\"</code> const std::string VocFile   = <code>\"VocFile\"</code>"},{"location":"acdoxygen/classAIAC_1_1Config/#public-functions","title":"Public Functions","text":"Type Name Config (std::string filename, bool updateFile=true)"},{"location":"acdoxygen/classAIAC_1_1Config/#public-static-functions","title":"Public Static Functions","text":"Type Name T Get (const std::string &amp; section, const std::string &amp; name)  T Get (const std::string &amp; section, const std::string &amp; name, T &amp;&amp; default_v)  std::vector&lt; T &gt; GetVector (const std::string &amp; section, const std::string &amp; name, const std::vector&lt; T &gt; &amp; default_v)  void InsertEntry (const std::string &amp; section, const std::string &amp; name, const T &amp; v)  void InsertEntry (const std::string &amp; section, const std::string &amp; name, const std::vector&lt; T &gt; &amp; vs)  void UpdateEntry (const std::string &amp; section, const std::string &amp; name, const T &amp; v)  void UpdateEntry (const std::string &amp; section, const std::string &amp; name, const std::vector&lt; T &gt; &amp; vs)  void WriteToFile (std::string writeFilename=\"\")"},{"location":"acdoxygen/classAIAC_1_1Config/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Config/#variable-ac_info_model","title":"variable AC_INFO_MODEL","text":"<pre><code>const std::string AIAC::Config::AC_INFO_MODEL;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-align_flip","title":"variable ALIGN_FLIP","text":"<pre><code>const std::string AIAC::Config::ALIGN_FLIP;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-align_offset","title":"variable ALIGN_OFFSET","text":"<pre><code>const std::string AIAC::Config::ALIGN_OFFSET;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-align_rotation","title":"variable ALIGN_ROTATION","text":"<pre><code>const std::string AIAC::Config::ALIGN_ROTATION;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-cached_toolhead","title":"variable CACHED_TOOLHEAD","text":"<pre><code>const std::string AIAC::Config::CACHED_TOOLHEAD;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-cam_flip_horizontal","title":"variable CAM_FLIP_HORIZONTAL","text":"<pre><code>const std::string AIAC::Config::CAM_FLIP_HORIZONTAL;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-cam_flip_vertical","title":"variable CAM_FLIP_VERTICAL","text":"<pre><code>const std::string AIAC::Config::CAM_FLIP_VERTICAL;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-cam_id","title":"variable CAM_ID","text":"<pre><code>const std::string AIAC::Config::CAM_ID;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-cam_params_file","title":"variable CAM_PARAMS_FILE","text":"<pre><code>const std::string AIAC::Config::CAM_PARAMS_FILE;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-config_file","title":"variable CONFIG_FILE","text":"<pre><code>const std::string AIAC::Config::CONFIG_FILE;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-dataset_dir","title":"variable DATASET_DIR","text":"<pre><code>const std::string AIAC::Config::DATASET_DIR;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-link_mode","title":"variable LINK_MODE","text":"<pre><code>const std::string AIAC::Config::LINK_MODE;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-map_file","title":"variable MAP_FILE","text":"<pre><code>const std::string AIAC::Config::MAP_FILE;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-name","title":"variable NAME","text":"<pre><code>const std::string AIAC::Config::NAME;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-reconstruct_config_default_file","title":"variable RECONSTRUCT_CONFIG_DEFAULT_FILE","text":"<pre><code>const std::string AIAC::Config::RECONSTRUCT_CONFIG_DEFAULT_FILE;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-resolution","title":"variable RESOLUTION","text":"<pre><code>const std::string AIAC::Config::RESOLUTION;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-save_dir_maps","title":"variable SAVE_DIR_MAPS","text":"<pre><code>const std::string AIAC::Config::SAVE_DIR_MAPS;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-scale_factor","title":"variable SCALE_FACTOR","text":"<pre><code>const std::string AIAC::Config::SCALE_FACTOR;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-scanned_model","title":"variable SCANNED_MODEL","text":"<pre><code>const std::string AIAC::Config::SCANNED_MODEL;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-sec_aiac","title":"variable SEC_AIAC","text":"<pre><code>const std::string AIAC::Config::SEC_AIAC;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-sec_test","title":"variable SEC_TEST","text":"<pre><code>const std::string AIAC::Config::SEC_TEST;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-sec_touch_monitor_specs","title":"variable SEC_TOUCH_MONITOR_SPECS","text":"<pre><code>const std::string AIAC::Config::SEC_TOUCH_MONITOR_SPECS;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-sec_tslam","title":"variable SEC_TSLAM","text":"<pre><code>const std::string AIAC::Config::SEC_TSLAM;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-sec_ttool","title":"variable SEC_TTOOL","text":"<pre><code>const std::string AIAC::Config::SEC_TTOOL;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-sec_utils","title":"variable SEC_UTILS","text":"<pre><code>const std::string AIAC::Config::SEC_UTILS;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-stabilization_frame_count","title":"variable STABILIZATION_FRAME_COUNT","text":"<pre><code>const std::string AIAC::Config::STABILIZATION_FRAME_COUNT;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-ttool_root_path","title":"variable TTOOL_ROOT_PATH","text":"<pre><code>const std::string AIAC::Config::TTOOL_ROOT_PATH;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-utils_path","title":"variable UTILS_PATH","text":"<pre><code>const std::string AIAC::Config::UTILS_PATH;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-video_path","title":"variable VIDEO_PATH","text":"<pre><code>const std::string AIAC::Config::VIDEO_PATH;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#variable-vocfile","title":"variable VocFile","text":"<pre><code>const std::string AIAC::Config::VocFile;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Config/#function-config","title":"function Config","text":"<pre><code>inline AIAC::Config::Config (\n    std::string filename,\n    bool updateFile=true\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Config/#function-get-12","title":"function Get [\u00bd]","text":"<pre><code>template&lt;typename T&gt;\nstatic inline T AIAC::Config::Get (\n    const std::string &amp; section,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-get-22","title":"function Get [2/2]","text":"<pre><code>template&lt;typename T&gt;\nstatic inline T AIAC::Config::Get (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    T &amp;&amp; default_v\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-getvector","title":"function GetVector","text":"<pre><code>template&lt;typename T&gt;\nstatic inline std::vector&lt; T &gt; AIAC::Config::GetVector (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const std::vector&lt; T &gt; &amp; default_v\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-insertentry-12","title":"function InsertEntry [\u00bd]","text":"<pre><code>template&lt;typename T&gt;\nstatic inline void AIAC::Config::InsertEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const T &amp; v\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-insertentry-22","title":"function InsertEntry [2/2]","text":"<pre><code>template&lt;typename T&gt;\nstatic inline void AIAC::Config::InsertEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const std::vector&lt; T &gt; &amp; vs\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-updateentry-12","title":"function UpdateEntry [\u00bd]","text":"<pre><code>template&lt;typename T&gt;\nstatic inline void AIAC::Config::UpdateEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const T &amp; v\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-updateentry-22","title":"function UpdateEntry [2/2]","text":"<pre><code>template&lt;typename T&gt;\nstatic inline void AIAC::Config::UpdateEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const std::vector&lt; T &gt; &amp; vs\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Config/#function-writetofile","title":"function WriteToFile","text":"<pre><code>static inline void AIAC::Config::WriteToFile (\n    std::string writeFilename=\"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Config.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/","title":"Class AIAC::CutBladeThicknessVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutBladeThicknessVisualizer</p> <p>The idea behind the CutBladeThicknessVisualizer is to give a visual feedback on the thickness of the blade. We do this by intersecting the two neighbours faces of the current highlighted face.</p> <ul> <li><code>#include &lt;CutBladeThicknessVisualizer.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p> <p>Inherited by the following classes: AIAC::CircularSawCutBladeThicknessVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#public-attributes","title":"Public Attributes","text":"Type Name bool IsSegmenDetectToolPlaneVisible   = <code>false</code>&lt;"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutBladeThicknessVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#protected-attributes","title":"Protected Attributes","text":"Type Name float m_BladeOverhangScaled the reference to the current toolhead's normal start float m_BladeTotalThicknessScaled the overhang distance of the blade's teeth from one side only glm::vec3 m_DisplacedCenterAwayFromCamera glm::vec3 m_DisplacedCenterTowardsCamera the displaced center of the face away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmenDetectToolPlane &lt; std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAwayFromCameraA the thickness A of the blade away from the camera on second neighbour side std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAwayFromCameraB the scaled thickness of the blade towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentTowardsCameraA the thickness of the blade towards the camera on second neighbour side std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentTowardsCameraB the thickness A of the blade away from the camera on first neighbour side glm::vec3 m_NormalOppositeUnitized the displaced center of the face towards the camera glm::vec3 m_NormalUnitized the opposite unitize value of the normal glm::vec3 m_ToolheadRefCenter the unitize value of the normal glm::vec3 m_ToolheadRefNormEnd the reference to the current toolhead's center glm::vec3 m_ToolheadRefNormStart the reference to the current toolhead's normal end"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#protected-functions","title":"Protected Functions","text":"Type Name virtual bool IntersectBladeWithNeighbours (AIAC::TimberInfo::Cut * cut, AIAC::TimberInfo::Cut::Face &amp; face, bool isTowardsCamera, bool isDetectToolPlane, std::shared_ptr&lt; GOLine &gt; &amp; lineIntersection) = 0This function intersect the plane of the blade with the two(or one) neighbour faces. virtual void UpdateToolheadsData () = 0Update the current toolhead's data: normalStart, normEnd and center, as well the thickness. Since there could be multiple cutting toolheads (sawblade or chainsaw), we need to get the correct toolhead's type."},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-issegmendetecttoolplanevisible","title":"variable IsSegmenDetectToolPlaneVisible","text":"<p>&lt; <pre><code>bool AIAC::CutBladeThicknessVisualizer::IsSegmenDetectToolPlaneVisible;\n</code></pre></p> <p>if the segment of the detected blade is visible </p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#function-cutbladethicknessvisualizer","title":"function CutBladeThicknessVisualizer","text":"<pre><code>AIAC::CutBladeThicknessVisualizer::CutBladeThicknessVisualizer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_bladeoverhangscaled","title":"variable m_BladeOverhangScaled","text":"<p>the reference to the current toolhead's normal start <pre><code>float AIAC::CutBladeThicknessVisualizer::m_BladeOverhangScaled;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_bladetotalthicknessscaled","title":"variable m_BladeTotalThicknessScaled","text":"<p>the overhang distance of the blade's teeth from one side only <pre><code>float AIAC::CutBladeThicknessVisualizer::m_BladeTotalThicknessScaled;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_displacedcenterawayfromcamera","title":"variable m_DisplacedCenterAwayFromCamera","text":"<pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_DisplacedCenterAwayFromCamera;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_displacedcentertowardscamera","title":"variable m_DisplacedCenterTowardsCamera","text":"<p>the displaced center of the face away from the camera <pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_DisplacedCenterTowardsCamera;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_longestintersectsegmendetecttoolplane","title":"variable m_LongestIntersectSegmenDetectToolPlane","text":"<p>&lt; <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutBladeThicknessVisualizer::m_LongestIntersectSegmenDetectToolPlane;\n</code></pre></p> <p>the segment where the blade is detected by the toolhead</p> <p>the thickness of the blade towards the camera on first neighbour side </p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_longestintersectsegmentawayfromcameraa","title":"variable m_LongestIntersectSegmentAwayFromCameraA","text":"<p>the thickness A of the blade away from the camera on second neighbour side <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutBladeThicknessVisualizer::m_LongestIntersectSegmentAwayFromCameraA;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_longestintersectsegmentawayfromcamerab","title":"variable m_LongestIntersectSegmentAwayFromCameraB","text":"<p>the scaled thickness of the blade towards the camera <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutBladeThicknessVisualizer::m_LongestIntersectSegmentAwayFromCameraB;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_longestintersectsegmenttowardscameraa","title":"variable m_LongestIntersectSegmentTowardsCameraA","text":"<p>the thickness of the blade towards the camera on second neighbour side <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutBladeThicknessVisualizer::m_LongestIntersectSegmentTowardsCameraA;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_longestintersectsegmenttowardscamerab","title":"variable m_LongestIntersectSegmentTowardsCameraB","text":"<p>the thickness A of the blade away from the camera on first neighbour side <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutBladeThicknessVisualizer::m_LongestIntersectSegmentTowardsCameraB;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_normaloppositeunitized","title":"variable m_NormalOppositeUnitized","text":"<p>the displaced center of the face towards the camera <pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_NormalOppositeUnitized;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_normalunitized","title":"variable m_NormalUnitized","text":"<p>the opposite unitize value of the normal <pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_NormalUnitized;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_toolheadrefcenter","title":"variable m_ToolheadRefCenter","text":"<p>the unitize value of the normal <pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_ToolheadRefCenter;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_toolheadrefnormend","title":"variable m_ToolheadRefNormEnd","text":"<p>the reference to the current toolhead's center <pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_ToolheadRefNormEnd;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#variable-m_toolheadrefnormstart","title":"variable m_ToolheadRefNormStart","text":"<p>the reference to the current toolhead's normal end <pre><code>glm::vec3 AIAC::CutBladeThicknessVisualizer::m_ToolheadRefNormStart;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#function-intersectbladewithneighbours","title":"function IntersectBladeWithNeighbours","text":"<p>This function intersect the plane of the blade with the two(or one) neighbour faces. <pre><code>virtual bool AIAC::CutBladeThicknessVisualizer::IntersectBladeWithNeighbours (\n    AIAC::TimberInfo::Cut * cut,\n    AIAC::TimberInfo::Cut::Face &amp; face,\n    bool isTowardsCamera,\n    bool isDetectToolPlane,\n    std::shared_ptr&lt; GOLine &gt; &amp; lineIntersection\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cut</code> the TimberInfo::Cut object </li> <li><code>face</code> the face belonging to the cut to intersect with </li> <li><code>isTowardsCamera</code> the boolean to indicate if we intersect the blade's edge close to the camera </li> <li><code>isDetectToolPlane</code> the intersection is for the reference toolhead's plane </li> <li><code>lineIntersection</code> the reference to the line intersection</li> </ul> <p>Returns:</p> <p>bool true if the intersection is successful, false otherwise </p>"},{"location":"acdoxygen/classAIAC_1_1CutBladeThicknessVisualizer/#function-updatetoolheadsdata","title":"function UpdateToolheadsData","text":"<p>Update the current toolhead's data: normalStart, normEnd and center, as well the thickness. Since there could be multiple cutting toolheads (sawblade or chainsaw), we need to get the correct toolhead's type. <pre><code>virtual void AIAC::CutBladeThicknessVisualizer::UpdateToolheadsData () = 0\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutBladeThicknessVisualizer.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/","title":"Class AIAC::CutChainSawAngleFeedVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutChainSawAngleFeedVisualizer</p> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutChainSawAngleFeedVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutChainSawAngleFeedVisualizer/#function-cutchainsawanglefeedvisualizer","title":"function CutChainSawAngleFeedVisualizer","text":"<pre><code>AIAC::CutChainSawAngleFeedVisualizer::CutChainSawAngleFeedVisualizer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/","title":"Class AIAC::CutChainSawDepthFeedVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutChainSawDepthFeedVisualizer</p> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutChainSawDepthFeedVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutChainSawDepthFeedVisualizer/#function-cutchainsawdepthfeedvisualizer","title":"function CutChainSawDepthFeedVisualizer","text":"<pre><code>AIAC::CutChainSawDepthFeedVisualizer::CutChainSawDepthFeedVisualizer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/","title":"Class AIAC::CutChainSawFeedVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutChainSawFeedVisualizer</p> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutChainSawFeedVisualizer ()  CutChainSawAngleFeedVisualizer &amp; GetAngleFeedVisualizer ()  CutChainSawDepthFeedVisualizer &amp; GetDepthFeedVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#function-cutchainsawfeedvisualizer","title":"function CutChainSawFeedVisualizer","text":"<pre><code>AIAC::CutChainSawFeedVisualizer::CutChainSawFeedVisualizer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#function-getanglefeedvisualizer","title":"function GetAngleFeedVisualizer","text":"<pre><code>inline CutChainSawAngleFeedVisualizer &amp; AIAC::CutChainSawFeedVisualizer::GetAngleFeedVisualizer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedVisualizer/#function-getdepthfeedvisualizer","title":"function GetDepthFeedVisualizer","text":"<pre><code>inline CutChainSawDepthFeedVisualizer &amp; AIAC::CutChainSawFeedVisualizer::GetDepthFeedVisualizer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/","title":"Class AIAC::CutChainSawFeedback","text":"<p>ClassList &gt; AIAC &gt; CutChainSawFeedback</p> <p>Inherits the following classes: AIAC::FabFeedback</p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#public-attributes","title":"Public Attributes","text":"Type Name bool IsRefFacesSelectedManually   = <code>false</code>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#public-functions","title":"Public Functions","text":"Type Name virtual void Activate () override CutChainSawFeedback () = default virtual void Deactivate () override void EnableCutPlane (bool enable)  void ManuallyScrollRefFace (int scrollDirection)  virtual void Update () override"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#public-functions-inherited-from-aiacfabfeedback","title":"Public Functions inherited from AIAC::FabFeedback","text":"<p>See AIAC::FabFeedback</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FabFeedback ()  virtual void Update ()  ~FabFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#protected-attributes-inherited-from-aiacfabfeedback","title":"Protected Attributes inherited from AIAC::FabFeedback","text":"<p>See AIAC::FabFeedback</p> Type Name float m_ScaleFactor   = <code>0.0f</code>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#variable-isreffacesselectedmanually","title":"variable IsRefFacesSelectedManually","text":"<pre><code>bool AIAC::CutChainSawFeedback::IsRefFacesSelectedManually;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#function-activate","title":"function Activate","text":"<pre><code>virtual void AIAC::CutChainSawFeedback::Activate () override\n</code></pre> <p>Implements AIAC::FabFeedback::Activate</p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#function-cutchainsawfeedback","title":"function CutChainSawFeedback","text":"<pre><code>AIAC::CutChainSawFeedback::CutChainSawFeedback () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#function-deactivate","title":"function Deactivate","text":"<pre><code>virtual void AIAC::CutChainSawFeedback::Deactivate () override\n</code></pre> <p>Implements AIAC::FabFeedback::Deactivate</p>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#function-enablecutplane","title":"function EnableCutPlane","text":"<pre><code>inline void AIAC::CutChainSawFeedback::EnableCutPlane (\n    bool enable\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#function-manuallyscrollrefface","title":"function ManuallyScrollRefFace","text":"<pre><code>void AIAC::CutChainSawFeedback::ManuallyScrollRefFace (\n    int scrollDirection\n) \n</code></pre> <p>Manually select the reference face (the nearest parallel face) </p> <p>Parameters:</p> <ul> <li><code>scrollDirection</code> when &gt; 0, goes to next; &lt;= 0, goes back. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1CutChainSawFeedback/#function-update","title":"function Update","text":"<pre><code>virtual void AIAC::CutChainSawFeedback::Update () override\n</code></pre> <p>Implements AIAC::FabFeedback::Update</p> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/","title":"Class AIAC::CutCircularOrientationVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutCircularOrientationVisualizer</p> <p>This visualizer ggdb ives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. </p> <ul> <li><code>#include &lt;CutCircularSawFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutCircularOrientationVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularOrientationVisualizer/#function-cutcircularorientationvisualizer","title":"function CutCircularOrientationVisualizer","text":"<pre><code>AIAC::CutCircularOrientationVisualizer::CutCircularOrientationVisualizer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/","title":"Class AIAC::CutCircularSawDepthVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutCircularSawDepthVisualizer</p> <p>Visualizer for showing the depth of the cut. </p> <ul> <li><code>#include &lt;CutCircularSawFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutCircularSawDepthVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularSawDepthVisualizer/#function-cutcircularsawdepthvisualizer","title":"function CutCircularSawDepthVisualizer","text":"<pre><code>AIAC::CutCircularSawDepthVisualizer::CutCircularSawDepthVisualizer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/","title":"Class AIAC::CutCircularSawFeedback","text":"<p>ClassList &gt; AIAC &gt; CutCircularSawFeedback</p> <p>Inherits the following classes: AIAC::FabFeedback</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#public-attributes","title":"Public Attributes","text":"Type Name bool IsRefFacesSelectedManually   = <code>false</code>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#public-functions","title":"Public Functions","text":"Type Name virtual void Activate () override CutCircularSawFeedback () = default virtual void Deactivate () override void EnableCutPlane (bool enable)  void ManuallyScrollRefFace (int scrollDirection)  virtual void Update () override ~CutCircularSawFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#public-functions-inherited-from-aiacfabfeedback","title":"Public Functions inherited from AIAC::FabFeedback","text":"<p>See AIAC::FabFeedback</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FabFeedback ()  virtual void Update ()  ~FabFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#protected-attributes-inherited-from-aiacfabfeedback","title":"Protected Attributes inherited from AIAC::FabFeedback","text":"<p>See AIAC::FabFeedback</p> Type Name float m_ScaleFactor   = <code>0.0f</code>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#variable-isreffacesselectedmanually","title":"variable IsRefFacesSelectedManually","text":"<pre><code>bool AIAC::CutCircularSawFeedback::IsRefFacesSelectedManually;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-activate","title":"function Activate","text":"<pre><code>virtual void AIAC::CutCircularSawFeedback::Activate () override\n</code></pre> <p>Implements AIAC::FabFeedback::Activate</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-cutcircularsawfeedback","title":"function CutCircularSawFeedback","text":"<pre><code>AIAC::CutCircularSawFeedback::CutCircularSawFeedback () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-deactivate","title":"function Deactivate","text":"<pre><code>virtual void AIAC::CutCircularSawFeedback::Deactivate () override\n</code></pre> <p>Implements AIAC::FabFeedback::Deactivate</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-enablecutplane","title":"function EnableCutPlane","text":"<pre><code>inline void AIAC::CutCircularSawFeedback::EnableCutPlane (\n    bool enable\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-manuallyscrollrefface","title":"function ManuallyScrollRefFace","text":"<pre><code>void AIAC::CutCircularSawFeedback::ManuallyScrollRefFace (\n    int scrollDirection\n) \n</code></pre> <p>Manually select the reference face (the nearest parallel face) </p> <p>Parameters:</p> <ul> <li><code>scrollDirection</code> when &gt; 0, goes to next; &lt;= 0, goes back. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-update","title":"function Update","text":"<pre><code>virtual void AIAC::CutCircularSawFeedback::Update () override\n</code></pre> <p>Implements AIAC::FabFeedback::Update</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawFeedback/#function-cutcircularsawfeedback_1","title":"function ~CutCircularSawFeedback","text":"<pre><code>AIAC::CutCircularSawFeedback::~CutCircularSawFeedback () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/","title":"Class AIAC::CutCircularSawPositionStartVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutCircularSawPositionStartVisualizer</p> <p>This visualizer gives guidance on the start position of the lateral cuts for the circular saw. </p> <ul> <li><code>#include &lt;CutCircularSawFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#public-attributes","title":"Public Attributes","text":"Type Name float ToleranceStartThreshold   = <code>0.2f</code>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutCircularSawPositionStartVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#variable-tolerancestartthreshold","title":"variable ToleranceStartThreshold","text":"<pre><code>float AIAC::CutCircularSawPositionStartVisualizer::ToleranceStartThreshold;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#function-cutcircularsawpositionstartvisualizer","title":"function CutCircularSawPositionStartVisualizer","text":"<pre><code>AIAC::CutCircularSawPositionStartVisualizer::CutCircularSawPositionStartVisualizer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#friends-documentation","title":"Friends Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutCircularSawPositionStartVisualizer/#friend-cutcircularsawfeedback","title":"friend CutCircularSawFeedback","text":"<pre><code>class AIAC::CutCircularSawPositionStartVisualizer::CutCircularSawFeedback (\n    CutCircularSawFeedback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/","title":"Class AIAC::CutOrientationVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutOrientationVisualizer</p> <p>This visualizer gives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. </p> <ul> <li><code>#include &lt;CutChainSawFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/#public-functions","title":"Public Functions","text":"Type Name CutOrientationVisualizer ()"},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutOrientationVisualizer/#function-cutorientationvisualizer","title":"function CutOrientationVisualizer","text":"<pre><code>AIAC::CutOrientationVisualizer::CutOrientationVisualizer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/","title":"Class AIAC::CutPlaneVisualizer","text":"<p>ClassList &gt; AIAC &gt; CutPlaneVisualizer</p> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p> <p>Inherited by the following classes: AIAC::ChainSawCutPlaneVisualizer,  AIAC::CircularSawCutPlaneVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#public-functions","title":"Public Functions","text":"Type Name virtual void Activate () override CutPlaneVisualizer ()  virtual void Deactivate () override std::vector&lt; glm::vec3 &gt; Update (glm::vec3 faceNorm, glm::vec3 facePt) Update the intersection polyline and face, and return the intersection point."},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#protected-attributes","title":"Protected Attributes","text":"Type Name std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentA1 the intersection line of the blade indicating the thickness away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentA2 the intersection line of the blade indicating the thickness towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAppCenterA &lt; std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentAppCenterB the intersection line of the blade indicating the thickness towards the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentB1 the intersection line of the blade indicating the thickness away from the camera std::shared_ptr&lt; GOLine &gt; m_LongestIntersectSegmentB2"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#function-activate","title":"function Activate","text":"<pre><code>virtual void AIAC::CutPlaneVisualizer::Activate () override\n</code></pre> <p>Implements AIAC::FeedbackVisualizer::Activate</p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#function-cutplanevisualizer","title":"function CutPlaneVisualizer","text":"<pre><code>AIAC::CutPlaneVisualizer::CutPlaneVisualizer () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#function-deactivate","title":"function Deactivate","text":"<pre><code>virtual void AIAC::CutPlaneVisualizer::Deactivate () override\n</code></pre> <p>Implements AIAC::FeedbackVisualizer::Deactivate</p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#function-update","title":"function Update","text":"<p>Update the intersection polyline and face, and return the intersection point. <pre><code>std::vector&lt; glm::vec3 &gt; AIAC::CutPlaneVisualizer::Update (\n    glm::vec3 faceNorm,\n    glm::vec3 facePt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>faceNorm</code> the normal of the face </li> <li><code>facePt</code> the point on the face </li> </ul> <p>Returns:</p> <p>std::vector&lt;glm::vec3&gt; the intersection point of the bbox and the face </p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#variable-m_longestintersectsegmenta1","title":"variable m_LongestIntersectSegmentA1","text":"<p>the intersection line of the blade indicating the thickness away from the camera <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutPlaneVisualizer::m_LongestIntersectSegmentA1;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#variable-m_longestintersectsegmenta2","title":"variable m_LongestIntersectSegmentA2","text":"<p>the intersection line of the blade indicating the thickness towards the camera <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutPlaneVisualizer::m_LongestIntersectSegmentA2;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#variable-m_longestintersectsegmentappcentera","title":"variable m_LongestIntersectSegmentAppCenterA","text":"<p>&lt; <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutPlaneVisualizer::m_LongestIntersectSegmentAppCenterA;\n</code></pre></p> <p>the intersection of the top plane of the blade from the closest side to the center of the blade</p> <p>the intersection of the top plane of the blade from the second closest side to the center of the blade </p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#variable-m_longestintersectsegmentappcenterb","title":"variable m_LongestIntersectSegmentAppCenterB","text":"<p>the intersection line of the blade indicating the thickness towards the camera <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutPlaneVisualizer::m_LongestIntersectSegmentAppCenterB;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#variable-m_longestintersectsegmentb1","title":"variable m_LongestIntersectSegmentB1","text":"<p>the intersection line of the blade indicating the thickness away from the camera <pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutPlaneVisualizer::m_LongestIntersectSegmentB1;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1CutPlaneVisualizer/#variable-m_longestintersectsegmentb2","title":"variable m_LongestIntersectSegmentB2","text":"<pre><code>std::shared_ptr&lt;GOLine&gt; AIAC::CutPlaneVisualizer::m_LongestIntersectSegmentB2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutPlaneVisualizer.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1CylinderPole/","title":"Struct AIAC::CylinderPole","text":"<p>ClassList &gt; AIAC &gt; CylinderPole</p>"},{"location":"acdoxygen/structAIAC_1_1CylinderPole/#public-attributes","title":"Public Attributes","text":"Type Name GLfloat x GLfloat z"},{"location":"acdoxygen/structAIAC_1_1CylinderPole/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1CylinderPole/#variable-x","title":"variable x","text":"<pre><code>GLfloat AIAC::CylinderPole::x;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1CylinderPole/#variable-z","title":"variable z","text":"<pre><code>GLfloat AIAC::CylinderPole::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.cpp</code></p>"},{"location":"acdoxygen/classAIAC_1_1DLoader/","title":"Class AIAC::DLoader","text":"<p>ClassList &gt; AIAC &gt; DLoader</p>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#public-functions","title":"Public Functions","text":"Type Name void CvtAssimpMeshColorsToGlmVector (const aiMesh * mesh, std::vector&lt; glm::vec3 &gt; &amp; glmColors)  void CvtAssimpMeshFacesToGlmVector (const aiMesh * mesh, std::vector&lt; uint32_t &gt; &amp; glmIndices)  void CvtAssimpMeshNormalsToGlmVector (const aiMesh * mesh, std::vector&lt; glm::vec3 &gt; &amp; glmNormals)  bool CvtAssimpMeshToGOMesh (const aiMesh * mesh, GOMesh &amp; goMesh)  void CvtAssimpMeshVerticesToGlmVector (const aiMesh * mesh, std::vector&lt; glm::vec3 &gt; &amp; glmVertices)  DLoader () = default bool LoadGOMesh (const char * path, GOMesh &amp; goMesh)  ~DLoader () = default"},{"location":"acdoxygen/classAIAC_1_1DLoader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-cvtassimpmeshcolorstoglmvector","title":"function CvtAssimpMeshColorsToGlmVector","text":"<pre><code>void AIAC::DLoader::CvtAssimpMeshColorsToGlmVector (\n    const aiMesh * mesh,\n    std::vector&lt; glm::vec3 &gt; &amp; glmColors\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-cvtassimpmeshfacestoglmvector","title":"function CvtAssimpMeshFacesToGlmVector","text":"<pre><code>void AIAC::DLoader::CvtAssimpMeshFacesToGlmVector (\n    const aiMesh * mesh,\n    std::vector&lt; uint32_t &gt; &amp; glmIndices\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-cvtassimpmeshnormalstoglmvector","title":"function CvtAssimpMeshNormalsToGlmVector","text":"<pre><code>void AIAC::DLoader::CvtAssimpMeshNormalsToGlmVector (\n    const aiMesh * mesh,\n    std::vector&lt; glm::vec3 &gt; &amp; glmNormals\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-cvtassimpmeshtogomesh","title":"function CvtAssimpMeshToGOMesh","text":"<pre><code>bool AIAC::DLoader::CvtAssimpMeshToGOMesh (\n    const aiMesh * mesh,\n    GOMesh &amp; goMesh\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-cvtassimpmeshverticestoglmvector","title":"function CvtAssimpMeshVerticesToGlmVector","text":"<pre><code>void AIAC::DLoader::CvtAssimpMeshVerticesToGlmVector (\n    const aiMesh * mesh,\n    std::vector&lt; glm::vec3 &gt; &amp; glmVertices\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-dloader","title":"function DLoader","text":"<pre><code>AIAC::DLoader::DLoader () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-loadgomesh","title":"function LoadGOMesh","text":"<pre><code>bool AIAC::DLoader::LoadGOMesh (\n    const char * path,\n    GOMesh &amp; goMesh\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1DLoader/#function-dloader_1","title":"function ~DLoader","text":"<pre><code>AIAC::DLoader::~DLoader () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/DLoader.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/","title":"Struct AIAC::DrillBitData","text":"<p>ClassList &gt; AIAC &gt; DrillBitData</p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#public-attributes","title":"Public Attributes","text":"Type Name glm::vec3 ChucktipACIT original position of the end of the drill chuck std::shared_ptr&lt; GOPoint &gt; ChucktipGO glm::vec3 EattipACIT original position of the tip of the toolhead eating the material std::shared_ptr&lt; GOPoint &gt; EattipGO std::string NameACIT name of the toolhead float RadiusACIT radius of the drillbit glm::vec3 ToolbaseACIT original position of the base of the toolhead std::shared_ptr&lt; GOPoint &gt; ToolbaseGO GOPoints equivalent. glm::vec3 TooltipACIT original position of the tip of the toolhead std::shared_ptr&lt; GOPoint &gt; TooltipGO"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#public-functions","title":"Public Functions","text":"Type Name DrillBitData ()"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-chucktipacit","title":"variable ChucktipACIT","text":"<p>original position of the end of the drill chuck <pre><code>glm::vec3 AIAC::DrillBitData::ChucktipACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-chucktipgo","title":"variable ChucktipGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::DrillBitData::ChucktipGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-eattipacit","title":"variable EattipACIT","text":"<p>original position of the tip of the toolhead eating the material <pre><code>glm::vec3 AIAC::DrillBitData::EattipACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-eattipgo","title":"variable EattipGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::DrillBitData::EattipGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-nameacit","title":"variable NameACIT","text":"<p>name of the toolhead <pre><code>std::string AIAC::DrillBitData::NameACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-radiusacit","title":"variable RadiusACIT","text":"<p>radius of the drillbit <pre><code>float AIAC::DrillBitData::RadiusACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-toolbaseacit","title":"variable ToolbaseACIT","text":"<p>original position of the base of the toolhead <pre><code>glm::vec3 AIAC::DrillBitData::ToolbaseACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-toolbasego","title":"variable ToolbaseGO","text":"<p>GOPoints equivalent. <pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::DrillBitData::ToolbaseGO;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-tooltipacit","title":"variable TooltipACIT","text":"<p>original position of the tip of the toolhead <pre><code>glm::vec3 AIAC::DrillBitData::TooltipACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#variable-tooltipgo","title":"variable TooltipGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::DrillBitData::TooltipGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1DrillBitData/#function-drillbitdata","title":"function DrillBitData","text":"<pre><code>inline AIAC::DrillBitData::DrillBitData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Event/","title":"Class AIAC::Event","text":"<p>ClassList &gt; AIAC &gt; Event</p> <p>Inherited by the following classes: AIAC::AppCloseEvent,  AIAC::CameraCalibrationLoadedEvent,  AIAC::SLAMCombineMapEvent,  AIAC::SLAMMapLoadedEvent,  AIAC::SLAMStartMappingEvent,  AIAC::SLAMStopMappingEvent,  AIAC::SLAMVocabularyLoadedEvent</p>"},{"location":"acdoxygen/classAIAC_1_1Event/#public-functions","title":"Public Functions","text":"Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1Event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Event/#function-event","title":"function Event","text":"<pre><code>inline explicit AIAC::Event::Event (\n    const EventType type,\n    const EventCategory category=EventCategory::None,\n    int32_t priority=0\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Event/#function-getcategory","title":"function GetCategory","text":"<pre><code>inline EventCategory AIAC::Event::GetCategory () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Event/#function-gettype","title":"function GetType","text":"<pre><code>inline EventType AIAC::Event::GetType () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Event/#function-event_1","title":"function ~Event","text":"<pre><code>virtual AIAC::Event::~Event () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/Event.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1EventBus/","title":"Class AIAC::EventBus","text":"<p>ClassList &gt; AIAC &gt; EventBus</p>"},{"location":"acdoxygen/classAIAC_1_1EventBus/#public-functions","title":"Public Functions","text":"Type Name void DispatchEvent (const EventPointer &amp; sharedPtrEvent)  void EnqueueEvent (const EventPointer &amp; sharedPtrEvent)  void Init ()  bool IsEventQueueEmpty () const void ProcessQueue ()  ~EventBus () = default"},{"location":"acdoxygen/classAIAC_1_1EventBus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1EventBus/#function-dispatchevent","title":"function DispatchEvent","text":"<pre><code>inline void AIAC::EventBus::DispatchEvent (\n    const EventPointer &amp; sharedPtrEvent\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1EventBus/#function-enqueueevent","title":"function EnqueueEvent","text":"<pre><code>inline void AIAC::EventBus::EnqueueEvent (\n    const EventPointer &amp; sharedPtrEvent\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1EventBus/#function-init","title":"function Init","text":"<pre><code>inline void AIAC::EventBus::Init () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1EventBus/#function-iseventqueueempty","title":"function IsEventQueueEmpty","text":"<pre><code>inline bool AIAC::EventBus::IsEventQueueEmpty () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1EventBus/#function-processqueue","title":"function ProcessQueue","text":"<pre><code>inline void AIAC::EventBus::ProcessQueue () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1EventBus/#function-eventbus","title":"function ~EventBus","text":"<pre><code>AIAC::EventBus::~EventBus () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/EventBus.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1EventCompare/","title":"Struct AIAC::EventCompare","text":"<p>ClassList &gt; AIAC &gt; EventCompare</p>"},{"location":"acdoxygen/structAIAC_1_1EventCompare/#public-functions","title":"Public Functions","text":"Type Name bool operator() (const T &amp; a, const T &amp; b) const"},{"location":"acdoxygen/structAIAC_1_1EventCompare/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1EventCompare/#function-operator","title":"function operator()","text":"<pre><code>template&lt;typename T&gt;\ninline bool AIAC::EventCompare::operator() (\n    const T &amp; a,\n    const T &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/Event.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1EventPolicy/","title":"Struct AIAC::EventPolicy","text":"<p>ClassList &gt; AIAC &gt; EventPolicy</p>"},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#public-types","title":"Public Types","text":"Type Name typedef std::priority_queue&lt; Item, std::vector&lt; Item &gt;, EventCompare &gt; PrioriQueueListtyQueue"},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#public-static-functions","title":"Public Static Functions","text":"Type Name EventCategory GetCategory (const EventPointer &amp; event)  EventType GetEvent (const EventPointer &amp; event)"},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#typedef-prioriqueuelisttyqueue","title":"typedef PrioriQueueListtyQueue","text":"<pre><code>using AIAC::EventPolicy::PrioriQueueListtyQueue =  std::priority_queue&lt;Item, std::vector&lt;Item&gt;, EventCompare&gt;;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#function-getcategory","title":"function GetCategory","text":"<pre><code>static inline EventCategory AIAC::EventPolicy::GetCategory (\n    const EventPointer &amp; event\n) \n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1EventPolicy/#function-getevent","title":"function GetEvent","text":"<pre><code>static inline EventType AIAC::EventPolicy::GetEvent (\n    const EventPointer &amp; event\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/Event.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/","title":"Class AIAC::FabFeedback","text":"<p>ClassList &gt; AIAC &gt; FabFeedback</p> <p>Inherited by the following classes: AIAC::CutChainSawFeedback,  AIAC::CutCircularSawFeedback,  AIAC::HoleFeedback</p>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#public-functions","title":"Public Functions","text":"Type Name virtual void Activate ()  virtual void Deactivate ()  FabFeedback ()  virtual void Update ()  ~FabFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#protected-attributes","title":"Protected Attributes","text":"Type Name float m_ScaleFactor   = <code>0.0f</code>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#function-activate","title":"function Activate","text":"<pre><code>inline virtual void AIAC::FabFeedback::Activate () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#function-deactivate","title":"function Deactivate","text":"<pre><code>inline virtual void AIAC::FabFeedback::Deactivate () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#function-fabfeedback","title":"function FabFeedback","text":"<pre><code>inline AIAC::FabFeedback::FabFeedback () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#function-update","title":"function Update","text":"<pre><code>inline virtual void AIAC::FabFeedback::Update () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#function-fabfeedback_1","title":"function ~FabFeedback","text":"<pre><code>AIAC::FabFeedback::~FabFeedback () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1FabFeedback/#variable-m_scalefactor","title":"variable m_ScaleFactor","text":"<pre><code>float AIAC::FabFeedback::m_ScaleFactor;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/FabFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/","title":"Class AIAC::FeedbackVisualizer","text":"<p>ClassList &gt; AIAC &gt; FeedbackVisualizer</p> <p>Inherited by the following classes: AIAC::CutBladeThicknessVisualizer,  AIAC::CutChainSawAngleFeedVisualizer,  AIAC::CutChainSawDepthFeedVisualizer,  AIAC::CutChainSawFeedVisualizer,  AIAC::CutCircularOrientationVisualizer,  AIAC::CutCircularSawDepthVisualizer,  AIAC::CutCircularSawPositionStartVisualizer,  AIAC::CutOrientationVisualizer,  AIAC::CutPlaneVisualizer,  AIAC::HoleFeedbackPosition,  AIAC::HoleFeedbackRotation,  AIAC::HoleFeedbackText</p>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#public-functions","title":"Public Functions","text":"Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#public-static-functions","title":"Public Static Functions","text":"Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#function-activate","title":"function Activate","text":"<pre><code>inline virtual void AIAC::FeedbackVisualizer::Activate () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#function-deactivate","title":"function Deactivate","text":"<pre><code>inline virtual void AIAC::FeedbackVisualizer::Deactivate () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#function-feedbackvisualizer","title":"function FeedbackVisualizer","text":"<pre><code>AIAC::FeedbackVisualizer::FeedbackVisualizer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#function-feedbackvisualizer_1","title":"function ~FeedbackVisualizer","text":"<pre><code>AIAC::FeedbackVisualizer::~FeedbackVisualizer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#function-tostring","title":"function toString","text":"<p>Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\". <pre><code>static inline std::string AIAC::FeedbackVisualizer::toString (\n    double val\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1FeedbackVisualizer/#variable-m_allprimitives","title":"variable m_AllPrimitives","text":"<pre><code>std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt; &gt; AIAC::FeedbackVisualizer::m_AllPrimitives;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/FeedbackVisualizer.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/","title":"Class AIAC::GLLineObject","text":"<p>ClassList &gt; AIAC &gt; GLLineObject</p> <p>Inherits the following classes: AIAC::GLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#public-attributes","title":"Public Attributes","text":"Type Name GLfloat lineWidth"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#public-attributes-inherited-from-aiacglobject","title":"Public Attributes inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name GLuint colorBuf GLsizei size GLObjectType type GLuint vertexBuf"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#public-functions","title":"Public Functions","text":"Type Name virtual void Draw ()  GLLineObject ()  GLLineObject (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors, GLfloat lineWidth=1.0f)  GLLineObject (const GLLineObject &amp; other)  GLLineObject &amp; operator= (const GLLineObject &amp; other)"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#public-functions-inherited-from-aiacglobject","title":"Public Functions inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name void DeleteVBOs ()  virtual void Draw () = 0 GLObject () = default GLObject (const GLObject &amp; other)  GLObject &amp; operator= (const GLObject &amp; other)  ~GLObject ()"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#protected-functions-inherited-from-aiacglobject","title":"Protected Functions inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name void BindVBOs ()  void BufferData (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors)"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#variable-linewidth","title":"variable lineWidth","text":"<pre><code>GLfloat AIAC::GLLineObject::lineWidth;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#function-draw","title":"function Draw","text":"<pre><code>virtual void AIAC::GLLineObject::Draw () \n</code></pre> <p>Implements AIAC::GLObject::Draw</p>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#function-gllineobject-13","title":"function GLLineObject [\u2153]","text":"<pre><code>inline AIAC::GLLineObject::GLLineObject () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#function-gllineobject-23","title":"function GLLineObject [\u2154]","text":"<pre><code>AIAC::GLLineObject::GLLineObject (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors,\n    GLfloat lineWidth=1.0f\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#function-gllineobject-33","title":"function GLLineObject [3/3]","text":"<pre><code>inline AIAC::GLLineObject::GLLineObject (\n    const GLLineObject &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLLineObject/#function-operator","title":"function operator=","text":"<pre><code>inline GLLineObject &amp; AIAC::GLLineObject::operator= (\n    const GLLineObject &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/","title":"Class AIAC::GLMeshObject","text":"<p>ClassList &gt; AIAC &gt; GLMeshObject</p> <p>Inherits the following classes: AIAC::GLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#public-attributes","title":"Public Attributes","text":"Type Name GLuint indexBuf std::vector&lt; glm::vec4 &gt; m_Colors std::vector&lt; uint32_t &gt; m_Indices std::vector&lt; glm::vec3 &gt; m_Vertices"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#public-attributes-inherited-from-aiacglobject","title":"Public Attributes inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name GLuint colorBuf GLsizei size GLObjectType type GLuint vertexBuf"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#public-functions","title":"Public Functions","text":"Type Name virtual void Draw ()  GLMeshObject ()  GLMeshObject (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors, const std::vector&lt; uint32_t &gt; &amp; indices)  GLMeshObject (const GLMeshObject &amp; other)  GLMeshObject &amp; operator= (const GLMeshObject &amp; other)"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#public-functions-inherited-from-aiacglobject","title":"Public Functions inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name void DeleteVBOs ()  virtual void Draw () = 0 GLObject () = default GLObject (const GLObject &amp; other)  GLObject &amp; operator= (const GLObject &amp; other)  ~GLObject ()"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#protected-functions-inherited-from-aiacglobject","title":"Protected Functions inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name void BindVBOs ()  void BufferData (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors)"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#variable-indexbuf","title":"variable indexBuf","text":"<pre><code>GLuint AIAC::GLMeshObject::indexBuf;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#variable-m_colors","title":"variable m_Colors","text":"<pre><code>std::vector&lt;glm::vec4&gt; AIAC::GLMeshObject::m_Colors;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#variable-m_indices","title":"variable m_Indices","text":"<pre><code>std::vector&lt;uint32_t&gt; AIAC::GLMeshObject::m_Indices;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#variable-m_vertices","title":"variable m_Vertices","text":"<pre><code>std::vector&lt;glm::vec3&gt; AIAC::GLMeshObject::m_Vertices;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#function-draw","title":"function Draw","text":"<pre><code>virtual void AIAC::GLMeshObject::Draw () \n</code></pre> <p>Implements AIAC::GLObject::Draw</p>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#function-glmeshobject-13","title":"function GLMeshObject [\u2153]","text":"<pre><code>inline AIAC::GLMeshObject::GLMeshObject () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#function-glmeshobject-23","title":"function GLMeshObject [\u2154]","text":"<pre><code>AIAC::GLMeshObject::GLMeshObject (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors,\n    const std::vector&lt; uint32_t &gt; &amp; indices\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#function-glmeshobject-33","title":"function GLMeshObject [3/3]","text":"<pre><code>inline AIAC::GLMeshObject::GLMeshObject (\n    const GLMeshObject &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLMeshObject/#function-operator","title":"function operator=","text":"<pre><code>inline GLMeshObject &amp; AIAC::GLMeshObject::operator= (\n    const GLMeshObject &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GLObject/","title":"Class AIAC::GLObject","text":"<p>ClassList &gt; AIAC &gt; GLObject</p> <p>Inherited by the following classes: AIAC::GLLineObject,  AIAC::GLMeshObject,  AIAC::GLPointObject</p>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#public-attributes","title":"Public Attributes","text":"Type Name GLuint colorBuf GLsizei size GLObjectType type GLuint vertexBuf"},{"location":"acdoxygen/classAIAC_1_1GLObject/#public-functions","title":"Public Functions","text":"Type Name void DeleteVBOs ()  virtual void Draw () = 0 GLObject () = default GLObject (const GLObject &amp; other)  GLObject &amp; operator= (const GLObject &amp; other)  ~GLObject ()"},{"location":"acdoxygen/classAIAC_1_1GLObject/#protected-functions","title":"Protected Functions","text":"Type Name void BindVBOs ()  void BufferData (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors)"},{"location":"acdoxygen/classAIAC_1_1GLObject/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLObject/#variable-colorbuf","title":"variable colorBuf","text":"<pre><code>GLuint AIAC::GLObject::colorBuf;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#variable-size","title":"variable size","text":"<pre><code>GLsizei AIAC::GLObject::size;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#variable-type","title":"variable type","text":"<pre><code>GLObjectType AIAC::GLObject::type;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#variable-vertexbuf","title":"variable vertexBuf","text":"<pre><code>GLuint AIAC::GLObject::vertexBuf;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-deletevbos","title":"function DeleteVBOs","text":"<pre><code>void AIAC::GLObject::DeleteVBOs () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-draw","title":"function Draw","text":"<pre><code>virtual void AIAC::GLObject::Draw () = 0\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-globject-12","title":"function GLObject [\u00bd]","text":"<pre><code>AIAC::GLObject::GLObject () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-globject-22","title":"function GLObject [2/2]","text":"<pre><code>inline AIAC::GLObject::GLObject (\n    const GLObject &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-operator","title":"function operator=","text":"<pre><code>inline GLObject &amp; AIAC::GLObject::operator= (\n    const GLObject &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-globject","title":"function ~GLObject","text":"<pre><code>inline AIAC::GLObject::~GLObject () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-bindvbos","title":"function BindVBOs","text":"<pre><code>void AIAC::GLObject::BindVBOs () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLObject/#function-bufferdata","title":"function BufferData","text":"<pre><code>void AIAC::GLObject::BufferData (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/","title":"Class AIAC::GLPointObject","text":"<p>ClassList &gt; AIAC &gt; GLPointObject</p> <p>Inherits the following classes: AIAC::GLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#public-attributes","title":"Public Attributes","text":"Type Name GLfloat pointSize"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#public-attributes-inherited-from-aiacglobject","title":"Public Attributes inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name GLuint colorBuf GLsizei size GLObjectType type GLuint vertexBuf"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#public-functions","title":"Public Functions","text":"Type Name virtual void Draw ()  GLPointObject ()  GLPointObject (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors, GLfloat pointSize=1.0f)  GLPointObject (const GLPointObject &amp; other)  GLPointObject &amp; operator= (const GLPointObject &amp; other)"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#public-functions-inherited-from-aiacglobject","title":"Public Functions inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name void DeleteVBOs ()  virtual void Draw () = 0 GLObject () = default GLObject (const GLObject &amp; other)  GLObject &amp; operator= (const GLObject &amp; other)  ~GLObject ()"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#protected-functions-inherited-from-aiacglobject","title":"Protected Functions inherited from AIAC::GLObject","text":"<p>See AIAC::GLObject</p> Type Name void BindVBOs ()  void BufferData (const std::vector&lt; glm::vec3 &gt; &amp; vertices, const std::vector&lt; glm::vec4 &gt; &amp; colors)"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#variable-pointsize","title":"variable pointSize","text":"<pre><code>GLfloat AIAC::GLPointObject::pointSize;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#function-draw","title":"function Draw","text":"<pre><code>virtual void AIAC::GLPointObject::Draw () \n</code></pre> <p>Implements AIAC::GLObject::Draw</p>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#function-glpointobject-13","title":"function GLPointObject [\u2153]","text":"<pre><code>inline AIAC::GLPointObject::GLPointObject () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#function-glpointobject-23","title":"function GLPointObject [\u2154]","text":"<pre><code>AIAC::GLPointObject::GLPointObject (\n    const std::vector&lt; glm::vec3 &gt; &amp; vertices,\n    const std::vector&lt; glm::vec4 &gt; &amp; colors,\n    GLfloat pointSize=1.0f\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#function-glpointobject-33","title":"function GLPointObject [3/3]","text":"<pre><code>inline AIAC::GLPointObject::GLPointObject (\n    const GLPointObject &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GLPointObject/#function-operator","title":"function operator=","text":"<pre><code>inline GLPointObject &amp; AIAC::GLPointObject::operator= (\n    const GLPointObject &amp; other\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/","title":"Class AIAC::GOCircle","text":"<p>ClassList &gt; AIAC &gt; GOCircle</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#public-functions","title":"Public Functions","text":"Type Name glm::vec3 ClosestPointToPoint (glm::vec3 point) Get the closest point to the circle from a given point. GOPoint GetCenter () const glm::vec4 GetEdgeColor () const glm::vec3 GetNormal () const float GetRadius () const virtual void InitGLObject ()  void SetCenter (GOPoint center)  void SetEdgeColor (glm::vec4 edgeColor)  void SetNormal (glm::vec3 normal)  void SetRadius (float radius)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual ~GOCircle () = default"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOCircle &gt; Add (GOPoint center, float radius) Add GOCircle to the scene. std::shared_ptr&lt; GOCircle &gt; Add (GOPoint center, glm::vec3 normal, float radius)  float ClosestDistanceFromLineToCircle (std::shared_ptr&lt; GOLine &gt; ptrLine, const glm::vec3 &amp; circleCenter, float circleRadius) This function calculates the closest distance from a line, defined by a point and a direction, to a circle in 3D space. If the line intersects the circle, the function returns 0, indicating the minimum distance is inside the circle. std::pair&lt; float, std::pair&lt; glm::vec3, glm::vec3 &gt; &gt; ClosestDistanceFromSegmentToCircle (std::shared_ptr&lt; GOLine &gt; ptrLine, const glm::vec3 &amp; circleCenter, float circleRadius) This function calculates the closest distance from a segment. defined by two points, to a circle in 3D space. glm::vec3 ClosestPointToCircle (const glm::vec3 &amp; point, const glm::vec3 &amp; circleCenter, const glm::vec3 &amp; circleNormal, float circleRadius) &lt; Static geometry functions std::shared_ptr&lt; GOCircle &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOCircle &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-closestpointtopoint","title":"function ClosestPointToPoint","text":"<p>Get the closest point to the circle from a given point. <pre><code>glm::vec3 AIAC::GOCircle::ClosestPointToPoint (\n    glm::vec3 point\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>point</code> the point </li> </ul> <p>Returns:</p> <p>glm::vec3 </p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-getcenter","title":"function GetCenter","text":"<pre><code>inline GOPoint AIAC::GOCircle::GetCenter () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-getedgecolor","title":"function GetEdgeColor","text":"<pre><code>inline glm::vec4 AIAC::GOCircle::GetEdgeColor () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-getnormal","title":"function GetNormal","text":"<pre><code>inline glm::vec3 AIAC::GOCircle::GetNormal () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-getradius","title":"function GetRadius","text":"<pre><code>inline float AIAC::GOCircle::GetRadius () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOCircle::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-setcenter","title":"function SetCenter","text":"<pre><code>inline void AIAC::GOCircle::SetCenter (\n    GOPoint center\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-setedgecolor","title":"function SetEdgeColor","text":"<pre><code>inline void AIAC::GOCircle::SetEdgeColor (\n    glm::vec4 edgeColor\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-setnormal","title":"function SetNormal","text":"<pre><code>inline void AIAC::GOCircle::SetNormal (\n    glm::vec3 normal\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-setradius","title":"function SetRadius","text":"<pre><code>inline void AIAC::GOCircle::SetRadius (\n    float radius\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-setvaluefrom","title":"function SetValueFrom","text":"<pre><code>inline virtual void AIAC::GOCircle::SetValueFrom (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::SetValueFrom</p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOCircle::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-gocircle","title":"function ~GOCircle","text":"<pre><code>virtual AIAC::GOCircle::~GOCircle () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-add-12","title":"function Add [\u00bd]","text":"<p>Add GOCircle to the scene. <pre><code>static std::shared_ptr&lt; GOCircle &gt; AIAC::GOCircle::Add (\n    GOPoint center,\n    float radius\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>center</code> Center of the circle. </li> <li><code>radius</code> Radius of the circle. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the circle. </p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-add-22","title":"function Add [2/2]","text":"<pre><code>static std::shared_ptr&lt; GOCircle &gt; AIAC::GOCircle::Add (\n    GOPoint center,\n    glm::vec3 normal,\n    float radius\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-closestdistancefromlinetocircle","title":"function ClosestDistanceFromLineToCircle","text":"<p>This function calculates the closest distance from a line, defined by a point and a direction, to a circle in 3D space. If the line intersects the circle, the function returns 0, indicating the minimum distance is inside the circle. <pre><code>static inline float AIAC::GOCircle::ClosestDistanceFromLineToCircle (\n    std::shared_ptr&lt; GOLine &gt; ptrLine,\n    const glm::vec3 &amp; circleCenter,\n    float circleRadius\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ptrLine</code> the pointer to the line. </li> <li><code>circleCenter</code> The center of the circle. </li> <li><code>circleRadius</code> The radius of the circle. </li> </ul> <p>Returns:</p> <p>The closest distance from the line to the circle </p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-closestdistancefromsegmenttocircle","title":"function ClosestDistanceFromSegmentToCircle","text":"<p>This function calculates the closest distance from a segment. defined by two points, to a circle in 3D space. <pre><code>static inline std::pair&lt; float, std::pair&lt; glm::vec3, glm::vec3 &gt; &gt; AIAC::GOCircle::ClosestDistanceFromSegmentToCircle (\n    std::shared_ptr&lt; GOLine &gt; ptrLine,\n    const glm::vec3 &amp; circleCenter,\n    float circleRadius\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ptrLine</code> the pointer to the line. </li> <li><code>circleCenter</code> The center of the circle. </li> <li><code>circleRadius</code> The radius of the circle. </li> </ul> <p>Returns:</p> <p>The closest distance from the line to the circle and the closest point on the line and the circle </p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-closestpointtocircle","title":"function ClosestPointToCircle","text":"<p>&lt; Static geometry functions <pre><code>static inline glm::vec3 AIAC::GOCircle::ClosestPointToCircle (\n    const glm::vec3 &amp; point,\n    const glm::vec3 &amp; circleCenter,\n    const glm::vec3 &amp; circleNormal,\n    float circleRadius\n) \n</code></pre></p> <p>Calculates the closest point on a circle to a given point in 3D.</p> <p>Parameters:</p> <ul> <li><code>point</code> The point from which to find the closest point on the circle. </li> <li><code>circleCenter</code> The center of the circle. </li> <li><code>circleNormal</code> The normal vector of the circle's plane. </li> <li><code>circleRadius</code> The radius of the circle. </li> </ul> <p>Returns:</p> <p>The closest point on the circle to the given point. </p>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOCircle &gt; AIAC::GOCircle::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCircle/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOCircle &gt; &gt; AIAC::GOCircle::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1GOColor/","title":"Struct AIAC::GOColor","text":"<p>ClassList &gt; AIAC &gt; GOColor</p>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr glm::vec4 BLACK   = <code>glm::vec4(0.0f, 0.0f, 0.0f, 1.0f)</code> constexpr glm::vec4 BLUE   = <code>glm::vec4(0.0f, 0.0f, 1.0f, 1.0f)</code> constexpr glm::vec4 BROWN   = <code>glm::vec4(0.5f, 0.25f, 0.0f, 1.0f)</code> constexpr glm::vec4 CYAN   = <code>glm::vec4(0.0f, 1.0f, 1.0f, 1.0f)</code> constexpr glm::vec4 GRAY   = <code>glm::vec4(0.5f, 0.5f, 0.5f, 1.0f)</code> constexpr glm::vec4 GREEN   = <code>glm::vec4(0.0f, 1.0f, 0.0f, 1.0f)</code> constexpr glm::vec4 GREEN_DARKER_TRANSP07   = <code>glm::vec4(0.0f, 0.7f, 0.0f, 0.7f)</code> constexpr glm::vec4 GREEN_PUNK_TRANSP07   = <code>glm::vec4(0.0f, 0.7f, 0.0f, 0.7f)</code> constexpr glm::vec4 GREEN_TRANSP07   = <code>glm::vec4(0.0f, 1.0f, 0.0f, 0.7f)</code> constexpr glm::vec4 MAGENTA   = <code>glm::vec4(1.0f, 0.0f, 1.0f, 1.0f)</code> constexpr glm::vec4 MAGENTA_TRANSP07   = <code>glm::vec4(1.0f, 0.0f, 1.0f, 0.7f)</code> constexpr glm::vec4 ORANGE   = <code>glm::vec4(1.0f, 0.5f, 0.0f, 1.0f)</code> constexpr glm::vec4 ORANGE_TRANSP   = <code>glm::vec4(1.0f, 0.5f, 0.0f, 0.5f)</code> constexpr glm::vec4 PINK   = <code>glm::vec4(1.0f, 0.0f, 0.5f, 1.0f)</code> constexpr glm::vec4 PINK_TRANSP   = <code>glm::vec4(1.0f, 0.0f, 0.5f, 0.5f)</code> constexpr glm::vec4 PINK_TRANSP07   = <code>glm::vec4(1.0f, 0.0f, 0.5f, 0.7f)</code> constexpr glm::vec4 PURPLE   = <code>glm::vec4(0.5f, 0.0f, 0.5f, 1.0f)</code> constexpr glm::vec4 PURPLE_TRANSP   = <code>glm::vec4(0.5f, 0.0f, 0.5f, 0.5f)</code> constexpr glm::vec4 PURPLE_TRANSP07   = <code>glm::vec4(0.5f, 0.0f, 0.5f, 0.7f)</code> constexpr glm::vec4 RED   = <code>glm::vec4(1.0f, 0.0f, 0.0f, 1.0f)</code> constexpr glm::vec4 RED_TRANSP07   = <code>glm::vec4(1.0f, 0.0f, 0.0f, 0.7f)</code> constexpr glm::vec4 WHITE   = <code>glm::vec4(1.0f, 1.0f, 1.0f, 1.0f)</code> constexpr glm::vec4 YELLOW   = <code>glm::vec4(1.0f, 1.0f, 0.0f, 1.0f)</code> constexpr glm::vec4 YELLOW_TRANSP07   = <code>glm::vec4(1.0f, 1.0f, 0.0f, 0.7f)</code>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-black","title":"variable BLACK","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::BLACK;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-blue","title":"variable BLUE","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::BLUE;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-brown","title":"variable BROWN","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::BROWN;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-cyan","title":"variable CYAN","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::CYAN;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-gray","title":"variable GRAY","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::GRAY;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-green","title":"variable GREEN","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::GREEN;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-green_darker_transp07","title":"variable GREEN_DARKER_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::GREEN_DARKER_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-green_punk_transp07","title":"variable GREEN_PUNK_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::GREEN_PUNK_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-green_transp07","title":"variable GREEN_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::GREEN_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-magenta","title":"variable MAGENTA","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::MAGENTA;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-magenta_transp07","title":"variable MAGENTA_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::MAGENTA_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-orange","title":"variable ORANGE","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::ORANGE;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-orange_transp","title":"variable ORANGE_TRANSP","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::ORANGE_TRANSP;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-pink","title":"variable PINK","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::PINK;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-pink_transp","title":"variable PINK_TRANSP","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::PINK_TRANSP;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-pink_transp07","title":"variable PINK_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::PINK_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-purple","title":"variable PURPLE","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::PURPLE;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-purple_transp","title":"variable PURPLE_TRANSP","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::PURPLE_TRANSP;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-purple_transp07","title":"variable PURPLE_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::PURPLE_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-red","title":"variable RED","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::RED;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-red_transp07","title":"variable RED_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::RED_TRANSP07;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-white","title":"variable WHITE","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::WHITE;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-yellow","title":"variable YELLOW","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::YELLOW;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOColor/#variable-yellow_transp07","title":"variable YELLOW_TRANSP07","text":"<pre><code>constexpr glm::vec4 AIAC::GOColor::YELLOW_TRANSP07;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/","title":"Class AIAC::GOCylinder","text":"<p>ClassList &gt; AIAC &gt; GOCylinder</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#public-functions","title":"Public Functions","text":"Type Name glm::vec4 GetEdgeColor () const GOPoint GetPEnd () const GOPoint GetPStart () const float GetRadius () const virtual void InitGLObject ()  void SetEdgeColor (glm::vec4 edgeColor)  void SetPEnd (GOPoint pEnd)  void SetPStart (GOPoint pStart)  void SetRadius (float radius)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual ~GOCylinder () = default"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOCylinder &gt; Add (GOPoint p1, GOPoint p2, float radius) Add GOCylinder to the scene. std::shared_ptr&lt; GOCylinder &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOCylinder &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-getedgecolor","title":"function GetEdgeColor","text":"<pre><code>inline glm::vec4 AIAC::GOCylinder::GetEdgeColor () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-getpend","title":"function GetPEnd","text":"<pre><code>inline GOPoint AIAC::GOCylinder::GetPEnd () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-getpstart","title":"function GetPStart","text":"<pre><code>inline GOPoint AIAC::GOCylinder::GetPStart () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-getradius","title":"function GetRadius","text":"<pre><code>inline float AIAC::GOCylinder::GetRadius () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOCylinder::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-setedgecolor","title":"function SetEdgeColor","text":"<pre><code>inline void AIAC::GOCylinder::SetEdgeColor (\n    glm::vec4 edgeColor\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-setpend","title":"function SetPEnd","text":"<pre><code>inline void AIAC::GOCylinder::SetPEnd (\n    GOPoint pEnd\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-setpstart","title":"function SetPStart","text":"<pre><code>inline void AIAC::GOCylinder::SetPStart (\n    GOPoint pStart\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-setradius","title":"function SetRadius","text":"<pre><code>inline void AIAC::GOCylinder::SetRadius (\n    float radius\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-setvaluefrom","title":"function SetValueFrom","text":"<pre><code>inline virtual void AIAC::GOCylinder::SetValueFrom (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::SetValueFrom</p>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOCylinder::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-gocylinder","title":"function ~GOCylinder","text":"<pre><code>virtual AIAC::GOCylinder::~GOCylinder () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-add","title":"function Add","text":"<p>Add GOCylinder to the scene. <pre><code>static std::shared_ptr&lt; GOCylinder &gt; AIAC::GOCylinder::Add (\n    GOPoint p1,\n    GOPoint p2,\n    float radius\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p1</code> First point of the cylinder. </li> <li><code>p2</code> Second point of the cylinder. </li> <li><code>radius</code> Radius of the cylinder. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the cylinder. </p>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOCylinder &gt; AIAC::GOCylinder::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOCylinder/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOCylinder &gt; &gt; AIAC::GOCylinder::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/","title":"Class AIAC::GOLine","text":"<p>ClassList &gt; AIAC &gt; GOLine</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#public-functions","title":"Public Functions","text":"Type Name float ComputeAngle (std::shared_ptr&lt; GOLine &gt; ptrGO2) Compute the angle between the current line object and another one. float ComputeSignedAngle (std::shared_ptr&lt; GOLine &gt; ptrGO2) Compute the angle between the current line object and another one with a sign. void ExtendBothEnds (float length)  void ExtendFromEnd (float length)  void ExtendFromStart (float length)  float GetLength () const GOPoint GetMidPoint () const glm::vec3 GetMidPointValues () const glm::vec3 GetNormalValues () const GOPoint GetPEnd () const GOPoint GetPStart () const virtual void InitGLObject ()  void SetPEnd (GOPoint pEnd)  void SetPStart (GOPoint pStart)  void SetPts (GOPoint pStart, GOPoint pEnd)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOLine () = default"},{"location":"acdoxygen/classAIAC_1_1GOLine/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOLine/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOLine &gt; Add ()  std::shared_ptr&lt; GOLine &gt; Add (GOPoint p1, GOPoint p2, float weight=GOWeight::Default) Add GOLine to the scene. std::shared_ptr&lt; GOLine &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOLine &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOLine/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOLine/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-computeangle","title":"function ComputeAngle","text":"<p>Compute the angle between the current line object and another one. <pre><code>float AIAC::GOLine::ComputeAngle (\n    std::shared_ptr&lt; GOLine &gt; ptrGO2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ptrGO2</code> the second line </li> </ul> <p>Returns:</p> <p>float the angle in degrees </p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-computesignedangle","title":"function ComputeSignedAngle","text":"<p>Compute the angle between the current line object and another one with a sign. <pre><code>float AIAC::GOLine::ComputeSignedAngle (\n    std::shared_ptr&lt; GOLine &gt; ptrGO2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ptrGO2</code> the second line </li> </ul> <p>Returns:</p> <p>float the angle in degrees </p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-extendbothends","title":"function ExtendBothEnds","text":"<pre><code>inline void AIAC::GOLine::ExtendBothEnds (\n    float length\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-extendfromend","title":"function ExtendFromEnd","text":"<pre><code>inline void AIAC::GOLine::ExtendFromEnd (\n    float length\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-extendfromstart","title":"function ExtendFromStart","text":"<pre><code>inline void AIAC::GOLine::ExtendFromStart (\n    float length\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getlength","title":"function GetLength","text":"<pre><code>inline float AIAC::GOLine::GetLength () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getmidpoint","title":"function GetMidPoint","text":"<pre><code>inline GOPoint AIAC::GOLine::GetMidPoint () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getmidpointvalues","title":"function GetMidPointValues","text":"<pre><code>inline glm::vec3 AIAC::GOLine::GetMidPointValues () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getnormalvalues","title":"function GetNormalValues","text":"<pre><code>inline glm::vec3 AIAC::GOLine::GetNormalValues () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getpend","title":"function GetPEnd","text":"<pre><code>inline GOPoint AIAC::GOLine::GetPEnd () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getpstart","title":"function GetPStart","text":"<pre><code>inline GOPoint AIAC::GOLine::GetPStart () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOLine::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-setpend","title":"function SetPEnd","text":"<pre><code>inline void AIAC::GOLine::SetPEnd (\n    GOPoint pEnd\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-setpstart","title":"function SetPStart","text":"<pre><code>inline void AIAC::GOLine::SetPStart (\n    GOPoint pStart\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-setpts","title":"function SetPts","text":"<pre><code>inline void AIAC::GOLine::SetPts (\n    GOPoint pStart,\n    GOPoint pEnd\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-setvaluefrom","title":"function SetValueFrom","text":"<pre><code>inline virtual void AIAC::GOLine::SetValueFrom (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::SetValueFrom</p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOLine::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-translate","title":"function Translate","text":"<pre><code>inline virtual void AIAC::GOLine::Translate (\n    const glm::vec3 &amp; translation\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Translate</p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-goline","title":"function ~GOLine","text":"<pre><code>virtual AIAC::GOLine::~GOLine () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-add-12","title":"function Add [\u00bd]","text":"<pre><code>static std::shared_ptr&lt; GOLine &gt; AIAC::GOLine::Add () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-add-22","title":"function Add [2/2]","text":"<p>Add GOLine to the scene. <pre><code>static std::shared_ptr&lt; GOLine &gt; AIAC::GOLine::Add (\n    GOPoint p1,\n    GOPoint p2,\n    float weight=GOWeight::Default\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p1</code> First point of the line. </li> <li><code>p2</code> Second point of the line. </li> <li><code>weight</code> Weight of the line. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the line. </p>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOLine &gt; AIAC::GOLine::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOLine/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOLine &gt; &gt; AIAC::GOLine::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/","title":"Class AIAC::GOMesh","text":"<p>ClassList &gt; AIAC &gt; GOMesh</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#public-functions","title":"Public Functions","text":"Type Name const std::vector&lt; glm::vec4 &gt; GetColors () const const std::vector&lt; uint32_t &gt; GetIndices () const const std::vector&lt; glm::vec3 &gt; GetNormals () const const std::vector&lt; glm::vec3 &gt; GetVertices () const virtual void InitGLObject ()  void SetColor (glm::vec4 color)  void SetColors (std::vector&lt; glm::vec4 &gt; colors)  void SetIndices (std::vector&lt; uint32_t &gt; indices)  void SetNormals (std::vector&lt; glm::vec3 &gt; normals)  void SetVertices (std::vector&lt; glm::vec3 &gt; vertices)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  GOPrimitive operator* (const glm::mat4x4 &amp; transformMat)  virtual ~GOMesh () = default"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOMesh &gt; Add () Add empty GOMesh to the scene. std::shared_ptr&lt; GOMesh &gt; Add (std::vector&lt; glm::vec3 &gt; vertices, std::vector&lt; uint32_t &gt; indices) Add GOMesh to the scene. std::shared_ptr&lt; GOMesh &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOMesh &gt; &gt; GetAll ()  std::shared_ptr&lt; GOMesh &gt; LoadPly (std::string path) Load .ply and add the corresponding GOMesh to the scene."},{"location":"acdoxygen/classAIAC_1_1GOMesh/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-getcolors","title":"function GetColors","text":"<pre><code>inline const std::vector&lt; glm::vec4 &gt; AIAC::GOMesh::GetColors () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-getindices","title":"function GetIndices","text":"<pre><code>inline const std::vector&lt; uint32_t &gt; AIAC::GOMesh::GetIndices () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-getnormals","title":"function GetNormals","text":"<pre><code>inline const std::vector&lt; glm::vec3 &gt; AIAC::GOMesh::GetNormals () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-getvertices","title":"function GetVertices","text":"<pre><code>inline const std::vector&lt; glm::vec3 &gt; AIAC::GOMesh::GetVertices () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOMesh::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-setcolor","title":"function SetColor","text":"<pre><code>inline void AIAC::GOMesh::SetColor (\n    glm::vec4 color\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-setcolors","title":"function SetColors","text":"<pre><code>inline void AIAC::GOMesh::SetColors (\n    std::vector&lt; glm::vec4 &gt; colors\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-setindices","title":"function SetIndices","text":"<pre><code>inline void AIAC::GOMesh::SetIndices (\n    std::vector&lt; uint32_t &gt; indices\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-setnormals","title":"function SetNormals","text":"<pre><code>inline void AIAC::GOMesh::SetNormals (\n    std::vector&lt; glm::vec3 &gt; normals\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-setvertices","title":"function SetVertices","text":"<pre><code>inline void AIAC::GOMesh::SetVertices (\n    std::vector&lt; glm::vec3 &gt; vertices\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOMesh::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-operator","title":"function operator*","text":"<pre><code>inline GOPrimitive AIAC::GOMesh::operator* (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-gomesh","title":"function ~GOMesh","text":"<pre><code>virtual AIAC::GOMesh::~GOMesh () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-add-12","title":"function Add [\u00bd]","text":"<p>Add empty GOMesh to the scene. <pre><code>static std::shared_ptr&lt; GOMesh &gt; AIAC::GOMesh::Add () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-add-22","title":"function Add [2/2]","text":"<p>Add GOMesh to the scene. <pre><code>static std::shared_ptr&lt; GOMesh &gt; AIAC::GOMesh::Add (\n    std::vector&lt; glm::vec3 &gt; vertices,\n    std::vector&lt; uint32_t &gt; indices\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vertices</code> Vertices of the mesh. </li> <li><code>indices</code> Indices of the mesh. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the mesh. </p>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOMesh &gt; AIAC::GOMesh::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOMesh &gt; &gt; AIAC::GOMesh::GetAll () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOMesh/#function-loadply","title":"function LoadPly","text":"<p>Load .ply and add the corresponding GOMesh to the scene. <pre><code>static std::shared_ptr&lt; GOMesh &gt; AIAC::GOMesh::LoadPly (\n    std::string path\n) \n</code></pre></p> <p>Returns:</p> <p>uint32_t Id of the mesh. </p> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/","title":"Class AIAC::GOPoint","text":"<p>ClassList &gt; AIAC &gt; GOPoint</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#public-functions","title":"Public Functions","text":"Type Name float DistanceTo (const GOPoint &amp; point) const GOPoint () = default GOPoint (float x, float y, float z, float weight=GOWeight::Default)  GOPoint (glm::vec3 position, float weight=GOWeight::Default)  glm::vec3 GetPosition () const virtual void InitGLObject ()  void SetPosition (glm::vec3 position)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetWeight (float weight)  void SetX (float x)  void SetY (float y)  void SetZ (float z)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  float X () const float Y () const float Z () const vec3 () const virtual ~GOPoint () = default"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOPoint &gt; Add (float x, float y, float z, float weight=GOWeight::Default) Add GOPoint to the scene. std::shared_ptr&lt; GOPoint &gt; Add (glm::vec3 position, float weight=GOWeight::Default)  std::shared_ptr&lt; GOPoint &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOPoint &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-distanceto","title":"function DistanceTo","text":"<pre><code>inline float AIAC::GOPoint::DistanceTo (\n    const GOPoint &amp; point\n) const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-gopoint-13","title":"function GOPoint [\u2153]","text":"<pre><code>AIAC::GOPoint::GOPoint () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-gopoint-23","title":"function GOPoint [\u2154]","text":"<pre><code>AIAC::GOPoint::GOPoint (\n    float x,\n    float y,\n    float z,\n    float weight=GOWeight::Default\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-gopoint-33","title":"function GOPoint [3/3]","text":"<pre><code>AIAC::GOPoint::GOPoint (\n    glm::vec3 position,\n    float weight=GOWeight::Default\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-getposition","title":"function GetPosition","text":"<pre><code>inline glm::vec3 AIAC::GOPoint::GetPosition () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOPoint::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-setposition","title":"function SetPosition","text":"<pre><code>inline void AIAC::GOPoint::SetPosition (\n    glm::vec3 position\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-setvaluefrom","title":"function SetValueFrom","text":"<pre><code>inline virtual void AIAC::GOPoint::SetValueFrom (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::SetValueFrom</p>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-setweight","title":"function SetWeight","text":"<pre><code>inline void AIAC::GOPoint::SetWeight (\n    float weight\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-setx","title":"function SetX","text":"<pre><code>inline void AIAC::GOPoint::SetX (\n    float x\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-sety","title":"function SetY","text":"<pre><code>inline void AIAC::GOPoint::SetY (\n    float y\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-setz","title":"function SetZ","text":"<pre><code>inline void AIAC::GOPoint::SetZ (\n    float z\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOPoint::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-x","title":"function X","text":"<pre><code>inline float AIAC::GOPoint::X () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-y","title":"function Y","text":"<pre><code>inline float AIAC::GOPoint::Y () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-z","title":"function Z","text":"<pre><code>inline float AIAC::GOPoint::Z () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-vec3","title":"function vec3","text":"<pre><code>inline AIAC::GOPoint::vec3 () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-gopoint","title":"function ~GOPoint","text":"<pre><code>virtual AIAC::GOPoint::~GOPoint () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-add-12","title":"function Add [\u00bd]","text":"<p>Add GOPoint to the scene. <pre><code>static std::shared_ptr&lt; GOPoint &gt; AIAC::GOPoint::Add (\n    float x,\n    float y,\n    float z,\n    float weight=GOWeight::Default\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>x</code> X coordinate of the point. </li> <li><code>y</code> Y coordinate of the point. </li> <li><code>z</code> Z coordinate of the point. </li> <li><code>weight</code> Weight of the point. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the point. </p>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-add-22","title":"function Add [2/2]","text":"<pre><code>static std::shared_ptr&lt; GOPoint &gt; AIAC::GOPoint::Add (\n    glm::vec3 position,\n    float weight=GOWeight::Default\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOPoint &gt; AIAC::GOPoint::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPoint/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOPoint &gt; &gt; AIAC::GOPoint::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/","title":"Class AIAC::GOPolyline","text":"<p>ClassList &gt; AIAC &gt; GOPolyline</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#public-functions","title":"Public Functions","text":"Type Name const std::vector&lt; GOPoint &gt; &amp; GetPoints () const virtual void InitGLObject ()  bool IsClosed () const void SetClosed (bool isClosed)  void SetPoints (std::vector&lt; glm::vec3 &gt; points)  void SetPoints (std::vector&lt; GOPoint &gt; points)  void SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  GOPrimitive operator* (const glm::mat4x4 &amp; transformMat)  virtual ~GOPolyline () = default"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOPolyline &gt; Add () Add GOPolyline to the scene. std::shared_ptr&lt; GOPolyline &gt; Add (std::vector&lt; GOPoint &gt; points, bool isClosed=false, float weight=GOWeight::Default)  std::shared_ptr&lt; GOPolyline &gt; Add (std::vector&lt; glm::vec3 &gt; points, bool isClosed=false, float weight=GOWeight::Default)  std::shared_ptr&lt; GOPolyline &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOPolyline &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-getpoints","title":"function GetPoints","text":"<pre><code>inline const std::vector&lt; GOPoint &gt; &amp; AIAC::GOPolyline::GetPoints () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOPolyline::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-isclosed","title":"function IsClosed","text":"<pre><code>inline bool AIAC::GOPolyline::IsClosed () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-setclosed","title":"function SetClosed","text":"<pre><code>inline void AIAC::GOPolyline::SetClosed (\n    bool isClosed\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-setpoints-12","title":"function SetPoints [\u00bd]","text":"<pre><code>inline void AIAC::GOPolyline::SetPoints (\n    std::vector&lt; glm::vec3 &gt; points\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-setpoints-22","title":"function SetPoints [2/2]","text":"<pre><code>inline void AIAC::GOPolyline::SetPoints (\n    std::vector&lt; GOPoint &gt; points\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-setweight","title":"function SetWeight","text":"<pre><code>inline void AIAC::GOPolyline::SetWeight (\n    float weight\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOPolyline::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-operator","title":"function operator*","text":"<pre><code>inline GOPrimitive AIAC::GOPolyline::operator* (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-gopolyline","title":"function ~GOPolyline","text":"<pre><code>virtual AIAC::GOPolyline::~GOPolyline () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-add-13","title":"function Add [\u2153]","text":"<p>Add GOPolyline to the scene. <pre><code>static std::shared_ptr&lt; GOPolyline &gt; AIAC::GOPolyline::Add () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>points</code> Points of the polyline. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the polyline. </p>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-add-23","title":"function Add [\u2154]","text":"<pre><code>static std::shared_ptr&lt; GOPolyline &gt; AIAC::GOPolyline::Add (\n    std::vector&lt; GOPoint &gt; points,\n    bool isClosed=false,\n    float weight=GOWeight::Default\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-add-33","title":"function Add [3/3]","text":"<pre><code>static std::shared_ptr&lt; GOPolyline &gt; AIAC::GOPolyline::Add (\n    std::vector&lt; glm::vec3 &gt; points,\n    bool isClosed=false,\n    float weight=GOWeight::Default\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOPolyline &gt; AIAC::GOPolyline::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPolyline/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOPolyline &gt; &gt; AIAC::GOPolyline::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/","title":"Class AIAC::GOPrimitive","text":"<p>ClassList &gt; AIAC &gt; GOPrimitive</p> <p>Inherited by the following classes: AIAC::GOCircle,  AIAC::GOCylinder,  AIAC::GOLine,  AIAC::GOMesh,  AIAC::GOPoint,  AIAC::GOPolyline,  AIAC::GOText,  AIAC::GOTriangle</p>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#public-functions","title":"Public Functions","text":"Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#public-static-functions","title":"Public Static Functions","text":"Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#protected-attributes","title":"Protected Attributes","text":"Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-clearglobject","title":"function ClearGLObject","text":"<pre><code>void AIAC::GOPrimitive::ClearGLObject () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-draw","title":"function Draw","text":"<pre><code>inline void AIAC::GOPrimitive::Draw () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-goprimitive","title":"function GOPrimitive","text":"<pre><code>explicit AIAC::GOPrimitive::GOPrimitive (\n    bool isVisible=true,\n    glm::vec4 color=glm::vec4(0, 0, 0, 1.0)\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-generateid","title":"function GenerateId","text":"<pre><code>uint32_t AIAC::GOPrimitive::GenerateId () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-getcolor","title":"function GetColor","text":"<pre><code>inline glm::vec4 AIAC::GOPrimitive::GetColor () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-getid","title":"function GetId","text":"<pre><code>inline uint32_t AIAC::GOPrimitive::GetId () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-getname","title":"function GetName","text":"<pre><code>inline std::string AIAC::GOPrimitive::GetName () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-getstate","title":"function GetState","text":"<pre><code>inline bool AIAC::GOPrimitive::GetState () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-gettype","title":"function GetType","text":"<pre><code>inline GOTypeFlags AIAC::GOPrimitive::GetType () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-getvisibility","title":"function GetVisibility","text":"<pre><code>inline bool AIAC::GOPrimitive::GetVisibility () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-getweight","title":"function GetWeight","text":"<pre><code>inline float AIAC::GOPrimitive::GetWeight () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-initglobject","title":"function InitGLObject","text":"<pre><code>inline virtual void AIAC::GOPrimitive::InitGLObject () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-isvisible","title":"function IsVisible","text":"<pre><code>inline bool AIAC::GOPrimitive::IsVisible () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-setcolor","title":"function SetColor","text":"<pre><code>inline void AIAC::GOPrimitive::SetColor (\n    glm::vec4 color\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-setname","title":"function SetName","text":"<pre><code>inline void AIAC::GOPrimitive::SetName (\n    std::string name\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-setstate","title":"function SetState","text":"<pre><code>inline void AIAC::GOPrimitive::SetState (\n    bool state\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-setvaluefrom","title":"function SetValueFrom","text":"<pre><code>inline virtual void AIAC::GOPrimitive::SetValueFrom (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-setvisibility","title":"function SetVisibility","text":"<pre><code>inline void AIAC::GOPrimitive::SetVisibility (\n    bool isVisible\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-setweight","title":"function SetWeight","text":"<pre><code>inline int AIAC::GOPrimitive::SetWeight (\n    float weight\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOPrimitive::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-translate","title":"function Translate","text":"<pre><code>inline virtual void AIAC::GOPrimitive::Translate (\n    const glm::vec3 &amp; translation\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-goprimitive_1","title":"function ~GOPrimitive","text":"<pre><code>virtual AIAC::GOPrimitive::~GOPrimitive () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-remove-12","title":"function Remove [\u00bd]","text":"<pre><code>static void AIAC::GOPrimitive::Remove (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#function-remove-22","title":"function Remove [2/2]","text":"<pre><code>static void AIAC::GOPrimitive::Remove (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_color","title":"variable m_Color","text":"<pre><code>glm::vec4 AIAC::GOPrimitive::m_Color;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_globjects","title":"variable m_GLObjects","text":"<pre><code>std::vector&lt;std::shared_ptr&lt;GLObject&gt; &gt; AIAC::GOPrimitive::m_GLObjects;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_id","title":"variable m_Id","text":"<pre><code>uint32_t AIAC::GOPrimitive::m_Id;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_isvisible","title":"variable m_IsVisible","text":"<pre><code>bool AIAC::GOPrimitive::m_IsVisible;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_name","title":"variable m_Name","text":"<pre><code>std::string AIAC::GOPrimitive::m_Name;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_state","title":"variable m_State","text":"<pre><code>bool AIAC::GOPrimitive::m_State;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_type","title":"variable m_Type","text":"<pre><code>GOTypeFlags AIAC::GOPrimitive::m_Type;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOPrimitive/#variable-m_weight","title":"variable m_Weight","text":"<pre><code>float AIAC::GOPrimitive::m_Weight;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/","title":"Class AIAC::GORegistry","text":"<p>ClassList &gt; AIAC &gt; GORegistry</p>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#public-functions","title":"Public Functions","text":"Type Name uint32_t CheckIfKeyExists (uint32_t key) Check if a GO is in the registry by id. void Clear () Clear the registry from all the entries. uint32_t Count () constGet the total number of GOs in the registry. GORegistry () = default void GetAllGOs (std::vector&lt; std::shared_ptr&lt; GOPoint &gt; &gt; &amp; points, std::vector&lt; std::shared_ptr&lt; GOLine &gt; &gt; &amp; lines, std::vector&lt; std::shared_ptr&lt; GOCircle &gt; &gt; &amp; circles, std::vector&lt; std::shared_ptr&lt; GOCylinder &gt; &gt; &amp; cylinders, std::vector&lt; std::shared_ptr&lt; GOPolyline &gt; &gt; &amp; polylines, std::vector&lt; std::shared_ptr&lt; GOTriangle &gt; &gt; &amp; triangles, std::vector&lt; std::shared_ptr&lt; GOMesh &gt; &gt; &amp; meshes, std::vector&lt; std::shared_ptr&lt; GOText &gt; &gt; &amp; texts) Get the All GOs by category. std::vector&lt; std::shared_ptr&lt; T &gt; &gt; GetAllGOs () Get all GOs of a specific type in the registry. void GetAllGOs (std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; &amp; goVector) Get the All GOs as primitives. std::shared_ptr&lt; T &gt; GetGO (const uint32_t &amp; id) Retrieve the GO pointer from the registry by index and template as GOObject. void Init ()  void Register (std::shared_ptr&lt; T &gt; go) Add a GO to the registry. void Register (const uint32_t &amp; id, std::shared_ptr&lt; T &gt; go) Add a GO to the registry with a given id. void Unregister (const uint32_t &amp; id) Erase the GO from the register. ~GORegistry () = default"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-checkifkeyexists","title":"function CheckIfKeyExists","text":"<p>Check if a GO is in the registry by id. <pre><code>inline uint32_t AIAC::GORegistry::CheckIfKeyExists (\n    uint32_t key\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> Id of the object to check. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-clear","title":"function Clear","text":"<p>Clear the registry from all the entries. <pre><code>inline void AIAC::GORegistry::Clear () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-count","title":"function Count","text":"<p>Get the total number of GOs in the registry. <pre><code>inline uint32_t AIAC::GORegistry::Count () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-goregistry","title":"function GORegistry","text":"<pre><code>AIAC::GORegistry::GORegistry () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-getallgos-13","title":"function GetAllGOs [\u2153]","text":"<p>Get the All GOs by category. <pre><code>inline void AIAC::GORegistry::GetAllGOs (\n    std::vector&lt; std::shared_ptr&lt; GOPoint &gt; &gt; &amp; points,\n    std::vector&lt; std::shared_ptr&lt; GOLine &gt; &gt; &amp; lines,\n    std::vector&lt; std::shared_ptr&lt; GOCircle &gt; &gt; &amp; circles,\n    std::vector&lt; std::shared_ptr&lt; GOCylinder &gt; &gt; &amp; cylinders,\n    std::vector&lt; std::shared_ptr&lt; GOPolyline &gt; &gt; &amp; polylines,\n    std::vector&lt; std::shared_ptr&lt; GOTriangle &gt; &gt; &amp; triangles,\n    std::vector&lt; std::shared_ptr&lt; GOMesh &gt; &gt; &amp; meshes,\n    std::vector&lt; std::shared_ptr&lt; GOText &gt; &gt; &amp; texts\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>points</code> A vector of all GOPoints to pass as reference. </li> <li><code>lines</code> A vector of all GOLines to pass as reference. </li> <li><code>circles</code> A vector of all GOCircles to pass as reference. </li> <li><code>cylinders</code> A vector of all GOCylinders to pass as reference. </li> <li><code>polylines</code> A vector of all GOPolylines to pass as reference. </li> <li><code>triangles</code> A vector of all GOTriangles to pass as reference. </li> <li><code>texts</code> A vector of all GOTexts to pass as reference. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-getallgos-23","title":"function GetAllGOs [\u2154]","text":"<p>Get all GOs of a specific type in the registry. <pre><code>template&lt;typename T&gt;\ninline std::vector&lt; std::shared_ptr&lt; T &gt; &gt; AIAC::GORegistry::GetAllGOs () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-getallgos-33","title":"function GetAllGOs [3/3]","text":"<p>Get the All GOs as primitives. <pre><code>inline void AIAC::GORegistry::GetAllGOs (\n    std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; &amp; goVector\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>goVector</code> A reference vector to load with all the GOPrimitives. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-getgo","title":"function GetGO","text":"<p>Retrieve the GO pointer from the registry by index and template as GOObject. <pre><code>template&lt;typename T&gt;\ninline std::shared_ptr&lt; T &gt; AIAC::GORegistry::GetGO (\n    const uint32_t &amp; id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> Id of the object when created. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-init","title":"function Init","text":"<pre><code>inline void AIAC::GORegistry::Init () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-register-12","title":"function Register [\u00bd]","text":"<p>Add a GO to the registry. <pre><code>template&lt;typename T&gt;\ninline void AIAC::GORegistry::Register (\n    std::shared_ptr&lt; T &gt; go\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> Id of the object to register. </li> <li><code>go</code> Smart pointer to the object to register. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-register-22","title":"function Register [2/2]","text":"<p>Add a GO to the registry with a given id. <pre><code>template&lt;typename T&gt;\ninline void AIAC::GORegistry::Register (\n    const uint32_t &amp; id,\n    std::shared_ptr&lt; T &gt; go\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> Id of the object to register. </li> <li><code>go</code> Smart pointer to the object to register. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-unregister","title":"function Unregister","text":"<p>Erase the GO from the register. <pre><code>inline void AIAC::GORegistry::Unregister (\n    const uint32_t &amp; id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> Id of the object to erase from the register. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1GORegistry/#function-goregistry_1","title":"function ~GORegistry","text":"<pre><code>AIAC::GORegistry::~GORegistry () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GORegistry.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOText/","title":"Class AIAC::GOText","text":"<p>ClassList &gt; AIAC &gt; GOText</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOText/#public-functions","title":"Public Functions","text":"Type Name const GOPoint GetAnchor () const const std::string GetText () const const double GetTextSize () const void SetAnchor (const GOPoint anchor)  void SetAnchor (const glm::vec3 anchor)  void SetText (const std::string text)  void SetTextSize (const double size)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  GOPrimitive operator* (const glm::mat4x4 &amp; transformMat)  virtual ~GOText () = default"},{"location":"acdoxygen/classAIAC_1_1GOText/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOText/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOText &gt; Add () Add GOText to the scene. std::shared_ptr&lt; GOText &gt; Add (std::string text, GOPoint anchor, double size=GOTextSize::Default)  std::shared_ptr&lt; GOText &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOText &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOText/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOText/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOText/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOText/#function-getanchor","title":"function GetAnchor","text":"<pre><code>inline const GOPoint AIAC::GOText::GetAnchor () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-gettext","title":"function GetText","text":"<pre><code>inline const std::string AIAC::GOText::GetText () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-gettextsize","title":"function GetTextSize","text":"<pre><code>inline const double AIAC::GOText::GetTextSize () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-setanchor-12","title":"function SetAnchor [\u00bd]","text":"<pre><code>inline void AIAC::GOText::SetAnchor (\n    const GOPoint anchor\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-setanchor-22","title":"function SetAnchor [2/2]","text":"<pre><code>inline void AIAC::GOText::SetAnchor (\n    const glm::vec3 anchor\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-settext","title":"function SetText","text":"<pre><code>inline void AIAC::GOText::SetText (\n    const std::string text\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-settextsize","title":"function SetTextSize","text":"<pre><code>inline void AIAC::GOText::SetTextSize (\n    const double size\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-setvaluefrom","title":"function SetValueFrom","text":"<pre><code>inline virtual void AIAC::GOText::SetValueFrom (\n    const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::SetValueFrom</p>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOText::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-operator","title":"function operator*","text":"<pre><code>inline GOPrimitive AIAC::GOText::operator* (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-gotext","title":"function ~GOText","text":"<pre><code>virtual AIAC::GOText::~GOText () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOText/#function-add-12","title":"function Add [\u00bd]","text":"<p>Add GOText to the scene. <pre><code>static std::shared_ptr&lt; GOText &gt; AIAC::GOText::Add () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>text</code> Text of the text. </li> <li><code>anchor</code> Anchor of the text. </li> <li><code>size</code> Size of the text. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the text. </p>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-add-22","title":"function Add [2/2]","text":"<pre><code>static std::shared_ptr&lt; GOText &gt; AIAC::GOText::Add (\n    std::string text,\n    GOPoint anchor,\n    double size=GOTextSize::Default\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOText &gt; AIAC::GOText::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOText/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOText &gt; &gt; AIAC::GOText::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/","title":"Struct AIAC::GOTextSize","text":"<p>ClassList &gt; AIAC &gt; GOTextSize</p>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr double Average   = <code>0.75</code> constexpr double Big   = <code>10.0</code> constexpr double BitSmall   = <code>0.4</code> constexpr double Default   = <code>1.0</code> constexpr double ExtraSmall   = <code>0.35</code> constexpr double Medium   = <code>5.0</code> constexpr double Small   = <code>0.5</code>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-average","title":"variable Average","text":"<pre><code>constexpr double AIAC::GOTextSize::Average;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-big","title":"variable Big","text":"<pre><code>constexpr double AIAC::GOTextSize::Big;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-bitsmall","title":"variable BitSmall","text":"<pre><code>constexpr double AIAC::GOTextSize::BitSmall;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-default","title":"variable Default","text":"<pre><code>constexpr double AIAC::GOTextSize::Default;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-extrasmall","title":"variable ExtraSmall","text":"<pre><code>constexpr double AIAC::GOTextSize::ExtraSmall;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-medium","title":"variable Medium","text":"<pre><code>constexpr double AIAC::GOTextSize::Medium;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOTextSize/#variable-small","title":"variable Small","text":"<pre><code>constexpr double AIAC::GOTextSize::Small;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/","title":"Class AIAC::GOTriangle","text":"<p>ClassList &gt; AIAC &gt; GOTriangle</p> <p>Inherits the following classes: AIAC::GOPrimitive</p>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#public-functions","title":"Public Functions","text":"Type Name const std::vector&lt; glm::vec3 &gt; GetVertices () const virtual void InitGLObject ()  void SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  GOPrimitive operator* (const glm::mat4x4 &amp; transformMat)  virtual ~GOTriangle () = default"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#public-functions-inherited-from-aiacgoprimitive","title":"Public Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void ClearGLObject ()  void Draw ()  GOPrimitive (bool isVisible=true, glm::vec4 color=glm::vec4(0, 0, 0, 1.0))  uint32_t GenerateId ()  glm::vec4 GetColor () const uint32_t GetId ()  std::string GetName () const bool GetState ()  GOTypeFlags GetType ()  bool GetVisibility ()  float GetWeight () const virtual void InitGLObject ()  bool IsVisible () const void SetColor (glm::vec4 color)  void SetName (std::string name)  void SetState (bool state)  virtual void SetValueFrom (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)  void SetVisibility (bool isVisible)  int SetWeight (float weight)  virtual void Transform (const glm::mat4x4 &amp; transformMat)  virtual void Translate (const glm::vec3 &amp; translation)  virtual ~GOPrimitive () = default"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; GOTriangle &gt; Add (GOPoint p1, GOPoint p2, GOPoint p3) Add GOTriangle to the scene. std::shared_ptr&lt; GOTriangle &gt; Get (const uint32_t &amp; id)  std::vector&lt; std::shared_ptr&lt; GOTriangle &gt; &gt; GetAll ()"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#public-static-functions-inherited-from-aiacgoprimitive","title":"Public Static Functions inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name void Remove (const uint32_t &amp; id)  void Remove (const std::shared_ptr&lt; GOPrimitive &gt; &amp; ptrGO)"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#protected-attributes-inherited-from-aiacgoprimitive","title":"Protected Attributes inherited from AIAC::GOPrimitive","text":"<p>See AIAC::GOPrimitive</p> Type Name glm::vec4 m_Color std::vector&lt; std::shared_ptr&lt; GLObject &gt; &gt; m_GLObjects uint32_t m_Id bool m_IsVisible std::string m_Name bool m_State GOTypeFlags m_Type float m_Weight   = <code>GOWeight::Default</code>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-getvertices","title":"function GetVertices","text":"<pre><code>inline const std::vector&lt; glm::vec3 &gt; AIAC::GOTriangle::GetVertices () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-initglobject","title":"function InitGLObject","text":"<pre><code>virtual void AIAC::GOTriangle::InitGLObject () \n</code></pre> <p>Implements AIAC::GOPrimitive::InitGLObject</p>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-setweight","title":"function SetWeight","text":"<pre><code>inline void AIAC::GOTriangle::SetWeight (\n    float weight\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-transform","title":"function Transform","text":"<pre><code>inline virtual void AIAC::GOTriangle::Transform (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre> <p>Implements AIAC::GOPrimitive::Transform</p>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-operator","title":"function operator*","text":"<pre><code>inline GOPrimitive AIAC::GOTriangle::operator* (\n    const glm::mat4x4 &amp; transformMat\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-gotriangle","title":"function ~GOTriangle","text":"<pre><code>virtual AIAC::GOTriangle::~GOTriangle () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-add","title":"function Add","text":"<p>Add GOTriangle to the scene. <pre><code>static std::shared_ptr&lt; GOTriangle &gt; AIAC::GOTriangle::Add (\n    GOPoint p1,\n    GOPoint p2,\n    GOPoint p3\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p1</code> First point of the triangle. </li> <li><code>p2</code> Second point of the triangle. </li> <li><code>p3</code> Third point of the triangle. </li> </ul> <p>Returns:</p> <p>uint32_t Id of the triangle. </p>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-get","title":"function Get","text":"<pre><code>static std::shared_ptr&lt; GOTriangle &gt; AIAC::GOTriangle::Get (\n    const uint32_t &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1GOTriangle/#function-getall","title":"function GetAll","text":"<pre><code>static std::vector&lt; std::shared_ptr&lt; GOTriangle &gt; &gt; AIAC::GOTriangle::GetAll () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/","title":"Struct AIAC::GOWeight","text":"<p>ClassList &gt; AIAC &gt; GOWeight</p>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float Bold   = <code>2.5f</code> constexpr float BoldThick   = <code>15.0f</code> constexpr float Default   = <code>1.01f</code> constexpr float ExtraThick   = <code>10.0f</code> constexpr float Light   = <code>1.4f</code> constexpr float MaxThick   = <code>20.0f</code> constexpr float Medium   = <code>1.8f</code> constexpr float MediumThick   = <code>7.0f</code> constexpr float Thick   = <code>5.0f</code>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-bold","title":"variable Bold","text":"<pre><code>constexpr float AIAC::GOWeight::Bold;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-boldthick","title":"variable BoldThick","text":"<pre><code>constexpr float AIAC::GOWeight::BoldThick;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-default","title":"variable Default","text":"<pre><code>constexpr float AIAC::GOWeight::Default;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-extrathick","title":"variable ExtraThick","text":"<pre><code>constexpr float AIAC::GOWeight::ExtraThick;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-light","title":"variable Light","text":"<pre><code>constexpr float AIAC::GOWeight::Light;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-maxthick","title":"variable MaxThick","text":"<pre><code>constexpr float AIAC::GOWeight::MaxThick;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-medium","title":"variable Medium","text":"<pre><code>constexpr float AIAC::GOWeight::Medium;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-mediumthick","title":"variable MediumThick","text":"<pre><code>constexpr float AIAC::GOWeight::MediumThick;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1GOWeight/#variable-thick","title":"variable Thick","text":"<pre><code>constexpr float AIAC::GOWeight::Thick;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/","title":"Class AIAC::HoleFeedback","text":"<p>ClassList &gt; AIAC &gt; HoleFeedback</p> <p>The UI widget for providing feedback on orientation Feeds (in chronological order): More...</p> <ul> <li><code>#include &lt;HoleFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FabFeedback</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#public-functions","title":"Public Functions","text":"Type Name virtual void Activate () override virtual void Deactivate () override HoleFeedback ()  virtual void Update () override ~HoleFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#public-functions-inherited-from-aiacfabfeedback","title":"Public Functions inherited from AIAC::FabFeedback","text":"<p>See AIAC::FabFeedback</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FabFeedback ()  virtual void Update ()  ~FabFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#protected-attributes-inherited-from-aiacfabfeedback","title":"Protected Attributes inherited from AIAC::FabFeedback","text":"<p>See AIAC::FabFeedback</p> Type Name float m_ScaleFactor   = <code>0.0f</code>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#detailed-description","title":"Detailed Description","text":"<ul> <li>(i) position</li> <li>(ii) angle</li> <li>(iii) depthx Tb    v3   x Tt .. . .v2 . . . x Hs v1 . / . / . / v4 . / ./ x He </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#function-activate","title":"function Activate","text":"<pre><code>virtual void AIAC::HoleFeedback::Activate () override\n</code></pre> <p>Implements AIAC::FabFeedback::Activate</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#function-deactivate","title":"function Deactivate","text":"<pre><code>virtual void AIAC::HoleFeedback::Deactivate () override\n</code></pre> <p>Implements AIAC::FabFeedback::Deactivate</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#function-holefeedback","title":"function HoleFeedback","text":"<pre><code>AIAC::HoleFeedback::HoleFeedback () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#function-update","title":"function Update","text":"<pre><code>virtual void AIAC::HoleFeedback::Update () override\n</code></pre> <p>Implements AIAC::FabFeedback::Update</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedback/#function-holefeedback_1","title":"function ~HoleFeedback","text":"<pre><code>AIAC::HoleFeedback::~HoleFeedback () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/HoleFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/","title":"Class AIAC::HoleFeedbackPosition","text":"<p>ClassList &gt; AIAC &gt; HoleFeedbackPosition</p> <p>The UI widget for providing feedback on position. </p> <ul> <li><code>#include &lt;HoleFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/#public-functions","title":"Public Functions","text":"Type Name HoleFeedbackPosition ()"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackPosition/#function-holefeedbackposition","title":"function HoleFeedbackPosition","text":"<pre><code>AIAC::HoleFeedbackPosition::HoleFeedbackPosition () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/HoleFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/","title":"Class AIAC::HoleFeedbackRotation","text":"<p>ClassList &gt; AIAC &gt; HoleFeedbackRotation</p> <p>The UI widget for providing feedback on rotation. </p> <ul> <li><code>#include &lt;HoleFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/#public-functions","title":"Public Functions","text":"Type Name HoleFeedbackRotation ()"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackRotation/#function-holefeedbackrotation","title":"function HoleFeedbackRotation","text":"<pre><code>AIAC::HoleFeedbackRotation::HoleFeedbackRotation () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/HoleFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/","title":"Class AIAC::HoleFeedbackText","text":"<p>ClassList &gt; AIAC &gt; HoleFeedbackText</p> <p>The general visualizer for the info displayed as text. </p> <ul> <li><code>#include &lt;HoleFeedback.h&gt;</code></li> </ul> <p>Inherits the following classes: AIAC::FeedbackVisualizer</p>"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/#public-functions","title":"Public Functions","text":"Type Name HoleFeedbackText ()"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/#public-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name virtual void Activate ()  virtual void Deactivate ()  FeedbackVisualizer () = default ~FeedbackVisualizer () = default"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/#public-static-functions-inherited-from-aiacfeedbackvisualizer","title":"Public Static Functions inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::string toString (double val) Convert a double value to the real world scale in mm and return a string with 2 digits. If the value in mm is &gt; 99, return \"99\"."},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/#protected-attributes-inherited-from-aiacfeedbackvisualizer","title":"Protected Attributes inherited from AIAC::FeedbackVisualizer","text":"<p>See AIAC::FeedbackVisualizer</p> Type Name std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_AllPrimitives"},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1HoleFeedbackText/#function-holefeedbacktext","title":"function HoleFeedbackText","text":"<pre><code>AIAC::HoleFeedbackText::HoleFeedbackText () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/HoleFeedback.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1ImTexture/","title":"Struct AIAC::ImTexture","text":"<p>ClassList &gt; AIAC &gt; ImTexture</p> <p>Structure representing an ImGui texture. </p> <ul> <li><code>#include &lt;Image.h&gt;</code></li> </ul>"},{"location":"acdoxygen/structAIAC_1_1ImTexture/#public-attributes","title":"Public Attributes","text":"Type Name ImTextureID ID Texture ID. ImVec2 Size Size of the texture."},{"location":"acdoxygen/structAIAC_1_1ImTexture/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1ImTexture/#variable-id","title":"variable ID","text":"<p>Texture ID. <pre><code>ImTextureID AIAC::ImTexture::ID;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1ImTexture/#variable-size","title":"variable Size","text":"<p>Size of the texture. <pre><code>ImVec2 AIAC::ImTexture::Size;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/Image.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Image/","title":"Class AIAC::Image","text":"<p>ClassList &gt; AIAC &gt; Image</p> <p>Class representing the main iamge object for AC. </p> <ul> <li><code>#include &lt;Image.h&gt;</code></li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#public-functions","title":"Public Functions","text":"Type Name void DeleteGlTexture () Delete the OpenGL texture object. const cv::Mat GetCvMat () constGet the OpenCV matrix of the image. GLuint GetGlTextureObj () Get the OpenGL texture object of the image. int GetHeight () constGet the height of the image. ImTexture GetImTexture (ImVec2 size=ImVec2(0, 0)) Get the ImGui texture of the image. std::string_view GetPath () constGet the file path of the image. const cv::Mat GetPureCvMat () constGet the pure OpenCV matrix of the image (BGR format). int GetWidth () constGet the width of the image. bool HasGlTextureObj () Check if the image has a valid OpenGL texture object. bool HasImTexture () Check if the image has a valid ImGui texture. Image () Default constructor. Image (cv::Mat cvImg) Constructor with OpenCV matrix. Image (AIAC::Image &amp; img) Copy constructor. Image (const char * path, int cvImReadFlag=cv::IMREAD_UNCHANGED) Constructor with file path. void ReplaceCvMat (cv::Mat cvMat) Replace the OpenCV matrix of the image. void Resize (int newWidth, int newHeight) Resize the image. void SetImTextureSize (ImVec2 size) Set the size of the ImGui texture. void UpdateData (cv::Mat cvImg) Update image data with a new OpenCV matrix. void UpdateGlTextureObj () Update the OpenGL texture object of the image. void UpdateImTexture () Update the ImGui texture of the image. Image &amp; operator= (cv::Mat cvImg) Assignment operator for OpenCV matrix. ~Image () Destructor."},{"location":"acdoxygen/classAIAC_1_1Image/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Image/#function-deletegltexture","title":"function DeleteGlTexture","text":"<p>Delete the OpenGL texture object. <pre><code>inline void AIAC::Image::DeleteGlTexture () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getcvmat","title":"function GetCvMat","text":"<p>Get the OpenCV matrix of the image. <pre><code>inline const cv::Mat AIAC::Image::GetCvMat () const\n</code></pre></p> <p>Returns:</p> <p>OpenCV matrix of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getgltextureobj","title":"function GetGlTextureObj","text":"<p>Get the OpenGL texture object of the image. <pre><code>GLuint AIAC::Image::GetGlTextureObj () \n</code></pre></p> <p>Returns:</p> <p>OpenGL texture object of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getheight","title":"function GetHeight","text":"<p>Get the height of the image. <pre><code>inline int AIAC::Image::GetHeight () const\n</code></pre></p> <p>Returns:</p> <p>Height of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getimtexture","title":"function GetImTexture","text":"<p>Get the ImGui texture of the image. <pre><code>ImTexture AIAC::Image::GetImTexture (\n    ImVec2 size=ImVec2(0, 0)\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> Size of the texture. </li> </ul> <p>Returns:</p> <p>ImGui texture of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getpath","title":"function GetPath","text":"<p>Get the file path of the image. <pre><code>inline std::string_view AIAC::Image::GetPath () const\n</code></pre></p> <p>Returns:</p> <p>File path of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getpurecvmat","title":"function GetPureCvMat","text":"<p>Get the pure OpenCV matrix of the image (BGR format). <pre><code>inline const cv::Mat AIAC::Image::GetPureCvMat () const\n</code></pre></p> <p>Returns:</p> <p>Pure OpenCV matrix of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-getwidth","title":"function GetWidth","text":"<p>Get the width of the image. <pre><code>inline int AIAC::Image::GetWidth () const\n</code></pre></p> <p>Returns:</p> <p>Width of the image. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-hasgltextureobj","title":"function HasGlTextureObj","text":"<p>Check if the image has a valid OpenGL texture object. <pre><code>inline bool AIAC::Image::HasGlTextureObj () \n</code></pre></p> <p>Returns:</p> <p>True if the image has a valid OpenGL texture object, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-hasimtexture","title":"function HasImTexture","text":"<p>Check if the image has a valid ImGui texture. <pre><code>inline bool AIAC::Image::HasImTexture () \n</code></pre></p> <p>Returns:</p> <p>True if the image has a valid ImGui texture, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-image-14","title":"function Image [\u00bc]","text":"<p>Default constructor. <pre><code>AIAC::Image::Image () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-image-24","title":"function Image [2/4]","text":"<p>Constructor with OpenCV matrix. <pre><code>AIAC::Image::Image (\n    cv::Mat cvImg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cvImg</code> OpenCV matrix representing the image. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-image-34","title":"function Image [\u00be]","text":"<p>Copy constructor. <pre><code>AIAC::Image::Image (\n    AIAC::Image &amp; img\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>img</code> Reference to another AIAC::Image object. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-image-44","title":"function Image [4/4]","text":"<p>Constructor with file path. <pre><code>AIAC::Image::Image (\n    const char * path,\n    int cvImReadFlag=cv::IMREAD_UNCHANGED\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> Path to the image file. </li> <li><code>cvImReadFlag</code> Flag for OpenCV image reading. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-replacecvmat","title":"function ReplaceCvMat","text":"<p>Replace the OpenCV matrix of the image. <pre><code>inline void AIAC::Image::ReplaceCvMat (\n    cv::Mat cvMat\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cvMat</code> New OpenCV matrix. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-resize","title":"function Resize","text":"<p>Resize the image. <pre><code>inline void AIAC::Image::Resize (\n    int newWidth,\n    int newHeight\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>newWidth</code> New width of the image. </li> <li><code>newHeight</code> New height of the image. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-setimtexturesize","title":"function SetImTextureSize","text":"<p>Set the size of the ImGui texture. <pre><code>inline void AIAC::Image::SetImTextureSize (\n    ImVec2 size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> Size of the texture. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-updatedata","title":"function UpdateData","text":"<p>Update image data with a new OpenCV matrix. <pre><code>void AIAC::Image::UpdateData (\n    cv::Mat cvImg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cvImg</code> OpenCV matrix representing the new image data. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-updategltextureobj","title":"function UpdateGlTextureObj","text":"<p>Update the OpenGL texture object of the image. <pre><code>void AIAC::Image::UpdateGlTextureObj () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-updateimtexture","title":"function UpdateImTexture","text":"<p>Update the ImGui texture of the image. <pre><code>void AIAC::Image::UpdateImTexture () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-operator","title":"function operator=","text":"<p>Assignment operator for OpenCV matrix. <pre><code>inline Image &amp; AIAC::Image::operator= (\n    cv::Mat cvImg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cvImg</code> OpenCV matrix representing the new image data. </li> </ul> <p>Returns:</p> <p>Reference to the updated image object. </p>"},{"location":"acdoxygen/classAIAC_1_1Image/#function-image","title":"function ~Image","text":"<p>Destructor. <pre><code>AIAC::Image::~Image () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/Image.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/","title":"Class AIAC::Layer","text":"<p>ClassList &gt; AIAC &gt; Layer</p> <p>Inherited by the following classes: AIAC::LayerCamera,  AIAC::LayerCameraCalib,  AIAC::LayerFeedback,  AIAC::LayerLogRecorder,  AIAC::LayerModel,  AIAC::LayerSlam,  AIAC::LayerToolhead,  AIAC::LayerUI,  AIAC::LayerUtils</p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#public-functions","title":"Public Functions","text":"Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1Layer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Layer/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>inline virtual void AIAC::Layer::OnAttach () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#function-ondetach","title":"function OnDetach","text":"<p>Is called when the layer is detached from the application (~app). <pre><code>inline virtual void AIAC::Layer::OnDetach () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#function-onframeawake","title":"function OnFrameAwake","text":"<p>Is calle before GLFW poll events, GL frame and Imgui Frame. <pre><code>inline virtual void AIAC::Layer::OnFrameAwake () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#function-onframeend","title":"function OnFrameEnd","text":"<p>Is called when frame ends. <pre><code>inline virtual void AIAC::Layer::OnFrameEnd () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#function-onframefall","title":"function OnFrameFall","text":"<p>Is called when the GLFW, GL and Imgui frame is updated and rendered. <pre><code>inline virtual void AIAC::Layer::OnFrameFall () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>inline virtual void AIAC::Layer::OnFrameStart () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Layer/#function-layer","title":"function ~Layer","text":"<pre><code>virtual AIAC::Layer::~Layer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Layer.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/","title":"Class AIAC::LayerCamera","text":"<p>ClassList &gt; AIAC &gt; LayerCamera</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::string &gt; AvailableDevices AIAC::Camera MainCamera"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#public-functions","title":"Public Functions","text":"Type Name std::string GetCurrentDevice () const int GetCurrentDeviceIndex () const LayerCamera () = default virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. void SetCurrentDevice (std::string path)  void SetCurrentDeviceIndex (int index)  bool UpdateAvailableDevices () Update the list of available devices. virtual ~LayerCamera () = default"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#variable-availabledevices","title":"variable AvailableDevices","text":"<pre><code>std::vector&lt;std::string&gt; AIAC::LayerCamera::AvailableDevices;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#variable-maincamera","title":"variable MainCamera","text":"<pre><code>AIAC::Camera AIAC::LayerCamera::MainCamera;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-getcurrentdevice","title":"function GetCurrentDevice","text":"<pre><code>inline std::string AIAC::LayerCamera::GetCurrentDevice () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-getcurrentdeviceindex","title":"function GetCurrentDeviceIndex","text":"<pre><code>inline int AIAC::LayerCamera::GetCurrentDeviceIndex () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-layercamera","title":"function LayerCamera","text":"<pre><code>AIAC::LayerCamera::LayerCamera () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerCamera::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerCamera::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-setcurrentdevice","title":"function SetCurrentDevice","text":"<pre><code>void AIAC::LayerCamera::SetCurrentDevice (\n    std::string path\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-setcurrentdeviceindex","title":"function SetCurrentDeviceIndex","text":"<pre><code>void AIAC::LayerCamera::SetCurrentDeviceIndex (\n    int index\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-updateavailabledevices","title":"function UpdateAvailableDevices","text":"<p>Update the list of available devices. <pre><code>bool AIAC::LayerCamera::UpdateAvailableDevices () \n</code></pre></p> <p>Returns:</p> <p>true if the list contains &gt;= 1 device </p> <p>Returns:</p> <p>false if the list has no devices </p>"},{"location":"acdoxygen/classAIAC_1_1LayerCamera/#function-layercamera_1","title":"function ~LayerCamera","text":"<pre><code>virtual AIAC::LayerCamera::~LayerCamera () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerCamera.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/","title":"Class AIAC::LayerCameraCalib","text":"<p>ClassList &gt; AIAC &gt; LayerCameraCalib</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#public-attributes","title":"Public Attributes","text":"Type Name bool AutoCapture   = <code>true</code> int Delay   = <code>1500</code> bool JustCaptured   = <code>false</code> int NumOfFrame   = <code>100</code> std::string SaveFilename   = <code>\"assets/tslam/calibration.yml\"</code>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#public-functions","title":"Public Functions","text":"Type Name void Clear ()  CameraCalibrator &amp; GetCameraCalibrator ()  bool IsCalibrating () const bool IsCapturing () const LayerCameraCalib () = default virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. void SetSaveFilename (const std::string &amp; filename)  void StartCalibration ()  void StartCapturing ()  void StopCalibration ()  ~LayerCameraCalib () override"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#variable-autocapture","title":"variable AutoCapture","text":"<pre><code>bool AIAC::LayerCameraCalib::AutoCapture;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#variable-delay","title":"variable Delay","text":"<pre><code>int AIAC::LayerCameraCalib::Delay;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#variable-justcaptured","title":"variable JustCaptured","text":"<pre><code>bool AIAC::LayerCameraCalib::JustCaptured;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#variable-numofframe","title":"variable NumOfFrame","text":"<pre><code>int AIAC::LayerCameraCalib::NumOfFrame;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#variable-savefilename","title":"variable SaveFilename","text":"<pre><code>std::string AIAC::LayerCameraCalib::SaveFilename;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-clear","title":"function Clear","text":"<pre><code>void AIAC::LayerCameraCalib::Clear () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-getcameracalibrator","title":"function GetCameraCalibrator","text":"<pre><code>inline CameraCalibrator &amp; AIAC::LayerCameraCalib::GetCameraCalibrator () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-iscalibrating","title":"function IsCalibrating","text":"<pre><code>inline bool AIAC::LayerCameraCalib::IsCalibrating () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-iscapturing","title":"function IsCapturing","text":"<pre><code>inline bool AIAC::LayerCameraCalib::IsCapturing () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-layercameracalib","title":"function LayerCameraCalib","text":"<pre><code>AIAC::LayerCameraCalib::LayerCameraCalib () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerCameraCalib::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerCameraCalib::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-setsavefilename","title":"function SetSaveFilename","text":"<pre><code>inline void AIAC::LayerCameraCalib::SetSaveFilename (\n    const std::string &amp; filename\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-startcalibration","title":"function StartCalibration","text":"<pre><code>void AIAC::LayerCameraCalib::StartCalibration () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-startcapturing","title":"function StartCapturing","text":"<pre><code>inline void AIAC::LayerCameraCalib::StartCapturing () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-stopcalibration","title":"function StopCalibration","text":"<pre><code>inline void AIAC::LayerCameraCalib::StopCalibration () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerCameraCalib/#function-layercameracalib_1","title":"function ~LayerCameraCalib","text":"<pre><code>AIAC::LayerCameraCalib::~LayerCameraCalib () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerCameraCalib.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/","title":"Class AIAC::LayerFeedback","text":"<p>ClassList &gt; AIAC &gt; LayerFeedback</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#public-attributes","title":"Public Attributes","text":"Type Name bool ToShowCutPlane   = <code>false</code>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#public-functions","title":"Public Functions","text":"Type Name void ActivateCurrentFeedbackVisibility ()  void DeactivateCurrentFeedbackVisibility ()  void EnableCutPlane (bool enable)  FabFeedback * GetCurrentFabFeedback ()  LayerFeedback ()  virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. virtual ~LayerFeedback () = default"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#variable-toshowcutplane","title":"variable ToShowCutPlane","text":"<pre><code>bool AIAC::LayerFeedback::ToShowCutPlane;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-activatecurrentfeedbackvisibility","title":"function ActivateCurrentFeedbackVisibility","text":"<pre><code>inline void AIAC::LayerFeedback::ActivateCurrentFeedbackVisibility () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-deactivatecurrentfeedbackvisibility","title":"function DeactivateCurrentFeedbackVisibility","text":"<pre><code>inline void AIAC::LayerFeedback::DeactivateCurrentFeedbackVisibility () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-enablecutplane","title":"function EnableCutPlane","text":"<pre><code>inline void AIAC::LayerFeedback::EnableCutPlane (\n    bool enable\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-getcurrentfabfeedback","title":"function GetCurrentFabFeedback","text":"<pre><code>inline FabFeedback * AIAC::LayerFeedback::GetCurrentFabFeedback () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-layerfeedback","title":"function LayerFeedback","text":"<pre><code>AIAC::LayerFeedback::LayerFeedback () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerFeedback::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerFeedback::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerFeedback/#function-layerfeedback_1","title":"function ~LayerFeedback","text":"<pre><code>virtual AIAC::LayerFeedback::~LayerFeedback () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerFeedback.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/","title":"Class AIAC::LayerLogRecorder","text":"<p>ClassList &gt; AIAC &gt; LayerLogRecorder</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#public-functions","title":"Public Functions","text":"Type Name bool IsPaused () constthe recoder is paused bool IsRecording () constthe recorder is on LayerLogRecorder () = default virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. void PauseRecording () Pause recording. void ResumeRecording () Pause recording. void StartRecording (std::string logRootFolderPath=\"\") Start recording the log to a file. void StopRecording () Stop recording the log to a file. virtual ~LayerLogRecorder () = default"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-ispaused","title":"function IsPaused","text":"<p>the recoder is paused <pre><code>inline bool AIAC::LayerLogRecorder::IsPaused () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-isrecording","title":"function IsRecording","text":"<p>the recorder is on <pre><code>inline bool AIAC::LayerLogRecorder::IsRecording () const\n</code></pre></p> <p>Returns:</p> <p>true if it's recording, false otherwise </p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-layerlogrecorder","title":"function LayerLogRecorder","text":"<pre><code>AIAC::LayerLogRecorder::LayerLogRecorder () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerLogRecorder::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerLogRecorder::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-pauserecording","title":"function PauseRecording","text":"<p>Pause recording. <pre><code>void AIAC::LayerLogRecorder::PauseRecording () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-resumerecording","title":"function ResumeRecording","text":"<p>Pause recording. <pre><code>void AIAC::LayerLogRecorder::ResumeRecording () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-startrecording","title":"function StartRecording","text":"<p>Start recording the log to a file. <pre><code>void AIAC::LayerLogRecorder::StartRecording (\n    std::string logRootFolderPath=\"\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>logRootFolderPath</code> The filename of the log file </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-stoprecording","title":"function StopRecording","text":"<p>Stop recording the log to a file. <pre><code>void AIAC::LayerLogRecorder::StopRecording () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerLogRecorder/#function-layerlogrecorder_1","title":"function ~LayerLogRecorder","text":"<pre><code>virtual AIAC::LayerLogRecorder::~LayerLogRecorder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerLogRecorder.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/","title":"Class AIAC::LayerModel","text":"<p>ClassList &gt; AIAC &gt; LayerModel</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#public-functions","title":"Public Functions","text":"Type Name void AddAlignOffset (float diff) Change the align offset. The value is in TSLAM unit. void AlignModels () transform the ACInfoModel to theScannedModel __ void ChangeAlignRotation (int diff) Change the align rotation. The value is in degree. void FlipAlign () Change the align flip. void ForceAlignToEnd (bool leftOrRight) Set the offset make it align to one end. ACInfoModel &amp; GetACInfoModel () Return the ACInfoModel . const std::string GetACInfoModelName () constReturn the file name of the loaded ACInfoModel . const std::string &amp; GetACInfoModelPath () constReturn the filepath to the loaded ACInfoModel . bool GetAlignFlip () constGet the flip status of the model. float GetAlignOffset () Get the Align Offset of the model. int GetAlignRotation () constGet the rotation position of the model. ScannedModel &amp; GetScannedModel () Get the Scanned Model object. const std::string &amp; GetScannedModelPath () constReturn the filepath to the loaded ScannedModel . glm::mat4x4 GetTransformMat () constGet the transform matrix of the model. LayerModel ()  void LoadACInfoModel (const std::string &amp; path) Load a .acim model from a file. void LoadScannedModel (const std::string &amp; path) Load a .ply model from a file. virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. void ReloadACInfoModel () Reload the ACInfoModel from the current path from config. void ResetAlignFlip () Reset the align flip to false (No flip). void ResetAlignOffset () Reset the align offset to 0 (Center). void ResetAlignRotation () Reset the align rotation to 0 (No rotation). virtual ~LayerModel () = default"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-addalignoffset","title":"function AddAlignOffset","text":"<p>Change the align offset. The value is in TSLAM unit. <pre><code>inline void AIAC::LayerModel::AddAlignOffset (\n    float diff\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-alignmodels","title":"function AlignModels","text":"<p>transform the ACInfoModel to theScannedModel __ <pre><code>void AIAC::LayerModel::AlignModels () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-changealignrotation","title":"function ChangeAlignRotation","text":"<p>Change the align rotation. The value is in degree. <pre><code>inline void AIAC::LayerModel::ChangeAlignRotation (\n    int diff\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>diff</code> +1 or -1 to rotate 90 degree (counter-)clock wise. </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-flipalign","title":"function FlipAlign","text":"<p>Change the align flip. <pre><code>inline void AIAC::LayerModel::FlipAlign () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-forcealigntoend","title":"function ForceAlignToEnd","text":"<p>Set the offset make it align to one end. <pre><code>inline void AIAC::LayerModel::ForceAlignToEnd (\n    bool leftOrRight\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getacinfomodel","title":"function GetACInfoModel","text":"<p>Return the ACInfoModel . <pre><code>inline ACInfoModel &amp; AIAC::LayerModel::GetACInfoModel () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getacinfomodelname","title":"function GetACInfoModelName","text":"<p>Return the file name of the loaded ACInfoModel . <pre><code>inline const std::string AIAC::LayerModel::GetACInfoModelName () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getacinfomodelpath","title":"function GetACInfoModelPath","text":"<p>Return the filepath to the loaded ACInfoModel . <pre><code>inline const std::string &amp; AIAC::LayerModel::GetACInfoModelPath () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getalignflip","title":"function GetAlignFlip","text":"<p>Get the flip status of the model. <pre><code>inline bool AIAC::LayerModel::GetAlignFlip () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getalignoffset","title":"function GetAlignOffset","text":"<p>Get the Align Offset of the model. <pre><code>inline float AIAC::LayerModel::GetAlignOffset () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getalignrotation","title":"function GetAlignRotation","text":"<p>Get the rotation position of the model. <pre><code>inline int AIAC::LayerModel::GetAlignRotation () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getscannedmodel","title":"function GetScannedModel","text":"<p>Get the Scanned Model object. <pre><code>inline ScannedModel &amp; AIAC::LayerModel::GetScannedModel () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-getscannedmodelpath","title":"function GetScannedModelPath","text":"<p>Return the filepath to the loaded ScannedModel . <pre><code>inline const std::string &amp; AIAC::LayerModel::GetScannedModelPath () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-gettransformmat","title":"function GetTransformMat","text":"<p>Get the transform matrix of the model. <pre><code>inline glm::mat4x4 AIAC::LayerModel::GetTransformMat () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-layermodel","title":"function LayerModel","text":"<pre><code>AIAC::LayerModel::LayerModel () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-loadacinfomodel","title":"function LoadACInfoModel","text":"<p>Load a .acim model from a file. <pre><code>void AIAC::LayerModel::LoadACInfoModel (\n    const std::string &amp; path\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-loadscannedmodel","title":"function LoadScannedModel","text":"<p>Load a .ply model from a file. <pre><code>void AIAC::LayerModel::LoadScannedModel (\n    const std::string &amp; path\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerModel::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerModel::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-reloadacinfomodel","title":"function ReloadACInfoModel","text":"<p>Reload the ACInfoModel from the current path from config. <pre><code>void AIAC::LayerModel::ReloadACInfoModel () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-resetalignflip","title":"function ResetAlignFlip","text":"<p>Reset the align flip to false (No flip). <pre><code>inline void AIAC::LayerModel::ResetAlignFlip () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-resetalignoffset","title":"function ResetAlignOffset","text":"<p>Reset the align offset to 0 (Center). <pre><code>inline void AIAC::LayerModel::ResetAlignOffset () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-resetalignrotation","title":"function ResetAlignRotation","text":"<p>Reset the align rotation to 0 (No rotation). <pre><code>inline void AIAC::LayerModel::ResetAlignRotation () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerModel/#function-layermodel_1","title":"function ~LayerModel","text":"<pre><code>virtual AIAC::LayerModel::~LayerModel () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/","title":"Class AIAC::LayerSlam","text":"<p>ClassList &gt; AIAC &gt; LayerSlam</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#public-attributes","title":"Public Attributes","text":"Type Name tslam::TSlam Slam bool ToEnhance   = <code>false</code> bool ToProcess   = <code>true</code> bool ToShowTag   = <code>false</code>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#public-functions","title":"Public Functions","text":"Type Name const cv::Mat GetCamPoseCv ()  glm::mat4 GetCamPoseGlm ()  void GetCamPoseInObjCoord (cv::Mat &amp; rotationMatrix, cv::Mat &amp; tvec)  void GetCamPoseQuaternionAndTvec (cv::Vec4f &amp; quaternion, cv::Vec3f &amp; tvec)  glm::mat4 GetInvCamPoseGlm ()  const int GetNumLostFrame ()  AIAC::Image &amp; GetProcessedFrame ()  void InitSlamMapGOs ()  const bool IsMapping () const const bool IsTracked ()  LayerSlam () = default virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. void StartMapping ()  void StopMapping ()  void UpdateMap (std::string path)  ~LayerSlam () = default"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#variable-slam","title":"variable Slam","text":"<pre><code>tslam::TSlam AIAC::LayerSlam::Slam;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#variable-toenhance","title":"variable ToEnhance","text":"<pre><code>bool AIAC::LayerSlam::ToEnhance;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#variable-toprocess","title":"variable ToProcess","text":"<pre><code>bool AIAC::LayerSlam::ToProcess;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#variable-toshowtag","title":"variable ToShowTag","text":"<pre><code>bool AIAC::LayerSlam::ToShowTag;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getcamposecv","title":"function GetCamPoseCv","text":"<pre><code>inline const cv::Mat AIAC::LayerSlam::GetCamPoseCv () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getcamposeglm","title":"function GetCamPoseGlm","text":"<pre><code>glm::mat4 AIAC::LayerSlam::GetCamPoseGlm () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getcamposeinobjcoord","title":"function GetCamPoseInObjCoord","text":"<pre><code>void AIAC::LayerSlam::GetCamPoseInObjCoord (\n    cv::Mat &amp; rotationMatrix,\n    cv::Mat &amp; tvec\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getcamposequaternionandtvec","title":"function GetCamPoseQuaternionAndTvec","text":"<pre><code>void AIAC::LayerSlam::GetCamPoseQuaternionAndTvec (\n    cv::Vec4f &amp; quaternion,\n    cv::Vec3f &amp; tvec\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getinvcamposeglm","title":"function GetInvCamPoseGlm","text":"<pre><code>glm::mat4 AIAC::LayerSlam::GetInvCamPoseGlm () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getnumlostframe","title":"function GetNumLostFrame","text":"<pre><code>inline const int AIAC::LayerSlam::GetNumLostFrame () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-getprocessedframe","title":"function GetProcessedFrame","text":"<pre><code>inline AIAC::Image &amp; AIAC::LayerSlam::GetProcessedFrame () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-initslammapgos","title":"function InitSlamMapGOs","text":"<pre><code>void AIAC::LayerSlam::InitSlamMapGOs () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-ismapping","title":"function IsMapping","text":"<pre><code>inline const bool AIAC::LayerSlam::IsMapping () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-istracked","title":"function IsTracked","text":"<pre><code>inline const bool AIAC::LayerSlam::IsTracked () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-layerslam","title":"function LayerSlam","text":"<pre><code>AIAC::LayerSlam::LayerSlam () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerSlam::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerSlam::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-startmapping","title":"function StartMapping","text":"<pre><code>void AIAC::LayerSlam::StartMapping () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-stopmapping","title":"function StopMapping","text":"<pre><code>void AIAC::LayerSlam::StopMapping () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-updatemap","title":"function UpdateMap","text":"<pre><code>void AIAC::LayerSlam::UpdateMap (\n    std::string path\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerSlam/#function-layerslam_1","title":"function ~LayerSlam","text":"<pre><code>AIAC::LayerSlam::~LayerSlam () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerSlam.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/","title":"Class AIAC::LayerToolhead","text":"<p>ClassList &gt; AIAC &gt; LayerToolhead</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; AIAC::ACInfoToolheadManager &gt; ACInfoToolheadManager The manager holding the toolheads and setting the active one. bool IsSavePoseLog   = <code>false</code>Save pose log. bool IsShowShaded   = <code>false</code>Show the silouhette of the ttool. bool IsShowSilouhette Show the silouhette of the ttool. bool IsShowToolheadGOInfo Show the GOInfo toolhead's elements. std::shared_ptr&lt; ttool::TTool &gt; TTool The ttool object. int ToolheadStateUI The UI state of the toolhead (None, PoseInput, Tracking)"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#public-functions","title":"Public Functions","text":"Type Name void DetectToolhead ()  std::string GetClassifierLog () constGet the current classifier log of the ttool. std::vector&lt; std::string &gt; GetClassifierToolheadList () const cv::Matx44f GetPose () constGet the current pose of the ttool. std::string GetTrackingStatus () constGet the current tracking status of the ttool. ttool::EventType GetTtoolState () constGet the Ttool State object of the ttool event type. glm::mat4x4 GetWorldPose () Get the current pose of the ttool. LayerToolhead ()  virtual void OnAttach () overrideIs called when the layer is attached to the application. virtual void OnFrameStart () overrideIs called when frame starts. void ReloadCameraFromFile () Destroy the ttool view and recreate a new ttool object. void ReloadCameraFromMatrix (cv::Mat cameraMatrix, cv::Size cameraSize) Destroy the ttool view and recreate a new ttool object with given camera params. void ResetPoseFromConfig () Set the pose from the value in the config initially read. void ResetToLastSavedPose () Reset the pose of the ttool to the last saved pose. void SavePose () Save the current pose of the ttool to the config file and to the ttool model manager (as a fallback pose for the ttool) It will reset LayerToolhead state to None (i.e. stop tracking and pose input) void SetCurrentObject (std::string name) Set the current active object for both the ttool and acit menager. void UpdateToolheadStateUI () Update the ttool state from the UI."},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-acinfotoolheadmanager","title":"variable ACInfoToolheadManager","text":"<p>The manager holding the toolheads and setting the active one. <pre><code>std::shared_ptr&lt;AIAC::ACInfoToolheadManager&gt; AIAC::LayerToolhead::ACInfoToolheadManager;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-issaveposelog","title":"variable IsSavePoseLog","text":"<p>Save pose log. <pre><code>bool AIAC::LayerToolhead::IsSavePoseLog;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-isshowshaded","title":"variable IsShowShaded","text":"<p>Show the silouhette of the ttool. <pre><code>bool AIAC::LayerToolhead::IsShowShaded;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-isshowsilouhette","title":"variable IsShowSilouhette","text":"<p>Show the silouhette of the ttool. <pre><code>bool AIAC::LayerToolhead::IsShowSilouhette;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-isshowtoolheadgoinfo","title":"variable IsShowToolheadGOInfo","text":"<p>Show the GOInfo toolhead's elements. <pre><code>bool AIAC::LayerToolhead::IsShowToolheadGOInfo;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-ttool","title":"variable TTool","text":"<p>The ttool object. <pre><code>std::shared_ptr&lt;ttool::TTool&gt; AIAC::LayerToolhead::TTool;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#variable-toolheadstateui","title":"variable ToolheadStateUI","text":"<p>The UI state of the toolhead (None, PoseInput, Tracking) <pre><code>int AIAC::LayerToolhead::ToolheadStateUI;\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-detecttoolhead","title":"function DetectToolhead","text":"<pre><code>void AIAC::LayerToolhead::DetectToolhead () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-getclassifierlog","title":"function GetClassifierLog","text":"<p>Get the current classifier log of the ttool. <pre><code>inline std::string AIAC::LayerToolhead::GetClassifierLog () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-getclassifiertoolheadlist","title":"function GetClassifierToolheadList","text":"<pre><code>inline std::vector&lt; std::string &gt; AIAC::LayerToolhead::GetClassifierToolheadList () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-getpose","title":"function GetPose","text":"<p>Get the current pose of the ttool. <pre><code>inline cv::Matx44f AIAC::LayerToolhead::GetPose () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-gettrackingstatus","title":"function GetTrackingStatus","text":"<p>Get the current tracking status of the ttool. <pre><code>inline std::string AIAC::LayerToolhead::GetTrackingStatus () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-getttoolstate","title":"function GetTtoolState","text":"<p>Get the Ttool State object of the ttool event type. <pre><code>inline ttool::EventType AIAC::LayerToolhead::GetTtoolState () const\n</code></pre></p> <p>&lt; Getters and setters </p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-getworldpose","title":"function GetWorldPose","text":"<p>Get the current pose of the ttool. <pre><code>glm::mat4x4 AIAC::LayerToolhead::GetWorldPose () \n</code></pre></p> <p>Get the world pose of the toolhead.</p> <p>Returns:</p> <p>The transformation matrix that transforms from the toolhead frame to the world frame </p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-layertoolhead","title":"function LayerToolhead","text":"<pre><code>inline AIAC::LayerToolhead::LayerToolhead () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerToolhead::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerToolhead::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-reloadcamerafromfile","title":"function ReloadCameraFromFile","text":"<p>Destroy the ttool view and recreate a new ttool object. <pre><code>void AIAC::LayerToolhead::ReloadCameraFromFile () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-reloadcamerafrommatrix","title":"function ReloadCameraFromMatrix","text":"<p>Destroy the ttool view and recreate a new ttool object with given camera params. <pre><code>void AIAC::LayerToolhead::ReloadCameraFromMatrix (\n    cv::Mat cameraMatrix,\n    cv::Size cameraSize\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-resetposefromconfig","title":"function ResetPoseFromConfig","text":"<p>Set the pose from the value in the config initially read. <pre><code>void AIAC::LayerToolhead::ResetPoseFromConfig () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-resettolastsavedpose","title":"function ResetToLastSavedPose","text":"<p>Reset the pose of the ttool to the last saved pose. <pre><code>void AIAC::LayerToolhead::ResetToLastSavedPose () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-savepose","title":"function SavePose","text":"<p>Save the current pose of the ttool to the config file and to the ttool model manager (as a fallback pose for the ttool) It will reset LayerToolhead state to None (i.e. stop tracking and pose input) <pre><code>void AIAC::LayerToolhead::SavePose () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-setcurrentobject","title":"function SetCurrentObject","text":"<p>Set the current active object for both the ttool and acit menager. <pre><code>void AIAC::LayerToolhead::SetCurrentObject (\n    std::string name\n) \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerToolhead/#function-updatetoolheadstateui","title":"function UpdateToolheadStateUI","text":"<p>Update the ttool state from the UI. <pre><code>void AIAC::LayerToolhead::UpdateToolheadStateUI () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerToolhead.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/","title":"Class AIAC::LayerUI","text":"<p>ClassList &gt; AIAC &gt; LayerUI</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#public-functions","title":"Public Functions","text":"Type Name PaneUI * GetOpenedPaneUI ()  LayerUI () = default void LoadReconstructParams ()  virtual void OnAttach () overrideIs called when the layer is attached to the application. void OnCollapsingPaneUIToolhead ()  virtual void OnDetach () overrideIs called when the layer is detached from the application (~app). virtual void OnFrameStart () overrideIs called when frame starts. void OnUIRender ()  void OpenFileSelectDialog (const char * title, const char * fileExt, char * path, std::function&lt; void()&gt; callback=[]{})  void SetOpenedPaneUI (PaneUI * paneUI)  void SetPaneUIACIM ()  void SetPaneUICamera ()  void SetPaneUISlam ()  void SetPaneUIToolhead ()  void SetPaneUIUtils ()  void ShowCamCalibPopup ()  void ShowCombineMapPopup ()  void ShowFileSelectDialog ()  void ShowLogRecorderUI ()  void ShowMainUI ()  void ShowMapFileDialog (char * path)  void ShowMappingPopup ()  void ShowMenuBar ()  void ShowReconExportFilePathDialog ()  void ShowReconstruct3DPopup ()  void ShowSaveCamCalibFileDialog ()  void ShowSaveMapFileDialog ()  void ShowSaveVideoRecorderFileDialog ()  void ShowSceneViewport ()  void StackPane (PaneUI pane)  virtual ~LayerUI () = default"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-getopenedpaneui","title":"function GetOpenedPaneUI","text":"<pre><code>inline PaneUI * AIAC::LayerUI::GetOpenedPaneUI () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-layerui","title":"function LayerUI","text":"<pre><code>AIAC::LayerUI::LayerUI () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-loadreconstructparams","title":"function LoadReconstructParams","text":"<pre><code>void AIAC::LayerUI::LoadReconstructParams () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-onattach","title":"function OnAttach","text":"<p>Is called when the layer is attached to the application. <pre><code>virtual void AIAC::LayerUI::OnAttach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnAttach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-oncollapsingpaneuitoolhead","title":"function OnCollapsingPaneUIToolhead","text":"<pre><code>void AIAC::LayerUI::OnCollapsingPaneUIToolhead () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-ondetach","title":"function OnDetach","text":"<p>Is called when the layer is detached from the application (~app). <pre><code>virtual void AIAC::LayerUI::OnDetach () override\n</code></pre></p> <p>Implements AIAC::Layer::OnDetach</p>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-onframestart","title":"function OnFrameStart","text":"<p>Is called when frame starts. <pre><code>virtual void AIAC::LayerUI::OnFrameStart () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameStart</p>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-onuirender","title":"function OnUIRender","text":"<pre><code>void AIAC::LayerUI::OnUIRender () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-openfileselectdialog","title":"function OpenFileSelectDialog","text":"<pre><code>void AIAC::LayerUI::OpenFileSelectDialog (\n    const char * title,\n    const char * fileExt,\n    char * path,\n    std::function&lt; void()&gt; callback=[]{}\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-setopenedpaneui","title":"function SetOpenedPaneUI","text":"<pre><code>inline void AIAC::LayerUI::SetOpenedPaneUI (\n    PaneUI * paneUI\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-setpaneuiacim","title":"function SetPaneUIACIM","text":"<pre><code>void AIAC::LayerUI::SetPaneUIACIM () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-setpaneuicamera","title":"function SetPaneUICamera","text":"<pre><code>void AIAC::LayerUI::SetPaneUICamera () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-setpaneuislam","title":"function SetPaneUISlam","text":"<pre><code>void AIAC::LayerUI::SetPaneUISlam () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-setpaneuitoolhead","title":"function SetPaneUIToolhead","text":"<pre><code>void AIAC::LayerUI::SetPaneUIToolhead () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-setpaneuiutils","title":"function SetPaneUIUtils","text":"<pre><code>void AIAC::LayerUI::SetPaneUIUtils () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showcamcalibpopup","title":"function ShowCamCalibPopup","text":"<pre><code>void AIAC::LayerUI::ShowCamCalibPopup () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showcombinemappopup","title":"function ShowCombineMapPopup","text":"<pre><code>void AIAC::LayerUI::ShowCombineMapPopup () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showfileselectdialog","title":"function ShowFileSelectDialog","text":"<pre><code>void AIAC::LayerUI::ShowFileSelectDialog () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showlogrecorderui","title":"function ShowLogRecorderUI","text":"<pre><code>void AIAC::LayerUI::ShowLogRecorderUI () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showmainui","title":"function ShowMainUI","text":"<pre><code>void AIAC::LayerUI::ShowMainUI () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showmapfiledialog","title":"function ShowMapFileDialog","text":"<pre><code>void AIAC::LayerUI::ShowMapFileDialog (\n    char * path\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showmappingpopup","title":"function ShowMappingPopup","text":"<pre><code>void AIAC::LayerUI::ShowMappingPopup () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showmenubar","title":"function ShowMenuBar","text":"<pre><code>void AIAC::LayerUI::ShowMenuBar () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showreconexportfilepathdialog","title":"function ShowReconExportFilePathDialog","text":"<pre><code>void AIAC::LayerUI::ShowReconExportFilePathDialog () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showreconstruct3dpopup","title":"function ShowReconstruct3DPopup","text":"<pre><code>void AIAC::LayerUI::ShowReconstruct3DPopup () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showsavecamcalibfiledialog","title":"function ShowSaveCamCalibFileDialog","text":"<pre><code>void AIAC::LayerUI::ShowSaveCamCalibFileDialog () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showsavemapfiledialog","title":"function ShowSaveMapFileDialog","text":"<pre><code>void AIAC::LayerUI::ShowSaveMapFileDialog () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showsavevideorecorderfiledialog","title":"function ShowSaveVideoRecorderFileDialog","text":"<pre><code>void AIAC::LayerUI::ShowSaveVideoRecorderFileDialog () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-showsceneviewport","title":"function ShowSceneViewport","text":"<pre><code>void AIAC::LayerUI::ShowSceneViewport () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-stackpane","title":"function StackPane","text":"<pre><code>inline void AIAC::LayerUI::StackPane (\n    PaneUI pane\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUI/#function-layerui_1","title":"function ~LayerUI","text":"<pre><code>virtual AIAC::LayerUI::~LayerUI () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/","title":"Class AIAC::LayerUtils","text":"<p>ClassList &gt; AIAC &gt; LayerUtils</p> <p>Inherits the following classes: AIAC::Layer</p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#public-functions","title":"Public Functions","text":"Type Name void ExportHoleToolheadAxis () Export and write the hole and toolhead coordinates. std::string GetSaveFolderPath () Get the current save folder path for the utils. bool IsProcessing () Check if the video is being processed. LayerUtils ()  virtual void OnFrameEnd () overrideIs called when frame ends. void SetSaveFolderPath (const std::string &amp; path) Set the save folder path for the utils from UI. void SetWindowScreenshot (bool value) Set the flag to check if the screenshot is of the window. void StartRecording () Start recording the video of a window. void StopRecording () Stop recording the video of a window. void TakeBufferScreenshot () Take a screenshot of the colored buffer. void TakeWindowScreenshot () Take a screenshot of the current window."},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#public-functions-inherited-from-aiaclayer","title":"Public Functions inherited from AIAC::Layer","text":"<p>See AIAC::Layer</p> Type Name virtual void OnAttach () Is called when the layer is attached to the application. virtual void OnDetach () Is called when the layer is detached from the application (~app). virtual void OnFrameAwake () Is calle before GLFW poll events, GL frame and Imgui Frame. virtual void OnFrameEnd () Is called when frame ends. virtual void OnFrameFall () Is called when the GLFW, GL and Imgui frame is updated and rendered. virtual void OnFrameStart () Is called when frame starts. virtual ~Layer () = default"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#public-static-functions","title":"Public Static Functions","text":"Type Name bool CreateFolder (const std::string &amp; path) Create a folder if it does not exist."},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-exportholetoolheadaxis","title":"function ExportHoleToolheadAxis","text":"<p>Export and write the hole and toolhead coordinates. <pre><code>void AIAC::LayerUtils::ExportHoleToolheadAxis () \n</code></pre></p> <p>&lt; hole and toolhead exporter </p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-getsavefolderpath","title":"function GetSaveFolderPath","text":"<p>Get the current save folder path for the utils. <pre><code>inline std::string AIAC::LayerUtils::GetSaveFolderPath () \n</code></pre></p> <p>Returns:</p> <p>std::string Path to the current utils folder </p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-isprocessing","title":"function IsProcessing","text":"<p>Check if the video is being processed. <pre><code>inline bool AIAC::LayerUtils::IsProcessing () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-layerutils","title":"function LayerUtils","text":"<pre><code>AIAC::LayerUtils::LayerUtils () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-onframeend","title":"function OnFrameEnd","text":"<p>Is called when frame ends. <pre><code>virtual void AIAC::LayerUtils::OnFrameEnd () override\n</code></pre></p> <p>Implements AIAC::Layer::OnFrameEnd</p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-setsavefolderpath","title":"function SetSaveFolderPath","text":"<p>Set the save folder path for the utils from UI. <pre><code>void AIAC::LayerUtils::SetSaveFolderPath (\n    const std::string &amp; path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> Path to the folder that comes from UI </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-setwindowscreenshot","title":"function SetWindowScreenshot","text":"<p>Set the flag to check if the screenshot is of the window. <pre><code>inline void AIAC::LayerUtils::SetWindowScreenshot (\n    bool value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>value</code> True if the screenshot is of the window </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-startrecording","title":"function StartRecording","text":"<p>Start recording the video of a window. <pre><code>void AIAC::LayerUtils::StartRecording () \n</code></pre></p> <p>&lt; video recorder </p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-stoprecording","title":"function StopRecording","text":"<p>Stop recording the video of a window. <pre><code>void AIAC::LayerUtils::StopRecording () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-takebufferscreenshot","title":"function TakeBufferScreenshot","text":"<p>Take a screenshot of the colored buffer. <pre><code>void AIAC::LayerUtils::TakeBufferScreenshot () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-takewindowscreenshot","title":"function TakeWindowScreenshot","text":"<p>Take a screenshot of the current window. <pre><code>void AIAC::LayerUtils::TakeWindowScreenshot () \n</code></pre></p> <p>&lt; screenshot </p>"},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1LayerUtils/#function-createfolder","title":"function CreateFolder","text":"<p>Create a folder if it does not exist. <pre><code>static bool AIAC::LayerUtils::CreateFolder (\n    const std::string &amp; path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> Path to the folder </li> </ul> <p>Returns:</p> <p>true if the folder is created </p> <p>Returns:</p> <p>false if the folder already exists </p> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUtils.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Log/","title":"Class AIAC::Log","text":"<p>ClassList &gt; AIAC &gt; Log</p>"},{"location":"acdoxygen/classAIAC_1_1Log/#public-static-functions","title":"Public Static Functions","text":"Type Name std::shared_ptr&lt; spdlog::logger &gt; &amp; GetLogger ()  void Init ()  void Shutdown ()"},{"location":"acdoxygen/classAIAC_1_1Log/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Log/#function-getlogger","title":"function GetLogger","text":"<pre><code>static inline std::shared_ptr&lt; spdlog::logger &gt; &amp; AIAC::Log::GetLogger () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Log/#function-init","title":"function Init","text":"<pre><code>static void AIAC::Log::Init () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Log/#function-shutdown","title":"function Shutdown","text":"<pre><code>static void AIAC::Log::Shutdown () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Log.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1PaneUI/","title":"Class AIAC::PaneUI","text":"<p>ClassList &gt; AIAC &gt; PaneUI</p>"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#public-types","title":"Public Types","text":"Type Name enum CollapseState typedef std::function&lt; void()&gt; Func"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#public-functions","title":"Public Functions","text":"Type Name void CheckOnCollapsing (Args &amp;&amp;... args)  PaneUI (const char * label, bool isCollapsed, Func func, Func onCollapseCallback=[]{})  void Show (Args &amp;&amp;... args)"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1PaneUI/#enum-collapsestate","title":"enum CollapseState","text":"<pre><code>enum AIAC::PaneUI::CollapseState {\n    OPEN,\n    ON_COLLAPSING,\n    COLLAPSE\n};\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#typedef-func","title":"typedef Func","text":"<pre><code>typedef std::function&lt;void()&gt; AIAC::PaneUI::Func;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1PaneUI/#function-checkoncollapsing","title":"function CheckOnCollapsing","text":"<pre><code>template&lt;typename... Args&gt;\nvoid AIAC::PaneUI::CheckOnCollapsing (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#function-paneui","title":"function PaneUI","text":"<pre><code>inline AIAC::PaneUI::PaneUI (\n    const char * label,\n    bool isCollapsed,\n    Func func,\n    Func onCollapseCallback=[]{}\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1PaneUI/#function-show","title":"function Show","text":"<pre><code>template&lt;typename... Args&gt;\nvoid AIAC::PaneUI::Show (\n    Args &amp;&amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1Position/","title":"Struct AIAC::Position","text":"<p>ClassList &gt; AIAC &gt; Position</p>"},{"location":"acdoxygen/structAIAC_1_1Position/#public-attributes","title":"Public Attributes","text":"Type Name double x double y"},{"location":"acdoxygen/structAIAC_1_1Position/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1Position/#variable-x","title":"variable x","text":"<pre><code>double AIAC::Position::x;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Position/#variable-y","title":"variable y","text":"<pre><code>double AIAC::Position::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Window.cpp</code></p>"},{"location":"acdoxygen/classAIAC_1_1Renderer/","title":"Class AIAC::Renderer","text":"<p>ClassList &gt; AIAC &gt; Renderer</p>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#public-types","title":"Public Types","text":"Type Name enum CameraFrameType enum StandardView"},{"location":"acdoxygen/classAIAC_1_1Renderer/#public-functions","title":"Public Functions","text":"Type Name GLuint GetCamCalibView () const GLuint GetGlobalView () const GLuint GetMappingView () const void Init ()  void InitProjMatrix ()  void OnRender ()  Renderer () = default void SetCamCalibViewSize (float w, float h)  void SetGlobalViewSize (float w, float h)  void SetGlobalViewToActivatedComponent (StandardView standardView)  void SetMappingViewSize (float w, float h)  void UpdateGlobalViewCameraRotation (double diffX, double diffY)  void UpdateGlobalViewCameraScale (double diff)  void UpdateGlobalViewCameraTranslation (double diffX, double diffY)  virtual ~Renderer () = default"},{"location":"acdoxygen/classAIAC_1_1Renderer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Renderer/#enum-cameraframetype","title":"enum CameraFrameType","text":"<pre><code>enum AIAC::Renderer::CameraFrameType {\n    RAW,\n    UNDISTORTED,\n    SLAM_PROCESSED\n};\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#enum-standardview","title":"enum StandardView","text":"<pre><code>enum AIAC::Renderer::StandardView {\n    TOP,\n    BOTTOM,\n    NW,\n    NE,\n    SW,\n    SE\n};\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-getcamcalibview","title":"function GetCamCalibView","text":"<pre><code>inline GLuint AIAC::Renderer::GetCamCalibView () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-getglobalview","title":"function GetGlobalView","text":"<pre><code>inline GLuint AIAC::Renderer::GetGlobalView () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-getmappingview","title":"function GetMappingView","text":"<pre><code>inline GLuint AIAC::Renderer::GetMappingView () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-init","title":"function Init","text":"<pre><code>void AIAC::Renderer::Init () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-initprojmatrix","title":"function InitProjMatrix","text":"<pre><code>void AIAC::Renderer::InitProjMatrix () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-onrender","title":"function OnRender","text":"<pre><code>void AIAC::Renderer::OnRender () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-renderer","title":"function Renderer","text":"<pre><code>AIAC::Renderer::Renderer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-setcamcalibviewsize","title":"function SetCamCalibViewSize","text":"<pre><code>void AIAC::Renderer::SetCamCalibViewSize (\n    float w,\n    float h\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-setglobalviewsize","title":"function SetGlobalViewSize","text":"<pre><code>void AIAC::Renderer::SetGlobalViewSize (\n    float w,\n    float h\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-setglobalviewtoactivatedcomponent","title":"function SetGlobalViewToActivatedComponent","text":"<pre><code>void AIAC::Renderer::SetGlobalViewToActivatedComponent (\n    StandardView standardView\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-setmappingviewsize","title":"function SetMappingViewSize","text":"<pre><code>void AIAC::Renderer::SetMappingViewSize (\n    float w,\n    float h\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-updateglobalviewcamerarotation","title":"function UpdateGlobalViewCameraRotation","text":"<pre><code>void AIAC::Renderer::UpdateGlobalViewCameraRotation (\n    double diffX,\n    double diffY\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-updateglobalviewcamerascale","title":"function UpdateGlobalViewCameraScale","text":"<pre><code>void AIAC::Renderer::UpdateGlobalViewCameraScale (\n    double diff\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-updateglobalviewcameratranslation","title":"function UpdateGlobalViewCameraTranslation","text":"<pre><code>void AIAC::Renderer::UpdateGlobalViewCameraTranslation (\n    double diffX,\n    double diffY\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Renderer/#function-renderer_1","title":"function ~Renderer","text":"<pre><code>virtual AIAC::Renderer::~Renderer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Renderer.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1SLAMCombineMapEvent/","title":"Class AIAC::SLAMCombineMapEvent","text":"<p>ClassList &gt; AIAC &gt; SLAMCombineMapEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1SLAMCombineMapEvent/#public-functions","title":"Public Functions","text":"Type Name void OnSLAMCombineMap ()  SLAMCombineMapEvent (std::string mapPathA, std::string mapPathB, std::string outputPath, int optimizeIterations, float radiusSearch, double creaseAngleThreshold, int minClusterSize, double AABBScaleFactor, double maxPolyTagDist, double maxPlnDist2Merge, double maxPlnAngle2Merge, double EPS)"},{"location":"acdoxygen/classAIAC_1_1SLAMCombineMapEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1SLAMCombineMapEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1SLAMCombineMapEvent/#function-onslamcombinemap","title":"function OnSLAMCombineMap","text":"<pre><code>void AIAC::SLAMCombineMapEvent::OnSLAMCombineMap () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1SLAMCombineMapEvent/#function-slamcombinemapevent","title":"function SLAMCombineMapEvent","text":"<pre><code>inline explicit AIAC::SLAMCombineMapEvent::SLAMCombineMapEvent (\n    std::string mapPathA,\n    std::string mapPathB,\n    std::string outputPath,\n    int optimizeIterations,\n    float radiusSearch,\n    double creaseAngleThreshold,\n    int minClusterSize,\n    double AABBScaleFactor,\n    double maxPolyTagDist,\n    double maxPlnDist2Merge,\n    double maxPlnAngle2Merge,\n    double EPS\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1SLAMMapLoadedEvent/","title":"Class AIAC::SLAMMapLoadedEvent","text":"<p>ClassList &gt; AIAC &gt; SLAMMapLoadedEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1SLAMMapLoadedEvent/#public-functions","title":"Public Functions","text":"Type Name void OnSLAMMapLoaded ()  SLAMMapLoadedEvent (const std::string filePath)"},{"location":"acdoxygen/classAIAC_1_1SLAMMapLoadedEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1SLAMMapLoadedEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1SLAMMapLoadedEvent/#function-onslammaploaded","title":"function OnSLAMMapLoaded","text":"<pre><code>void AIAC::SLAMMapLoadedEvent::OnSLAMMapLoaded () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1SLAMMapLoadedEvent/#function-slammaploadedevent","title":"function SLAMMapLoadedEvent","text":"<pre><code>inline explicit AIAC::SLAMMapLoadedEvent::SLAMMapLoadedEvent (\n    const std::string filePath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1SLAMStartMappingEvent/","title":"Class AIAC::SLAMStartMappingEvent","text":"<p>ClassList &gt; AIAC &gt; SLAMStartMappingEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1SLAMStartMappingEvent/#public-functions","title":"Public Functions","text":"Type Name void OnSLAMStartMapping ()  SLAMStartMappingEvent ()"},{"location":"acdoxygen/classAIAC_1_1SLAMStartMappingEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1SLAMStartMappingEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1SLAMStartMappingEvent/#function-onslamstartmapping","title":"function OnSLAMStartMapping","text":"<pre><code>void AIAC::SLAMStartMappingEvent::OnSLAMStartMapping () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1SLAMStartMappingEvent/#function-slamstartmappingevent","title":"function SLAMStartMappingEvent","text":"<pre><code>inline explicit AIAC::SLAMStartMappingEvent::SLAMStartMappingEvent () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1SLAMStopMappingEvent/","title":"Class AIAC::SLAMStopMappingEvent","text":"<p>ClassList &gt; AIAC &gt; SLAMStopMappingEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1SLAMStopMappingEvent/#public-functions","title":"Public Functions","text":"Type Name void OnSLAMStopMapping ()  SLAMStopMappingEvent (bool toSave, std::string savePath, bool toOptimize, float radiusSearch, double creaseAngleThreshold, int minClusterSize, double AABBScaleFactor, double maxPolyTagDist, double maxPlnDist2Merge, double maxPlnAngle2Merge, double EPS)"},{"location":"acdoxygen/classAIAC_1_1SLAMStopMappingEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1SLAMStopMappingEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1SLAMStopMappingEvent/#function-onslamstopmapping","title":"function OnSLAMStopMapping","text":"<pre><code>void AIAC::SLAMStopMappingEvent::OnSLAMStopMapping () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1SLAMStopMappingEvent/#function-slamstopmappingevent","title":"function SLAMStopMappingEvent","text":"<pre><code>inline explicit AIAC::SLAMStopMappingEvent::SLAMStopMappingEvent (\n    bool toSave,\n    std::string savePath,\n    bool toOptimize,\n    float radiusSearch,\n    double creaseAngleThreshold,\n    int minClusterSize,\n    double AABBScaleFactor,\n    double maxPolyTagDist,\n    double maxPlnDist2Merge,\n    double maxPlnAngle2Merge,\n    double EPS\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1SLAMVocabularyLoadedEvent/","title":"Class AIAC::SLAMVocabularyLoadedEvent","text":"<p>ClassList &gt; AIAC &gt; SLAMVocabularyLoadedEvent</p> <p>Inherits the following classes: AIAC::Event</p>"},{"location":"acdoxygen/classAIAC_1_1SLAMVocabularyLoadedEvent/#public-functions","title":"Public Functions","text":"Type Name void OnSLAMVocabularyLoaded ()  SLAMVocabularyLoadedEvent (const std::string filePath)"},{"location":"acdoxygen/classAIAC_1_1SLAMVocabularyLoadedEvent/#public-functions-inherited-from-aiacevent","title":"Public Functions inherited from AIAC::Event","text":"<p>See AIAC::Event</p> Type Name Event (const EventType type, const EventCategory category=EventCategory::None, int32_t priority=0)  EventCategory GetCategory () const EventType GetType () const virtual ~Event () = default"},{"location":"acdoxygen/classAIAC_1_1SLAMVocabularyLoadedEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1SLAMVocabularyLoadedEvent/#function-onslamvocabularyloaded","title":"function OnSLAMVocabularyLoaded","text":"<pre><code>void AIAC::SLAMVocabularyLoadedEvent::OnSLAMVocabularyLoaded () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1SLAMVocabularyLoadedEvent/#function-slamvocabularyloadedevent","title":"function SLAMVocabularyLoadedEvent","text":"<pre><code>inline explicit AIAC::SLAMVocabularyLoadedEvent::SLAMVocabularyLoadedEvent (\n    const std::string filePath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/","title":"Struct AIAC::SaberSawData","text":"<p>ClassList &gt; AIAC &gt; SaberSawData</p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#public-attributes","title":"Public Attributes","text":"Type Name std::string NameACIT name of the toolhead glm::vec3 NormEndACIT end of the normal of the blade plane std::shared_ptr&lt; GOPoint &gt; NormEndGO glm::vec3 NormStartACIT start of the normal of the blade plane std::shared_ptr&lt; GOPoint &gt; NormStartGO glm::vec3 ToolbaseACIT position of the base of the toolhead std::shared_ptr&lt; GOPoint &gt; ToolbaseGO GOPoints equivalent. glm::vec3 TooltipACIT position of the tip of the toolhead std::shared_ptr&lt; GOPoint &gt; TooltipGO"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#public-functions","title":"Public Functions","text":"Type Name SaberSawData ()"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-nameacit","title":"variable NameACIT","text":"<p>name of the toolhead <pre><code>std::string AIAC::SaberSawData::NameACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-normendacit","title":"variable NormEndACIT","text":"<p>end of the normal of the blade plane <pre><code>glm::vec3 AIAC::SaberSawData::NormEndACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-normendgo","title":"variable NormEndGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::SaberSawData::NormEndGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-normstartacit","title":"variable NormStartACIT","text":"<p>start of the normal of the blade plane <pre><code>glm::vec3 AIAC::SaberSawData::NormStartACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-normstartgo","title":"variable NormStartGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::SaberSawData::NormStartGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-toolbaseacit","title":"variable ToolbaseACIT","text":"<p>position of the base of the toolhead <pre><code>glm::vec3 AIAC::SaberSawData::ToolbaseACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-toolbasego","title":"variable ToolbaseGO","text":"<p>GOPoints equivalent. <pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::SaberSawData::ToolbaseGO;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-tooltipacit","title":"variable TooltipACIT","text":"<p>position of the tip of the toolhead <pre><code>glm::vec3 AIAC::SaberSawData::TooltipACIT;\n</code></pre></p>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#variable-tooltipgo","title":"variable TooltipGO","text":"<pre><code>std::shared_ptr&lt;GOPoint&gt; AIAC::SaberSawData::TooltipGO;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1SaberSawData/#function-sabersawdata","title":"function SaberSawData","text":"<pre><code>inline AIAC::SaberSawData::SaberSawData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/","title":"Class AIAC::ScannedModel","text":"<p>ClassList &gt; AIAC &gt; ScannedModel</p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#public-functions","title":"Public Functions","text":"Type Name void BuildBoundingBox () Build the bounding box based on the ply model. std::vector&lt; std::pair&lt; int, int &gt; &gt; GetBboxEdgesIndices () const std::vector&lt; glm::vec3 &gt; GetBoundingBox () constGet the bounding box of the ply model. float GetLength () Get the length of the scanned model, which is calculated by averaging the four edges of the bounding box. bool Load (std::string path) Load a .ply model from a file. ScannedModel ()  void UpdateBboxGOLine () Update Boundary Box GOLine . ~ScannedModel ()"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-buildboundingbox","title":"function BuildBoundingBox","text":"<p>Build the bounding box based on the ply model. <pre><code>void AIAC::ScannedModel::BuildBoundingBox () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-getbboxedgesindices","title":"function GetBboxEdgesIndices","text":"<pre><code>inline std::vector&lt; std::pair&lt; int, int &gt; &gt; AIAC::ScannedModel::GetBboxEdgesIndices () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-getboundingbox","title":"function GetBoundingBox","text":"<p>Get the bounding box of the ply model. <pre><code>inline std::vector&lt; glm::vec3 &gt; AIAC::ScannedModel::GetBoundingBox () const\n</code></pre></p> <p>Returns:</p> <p>The bounding box of the ply model. </p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-getlength","title":"function GetLength","text":"<p>Get the length of the scanned model, which is calculated by averaging the four edges of the bounding box. <pre><code>float AIAC::ScannedModel::GetLength () \n</code></pre></p> <p>Returns:</p> <p>The length of the scanned model. (in TSLAM unit) </p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-load","title":"function Load","text":"<p>Load a .ply model from a file. <pre><code>bool AIAC::ScannedModel::Load (\n    std::string path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> Path to the model file. </li> </ul> <p>Returns:</p> <p>True if the model is loaded successfully, false otherwise. </p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-scannedmodel","title":"function ScannedModel","text":"<pre><code>inline AIAC::ScannedModel::ScannedModel () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-updatebboxgoline","title":"function UpdateBboxGOLine","text":"<p>Update Boundary Box GOLine . <pre><code>void AIAC::ScannedModel::UpdateBboxGOLine () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1ScannedModel/#function-scannedmodel_1","title":"function ~ScannedModel","text":"<pre><code>inline AIAC::ScannedModel::~ScannedModel () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ScannedModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/","title":"Class AIAC::TextRenderer","text":"<p>ClassList &gt; AIAC &gt; TextRenderer</p>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::map&lt; char, Character &gt; Characters"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#public-functions","title":"Public Functions","text":"Type Name TextRenderer () = default ~TextRenderer () = default"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#public-static-functions","title":"Public Static Functions","text":"Type Name void Init () Initialize the static TextRenderer instance. void RenderTextIn3DSpace (std::string text, glm::vec3 position, glm::vec4 color, float scale=1.0f) Render text in the 3D space, but always facing the screen. void SetProjection (glm::mat4 projection) set the projection matrix for rendering text in 3D space"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#variable-characters","title":"variable Characters","text":"<pre><code>std::map&lt; char, Character &gt; AIAC::TextRenderer::Characters;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#function-textrenderer","title":"function TextRenderer","text":"<pre><code>AIAC::TextRenderer::TextRenderer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#function-textrenderer_1","title":"function ~TextRenderer","text":"<pre><code>AIAC::TextRenderer::~TextRenderer () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#function-init","title":"function Init","text":"<p>Initialize the static TextRenderer instance. <pre><code>static void AIAC::TextRenderer::Init () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#function-rendertextin3dspace","title":"function RenderTextIn3DSpace","text":"<p>Render text in the 3D space, but always facing the screen. <pre><code>static void AIAC::TextRenderer::RenderTextIn3DSpace (\n    std::string text,\n    glm::vec3 position,\n    glm::vec4 color,\n    float scale=1.0f\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>text</code> Text to show </li> <li><code>position</code> The anchor of the text </li> <li><code>color</code> Text color </li> <li><code>projection</code> The final MVP projection of the scene to show </li> <li><code>scale</code> Text scale, default = 1.0f </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1TextRenderer/#function-setprojection","title":"function SetProjection","text":"<p>set the projection matrix for rendering text in 3D space <pre><code>static inline void AIAC::TextRenderer::SetProjection (\n    glm::mat4 projection\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/TextRenderer.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/","title":"Class AIAC::TimberInfo","text":"<p>ClassList &gt; AIAC &gt; TimberInfo</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#classes","title":"Classes","text":"Type Name class Component class Cut class Hole"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#public-attributes","title":"Public Attributes","text":"Type Name bool IsShowingAllComponents   = <code>false</code> bool IsShowingCotas   = <code>false</code>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::string &gt; GetAllComponentsIDs () const std::vector&lt; std::pair&lt; int, int &gt; &gt; GetBboxEdgesIndices () const std::vector&lt; glm::vec3 &gt; GetBoundingBox () const Component * GetComponent (const std::string &amp; id)  Component * GetCurrentComponent ()  std::string GetCurrentComponentID ()  int GetFabricatedComponents () Get the number of fabricate components. float GetFabricationProgress () Get the progress of fabrication in percentage. std::string GetID () const int GetTotalComponents () Get the total number of components. void HideAllComponentsExceptCurrent ()  void SetCurrentComponentTo (std::string id)  void SetNextComponentAsCurrent ()  void SetPrevComponentAsCurrent ()  void ShowAllComponents ()  void UpdateCotasVisibility (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#variable-isshowingallcomponents","title":"variable IsShowingAllComponents","text":"<pre><code>bool AIAC::TimberInfo::IsShowingAllComponents;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#variable-isshowingcotas","title":"variable IsShowingCotas","text":"<pre><code>bool AIAC::TimberInfo::IsShowingCotas;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getallcomponentsids","title":"function GetAllComponentsIDs","text":"<pre><code>std::vector&lt; std::string &gt; AIAC::TimberInfo::GetAllComponentsIDs () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getbboxedgesindices","title":"function GetBboxEdgesIndices","text":"<pre><code>inline std::vector&lt; std::pair&lt; int, int &gt; &gt; AIAC::TimberInfo::GetBboxEdgesIndices () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getboundingbox","title":"function GetBoundingBox","text":"<pre><code>inline std::vector&lt; glm::vec3 &gt; AIAC::TimberInfo::GetBoundingBox () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getcomponent","title":"function GetComponent","text":"<pre><code>inline Component * AIAC::TimberInfo::GetComponent (\n    const std::string &amp; id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getcurrentcomponent","title":"function GetCurrentComponent","text":"<pre><code>inline Component * AIAC::TimberInfo::GetCurrentComponent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getcurrentcomponentid","title":"function GetCurrentComponentID","text":"<pre><code>inline std::string AIAC::TimberInfo::GetCurrentComponentID () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getfabricatedcomponents","title":"function GetFabricatedComponents","text":"<p>Get the number of fabricate components. <pre><code>inline int AIAC::TimberInfo::GetFabricatedComponents () \n</code></pre></p> <p>&lt; small utilities to calculate the progress of fabrication </p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getfabricationprogress","title":"function GetFabricationProgress","text":"<p>Get the progress of fabrication in percentage. <pre><code>inline float AIAC::TimberInfo::GetFabricationProgress () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-getid","title":"function GetID","text":"<pre><code>inline std::string AIAC::TimberInfo::GetID () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-gettotalcomponents","title":"function GetTotalComponents","text":"<p>Get the total number of components. <pre><code>inline int AIAC::TimberInfo::GetTotalComponents () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-hideallcomponentsexceptcurrent","title":"function HideAllComponentsExceptCurrent","text":"<pre><code>void AIAC::TimberInfo::HideAllComponentsExceptCurrent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-setcurrentcomponentto","title":"function SetCurrentComponentTo","text":"<pre><code>void AIAC::TimberInfo::SetCurrentComponentTo (\n    std::string id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-setnextcomponentascurrent","title":"function SetNextComponentAsCurrent","text":"<pre><code>void AIAC::TimberInfo::SetNextComponentAsCurrent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-setprevcomponentascurrent","title":"function SetPrevComponentAsCurrent","text":"<pre><code>void AIAC::TimberInfo::SetPrevComponentAsCurrent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-showallcomponents","title":"function ShowAllComponents","text":"<pre><code>void AIAC::TimberInfo::ShowAllComponents () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo/#function-updatecotasvisibility","title":"function UpdateCotasVisibility","text":"<pre><code>void AIAC::TimberInfo::UpdateCotasVisibility (\n    bool visible\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/","title":"Class AIAC::TimberInfo::Component","text":"<p>ClassList &gt; AIAC &gt; TimberInfo &gt; Component</p> <p>Inherited by the following classes: AIAC::TimberInfo::Cut,  AIAC::TimberInfo::Cut::Edge,  AIAC::TimberInfo::Cut::Face,  AIAC::TimberInfo::Hole</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#public-attributes","title":"Public Attributes","text":"Type Name bool IsMarkedDone"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#public-functions","title":"Public Functions","text":"Type Name Component (std::string type)  virtual glm::vec3 GetCenter () constHole . __always_inline std::string GetTypeString () const virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#protected-attributes","title":"Protected Attributes","text":"Type Name pugi::xml_node m_ACIMDocNode glm::vec3 m_Center std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_GOPrimitives std::string m_ID float m_Scale ACIMState m_State std::string m_Type"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-ismarkeddone","title":"variable IsMarkedDone","text":"<pre><code>bool AIAC::TimberInfo::Component::IsMarkedDone;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-component","title":"function Component","text":"<pre><code>inline AIAC::TimberInfo::Component::Component (\n    std::string type\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-getcenter","title":"function GetCenter","text":"<p>Hole . <pre><code>virtual glm::vec3 AIAC::TimberInfo::Component::GetCenter () const\n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-gettypestring","title":"function GetTypeString","text":"<pre><code>inline __always_inline std::string AIAC::TimberInfo::Component::GetTypeString () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-setascurrent","title":"function SetAsCurrent","text":"<p>&lt; Base Component __ <pre><code>virtual void AIAC::TimberInfo::Component::SetAsCurrent () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-setasdone","title":"function SetAsDone","text":"<pre><code>virtual void AIAC::TimberInfo::Component::SetAsDone () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-setasnotdone","title":"function SetAsNotDone","text":"<pre><code>virtual void AIAC::TimberInfo::Component::SetAsNotDone () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#function-setvisibility","title":"function SetVisibility","text":"<pre><code>virtual void AIAC::TimberInfo::Component::SetVisibility (\n    bool visible\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_acimdocnode","title":"variable m_ACIMDocNode","text":"<pre><code>pugi::xml_node AIAC::TimberInfo::Component::m_ACIMDocNode;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_center","title":"variable m_Center","text":"<pre><code>glm::vec3 AIAC::TimberInfo::Component::m_Center;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_goprimitives","title":"variable m_GOPrimitives","text":"<pre><code>std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt; &gt; AIAC::TimberInfo::Component::m_GOPrimitives;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_id","title":"variable m_ID","text":"<pre><code>std::string AIAC::TimberInfo::Component::m_ID;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_scale","title":"variable m_Scale","text":"<pre><code>float AIAC::TimberInfo::Component::m_Scale;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_state","title":"variable m_State","text":"<pre><code>ACIMState AIAC::TimberInfo::Component::m_State;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Component/#variable-m_type","title":"variable m_Type","text":"<pre><code>std::string AIAC::TimberInfo::Component::m_Type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/","title":"Class AIAC::TimberInfo::Cut","text":"<p>ClassList &gt; AIAC &gt; TimberInfo &gt; Cut</p> <p>Inherits the following classes: AIAC::TimberInfo::Component</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#classes","title":"Classes","text":"Type Name class Edge class Face"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#public-attributes-inherited-from-aiactimberinfocomponent","title":"Public Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name bool IsMarkedDone"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#public-functions","title":"Public Functions","text":"Type Name Cut ()  std::map&lt; std::string, Edge &gt; &amp; GetAllEdges ()  std::map&lt; std::string, Face &gt; &amp; GetAllFaces ()  std::set&lt; std::string &gt; &amp; GetAllNonExposedEdgeIDs ()  std::set&lt; std::string &gt; &amp; GetAllNonExposedFaceIDs ()  virtual glm::vec3 GetCenter () override constHole . Edge &amp; GetEdge (std::string id)  Face &amp; GetFace (std::string id)  std::map&lt; std::string, Face &gt; GetFaceNeighbors (std::string faceID)  TimberInfo::Cut::Face GetHighlightedFace ()  std::string GetHighlightedFaceID () const std::map&lt; std::string, Face &gt; GetHighlightedFaceNeighbors ()  void HighlightFace (const std::string &amp; faceId, glm::vec4 color=glm::vec4(0))  bool IsSingleFace () const virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible)  void SetVisibilityAllCotas (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#public-functions-inherited-from-aiactimberinfocomponent","title":"Public Functions inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name Component (std::string type)  virtual glm::vec3 GetCenter () constHole . __always_inline std::string GetTypeString () const virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#protected-attributes-inherited-from-aiactimberinfocomponent","title":"Protected Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name pugi::xml_node m_ACIMDocNode glm::vec3 m_Center std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_GOPrimitives std::string m_ID float m_Scale ACIMState m_State std::string m_Type"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-cut","title":"function Cut","text":"<pre><code>inline AIAC::TimberInfo::Cut::Cut () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getalledges","title":"function GetAllEdges","text":"<pre><code>inline std::map&lt; std::string, Edge &gt; &amp; AIAC::TimberInfo::Cut::GetAllEdges () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getallfaces","title":"function GetAllFaces","text":"<pre><code>inline std::map&lt; std::string, Face &gt; &amp; AIAC::TimberInfo::Cut::GetAllFaces () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getallnonexposededgeids","title":"function GetAllNonExposedEdgeIDs","text":"<pre><code>inline std::set&lt; std::string &gt; &amp; AIAC::TimberInfo::Cut::GetAllNonExposedEdgeIDs () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getallnonexposedfaceids","title":"function GetAllNonExposedFaceIDs","text":"<pre><code>inline std::set&lt; std::string &gt; &amp; AIAC::TimberInfo::Cut::GetAllNonExposedFaceIDs () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getcenter","title":"function GetCenter","text":"<p>Hole . <pre><code>inline virtual glm::vec3 AIAC::TimberInfo::Cut::GetCenter () override const\n</code></pre></p> <p>Implements AIAC::TimberInfo::Component::GetCenter</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getedge","title":"function GetEdge","text":"<pre><code>inline Edge &amp; AIAC::TimberInfo::Cut::GetEdge (\n    std::string id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getface","title":"function GetFace","text":"<pre><code>inline Face &amp; AIAC::TimberInfo::Cut::GetFace (\n    std::string id\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-getfaceneighbors","title":"function GetFaceNeighbors","text":"<pre><code>inline std::map&lt; std::string, Face &gt; AIAC::TimberInfo::Cut::GetFaceNeighbors (\n    std::string faceID\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-gethighlightedface","title":"function GetHighlightedFace","text":"<pre><code>inline TimberInfo::Cut::Face AIAC::TimberInfo::Cut::GetHighlightedFace () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-gethighlightedfaceid","title":"function GetHighlightedFaceID","text":"<pre><code>inline std::string AIAC::TimberInfo::Cut::GetHighlightedFaceID () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-gethighlightedfaceneighbors","title":"function GetHighlightedFaceNeighbors","text":"<pre><code>inline std::map&lt; std::string, Face &gt; AIAC::TimberInfo::Cut::GetHighlightedFaceNeighbors () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-highlightface","title":"function HighlightFace","text":"<pre><code>void AIAC::TimberInfo::Cut::HighlightFace (\n    const std::string &amp; faceId,\n    glm::vec4 color=glm::vec4(0)\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-issingleface","title":"function IsSingleFace","text":"<pre><code>inline bool AIAC::TimberInfo::Cut::IsSingleFace () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-setascurrent","title":"function SetAsCurrent","text":"<p>&lt; Base Component __ <pre><code>virtual void AIAC::TimberInfo::Cut::SetAsCurrent () \n</code></pre></p> <p>Implements AIAC::TimberInfo::Component::SetAsCurrent</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-setasdone","title":"function SetAsDone","text":"<pre><code>virtual void AIAC::TimberInfo::Cut::SetAsDone () \n</code></pre> <p>Implements AIAC::TimberInfo::Component::SetAsDone</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-setasnotdone","title":"function SetAsNotDone","text":"<pre><code>virtual void AIAC::TimberInfo::Cut::SetAsNotDone () \n</code></pre> <p>Implements AIAC::TimberInfo::Component::SetAsNotDone</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-setvisibility","title":"function SetVisibility","text":"<pre><code>virtual void AIAC::TimberInfo::Cut::SetVisibility (\n    bool visible\n) \n</code></pre> <p>Implements AIAC::TimberInfo::Component::SetVisibility</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut/#function-setvisibilityallcotas","title":"function SetVisibilityAllCotas","text":"<pre><code>inline void AIAC::TimberInfo::Cut::SetVisibilityAllCotas (\n    bool visible\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/","title":"Class AIAC::TimberInfo::Cut::Edge","text":"<p>ClassList &gt; AIAC &gt; TimberInfo &gt; Cut &gt; Edge</p> <p>Inherits the following classes: AIAC::TimberInfo::Component</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#public-attributes-inherited-from-aiactimberinfocomponent","title":"Public Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name bool IsMarkedDone"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#public-functions","title":"Public Functions","text":"Type Name void ClearCotas () Clear the cotas. Edge ()  GOPoint GetEndPt ()  GOPoint GetStartPt ()  void SetCotasVisibility (bool visible) Set the Cotas Visibility object."},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#public-functions-inherited-from-aiactimberinfocomponent","title":"Public Functions inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name Component (std::string type)  virtual glm::vec3 GetCenter () constHole . __always_inline std::string GetTypeString () const virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#protected-attributes-inherited-from-aiactimberinfocomponent","title":"Protected Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name pugi::xml_node m_ACIMDocNode glm::vec3 m_Center std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_GOPrimitives std::string m_ID float m_Scale ACIMState m_State std::string m_Type"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#function-clearcotas","title":"function ClearCotas","text":"<p>Clear the cotas. <pre><code>inline void AIAC::TimberInfo::Cut::Edge::ClearCotas () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#function-edge","title":"function Edge","text":"<pre><code>inline AIAC::TimberInfo::Cut::Edge::Edge () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#function-getendpt","title":"function GetEndPt","text":"<pre><code>inline GOPoint AIAC::TimberInfo::Cut::Edge::GetEndPt () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#function-getstartpt","title":"function GetStartPt","text":"<pre><code>inline GOPoint AIAC::TimberInfo::Cut::Edge::GetStartPt () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Edge/#function-setcotasvisibility","title":"function SetCotasVisibility","text":"<p>Set the Cotas Visibility object. <pre><code>inline void AIAC::TimberInfo::Cut::Edge::SetCotasVisibility (\n    bool visible\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>visible</code> if true, the cotas will be visible </li> </ul> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/","title":"Class AIAC::TimberInfo::Cut::Face","text":"<p>ClassList &gt; AIAC &gt; TimberInfo &gt; Cut &gt; Face</p> <p>Inherits the following classes: AIAC::TimberInfo::Component</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#public-attributes-inherited-from-aiactimberinfocomponent","title":"Public Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name bool IsMarkedDone"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#public-functions","title":"Public Functions","text":"Type Name Face ()  virtual glm::vec3 GetCenter () override constHole . std::vector&lt; glm::vec3 &gt; GetCorners () const std::set&lt; std::string &gt; GetEdges () const std::set&lt; std::string &gt; GetNeighbors () const glm::vec3 GetNormal () const bool IsExposed () const"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#public-functions-inherited-from-aiactimberinfocomponent","title":"Public Functions inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name Component (std::string type)  virtual glm::vec3 GetCenter () constHole . __always_inline std::string GetTypeString () const virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#protected-attributes-inherited-from-aiactimberinfocomponent","title":"Protected Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name pugi::xml_node m_ACIMDocNode glm::vec3 m_Center std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_GOPrimitives std::string m_ID float m_Scale ACIMState m_State std::string m_Type"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-face","title":"function Face","text":"<pre><code>inline AIAC::TimberInfo::Cut::Face::Face () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-getcenter","title":"function GetCenter","text":"<p>Hole . <pre><code>inline virtual glm::vec3 AIAC::TimberInfo::Cut::Face::GetCenter () override const\n</code></pre></p> <p>Implements AIAC::TimberInfo::Component::GetCenter</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-getcorners","title":"function GetCorners","text":"<pre><code>inline std::vector&lt; glm::vec3 &gt; AIAC::TimberInfo::Cut::Face::GetCorners () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-getedges","title":"function GetEdges","text":"<pre><code>inline std::set&lt; std::string &gt; AIAC::TimberInfo::Cut::Face::GetEdges () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-getneighbors","title":"function GetNeighbors","text":"<pre><code>inline std::set&lt; std::string &gt; AIAC::TimberInfo::Cut::Face::GetNeighbors () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-getnormal","title":"function GetNormal","text":"<pre><code>inline glm::vec3 AIAC::TimberInfo::Cut::Face::GetNormal () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Cut_1_1Face/#function-isexposed","title":"function IsExposed","text":"<pre><code>inline bool AIAC::TimberInfo::Cut::Face::IsExposed () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/","title":"Class AIAC::TimberInfo::Hole","text":"<p>ClassList &gt; AIAC &gt; TimberInfo &gt; Hole</p> <p>Inherits the following classes: AIAC::TimberInfo::Component</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#public-attributes-inherited-from-aiactimberinfocomponent","title":"Public Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name bool IsMarkedDone"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#public-functions","title":"Public Functions","text":"Type Name virtual glm::vec3 GetCenter () override constHole . std::shared_ptr&lt; GOPoint &gt; GetEndPointGO ()  __always_inline double GetRadius () const __always_inline std::shared_ptr&lt; GOPoint &gt; GetStartPointGO ()  Hole ()  virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible) Cut . void SwapStartEnd ()"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#public-functions-inherited-from-aiactimberinfocomponent","title":"Public Functions inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name Component (std::string type)  virtual glm::vec3 GetCenter () constHole . __always_inline std::string GetTypeString () const virtual void SetAsCurrent () &lt; Base Component __ virtual void SetAsDone ()  virtual void SetAsNotDone ()  virtual void SetVisibility (bool visible)"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#protected-attributes-inherited-from-aiactimberinfocomponent","title":"Protected Attributes inherited from AIAC::TimberInfo::Component","text":"<p>See AIAC::TimberInfo::Component</p> Type Name pugi::xml_node m_ACIMDocNode glm::vec3 m_Center std::vector&lt; std::shared_ptr&lt; GOPrimitive &gt; &gt; m_GOPrimitives std::string m_ID float m_Scale ACIMState m_State std::string m_Type"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-getcenter","title":"function GetCenter","text":"<p>Hole . <pre><code>inline virtual glm::vec3 AIAC::TimberInfo::Hole::GetCenter () override const\n</code></pre></p> <p>Implements AIAC::TimberInfo::Component::GetCenter</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-getendpointgo","title":"function GetEndPointGO","text":"<pre><code>inline std::shared_ptr&lt; GOPoint &gt; AIAC::TimberInfo::Hole::GetEndPointGO () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-getradius","title":"function GetRadius","text":"<pre><code>inline __always_inline double AIAC::TimberInfo::Hole::GetRadius () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-getstartpointgo","title":"function GetStartPointGO","text":"<pre><code>inline __always_inline std::shared_ptr&lt; GOPoint &gt; AIAC::TimberInfo::Hole::GetStartPointGO () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-hole","title":"function Hole","text":"<pre><code>inline AIAC::TimberInfo::Hole::Hole () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-setascurrent","title":"function SetAsCurrent","text":"<p>&lt; Base Component __ <pre><code>virtual void AIAC::TimberInfo::Hole::SetAsCurrent () \n</code></pre></p> <p>Implements AIAC::TimberInfo::Component::SetAsCurrent</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-setasdone","title":"function SetAsDone","text":"<pre><code>virtual void AIAC::TimberInfo::Hole::SetAsDone () \n</code></pre> <p>Implements AIAC::TimberInfo::Component::SetAsDone</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-setasnotdone","title":"function SetAsNotDone","text":"<pre><code>virtual void AIAC::TimberInfo::Hole::SetAsNotDone () \n</code></pre> <p>Implements AIAC::TimberInfo::Component::SetAsNotDone</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-setvisibility","title":"function SetVisibility","text":"<p>Cut . <pre><code>virtual void AIAC::TimberInfo::Hole::SetVisibility (\n    bool visible\n) \n</code></pre></p> <p>Implements AIAC::TimberInfo::Component::SetVisibility</p>"},{"location":"acdoxygen/classAIAC_1_1TimberInfo_1_1Hole/#function-swapstartend","title":"function SwapStartEnd","text":"<pre><code>void AIAC::TimberInfo::Hole::SwapStartEnd () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1ToolHeadData/","title":"Class AIAC::ToolHeadData","text":"<p>ClassList &gt; AIAC &gt; ToolHeadData</p> <p>Class holding and parse and create data from the .acit file of the toolhead. </p> <ul> <li><code>#include &lt;ACInfoToolhead.h&gt;</code></li> </ul>"},{"location":"acdoxygen/classAIAC_1_1ToolHeadData/#public-functions","title":"Public Functions","text":"Type Name __always_inline std::string ToString () constconvert to a string ToolHeadData ()  ~ToolHeadData () = default"},{"location":"acdoxygen/classAIAC_1_1ToolHeadData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1ToolHeadData/#function-tostring","title":"function ToString","text":"<p>convert to a string <pre><code>inline __always_inline std::string AIAC::ToolHeadData::ToString () const\n</code></pre></p> <p>&lt; utils </p>"},{"location":"acdoxygen/classAIAC_1_1ToolHeadData/#function-toolheaddata","title":"function ToolHeadData","text":"<pre><code>inline AIAC::ToolHeadData::ToolHeadData () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1ToolHeadData/#function-toolheaddata_1","title":"function ~ToolHeadData","text":"<pre><code>AIAC::ToolHeadData::~ToolHeadData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/","title":"Class AIAC::TouchMonitor","text":"<p>ClassList &gt; AIAC &gt; TouchMonitor</p>"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#public-functions","title":"Public Functions","text":"Type Name GLFWmonitor *&amp; GetGLFWMonitor ()  void PrintInfoMonitors (int count, GLFWmonitor **&amp; monitors)  TouchMonitor ()  TouchMonitor (bool isPrintMonitorsInfo)  virtual ~TouchMonitor () = default"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#function-getglfwmonitor","title":"function GetGLFWMonitor","text":"<pre><code>inline GLFWmonitor *&amp; AIAC::TouchMonitor::GetGLFWMonitor () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#function-printinfomonitors","title":"function PrintInfoMonitors","text":"<pre><code>void AIAC::TouchMonitor::PrintInfoMonitors (\n    int count,\n    GLFWmonitor **&amp; monitors\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#function-touchmonitor-12","title":"function TouchMonitor [\u00bd]","text":"<pre><code>AIAC::TouchMonitor::TouchMonitor () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#function-touchmonitor-22","title":"function TouchMonitor [2/2]","text":"<pre><code>AIAC::TouchMonitor::TouchMonitor (\n    bool isPrintMonitorsInfo\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1TouchMonitor/#function-touchmonitor","title":"function ~TouchMonitor","text":"<pre><code>virtual AIAC::TouchMonitor::~TouchMonitor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/TouchMonitor.h</code></p>"},{"location":"acdoxygen/namespaceAIAC_1_1Utils/","title":"Namespace AIAC::Utils","text":"<p>Namespace List &gt; AIAC &gt; Utils</p>"},{"location":"acdoxygen/namespaceAIAC_1_1Utils/#classes","title":"Classes","text":"Type Name class HoleToolheadAxisExporter class Screenshot class VideoRecorder <p>The documentation for this class was generated from the following file <code>src/utils/HoleToolheadAxisExporter.cpp</code></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/","title":"Class AIAC::Utils::HoleToolheadAxisExporter","text":"<p>ClassList &gt; AIAC &gt; Utils &gt; HoleToolheadAxisExporter</p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#public-functions","title":"Public Functions","text":"Type Name void ExportCoordinates () Export and write the hole and toolhead coordinates. void ExportHoleAxis () Export the hole coordinates. void ExportToolheadAxis () Export the toolhead coordinates. std::string GetCurrentTimestamp () Get the current timestamp. HoleToolheadAxisExporter (const std::string &amp; basePath)  void WriteBufferToFile () Write the buffer to a file. void WriteCoordToBuffer (const std::string &amp; itemType, std::string itemName, const std::string &amp; pointType, std::shared_ptr&lt; GOPoint &gt; goPoint) Write the coordinates to a .log file. ~HoleToolheadAxisExporter () = default"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-exportcoordinates","title":"function ExportCoordinates","text":"<p>Export and write the hole and toolhead coordinates. <pre><code>void AIAC::Utils::HoleToolheadAxisExporter::ExportCoordinates () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-exportholeaxis","title":"function ExportHoleAxis","text":"<p>Export the hole coordinates. <pre><code>void AIAC::Utils::HoleToolheadAxisExporter::ExportHoleAxis () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-exporttoolheadaxis","title":"function ExportToolheadAxis","text":"<p>Export the toolhead coordinates. <pre><code>void AIAC::Utils::HoleToolheadAxisExporter::ExportToolheadAxis () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-getcurrenttimestamp","title":"function GetCurrentTimestamp","text":"<p>Get the current timestamp. <pre><code>std::string AIAC::Utils::HoleToolheadAxisExporter::GetCurrentTimestamp () \n</code></pre></p> <p>Returns:</p> <p>A string representing the current timestamp </p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-holetoolheadaxisexporter","title":"function HoleToolheadAxisExporter","text":"<pre><code>explicit AIAC::Utils::HoleToolheadAxisExporter::HoleToolheadAxisExporter (\n    const std::string &amp; basePath\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-writebuffertofile","title":"function WriteBufferToFile","text":"<p>Write the buffer to a file. <pre><code>void AIAC::Utils::HoleToolheadAxisExporter::WriteBufferToFile () \n</code></pre></p> <p>The data is written in the following format: ItemType,ItemName,PointType,X,Y,Z </p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-writecoordtobuffer","title":"function WriteCoordToBuffer","text":"<p>Write the coordinates to a .log file. <pre><code>void AIAC::Utils::HoleToolheadAxisExporter::WriteCoordToBuffer (\n    const std::string &amp; itemType,\n    std::string itemName,\n    const std::string &amp; pointType,\n    std::shared_ptr&lt; GOPoint &gt; goPoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>itemType</code> Type of the item (toolhead or hole) </li> <li><code>pointType</code> Type of the point (start or end) </li> <li><code>goPoint</code> Pointer to the GOPoint object to get the coordinates from </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1HoleToolheadAxisExporter/#function-holetoolheadaxisexporter_1","title":"function ~HoleToolheadAxisExporter","text":"<pre><code>AIAC::Utils::HoleToolheadAxisExporter::~HoleToolheadAxisExporter () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/HoleToolheadAxisExporter.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/","title":"Class AIAC::Utils::Screenshot","text":"<p>ClassList &gt; AIAC &gt; Utils &gt; Screenshot</p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#public-functions","title":"Public Functions","text":"Type Name void CaptureBuffer () Capture current buffer (color) void CaptureWindow () Capture pixels of the current window. void GenerateImageName (bool isWindow) Generate the name of the image. void SaveScreenshot (cv::Mat image) Save the screenshot. Screenshot (const std::string &amp; basePath)"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#function-capturebuffer","title":"function CaptureBuffer","text":"<p>Capture current buffer (color) <pre><code>void AIAC::Utils::Screenshot::CaptureBuffer () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#function-capturewindow","title":"function CaptureWindow","text":"<p>Capture pixels of the current window. <pre><code>void AIAC::Utils::Screenshot::CaptureWindow () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#function-generateimagename","title":"function GenerateImageName","text":"<p>Generate the name of the image. <pre><code>void AIAC::Utils::Screenshot::GenerateImageName (\n    bool isWindow\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isWindow</code> Flag to check if the image is a window screenshot if not it is a buffer screenshot </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#function-savescreenshot","title":"function SaveScreenshot","text":"<p>Save the screenshot. <pre><code>void AIAC::Utils::Screenshot::SaveScreenshot (\n    cv::Mat image\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>image</code> Image to save </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1Screenshot/#function-screenshot","title":"function Screenshot","text":"<pre><code>explicit AIAC::Utils::Screenshot::Screenshot (\n    const std::string &amp; basePath\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/Screenshot.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/","title":"Class AIAC::Utils::VideoRecorder","text":"<p>ClassList &gt; AIAC &gt; Utils &gt; VideoRecorder</p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#public-functions","title":"Public Functions","text":"Type Name void CaptureFrames () Capture frames from the window. void DeleteFrameFolder () Delete the /frames folder. void InitializeDirectories () Create folders for captured frames and videos. void MakeVideoFromFrames () Create video from the frames using ffmpeg. void SaveFrames (int height, int width, std::vector&lt; unsigned char &gt; pixels) Save frames to the frame folder. void UpdatePaths () Updates the paths used for video and frame storage. VideoRecorder (const std::string &amp; basePath)  ~VideoRecorder ()"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-captureframes","title":"function CaptureFrames","text":"<p>Capture frames from the window. <pre><code>void AIAC::Utils::VideoRecorder::CaptureFrames () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-deleteframefolder","title":"function DeleteFrameFolder","text":"<p>Delete the /frames folder. <pre><code>void AIAC::Utils::VideoRecorder::DeleteFrameFolder () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-initializedirectories","title":"function InitializeDirectories","text":"<p>Create folders for captured frames and videos. <pre><code>void AIAC::Utils::VideoRecorder::InitializeDirectories () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-makevideofromframes","title":"function MakeVideoFromFrames","text":"<p>Create video from the frames using ffmpeg. <pre><code>void AIAC::Utils::VideoRecorder::MakeVideoFromFrames () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-saveframes","title":"function SaveFrames","text":"<p>Save frames to the frame folder. <pre><code>void AIAC::Utils::VideoRecorder::SaveFrames (\n    int height,\n    int width,\n    std::vector&lt; unsigned char &gt; pixels\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>height</code> Height of the window </li> <li><code>width</code> Width of the window </li> <li><code>pixels</code> Vector to hold the data </li> </ul>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-updatepaths","title":"function UpdatePaths","text":"<p>Updates the paths used for video and frame storage. <pre><code>void AIAC::Utils::VideoRecorder::UpdatePaths () \n</code></pre></p>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-videorecorder","title":"function VideoRecorder","text":"<pre><code>explicit AIAC::Utils::VideoRecorder::VideoRecorder (\n    const std::string &amp; basePath\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Utils_1_1VideoRecorder/#function-videorecorder_1","title":"function ~VideoRecorder","text":"<pre><code>AIAC::Utils::VideoRecorder::~VideoRecorder () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/VideoRecorder.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Viewport/","title":"Class AIAC::Viewport","text":"<p>ClassList &gt; AIAC &gt; Viewport</p>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#public-functions","title":"Public Functions","text":"Type Name void Activate ()  GLuint GetH () const GLuint GetTexture () const GLuint GetW () const void Init (int w, int h)  void SetSize (int w, int h)  Viewport () = default ~Viewport () = default"},{"location":"acdoxygen/classAIAC_1_1Viewport/#protected-attributes","title":"Protected Attributes","text":"Type Name GLuint m_DepthBuffer GLuint m_FrameBuffer GLuint m_H GLuint m_Texture GLuint m_W"},{"location":"acdoxygen/classAIAC_1_1Viewport/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-activate","title":"function Activate","text":"<pre><code>void AIAC::Viewport::Activate () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-geth","title":"function GetH","text":"<pre><code>inline GLuint AIAC::Viewport::GetH () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-gettexture","title":"function GetTexture","text":"<pre><code>inline GLuint AIAC::Viewport::GetTexture () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-getw","title":"function GetW","text":"<pre><code>inline GLuint AIAC::Viewport::GetW () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-init","title":"function Init","text":"<pre><code>void AIAC::Viewport::Init (\n    int w,\n    int h\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-setsize","title":"function SetSize","text":"<pre><code>inline void AIAC::Viewport::SetSize (\n    int w,\n    int h\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-viewport","title":"function Viewport","text":"<pre><code>AIAC::Viewport::Viewport () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#function-viewport_1","title":"function ~Viewport","text":"<pre><code>AIAC::Viewport::~Viewport () = default\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Viewport/#variable-m_depthbuffer","title":"variable m_DepthBuffer","text":"<pre><code>GLuint AIAC::Viewport::m_DepthBuffer;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#variable-m_framebuffer","title":"variable m_FrameBuffer","text":"<pre><code>GLuint AIAC::Viewport::m_FrameBuffer;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#variable-m_h","title":"variable m_H","text":"<pre><code>GLuint AIAC::Viewport::m_H;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#variable-m_texture","title":"variable m_Texture","text":"<pre><code>GLuint AIAC::Viewport::m_Texture;\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Viewport/#variable-m_w","title":"variable m_W","text":"<pre><code>GLuint AIAC::Viewport::m_W;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Viewport.h</code></p>"},{"location":"acdoxygen/classAIAC_1_1Window/","title":"Class AIAC::Window","text":"<p>ClassList &gt; AIAC &gt; Window</p>"},{"location":"acdoxygen/classAIAC_1_1Window/#public-functions","title":"Public Functions","text":"Type Name int GetDisplayH ()  int GetDisplayW ()  GLFWwindow * GetGLFWWindow ()  const char * GetGlslVersion ()  uint32_t GetHeight () const uint32_t GetWidth () const void Init ()  bool IsOpen ()  bool IsVSync () const void MakeCurrent ()  void OnBufferSwap ()  void OnUpdate ()  void ReleaseCurrent ()  void SetVSync (bool enabled)  void Shutdown ()  Window (const WindowProps &amp; props)  virtual ~Window ()"},{"location":"acdoxygen/classAIAC_1_1Window/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classAIAC_1_1Window/#function-getdisplayh","title":"function GetDisplayH","text":"<pre><code>inline int AIAC::Window::GetDisplayH () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-getdisplayw","title":"function GetDisplayW","text":"<pre><code>inline int AIAC::Window::GetDisplayW () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-getglfwwindow","title":"function GetGLFWWindow","text":"<pre><code>inline GLFWwindow * AIAC::Window::GetGLFWWindow () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-getglslversion","title":"function GetGlslVersion","text":"<pre><code>inline const char * AIAC::Window::GetGlslVersion () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-getheight","title":"function GetHeight","text":"<pre><code>inline uint32_t AIAC::Window::GetHeight () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-getwidth","title":"function GetWidth","text":"<pre><code>inline uint32_t AIAC::Window::GetWidth () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-init","title":"function Init","text":"<pre><code>void AIAC::Window::Init () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-isopen","title":"function IsOpen","text":"<pre><code>bool AIAC::Window::IsOpen () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-isvsync","title":"function IsVSync","text":"<pre><code>inline bool AIAC::Window::IsVSync () const\n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-makecurrent","title":"function MakeCurrent","text":"<pre><code>void AIAC::Window::MakeCurrent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-onbufferswap","title":"function OnBufferSwap","text":"<pre><code>void AIAC::Window::OnBufferSwap () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-onupdate","title":"function OnUpdate","text":"<pre><code>void AIAC::Window::OnUpdate () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-releasecurrent","title":"function ReleaseCurrent","text":"<pre><code>void AIAC::Window::ReleaseCurrent () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-setvsync","title":"function SetVSync","text":"<pre><code>void AIAC::Window::SetVSync (\n    bool enabled\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-shutdown","title":"function Shutdown","text":"<pre><code>void AIAC::Window::Shutdown () \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-window","title":"function Window","text":"<pre><code>AIAC::Window::Window (\n    const WindowProps &amp; props\n) \n</code></pre>"},{"location":"acdoxygen/classAIAC_1_1Window/#function-window_1","title":"function ~Window","text":"<pre><code>virtual AIAC::Window::~Window () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Window.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/","title":"Struct AIAC::WindowProps","text":"<p>ClassList &gt; AIAC &gt; WindowProps</p>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t Height bool IsResizable const char * Title bool VSync uint32_t Width"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#public-functions","title":"Public Functions","text":"Type Name WindowProps (const char * title=\"augmented_carpentry\", uint32_t width=800, uint32_t height=480, bool vSync=true, bool isResizable=false)"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1WindowProps/#variable-height","title":"variable Height","text":"<pre><code>uint32_t AIAC::WindowProps::Height;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#variable-isresizable","title":"variable IsResizable","text":"<pre><code>bool AIAC::WindowProps::IsResizable;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#variable-title","title":"variable Title","text":"<pre><code>const char* AIAC::WindowProps::Title;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#variable-vsync","title":"variable VSync","text":"<pre><code>bool AIAC::WindowProps::VSync;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#variable-width","title":"variable Width","text":"<pre><code>uint32_t AIAC::WindowProps::Width;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1WindowProps/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1WindowProps/#function-windowprops","title":"function WindowProps","text":"<pre><code>inline AIAC::WindowProps::WindowProps (\n    const char * title=\"augmented_carpentry\",\n    uint32_t width=800,\n    uint32_t height=480,\n    bool vSync=true,\n    bool isResizable=false\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Window.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/","title":"Struct AIAC::LayerUI::CombineMapParams","text":"<p>ClassList &gt; CombineMapParams</p>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/#public-attributes","title":"Public Attributes","text":"Type Name char * FilePathTarget char MapPathA   = <code>{0}</code> char MapPathB   = <code>{0}</code> char OutputPath   = <code>{0}</code>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/#variable-filepathtarget","title":"variable FilePathTarget","text":"<pre><code>char* AIAC::LayerUI::CombineMapParams::FilePathTarget;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/#variable-mappatha","title":"variable MapPathA","text":"<pre><code>char AIAC::LayerUI::CombineMapParams::MapPathA[PATH_BUF_SIZE];\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/#variable-mappathb","title":"variable MapPathB","text":"<pre><code>char AIAC::LayerUI::CombineMapParams::MapPathB[PATH_BUF_SIZE];\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1CombineMapParams/#variable-outputpath","title":"variable OutputPath","text":"<pre><code>char AIAC::LayerUI::CombineMapParams::OutputPath[PATH_BUF_SIZE];\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1MappingParams/","title":"Struct AIAC::LayerUI::MappingParams","text":"<p>ClassList &gt; MappingParams</p>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1MappingParams/#public-attributes","title":"Public Attributes","text":"Type Name char MapSavingPath   = <code>\"./scanned\\_map/test.map\"</code> bool ToOptimizeMap   = <code>true</code> bool ToSaveMap   = <code>true</code>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1MappingParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1MappingParams/#variable-mapsavingpath","title":"variable MapSavingPath","text":"<pre><code>char AIAC::LayerUI::MappingParams::MapSavingPath[PATH_BUF_SIZE];\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1MappingParams/#variable-tooptimizemap","title":"variable ToOptimizeMap","text":"<pre><code>bool AIAC::LayerUI::MappingParams::ToOptimizeMap;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1MappingParams/#variable-tosavemap","title":"variable ToSaveMap","text":"<pre><code>bool AIAC::LayerUI::MappingParams::ToSaveMap;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/","title":"Struct AIAC::LayerUI::ReconstructParams","text":"<p>ClassList &gt; ReconstructParams</p>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#public-attributes","title":"Public Attributes","text":"Type Name double AABBScaleFactor   = <code>1.1f</code> double CreaseAngleThreshold   = <code>5.0f</code> double Eps   = <code>1e-5f</code> char ExportPath   = <code>{0}</code> double MaxPlnAngle   = <code>5.0f</code> double MaxPlnDist   = <code>1.0f</code> double MaxPolyDist   = <code>1.0f</code> int MinClusterSize   = <code>1</code> float RadiusSearch   = <code>2.0f</code> char TagMapPath   = <code>{0}</code>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-aabbscalefactor","title":"variable AABBScaleFactor","text":"<pre><code>double AIAC::LayerUI::ReconstructParams::AABBScaleFactor;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-creaseanglethreshold","title":"variable CreaseAngleThreshold","text":"<pre><code>double AIAC::LayerUI::ReconstructParams::CreaseAngleThreshold;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-eps","title":"variable Eps","text":"<pre><code>double AIAC::LayerUI::ReconstructParams::Eps;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-exportpath","title":"variable ExportPath","text":"<pre><code>char AIAC::LayerUI::ReconstructParams::ExportPath[PATH_BUF_SIZE];\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-maxplnangle","title":"variable MaxPlnAngle","text":"<pre><code>double AIAC::LayerUI::ReconstructParams::MaxPlnAngle;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-maxplndist","title":"variable MaxPlnDist","text":"<pre><code>double AIAC::LayerUI::ReconstructParams::MaxPlnDist;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-maxpolydist","title":"variable MaxPolyDist","text":"<pre><code>double AIAC::LayerUI::ReconstructParams::MaxPolyDist;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-minclustersize","title":"variable MinClusterSize","text":"<pre><code>int AIAC::LayerUI::ReconstructParams::MinClusterSize;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-radiussearch","title":"variable RadiusSearch","text":"<pre><code>float AIAC::LayerUI::ReconstructParams::RadiusSearch;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1LayerUI_1_1ReconstructParams/#variable-tagmappath","title":"variable TagMapPath","text":"<pre><code>char AIAC::LayerUI::ReconstructParams::TagMapPath[PATH_BUF_SIZE];\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.h</code></p>"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/","title":"Struct AIAC::Window::WindowData","text":"<p>ClassList &gt; WindowData</p>"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t Height bool IsResizable const char * Title bool VSync uint32_t Width"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#variable-height","title":"variable Height","text":"<pre><code>uint32_t AIAC::Window::WindowData::Height;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#variable-isresizable","title":"variable IsResizable","text":"<pre><code>bool AIAC::Window::WindowData::IsResizable;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#variable-title","title":"variable Title","text":"<pre><code>const char* AIAC::Window::WindowData::Title;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#variable-vsync","title":"variable VSync","text":"<pre><code>bool AIAC::Window::WindowData::VSync;\n</code></pre>"},{"location":"acdoxygen/structAIAC_1_1Window_1_1WindowData/#variable-width","title":"variable Width","text":"<pre><code>uint32_t AIAC::Window::WindowData::Width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Window.h</code></p>"},{"location":"acdoxygen/classCircularBuffer/","title":"Class CircularBuffer","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; CircularBuffer</p>"},{"location":"acdoxygen/classCircularBuffer/#public-types","title":"Public Types","text":"Type Name typedef BufferIterator&lt; true &gt; const_iterator typedef BufferIterator&lt; false &gt; iterator typedef T value_type"},{"location":"acdoxygen/classCircularBuffer/#public-functions","title":"Public Functions","text":"Type Name CircularBuffer (size_t size)  CircularBuffer (const CircularBuffer &amp; other)  CircularBuffer (CircularBuffer &amp;&amp; other) noexcept const_reference at (size_type index) const reference at (size_type index)  reference back ()  const_reference back () const iterator begin ()  const_iterator begin () const size_type buffer_size () const size_type capacity () const const_iterator cbegin () noexcept const const_iterator cend () noexcept const void clear ()  const_pointer data () const bool empty () const iterator end ()  const_iterator end () const reference front ()  const_reference front () const bool full () const CircularBuffer &amp; operator= (const CircularBuffer &amp; other)  CircularBuffer &amp; operator= (CircularBuffer &amp;&amp; other) noexcept const_reference operator[] (size_type index) const reference operator[] (size_type index)  void pop_front ()  void push_back (const value_type &amp; data)  void push_back (value_type &amp;&amp; data) noexcept iterator rbegin () noexcept const_iterator rbegin () noexcept const iterator rend () noexcept const_iterator rend () noexcept const size_type size () const"},{"location":"acdoxygen/classCircularBuffer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/classCircularBuffer/#typedef-const_iterator","title":"typedef const_iterator","text":"<pre><code>typedef BufferIterator&lt;true&gt; CircularBuffer&lt; T &gt;::const_iterator;\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#typedef-iterator","title":"typedef iterator","text":"<pre><code>typedef BufferIterator&lt;false&gt; CircularBuffer&lt; T &gt;::iterator;\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef T CircularBuffer&lt; T &gt;::value_type;\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classCircularBuffer/#function-circularbuffer-13","title":"function CircularBuffer [\u2153]","text":"<pre><code>inline explicit CircularBuffer::CircularBuffer (\n    size_t size\n) \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-circularbuffer-23","title":"function CircularBuffer [\u2154]","text":"<pre><code>inline CircularBuffer::CircularBuffer (\n    const CircularBuffer &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-circularbuffer-33","title":"function CircularBuffer [3/3]","text":"<pre><code>inline CircularBuffer::CircularBuffer (\n    CircularBuffer &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-at-12","title":"function at [\u00bd]","text":"<pre><code>inline const_reference CircularBuffer::at (\n    size_type index\n) const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-at-22","title":"function at [2/2]","text":"<pre><code>inline reference CircularBuffer::at (\n    size_type index\n) \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-back-12","title":"function back [\u00bd]","text":"<pre><code>inline reference CircularBuffer::back () \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-back-22","title":"function back [2/2]","text":"<pre><code>inline const_reference CircularBuffer::back () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-begin-12","title":"function begin [\u00bd]","text":"<pre><code>inline iterator CircularBuffer::begin () \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>inline const_iterator CircularBuffer::begin () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-buffer_size","title":"function buffer_size","text":"<pre><code>inline size_type CircularBuffer::buffer_size () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-capacity","title":"function capacity","text":"<pre><code>inline size_type CircularBuffer::capacity () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-cbegin","title":"function cbegin","text":"<pre><code>inline const_iterator CircularBuffer::cbegin () noexcept const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-cend","title":"function cend","text":"<pre><code>inline const_iterator CircularBuffer::cend () noexcept const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-clear","title":"function clear","text":"<pre><code>inline void CircularBuffer::clear () \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-data","title":"function data","text":"<pre><code>inline const_pointer CircularBuffer::data () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-empty","title":"function empty","text":"<pre><code>inline bool CircularBuffer::empty () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-end-12","title":"function end [\u00bd]","text":"<pre><code>inline iterator CircularBuffer::end () \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-end-22","title":"function end [2/2]","text":"<pre><code>inline const_iterator CircularBuffer::end () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-front-12","title":"function front [\u00bd]","text":"<pre><code>inline reference CircularBuffer::front () \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-front-22","title":"function front [2/2]","text":"<pre><code>inline const_reference CircularBuffer::front () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-full","title":"function full","text":"<pre><code>inline bool CircularBuffer::full () const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-operator","title":"function operator=","text":"<pre><code>inline CircularBuffer &amp; CircularBuffer::operator= (\n    const CircularBuffer &amp; other\n) \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-operator_1","title":"function operator=","text":"<pre><code>inline CircularBuffer &amp; CircularBuffer::operator= (\n    CircularBuffer &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-operator_2","title":"function operator[]","text":"<pre><code>inline const_reference CircularBuffer::operator[] (\n    size_type index\n) const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-operator_3","title":"function operator[]","text":"<pre><code>inline reference CircularBuffer::operator[] (\n    size_type index\n) \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-pop_front","title":"function pop_front","text":"<pre><code>inline void CircularBuffer::pop_front () \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-push_back-12","title":"function push_back [\u00bd]","text":"<pre><code>inline void CircularBuffer::push_back (\n    const value_type &amp; data\n) \n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-push_back-22","title":"function push_back [2/2]","text":"<pre><code>inline void CircularBuffer::push_back (\n    value_type &amp;&amp; data\n) noexcept\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-rbegin-12","title":"function rbegin [\u00bd]","text":"<pre><code>inline iterator CircularBuffer::rbegin () noexcept\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-rbegin-22","title":"function rbegin [2/2]","text":"<pre><code>inline const_iterator CircularBuffer::rbegin () noexcept const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-rend-12","title":"function rend [\u00bd]","text":"<pre><code>inline iterator CircularBuffer::rend () noexcept\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-rend-22","title":"function rend [2/2]","text":"<pre><code>inline const_iterator CircularBuffer::rend () noexcept const\n</code></pre>"},{"location":"acdoxygen/classCircularBuffer/#function-size","title":"function size","text":"<pre><code>inline size_type CircularBuffer::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/CircularBuffer.h</code></p>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/","title":"Struct CircularBuffer::BufferIterator","text":"<p>template &lt;bool isConst&gt;</p> <p>ClassList &gt; BufferIterator</p>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#public-types","title":"Public Types","text":"Type Name typedef std::conditional&lt; isConst, constCircularBuffer&lt; value_type &gt; *, CircularBuffer&lt; value_type &gt; * &gt;::type cbuf_pointer typedef ptrdiff_t difference_type typedef std::random_access_iterator_tag iterator_category typedef std::conditional&lt; isConst, constvalue_type *, value_type * &gt;::type pointer typedef std::conditional&lt; isConst, constvalue_type &amp;, value_type &amp; &gt;::type reference typedef T value_type"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#public-functions","title":"Public Functions","text":"Type Name BufferIterator ()  BufferIterator (const BufferIterator&lt; false &gt; &amp; it)  bool operator!= (const BufferIterator &amp; other) const reference operator* ()  BufferIterator &amp; operator++ ()  BufferIterator operator++ (int)  BufferIterator &amp; operator+= (difference_type n)  BufferIterator &amp; operator-- ()  BufferIterator operator-- (int)  BufferIterator &amp; operator-= (difference_type n)  pointer operator-&gt; ()  bool operator&lt; (const BufferIterator &amp; other) const bool operator&lt;= (const BufferIterator &amp; other) const bool operator== (const BufferIterator &amp; other) const bool operator&gt; (const BufferIterator &amp; other) const bool operator&gt;= (const BufferIterator &amp; other) const reference operator[] (size_type index)"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#typedef-cbuf_pointer","title":"typedef cbuf_pointer","text":"<pre><code>typedef std::conditional&lt;isConst,constCircularBuffer&lt;value_type&gt;*,CircularBuffer&lt;value_type&gt;*&gt;::type CircularBuffer&lt; T &gt;::BufferIterator&lt; isConst &gt;::cbuf_pointer;\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>typedef ptrdiff_t CircularBuffer&lt; T &gt;::BufferIterator&lt; isConst &gt;::difference_type;\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>typedef std::random_access_iterator_tag CircularBuffer&lt; T &gt;::BufferIterator&lt; isConst &gt;::iterator_category;\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>typedef std::conditional&lt;isConst,constvalue_type*,value_type*&gt;::type CircularBuffer&lt; T &gt;::BufferIterator&lt; isConst &gt;::pointer;\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#typedef-reference","title":"typedef reference","text":"<pre><code>typedef std::conditional&lt;isConst,constvalue_type&amp;,value_type&amp;&gt;::type CircularBuffer&lt; T &gt;::BufferIterator&lt; isConst &gt;::reference;\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef T CircularBuffer&lt; T &gt;::BufferIterator&lt; isConst &gt;::value_type;\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-bufferiterator-12","title":"function BufferIterator [\u00bd]","text":"<pre><code>inline BufferIterator::BufferIterator () \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-bufferiterator-22","title":"function BufferIterator [2/2]","text":"<pre><code>inline BufferIterator::BufferIterator (\n    const BufferIterator&lt; false &gt; &amp; it\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool BufferIterator::operator!= (\n    const BufferIterator &amp; other\n) const\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline reference BufferIterator::operator* () \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline BufferIterator &amp; BufferIterator::operator++ () \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_3","title":"function operator++","text":"<pre><code>inline BufferIterator BufferIterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_4","title":"function operator+=","text":"<pre><code>inline BufferIterator &amp; BufferIterator::operator+= (\n    difference_type n\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator-","title":"function operator--","text":"<pre><code>inline BufferIterator &amp; BufferIterator::operator-- () \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator-_1","title":"function operator--","text":"<pre><code>inline BufferIterator BufferIterator::operator-- (\n    int\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline BufferIterator &amp; BufferIterator::operator-= (\n    difference_type n\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator-_3","title":"function operator-&gt;","text":"<pre><code>inline pointer BufferIterator::operator-&gt; () \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_5","title":"function operator&lt;","text":"<pre><code>inline bool BufferIterator::operator&lt; (\n    const BufferIterator &amp; other\n) const\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_6","title":"function operator&lt;=","text":"<pre><code>inline bool BufferIterator::operator&lt;= (\n    const BufferIterator &amp; other\n) const\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_7","title":"function operator==","text":"<pre><code>inline bool BufferIterator::operator== (\n    const BufferIterator &amp; other\n) const\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_8","title":"function operator&gt;","text":"<pre><code>inline bool BufferIterator::operator&gt; (\n    const BufferIterator &amp; other\n) const\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_9","title":"function operator&gt;=","text":"<pre><code>inline bool BufferIterator::operator&gt;= (\n    const BufferIterator &amp; other\n) const\n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#function-operator_10","title":"function operator[]","text":"<pre><code>inline reference BufferIterator::operator[] (\n    size_type index\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#friends-documentation","title":"Friends Documentation","text":""},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#friend-circularbuffer-t","title":"friend CircularBuffer&lt; T &gt;","text":"<pre><code>class BufferIterator::CircularBuffer&lt; T &gt; (\n    CircularBuffer &lt; T &gt;\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#friend-operator","title":"friend operator+","text":"<pre><code>inline BufferIterator BufferIterator::operator+ (\n    BufferIterator lhsiter,\n    difference_type n\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#friend-operator_1","title":"friend operator+","text":"<pre><code>inline BufferIterator BufferIterator::operator+ (\n    difference_type n,\n    BufferIterator rhsiter\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#friend-operator-","title":"friend operator-","text":"<pre><code>inline BufferIterator BufferIterator::operator- (\n    BufferIterator lhsiter,\n    difference_type n\n) \n</code></pre>"},{"location":"acdoxygen/structCircularBuffer_1_1BufferIterator/#friend-operator-_1","title":"friend operator-","text":"<pre><code>inline difference_type BufferIterator::operator- (\n    const BufferIterator &amp; lhsiter,\n    const BufferIterator &amp; rhsiter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/CircularBuffer.h</code></p>"},{"location":"acdoxygen/structIGFD__Selection/","title":"Struct IGFD_Selection","text":"<p>ClassList &gt; IGFD_Selection</p>"},{"location":"acdoxygen/structIGFD__Selection/#public-attributes","title":"Public Attributes","text":"Type Name size_t count IGFD_Selection_Pair * table"},{"location":"acdoxygen/structIGFD__Selection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structIGFD__Selection/#variable-count","title":"variable count","text":"<pre><code>size_t IGFD_Selection::count;\n</code></pre>"},{"location":"acdoxygen/structIGFD__Selection/#variable-table","title":"variable table","text":"<pre><code>IGFD_Selection_Pair* IGFD_Selection::table;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/ImGuiFileDialog.h</code></p>"},{"location":"acdoxygen/structIGFD__Selection__Pair/","title":"Struct IGFD_Selection_Pair","text":"<p>ClassList &gt; IGFD_Selection_Pair</p>"},{"location":"acdoxygen/structIGFD__Selection__Pair/#public-attributes","title":"Public Attributes","text":"Type Name char * fileName char * filePathName"},{"location":"acdoxygen/structIGFD__Selection__Pair/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/structIGFD__Selection__Pair/#variable-filename","title":"variable fileName","text":"<pre><code>char* IGFD_Selection_Pair::fileName;\n</code></pre>"},{"location":"acdoxygen/structIGFD__Selection__Pair/#variable-filepathname","title":"variable filePathName","text":"<pre><code>char* IGFD_Selection_Pair::filePathName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/ImGuiFileDialog.h</code></p>"},{"location":"acdoxygen/namespaceglob/","title":"Namespace glob","text":"<p>Namespace List &gt; glob</p>"},{"location":"acdoxygen/namespaceglob/#classes","title":"Classes","text":"Type Name class glob class glob_impl <p>The documentation for this class was generated from the following file <code>src/utils/glob.cpp</code></p>"},{"location":"acdoxygen/classglob_1_1glob/","title":"Class glob::glob","text":"<p>ClassList &gt; glob &gt; glob</p>"},{"location":"acdoxygen/classglob_1_1glob/#public-attributes","title":"Public Attributes","text":"Type Name std::string dir_path"},{"location":"acdoxygen/classglob_1_1glob/#public-functions","title":"Public Functions","text":"Type Name void close ()  std::string current_match () const glob (const std::string &amp; pattern)  bool is_valid () const bool next ()  void open (const std::string &amp; pattern)  operator bool () const ~glob ()"},{"location":"acdoxygen/classglob_1_1glob/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classglob_1_1glob/#variable-dir_path","title":"variable dir_path","text":"<pre><code>std::string glob::glob::dir_path;\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classglob_1_1glob/#function-close","title":"function close","text":"<pre><code>void glob::glob::close () \n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-current_match","title":"function current_match","text":"<pre><code>std::string glob::glob::current_match () const\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-glob-12","title":"function glob [\u00bd]","text":"<pre><code>glob::glob::glob (\n    const std::string &amp; pattern\n) \n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-is_valid","title":"function is_valid","text":"<pre><code>bool glob::glob::is_valid () const\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-next","title":"function next","text":"<pre><code>bool glob::glob::next () \n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-open","title":"function open","text":"<pre><code>void glob::glob::open (\n    const std::string &amp; pattern\n) \n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline glob::glob::operator bool () const\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob/#function-glob","title":"function ~glob","text":"<pre><code>glob::glob::~glob () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/glob.h</code></p>"},{"location":"acdoxygen/classglob_1_1glob__impl/","title":"Class glob::glob_impl","text":"<p>ClassList &gt; glob &gt; glob_impl</p>"},{"location":"acdoxygen/classglob_1_1glob__impl/#public-attributes","title":"Public Attributes","text":"Type Name DIR * dir struct dirent * dir_entry std::string file_pattern"},{"location":"acdoxygen/classglob_1_1glob__impl/#public-functions","title":"Public Functions","text":"Type Name glob_impl ()"},{"location":"acdoxygen/classglob_1_1glob__impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"acdoxygen/classglob_1_1glob__impl/#variable-dir","title":"variable dir","text":"<pre><code>DIR* glob::glob_impl::dir;\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob__impl/#variable-dir_entry","title":"variable dir_entry","text":"<pre><code>struct dirent* glob::glob_impl::dir_entry;\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob__impl/#variable-file_pattern","title":"variable file_pattern","text":"<pre><code>std::string glob::glob_impl::file_pattern;\n</code></pre>"},{"location":"acdoxygen/classglob_1_1glob__impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classglob_1_1glob__impl/#function-glob_impl","title":"function glob_impl","text":"<pre><code>inline glob::glob_impl::glob_impl () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/glob.cpp</code></p>"},{"location":"acdoxygen/namespaceglob_1_1_0d100/","title":"Namespace glob","text":"<p>Namespace List &gt; glob</p> <p>The documentation for this class was generated from the following file <code>src/utils/glob.cpp</code></p>"},{"location":"acdoxygen/namespaceinih/","title":"Namespace inih","text":"<p>Namespace List &gt; inih</p> <p>More...</p>"},{"location":"acdoxygen/namespaceinih/#classes","title":"Classes","text":"Type Name class INIReader class INIWriter"},{"location":"acdoxygen/namespaceinih/#public-types","title":"Public Types","text":"Type Name typedef int(* ini_handler typedef char *(* ini_reader"},{"location":"acdoxygen/namespaceinih/#public-functions","title":"Public Functions","text":"Type Name int ini_parse (const char * filename, ini_handler handler, void * user)  int ini_parse_file (FILE * file, ini_handler handler, void * user)  int ini_parse_stream (ini_reader reader, void * stream, ini_handler handler, void * user)"},{"location":"acdoxygen/namespaceinih/#public-static-functions","title":"Public Static Functions","text":"Type Name char * find_chars_or_comment (const char * s, const char * chars)  char * lskip (const char * s)  char * rstrip (char * s)  char * strncpy0 (char * dest, const char * src, size_t size)"},{"location":"acdoxygen/namespaceinih/#detailed-description","title":"Detailed Description","text":"<p>Yet another .ini parser for modern c++ (made for cpp17), inspired and extend from @benhoyt's inih. See project page: https://github.com/SSARCandy/ini-cpp </p>"},{"location":"acdoxygen/namespaceinih/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/namespaceinih/#typedef-ini_handler","title":"typedef ini_handler","text":"<pre><code>typedef int(* inih::ini_handler) (void *user, const char *section, const char *name, const char *value);\n</code></pre>"},{"location":"acdoxygen/namespaceinih/#typedef-ini_reader","title":"typedef ini_reader","text":"<pre><code>typedef char *(* inih::ini_reader) (char *str, int num, void *stream);\n</code></pre>"},{"location":"acdoxygen/namespaceinih/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/namespaceinih/#function-ini_parse","title":"function ini_parse","text":"<pre><code>inline int inih::ini_parse (\n    const char * filename,\n    ini_handler handler,\n    void * user\n) \n</code></pre>"},{"location":"acdoxygen/namespaceinih/#function-ini_parse_file","title":"function ini_parse_file","text":"<pre><code>inline int inih::ini_parse_file (\n    FILE * file,\n    ini_handler handler,\n    void * user\n) \n</code></pre>"},{"location":"acdoxygen/namespaceinih/#function-ini_parse_stream","title":"function ini_parse_stream","text":"<pre><code>inline int inih::ini_parse_stream (\n    ini_reader reader,\n    void * stream,\n    ini_handler handler,\n    void * user\n) \n</code></pre>"},{"location":"acdoxygen/namespaceinih/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/namespaceinih/#function-find_chars_or_comment","title":"function find_chars_or_comment","text":"<pre><code>static inline char * inih::find_chars_or_comment (\n    const char * s,\n    const char * chars\n) \n</code></pre>"},{"location":"acdoxygen/namespaceinih/#function-lskip","title":"function lskip","text":"<pre><code>static inline char * inih::lskip (\n    const char * s\n) \n</code></pre>"},{"location":"acdoxygen/namespaceinih/#function-rstrip","title":"function rstrip","text":"<pre><code>static inline char * inih::rstrip (\n    char * s\n) \n</code></pre>"},{"location":"acdoxygen/namespaceinih/#function-strncpy0","title":"function strncpy0","text":"<pre><code>static inline char * inih::strncpy0 (\n    char * dest,\n    const char * src,\n    size_t size\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/Ini.h</code></p>"},{"location":"acdoxygen/classinih_1_1INIReader/","title":"Class inih::INIReader","text":"<p>ClassList &gt; inih &gt; INIReader</p>"},{"location":"acdoxygen/classinih_1_1INIReader/#public-functions","title":"Public Functions","text":"Type Name const std::unordered_map&lt; std::string, std::string &gt; Get (std::string section) const T Get (const std::string &amp; section, const std::string &amp; name) Return the value of the given key in the given section. T Get (const std::string &amp; section, const std::string &amp; name, T &amp; default_v) Return the value of the given key in the given section, return default if not found. std::vector&lt; T &gt; GetVector (const std::string &amp; section, const std::string &amp; name) Return the value array of the given key in the given section. std::vector&lt; T &gt; GetVector (const std::string &amp; section, const std::string &amp; name, const std::vector&lt; T &gt; &amp; default_v) Return the value array of the given key in the given section, return default if not found. INIReader ()  INIReader (std::string filename)  INIReader (FILE * file)  void InsertEntry (const std::string &amp; section, const std::string &amp; name, const T &amp; v)  void InsertEntry (const std::string &amp; section, const std::string &amp; name, const std::vector&lt; T &gt; &amp; vs)  const std::set&lt; std::string &gt; Keys (std::string section) constReturn the list of keys in the given section. int ParseError () const const std::set&lt; std::string &gt; Sections () constReturn the list of sections found in ini file. void UpdateEntry (const std::string &amp; section, const std::string &amp; name, const T &amp; v)  void UpdateEntry (const std::string &amp; section, const std::string &amp; name, const std::vector&lt; T &gt; &amp; vs)"},{"location":"acdoxygen/classinih_1_1INIReader/#protected-attributes","title":"Protected Attributes","text":"Type Name int _error std::unordered_map&lt; std::string, std::unordered_map&lt; std::string, std::string &gt; &gt; _values"},{"location":"acdoxygen/classinih_1_1INIReader/#protected-functions","title":"Protected Functions","text":"Type Name const bool BoolConverter (std::string s) const T Converter (const std::string &amp; s) const std::string V2String (const T &amp; v) const std::string Vec2String (const std::vector&lt; T &gt; &amp; v) const"},{"location":"acdoxygen/classinih_1_1INIReader/#protected-static-functions","title":"Protected Static Functions","text":"Type Name int ValueHandler (void * user, const char * section, const char * name, const char * value)"},{"location":"acdoxygen/classinih_1_1INIReader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classinih_1_1INIReader/#function-get-13","title":"function Get [\u2153]","text":"<pre><code>inline const std::unordered_map&lt; std::string, std::string &gt; inih::INIReader::Get (\n    std::string section\n) const\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-get-23","title":"function Get [\u2154]","text":"<p>Return the value of the given key in the given section. <pre><code>template&lt;typename T&gt;\ninline T inih::INIReader::Get (\n    const std::string &amp; section,\n    const std::string &amp; name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>section</code> The section name </li> <li><code>name</code> The key name </li> </ul> <p>Returns:</p> <p>The value of the given key in the given section </p>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-get-33","title":"function Get [3/3]","text":"<p>Return the value of the given key in the given section, return default if not found. <pre><code>template&lt;typename T&gt;\ninline T inih::INIReader::Get (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    T &amp; default_v\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>section</code> The section name </li> <li><code>name</code> The key name </li> <li><code>default_v</code> The default value </li> </ul> <p>Returns:</p> <p>The value of the given key in the given section, return default if not found </p>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-getvector-12","title":"function GetVector [\u00bd]","text":"<p>Return the value array of the given key in the given section. <pre><code>template&lt;typename T&gt;\ninline std::vector&lt; T &gt; inih::INIReader::GetVector (\n    const std::string &amp; section,\n    const std::string &amp; name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>section</code> The section name </li> <li><code>name</code> The key name </li> </ul> <p>Returns:</p> <p>The value array of the given key in the given section.</p> <p>For example:  <pre><code>[section]\nkey = 1 2 3 4\n</code></pre></p> <pre><code>const auto vs = ini.GetVector&lt;std::vector&lt;int&gt;&gt;(\"section\", \"key\");\n// vs = {1, 2, 3, 4}\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-getvector-22","title":"function GetVector [2/2]","text":"<p>Return the value array of the given key in the given section, return default if not found. <pre><code>template&lt;typename T&gt;\ninline std::vector&lt; T &gt; inih::INIReader::GetVector (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const std::vector&lt; T &gt; &amp; default_v\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>section</code> The section name </li> <li><code>name</code> The key name </li> <li><code>default_v</code> The default value </li> </ul> <p>Returns:</p> <p>The value array of the given key in the given section, return default if not found</p> <p>See also: INIReader::GetVector </p>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-inireader-13","title":"function INIReader [\u2153]","text":"<pre><code>inline inih::INIReader::INIReader () \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-inireader-23","title":"function INIReader [\u2154]","text":"<pre><code>inline inih::INIReader::INIReader (\n    std::string filename\n) \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-inireader-33","title":"function INIReader [3/3]","text":"<pre><code>inline inih::INIReader::INIReader (\n    FILE * file\n) \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-insertentry-12","title":"function InsertEntry [\u00bd]","text":"<pre><code>template&lt;typename T&gt;\ninline void inih::INIReader::InsertEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const T &amp; v\n) \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-insertentry-22","title":"function InsertEntry [2/2]","text":"<pre><code>template&lt;typename T&gt;\ninline void inih::INIReader::InsertEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const std::vector&lt; T &gt; &amp; vs\n) \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-keys","title":"function Keys","text":"<p>Return the list of keys in the given section. <pre><code>inline const std::set&lt; std::string &gt; inih::INIReader::Keys (\n    std::string section\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>section</code> The section name </li> </ul> <p>Returns:</p> <p>The list of keys in the given section </p>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-parseerror","title":"function ParseError","text":"<pre><code>inline int inih::INIReader::ParseError () const\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-sections","title":"function Sections","text":"<p>Return the list of sections found in ini file. <pre><code>inline const std::set&lt; std::string &gt; inih::INIReader::Sections () const\n</code></pre></p> <p>Returns:</p> <p>The list of sections found in ini file </p>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-updateentry-12","title":"function UpdateEntry [\u00bd]","text":"<pre><code>template&lt;typename T&gt;\ninline void inih::INIReader::UpdateEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const T &amp; v\n) \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-updateentry-22","title":"function UpdateEntry [2/2]","text":"<pre><code>template&lt;typename T&gt;\ninline void inih::INIReader::UpdateEntry (\n    const std::string &amp; section,\n    const std::string &amp; name,\n    const std::vector&lt; T &gt; &amp; vs\n) \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"acdoxygen/classinih_1_1INIReader/#variable-_error","title":"variable _error","text":"<pre><code>int inih::INIReader::_error;\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#variable-_values","title":"variable _values","text":"<pre><code>std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, std::string&gt; &gt; inih::INIReader::_values;\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"acdoxygen/classinih_1_1INIReader/#function-boolconverter","title":"function BoolConverter","text":"<pre><code>inline const bool inih::INIReader::BoolConverter (\n    std::string s\n) const\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-converter","title":"function Converter","text":"<pre><code>template&lt;typename T&gt;\ninline T inih::INIReader::Converter (\n    const std::string &amp; s\n) const\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-v2string","title":"function V2String","text":"<pre><code>template&lt;typename T&gt;\ninline std::string inih::INIReader::V2String (\n    const T &amp; v\n) const\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#function-vec2string","title":"function Vec2String","text":"<pre><code>template&lt;typename T&gt;\ninline std::string inih::INIReader::Vec2String (\n    const std::vector&lt; T &gt; &amp; v\n) const\n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIReader/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"acdoxygen/classinih_1_1INIReader/#function-valuehandler","title":"function ValueHandler","text":"<pre><code>static inline int inih::INIReader::ValueHandler (\n    void * user,\n    const char * section,\n    const char * name,\n    const char * value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/Ini.h</code></p>"},{"location":"acdoxygen/classinih_1_1INIWriter/","title":"Class inih::INIWriter","text":"<p>ClassList &gt; inih &gt; INIWriter</p>"},{"location":"acdoxygen/classinih_1_1INIWriter/#public-functions","title":"Public Functions","text":"Type Name INIWriter ()"},{"location":"acdoxygen/classinih_1_1INIWriter/#public-static-functions","title":"Public Static Functions","text":"Type Name void write (const std::string &amp; filepath, INIReader &amp; reader)"},{"location":"acdoxygen/classinih_1_1INIWriter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/classinih_1_1INIWriter/#function-iniwriter","title":"function INIWriter","text":"<pre><code>inline inih::INIWriter::INIWriter () \n</code></pre>"},{"location":"acdoxygen/classinih_1_1INIWriter/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"acdoxygen/classinih_1_1INIWriter/#function-write","title":"function write","text":"<pre><code>static inline void inih::INIWriter::write (\n    const std::string &amp; filepath,\n    INIReader &amp; reader\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/Ini.h</code></p>"},{"location":"acdoxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"acdoxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file ACApp.cpp file AIAC.h file aiacpch.cpp file aiacpch.h"},{"location":"acdoxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir AIAC dir utils <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"acdoxygen/ACApp_8cpp/","title":"File ACApp.cpp","text":"<p>FileList &gt; src &gt; ACApp.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC.h\"</code></li> </ul>"},{"location":"acdoxygen/ACApp_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"acdoxygen/ACApp_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/ACApp_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/ACApp.cpp</code></p>"},{"location":"acdoxygen/ACApp_8cpp_source/","title":"File ACApp.cpp","text":"<p>File List &gt; src &gt; ACApp.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n\n#include \"aiacpch.h\"\n#include \"AIAC.h\"\n\nint main(int argc, char* argv[]) {\n#ifdef __linux__\n    AIAC::Log::Init();\n\n    // by default, take the config.ini in the root folder\n    std::string configPath = \"config.ini\";\n    if (argc &gt;= 2){\n        configPath = argv[1];\n    }\n    AIAC::Config config(configPath, true);\n\n    AIAC::ApplicationSpecification appSpec;\n    appSpec.Name = \"augmented_carpentry\";  // \u304b\u304f\u3061\u3087\u3046_\u3060\u3044\u304f\n    appSpec.WinWidth = 800;\n    appSpec.WinHeight = 480;\n    appSpec.IsResizable = false;\n    appSpec.VSync = true;\n    appSpec.WindowBackColor = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\n\n    std::unique_ptr&lt;AIAC::Application&gt; acApp_ptr = std::unique_ptr&lt;AIAC::Application&gt;(new AIAC::Application(appSpec));\n\n    acApp_ptr-&gt;GetWindow()-&gt;Init();\n\n    acApp_ptr-&gt;GetGORegistry()-&gt;Init();\n\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerCamera&gt;();\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerCameraCalib&gt;();\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerSlam&gt;();\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerModel&gt;();\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerToolhead&gt;();\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerFeedback&gt;();\n#ifndef HEADLESS_TEST\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerUI&gt;();\n#endif\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerUtils&gt;();\n    acApp_ptr-&gt;PushLayer&lt;AIAC::LayerLogRecorder&gt;();\n\n    acApp_ptr-&gt;GetRenderer()-&gt;Init();\n\n    acApp_ptr-&gt;GetEventBus()-&gt;Init();\n    acApp_ptr-&gt;Run();\n\n    return 0;\n#else\n    return -1;\n#endif\n\n}\n</code></pre>"},{"location":"acdoxygen/AIAC_8h/","title":"File AIAC.h","text":"<p>FileList &gt; src &gt; AIAC.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GlHeader.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"stb/stb_image.h\"</code></li> <li><code>#include \"AIAC/Base.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Assert.h\"</code></li> <li><code>#include \"AIAC/TouchMonitor.h\"</code></li> <li><code>#include \"AIAC/Window.h\"</code></li> <li><code>#include \"AIAC/EventSys/Event.h\"</code></li> <li><code>#include \"AIAC/EventSys/SLAMEvent.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"AIAC/Camera.h\"</code></li> <li><code>#include \"AIAC/DLoader.h\"</code></li> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/LayerCamera.h\"</code></li> <li><code>#include \"AIAC/LayerCameraCalib.h\"</code></li> <li><code>#include \"AIAC/LayerSlam.h\"</code></li> <li><code>#include \"AIAC/LayerUI.h\"</code></li> <li><code>#include \"AIAC/LayerModel.h\"</code></li> <li><code>#include \"AIAC/LayerToolhead.h\"</code></li> <li><code>#include \"AIAC/LayerFeedback.h\"</code></li> <li><code>#include \"AIAC/LayerUtils.h\"</code></li> <li><code>#include \"AIAC/LayerLogRecorder.h\"</code></li> <li><code>#include \"AIAC/Render/Renderer.h\"</code></li> <li><code>#include \"AIAC/GOSys/GO.h\"</code></li> <li><code>#include \"AIAC/EventSys/CameraEvent.h\"</code></li> <li><code>#include \"AIAC/EventSys/ApplicationEvent.h\"</code></li> <li><code>#include \"AIAC/EventSys/EventBus.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> </ul>"},{"location":"acdoxygen/AIAC_8h/#macros","title":"Macros","text":"Type Name define STB_IMAGE_IMPLEMENTATION"},{"location":"acdoxygen/AIAC_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/AIAC_8h/#define-stb_image_implementation","title":"define STB_IMAGE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC.h</code></p>"},{"location":"acdoxygen/AIAC_8h_source/","title":"File AIAC.h","text":"<p>File List &gt; src &gt; AIAC.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n\n#pragma once\n\n#include \"AIAC/GlHeader.h\"\n\n#include \"AIAC/Config.h\"\n\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb/stb_image.h\"\n\n#include \"AIAC/Base.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Assert.h\"\n\n#include \"AIAC/TouchMonitor.h\"\n#include \"AIAC/Window.h\"\n\n#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n\n#include \"AIAC/Image.h\"\n#include \"AIAC/Camera.h\"\n#include \"AIAC/DLoader.h\"\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/LayerCamera.h\"\n#include \"AIAC/LayerCameraCalib.h\"\n#include \"AIAC/LayerSlam.h\"\n#include \"AIAC/LayerUI.h\"\n#include \"AIAC/LayerModel.h\"\n#include \"AIAC/LayerToolhead.h\"\n#include \"AIAC/LayerFeedback.h\"\n#include \"AIAC/LayerUtils.h\"\n#include \"AIAC/LayerLogRecorder.h\"\n\n#include \"AIAC/Render/Renderer.h\"\n#include \"AIAC/GOSys/GO.h\"\n\n#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n#include \"AIAC/EventSys/CameraEvent.h\"\n#include \"AIAC/EventSys/ApplicationEvent.h\"\n\n/* &gt;&gt; add types of events here &lt;&lt; */\n#include \"AIAC/EventSys/EventBus.h\"\n\n#include \"AIAC/Application.h\"\n</code></pre>"},{"location":"acdoxygen/aiacpch_8cpp/","title":"File aiacpch.cpp","text":"<p>FileList &gt; src &gt; aiacpch.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/aiacpch.cpp</code></p>"},{"location":"acdoxygen/aiacpch_8cpp_source/","title":"File aiacpch.cpp","text":"<p>File List &gt; src &gt; aiacpch.cpp</p> <p>Go to the documentation of this file</p> <pre><code># include \"aiacpch.h\"\n</code></pre>"},{"location":"acdoxygen/aiacpch_8h/","title":"File aiacpch.h","text":"<p>FileList &gt; src &gt; aiacpch.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;typeinfo&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/aiacpch.h</code></p>"},{"location":"acdoxygen/aiacpch_8h_source/","title":"File aiacpch.h","text":"<p>File List &gt; src &gt; aiacpch.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;filesystem&gt;\n\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;sstream&gt;\n#include &lt;array&gt;\n#include &lt;vector&gt;\n#include &lt;stdint.h&gt;\n#include &lt;type_traits&gt;\n#include &lt;typeindex&gt;\n#include &lt;typeinfo&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;opencv2/opencv.hpp&gt;\n</code></pre>"},{"location":"acdoxygen/dir_21da83368f7816722f2b707a7b03c84f/","title":"Dir src/AIAC","text":"<p>FileList &gt; AIAC</p>"},{"location":"acdoxygen/dir_21da83368f7816722f2b707a7b03c84f/#files","title":"Files","text":"Type Name file ACInfoModel.cpp file ACInfoModel.h file ACInfoToolhead.cpp file ACInfoToolhead.h file ACInfoToolheadManager.cpp file ACInfoToolheadManager.h file Application.cpp file Application.h file Assert.h file Base.h file Camera.cpp file Camera.h file CameraCalibrator.cpp file CameraCalibrator.h file Config.cpp file Config.h file DLoader.cpp file DLoader.h file GeometryUtils.cpp file GeometryUtils.h file GlHeader.h file Image.cpp file Image.h file Layer.h file LayerCamera.cpp file LayerCamera.h file LayerCameraCalib.cpp file LayerCameraCalib.h file LayerFeedback.cpp file LayerFeedback.h file LayerLogRecorder.cpp file LayerLogRecorder.h file LayerModel.cpp file LayerModel.h file LayerSlam.cpp file LayerSlam.h file LayerToolhead.cpp file LayerToolhead.h file LayerUI.cpp file LayerUI.h file LayerUtils.cpp file LayerUtils.h file Log.cpp file Log.h file ScannedModel.cpp file ScannedModel.h file TouchMonitor.cpp file TouchMonitor.h file Window.cpp file Window.h"},{"location":"acdoxygen/dir_21da83368f7816722f2b707a7b03c84f/#directories","title":"Directories","text":"Type Name dir EventSys dir Feedback dir GOSys dir Render dir UI <p>The documentation for this class was generated from the following file <code>src/AIAC/</code></p>"},{"location":"acdoxygen/ACInfoModel_8cpp/","title":"File ACInfoModel.cpp","text":"<p>FileList &gt; AIAC &gt; ACInfoModel.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"ACInfoModel.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"acdoxygen/ACInfoModel_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.cpp</code></p>"},{"location":"acdoxygen/ACInfoModel_8cpp_source/","title":"File ACInfoModel.cpp","text":"<p>File List &gt; AIAC &gt; ACInfoModel.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Application.h\"\n#include \"ACInfoModel.h\"\n#include \"AIAC/Config.h\"\n\n#include &lt;cmath&gt;\n\n\nnamespace AIAC\n{\n    void TimberInfo::Component::SetAsCurrent() {\n        m_State = ACIMState::CURRENT;\n\n#ifndef HEADLESS_TEST\n        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetDoc().child(\"acim\").child(\"timber\").child(\"current\").last_child().set_value(m_ID.c_str());\n        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().Save();\n\n        AIAC_APP.GetRenderer()-&gt;SetGlobalViewToActivatedComponent(Renderer::StandardView::TOP);\n#endif\n    }\n\n    void TimberInfo::Component::SetAsDone() {\n        AIAC_INFO(\"timberInfo::Component::SetAsDone()\");\n\n        m_State = ACIMState::DONE;\n        m_ACIMDocNode.child(\"state\").last_child().set_value(\"Done\");\n        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().Save();\n    }\n\n    void TimberInfo::Component::SetAsNotDone() {\n        m_State = ACIMState::NOT_DONE;\n        m_ACIMDocNode.child(\"state\").last_child().set_value(\"NotDone\");\n        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().Save();\n    }\n\n    void TimberInfo::Component::SetVisibility(bool visible) {\n        for (auto&amp; go : m_GOPrimitives) {\n            go-&gt;SetVisibility(visible);\n        }\n    }\n\n    glm::vec3 TimberInfo::Component::GetCenter() const {\n        throw std::logic_error(\"GetCenter() is not defined for the derived class.\");\n    }\n\n    void TimberInfo::Hole::SetAsCurrent() {\n        TimberInfo::Component::SetAsCurrent();\n        AIAC_INFO(\"Set Current Component to Hole #\" + m_ID);\n        m_AxisGO-&gt;SetColor(HOLE_AXIS_COLOR[ACIMState::CURRENT]);\n        m_CylinderGO-&gt;SetColor(HOLE_CYLINDER_COLOR[ACIMState::CURRENT]);\n    }\n\n    void TimberInfo::Hole::SetAsDone() {\n        TimberInfo::Component::SetAsDone();\n        AIAC_INFO(\"Set \" + m_ID + \" as Done\");\n        m_AxisGO-&gt;SetColor(HOLE_AXIS_COLOR[ACIMState::DONE]);\n        m_CylinderGO-&gt;SetColor(HOLE_CYLINDER_COLOR[ACIMState::DONE]);\n    }\n\n    void TimberInfo::Hole::SetAsNotDone() {\n        TimberInfo::Component::SetAsNotDone();\n        AIAC_INFO(\"Set \" + m_ID + \" as Not Done\");\n        m_AxisGO-&gt;SetColor(HOLE_AXIS_COLOR[ACIMState::NOT_DONE]);\n        m_CylinderGO-&gt;SetColor(HOLE_CYLINDER_COLOR[ACIMState::NOT_DONE]);\n    }\n\n    void TimberInfo::Hole::SwapStartEnd() {\n        // holeInfo.m_Start = StringToVec3(hole.child(\"start\").child(\"coordinates\").child_value()) * m_Scale;\n        // holeInfo.m_StartExposed = StringToBool(hole.child(\"start\").child(\"exposed\").child_value());\n        // holeInfo.m_End = StringToVec3(hole.child(\"end\").child(\"coordinates\").child_value()) * m_Scale;\n        // holeInfo.m_EndExposed = StringToBool(hole.child(\"end\").child(\"exposed\").child_value());\n\n        // Update .acim doc\n        std::swap(m_Start, m_End);\n        std::swap(m_StartExposed, m_EndExposed);\n\n        m_ACIMDocNode.child(\"start\").child(\"coordinates\").last_child().set_value(Vec3ToString(m_Start / m_Scale).c_str());\n        m_ACIMDocNode.child(\"start\").child(\"exposed\").last_child().set_value(m_StartExposed ? \"True\" : \"False\");\n        m_ACIMDocNode.child(\"end\").child(\"coordinates\").last_child().set_value(Vec3ToString(m_End / m_Scale).c_str());\n        m_ACIMDocNode.child(\"end\").child(\"exposed\").last_child().set_value(m_EndExposed ? \"True\" : \"False\");\n\n        // Update system\n        auto curStart = m_StartPointGO-&gt;GetPosition();\n        auto curEnd = m_EndPointGO-&gt;GetPosition();\n\n        m_StartPointGO-&gt;SetPosition(curEnd);\n        m_EndPointGO-&gt;SetPosition(curStart);\n        m_AxisGO-&gt;SetPts(curEnd, curStart);\n\n        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().Save();\n    }\n\n    void TimberInfo::Hole::SetVisibility(bool visible) {\n        TimberInfo::Component::SetVisibility(visible);\n    }\n\n    void TimberInfo::Cut::SetAsCurrent() {\n        TimberInfo::Component::SetAsCurrent();\n        AIAC_INFO(\"Set Current Component to \" + m_ID);\n        for (const auto&amp; [_, face] : m_Faces) {\n            if(face.m_GO != nullptr){\n                face.m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::CURRENT]);\n            }\n        }\n        for (const auto&amp; [_, edge] : m_Edges) {\n            if(edge.m_GO != nullptr){\n                edge.m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::CURRENT]);\n            }\n        }\n    }\n\n    void TimberInfo::Cut::SetAsDone() {\n        TimberInfo::Component::SetAsDone();\n        AIAC_INFO(\"Set \" + m_ID + \" as Done\");\n        for (const auto&amp; [_, face] : m_Faces) {\n            if(face.m_GO != nullptr){\n                face.m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::DONE]);\n            }\n        }\n        for (const auto&amp; [_, edge] : m_Edges) {\n            if(edge.m_GO != nullptr){\n                edge.m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::DONE]);\n            }\n        }\n    }\n\n    void TimberInfo::Cut::SetAsNotDone() {\n        TimberInfo::Component::SetAsNotDone();\n        AIAC_INFO(\"Set \" + m_ID + \" as Not Done\");\n        for (const auto&amp; [_, face] : m_Faces) {\n            if(face.m_GO != nullptr){\n                face.m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::NOT_DONE]);\n            }\n        }\n        for (const auto&amp; [_, edge] : m_Edges) {\n            if(edge.m_GO != nullptr){\n                edge.m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::NOT_DONE]);\n            }\n        }\n    }\n\n    void TimberInfo::Cut::SetVisibility(bool visible) {\n        TimberInfo::Component::SetVisibility(visible);\n        for (const auto&amp; [_, face] : m_Faces) {\n            if(face.m_GO != nullptr){\n                face.m_GO-&gt;SetVisibility(visible);\n            }\n        }\n        for (const auto&amp; [_, edge] : m_Edges) {\n            if(edge.m_GO != nullptr){\n                edge.m_GO-&gt;SetVisibility(visible);\n            }\n        }\n    }\n\n    void TimberInfo::Cut::HighlightFace(const std::string&amp; faceID, glm::vec4 color) {\n        if(faceID == m_HighlightedFaceID) return;\n\n        // faceID is empty -&gt; Reset everything to CURRENT\n        if(faceID.empty()){\n            for(auto&amp; [_, face] : m_Faces){\n                if(face.m_GO != nullptr){\n                    face.m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::CURRENT]);\n                }\n            }\n            for(auto&amp; [_, edge] : m_Edges){\n                if(edge.m_GO != nullptr){\n                    edge.m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::CURRENT]);\n                }\n            }\n            m_HighlightedFaceID = \"\";\n            return;\n        }\n\n        if(m_HighlightedFaceID.empty()){\n            // init : set all to NOT_DONE\n            for(auto&amp; [_, face] : m_Faces){\n                if(face.m_GO != nullptr){\n                    face.m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::NOT_DONE]);\n                }\n            }\n            for(auto&amp; [_, edge] : m_Edges){\n                if(edge.m_GO != nullptr){\n                    edge.m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::NOT_DONE]);\n                }\n            }\n        } else {\n            // reset the previous Highlighted face\n            m_Faces[m_HighlightedFaceID].m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::NOT_DONE]);\n            for(auto&amp; edgeID : m_Faces[m_HighlightedFaceID].m_Edges){\n                if(m_Edges[edgeID].m_GO != nullptr){\n                    m_Edges[edgeID].m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::NOT_DONE]);\n                }\n            }\n        }\n\n        // set the new Highlighted face\n        m_HighlightedFaceID = faceID;\n        m_Faces[m_HighlightedFaceID].m_GO-&gt;SetColor(CUT_FACE_COLOR[ACIMState::CURRENT]);\n        for(auto&amp; edgeID : m_Faces[m_HighlightedFaceID].m_Edges){\n            if(m_Edges[edgeID].m_GO != nullptr){\n                m_Edges[edgeID].m_GO-&gt;SetColor(CUT_EDGE_COLOR[ACIMState::CURRENT]);\n            }\n        }\n    }\n\n    std::vector&lt;std::string&gt; TimberInfo::GetAllComponentsIDs() const {\n        // This is only for C++20, but we're using C++17, I leave it here for future reference\n        // #include &lt;ranges&gt;\n        // auto kv = std::views::keys(m_Components);\n        // std::vector&lt;std::string&gt; keys{ kv.begin(), kv.end() };\n        // return keys;\n        std::vector&lt;std::string&gt; keys;\n        for (const auto&amp; [key, _] : m_Components) {\n            keys.push_back(key);\n        }\n        return keys;\n    }\n\n    void TimberInfo::SetCurrentComponentTo(std::string id) {\n        if(GetCurrentComponent() != nullptr){\n            if(GetCurrentComponent()-&gt;IsMarkedDone){\n                GetCurrentComponent()-&gt;SetAsDone();\n            } else { // Not Done\n                GetCurrentComponent()-&gt;SetAsNotDone();\n            }\n        }\n        m_CurrentComponentID = id;\n        m_Components[id]-&gt;SetAsCurrent();\n\n        if(auto cut = dynamic_cast&lt;Cut*&gt;(m_Components[id]))\n        {\n            if(cut -&gt; IsSingleFace())\n            // {\n                AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;EnableCutPlane(true);\n            // } else {\n            //     AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;EnableCutPlane(false);\n            // }\n        }\n\n        ShowAllComponents();\n        HideAllComponentsExceptCurrent();\n    }\n\n    std::string TimberInfo::ShortenComponentID(std::string id) {\n        if(id.find(\"Hole\") != std::string::npos){\n            return \"H\" + id.substr(5);\n        } else if(id.find(\"Cut\") != std::string::npos){\n            return \"C\" + id.substr(4);\n        }\n        return id;\n    }\n\n    void TimberInfo::SetNextComponentAsCurrent()\n    {\n        auto ids = GetAllComponentsIDs();\n        auto it = std::find(ids.begin(), ids.end(), m_CurrentComponentID);\n        if(it == ids.end()){\n            AIAC_ERROR(\"TimberInfo::SetNextComponentAsCurrent() : Current Component ID not found\");\n            return;\n        }\n        if(++it == ids.end()){\n            it = ids.begin();\n        }\n        SetCurrentComponentTo(*it);\n    }\n\n    void TimberInfo::SetPrevComponentAsCurrent()\n    {\n        auto ids = GetAllComponentsIDs();\n        auto it = std::find(ids.begin(), ids.end(), m_CurrentComponentID);\n        if(it == ids.end()){\n            AIAC_ERROR(\"TimberInfo::SetPrevComponentAsCurrent() : Current Component ID not found\");\n            return;\n        }\n        if(it == ids.begin()){\n            it = ids.end();\n        }\n        SetCurrentComponentTo(*--it);\n    }\n\n    void TimberInfo::HideAllComponentsExceptCurrent() {\n        for (const auto&amp; [_, component] : m_Components) {\n            if(component-&gt;m_ID != m_CurrentComponentID){\n                component-&gt;SetVisibility(false);\n                // if the component is a cut, we hide all the other cotas\n                if(auto cut = dynamic_cast&lt;Cut*&gt;(component)){\n                    cut-&gt;SetVisibilityAllCotas(false);\n                }\n            }\n        }\n        this-&gt;IsShowingAllComponents = false;\n    }\n\n    void TimberInfo::ShowAllComponents() {\n        for (const auto&amp; [_, component] : m_Components) {\n            for(auto&amp; go: component-&gt;m_GOPrimitives){\n                component-&gt;SetVisibility(true);\n            }\n            // if the component is a cut, we show all the cotas\n            if(auto cut = dynamic_cast&lt;Cut*&gt;(component)){\n                if(IsShowingCotas)\n                    cut-&gt;SetVisibilityAllCotas(true);\n            }\n        }\n        this-&gt;IsShowingAllComponents = true;\n    }\n\n    void TimberInfo::UpdateCotasVisibility(bool visible)\n    {\n        if (!visible || IsShowingAllComponents) {\n            this-&gt;IsShowingCotas = visible;\n            for (const auto&amp; [_, component] : m_Components) {\n                if(auto cut = dynamic_cast&lt;Cut*&gt;(component)){\n                    cut-&gt;SetVisibilityAllCotas(visible);\n                }\n            }\n        } else {\n            if(auto cut = dynamic_cast&lt;Cut*&gt;(this-&gt;GetCurrentComponent())){\n                cut-&gt;SetVisibilityAllCotas(visible);\n            }\n        }\n    }\n\n    bool ACInfoModel::Load(std::string path) {\n        // check if file is good\n        if(path.empty()){\n            AIAC_ERROR(\"ACInfoModel::Load() path is empty\");\n            return false;\n        }\n        if(!std::filesystem::exists(path)){\n            AIAC_ERROR(\"ACInfoModel::Load() file does not exist\");\n            return false;\n        }\n        if (std::filesystem::is_directory(path)){\n            AIAC_ERROR(\"ACInfoModel::Load() path is a directory\");\n            return false;\n        }\n        if (path.find(\".acim\") == std::string::npos){\n            AIAC_ERROR(\"ACInfoModel::Load() file is not .acim\");\n            return false;\n        }\n\n        m_FilePath = path;\n\n        Clear();\n\n        pugi::xml_parse_result result = m_ACIMDoc.load_file(path.c_str());\n        if (!result){\n            AIAC_ERROR(\"Could not load ACInfoModel from file: {0}\", path);\n            return false;\n        }\n        for(auto timber = m_ACIMDoc.child(\"acim\").child(\"timber\"); timber; timber = timber.next_sibling(\"timber\")){\n            TimberInfo timberInfo;\n            timberInfo.m_ID = timber.attribute(\"id\").as_string();\n            timberInfo.m_State = StringToState(timber.child(\"state\").child_value());\n            timberInfo.m_CurrentComponentID = timber.child(\"current\").child_value();\n            AIAC_INFO(\"Timber: {0}\", timberInfo.m_ID);\n\n            // Bounding Box\n            auto bboxNode = timber.child(\"bbox\");\n            for(auto corner = bboxNode.child(\"corner\"); corner; corner = corner.next_sibling(\"corner\")){\n                auto c = StringToVec3(corner.child_value());\n                timberInfo.m_Bbox.push_back(c * m_Scale);\n            }\n            m_TimberInfo = timberInfo;\n\n            // Holes\n            for(auto hole = timber.child(\"hole\"); hole; hole=hole.next_sibling(\"hole\")){\n                TimberInfo::Hole holeInfo;\n                holeInfo.m_ACIMDocNode = hole;\n                holeInfo.m_ID = hole.attribute(\"id\").as_string();\n                holeInfo.m_State = StringToState(hole.child(\"state\").child_value());\n                holeInfo.IsMarkedDone = holeInfo.m_State == ACIMState::DONE;\n                holeInfo.m_Neighbors = StringToSet(hole.child(\"neighbours\").child_value());\n                if(holeInfo.m_Neighbors.size() == 1 &amp;&amp; *holeInfo.m_Neighbors.begin() == \"-1\"){\n                    AIAC_INFO(\"Hole: {0} has no neighbors\", holeInfo.m_ID);\n                    holeInfo.m_Neighbors.clear();\n                }\n                holeInfo.m_Start = StringToVec3(hole.child(\"start\").child(\"coordinates\").child_value()) * m_Scale;\n                holeInfo.m_StartExposed = StringToBool(hole.child(\"start\").child(\"exposed\").child_value());\n                holeInfo.m_End = StringToVec3(hole.child(\"end\").child(\"coordinates\").child_value()) * m_Scale;\n                holeInfo.m_EndExposed = StringToBool(hole.child(\"end\").child(\"exposed\").child_value());\n                holeInfo.m_Radius = std::stof(hole.child(\"radius\").child_value());\n\n                // build GOPrimitive\n                holeInfo.m_AxisGO = GOLine::Add(holeInfo.m_Start, holeInfo.m_End, 2.0f);\n                holeInfo.m_AxisGO-&gt;SetColor(HOLE_AXIS_COLOR[holeInfo.m_State]);\n                holeInfo.m_CylinderGO = GOCylinder::Add(holeInfo.m_Start, holeInfo.m_End, holeInfo.m_Radius);\n                holeInfo.m_CylinderGO-&gt;SetColor(HOLE_CYLINDER_COLOR[holeInfo.m_State]);\n                holeInfo.m_StartPointGO = GOPoint::Add(holeInfo.m_Start, 2.0f);\n                holeInfo.m_EndPointGO = GOPoint::Add(holeInfo.m_End, 2.0f);\n                std::string shortenHoleID = m_TimberInfo.ShortenComponentID(holeInfo.m_ID);\n                holeInfo.m_IDLabelGO = GOText::Add(shortenHoleID, holeInfo.m_End, m_LabelSize);\n\n                holeInfo.m_GOPrimitives.push_back(holeInfo.m_AxisGO);\n                holeInfo.m_GOPrimitives.push_back(holeInfo.m_CylinderGO);\n                holeInfo.m_GOPrimitives.push_back(holeInfo.m_StartPointGO);\n                holeInfo.m_GOPrimitives.push_back(holeInfo.m_EndPointGO);\n                holeInfo.m_GOPrimitives.push_back(holeInfo.m_IDLabelGO);\n\n                m_TimberInfo.m_Holes[holeInfo.m_ID] = holeInfo;\n                m_TimberInfo.m_Components[holeInfo.m_ID] = &amp;m_TimberInfo.m_Holes[holeInfo.m_ID];\n            }\n\n            // cuts\n            for(auto cut = timber.child(\"cut\"); cut; cut=cut.next_sibling(\"cut\")){\n                TimberInfo::Cut cutInfo;\n                cutInfo.m_ACIMDocNode = cut;\n                cutInfo.m_ID = cut.attribute(\"id\").as_string();\n                cutInfo.m_State = StringToState(cut.child(\"state\").child_value());\n                cutInfo.IsMarkedDone = cutInfo.m_State == ACIMState::DONE;\n                cutInfo.m_Center = StringToVec3(cut.child(\"center\").child_value()) * m_Scale;\n                std::string shortenCutID = m_TimberInfo.ShortenComponentID(cutInfo.m_ID);\n                cutInfo.m_IDLabelGO = GOText::Add(shortenCutID, cutInfo.m_Center, m_LabelSize);\n                cutInfo.m_GOPrimitives.push_back(cutInfo.m_IDLabelGO);\n\n                auto faces = cut.child(\"faces\");\n                for(auto face = faces.child(\"face\"); face; face=face.next_sibling(\"face\")){\n                    TimberInfo::Cut::Face faceInfo;\n                    faceInfo.m_ID = face.attribute(\"id\").as_string();\n                    faceInfo.m_Exposed = StringToBool(face.child(\"exposed\").child_value());\n                    faceInfo.m_State = StringToState(face.child(\"state\").child_value());\n                    faceInfo.m_Edges = StringToSet(face.child(\"edges\").child_value());\n                    faceInfo.m_Center = glm::vec3(0.0f);\n                    if(!faceInfo.m_Exposed){\n                        cutInfo.m_NonExposedEdgeIDs.insert(faceInfo.m_Edges.begin(), faceInfo.m_Edges.end());\n                    }\n                    auto corners = face.child(\"corners\");\n                    for(auto corner = corners.child(\"corner\"); corner; corner=corner.next_sibling(\"corner\")){\n                        faceInfo.m_Corners.push_back(StringToVec3(corner.child_value()) * m_Scale);\n                        faceInfo.m_Center += faceInfo.m_Corners.back();\n                    }\n                    faceInfo.m_Center /= faceInfo.m_Corners.size();\n\n                    // build face GO\n                    if(faceInfo.m_Corners.size()&lt;3){\n                        AIAC_ERROR(\"Face: {0} has less than 3 corners\", faceInfo.m_ID);\n                        continue;\n                    }\n\n                    // skip exposed faces\n                    if(faceInfo.m_Exposed){\n                        continue;\n                    }\n\n                    // build normal\n                    faceInfo.m_Normal = glm::normalize(glm::cross(faceInfo.m_Corners[1] - faceInfo.m_Corners[0],\n                                                                  faceInfo.m_Corners[2] - faceInfo.m_Corners[0]));\n\n                    std::vector&lt;uint32_t&gt; indices;\n                    auto baseCornerIdx = 0;\n                    for(int i = 2; i &lt; faceInfo.m_Corners.size(); i++){\n                        indices.push_back(baseCornerIdx);\n                        indices.push_back(i-1);\n                        indices.push_back(i);\n                    }\n                    faceInfo.m_GO = GOMesh::Add(faceInfo.m_Corners, indices);\n                    faceInfo.m_GO-&gt;SetColor(CUT_FACE_COLOR[cutInfo.m_State]);\n                    // We only show non-exposed faces\n                    if(faceInfo.m_Exposed){\n                        faceInfo.m_GO-&gt;SetVisibility(false);\n                    }\n                    faceInfo.m_GOPrimitives.push_back(faceInfo.m_GO);\n\n                    cutInfo.m_Faces[faceInfo.m_ID] = faceInfo;\n                    if(!faceInfo.m_Exposed){\n                        cutInfo.m_NonExposedFaceIDs.insert(faceInfo.m_ID);\n                    }\n                }\n\n                auto edges = cut.child(\"edges\");\n                for(auto edge = edges.child(\"edge\"); edge; edge=edge.next_sibling(\"edge\")){\n                    auto id = edge.attribute(\"id\").as_string();\n\n                    TimberInfo::Cut::Edge edgeInfo;\n                    edgeInfo.m_ID = edge.attribute(\"id\").as_string();\n                    edgeInfo.m_Start = StringToVec3(edge.child(\"start\").child_value()) * m_Scale;\n                    edgeInfo.m_End = StringToVec3(edge.child(\"end\").child_value()) * m_Scale;\n\n                    // build GOPrimitive edges and cotas, only on non-exposed edges\n                    if(cutInfo.m_NonExposedEdgeIDs.find(id) != cutInfo.m_NonExposedEdgeIDs.end()){\n                        // GOLines for edges\n                        edgeInfo.m_GO = GOLine::Add(edgeInfo.m_Start, edgeInfo.m_End, m_EdgeWeight);\n                        edgeInfo.m_GO-&gt;SetColor(CUT_EDGE_COLOR[cutInfo.m_State]);\n                        edgeInfo.m_GOPrimitives.push_back(edgeInfo.m_GO);\n\n                        // ----------------------------------------------\n                        // GOTexts for cotas\n                        auto mid = (edgeInfo.m_Start + edgeInfo.m_End) / 2.0f;\n\n                        glm::vec3 cutCtr = cutInfo.m_Center;\n                        float displacement = 0.02f * m_Scale;\n                        glm::vec3 vecMidCtr = glm::normalize(mid - cutCtr);\n                        // random value between 0 and 1\n                        auto midMoved = mid + (vecMidCtr * displacement);\n                        auto lineCotas = GOLine::Add(GOPoint(mid), GOPoint(midMoved));\n                        lineCotas-&gt;SetColor(GOColor::GREEN_PUNK_TRANSP07);\n                        lineCotas-&gt;SetWeight(GOWeight::Default);\n                        edgeInfo.m_CotaLines.push_back(lineCotas);\n\n                        auto cotasPt = GOPoint::Add(mid);\n                        cotasPt-&gt;SetColor(GOColor::GREEN_DARKER_TRANSP07);\n                        cotasPt-&gt;SetWeight(GOWeight::MediumThick);\n                        edgeInfo.m_CotaPts.push_back(cotasPt);\n\n                        float dist = glm::distance(edgeInfo.m_Start, edgeInfo.m_End);\n                        float distmm = dist / m_Scale * 1000;\n                        int roundedDistmm = std::round(distmm);\n                        auto cotas = GOText::Add(\n                            std::to_string(roundedDistmm) + \"mm\",\n                            midMoved,\n                            GOTextSize::Small);\n                        cotas-&gt;SetColor(GOColor::GREEN);\n                        edgeInfo.m_Cotas.push_back(cotas);\n\n                        if (this-&gt;m_TimberInfo.IsShowingCotas) {\n                            lineCotas-&gt;SetVisibility(true);\n                            cotasPt-&gt;SetVisibility(true);\n                            cotas-&gt;SetVisibility(true);\n                        } else {\n                            lineCotas-&gt;SetVisibility(false);\n                            cotasPt-&gt;SetVisibility(false);\n                            cotas-&gt;SetVisibility(false);\n                        }\n\n                        edgeInfo.m_GOPrimitives.push_back(lineCotas);\n                        edgeInfo.m_GOPrimitives.push_back(cotasPt);\n                        edgeInfo.m_GOPrimitives.push_back(cotas);\n                    }\n                    cutInfo.m_Edges[edgeInfo.m_ID] = edgeInfo;\n                }\n\n                // here we compute and add the neighbors\n                // compare the edges for each face and understand which faces are neighbors\n                for(auto&amp; [faceID, face] : cutInfo.m_Faces){\n                    for(auto&amp; [edgeID, edge] : cutInfo.m_Edges){\n                        if(face.m_Edges.find(edgeID) != face.m_Edges.end()){\n                            for(auto&amp; [otherFaceID, otherFace] : cutInfo.m_Faces){\n                                if(faceID == otherFaceID) continue;\n                                if(otherFace.m_Edges.find(edgeID) != otherFace.m_Edges.end()){\n                                    face.m_Neighbors.insert(otherFaceID);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                m_TimberInfo.m_Cuts[cutInfo.m_ID] = cutInfo;\n                m_TimberInfo.m_Components[cutInfo.m_ID] = &amp;m_TimberInfo.m_Cuts[cutInfo.m_ID];\n            }\n\n            if(m_TimberInfo.GetCurrentComponent() == nullptr){\n                m_TimberInfo.m_CurrentComponentID = m_TimberInfo.m_Components.begin()-&gt;first;\n            }\n            m_TimberInfo.GetCurrentComponent()-&gt;SetAsCurrent();\n        }\n\n        UpdateBboxGOLine();\n        m_TimberInfo.IsShowingAllComponents = true;\n\n        // Update the real world length\n        m_MeasuredBboxLength = GetRealWorldLength();\n\n        return true;\n    }\n\n    void ACInfoModel::Save() {\n        m_ACIMDoc.save_file(m_FilePath.c_str());\n    }\n\n    void ACInfoModel::Clear() {\n        for(auto&amp; line : m_BboxGOLines)\n            GOLine::Remove(line);\n        m_BboxGOLines.clear();\n\n        for(auto&amp; hole : m_TimberInfo.m_Holes){\n            for(auto&amp; primitive : hole.second.m_GOPrimitives)\n                GOPrimitive::Remove(primitive);\n        }\n        m_TimberInfo.m_Holes.clear();\n\n        for(auto&amp; cut : m_TimberInfo.m_Cuts){\n            for(auto&amp; primitive : cut.second.m_GOPrimitives)\n                GOPrimitive::Remove(primitive);\n            for(auto&amp; face : cut.second.m_Faces){\n                for(auto&amp; primitive : face.second.m_GOPrimitives)\n                    GOPrimitive::Remove(primitive);\n            }\n            for(auto&amp; edge : cut.second.m_Edges){\n                for(auto&amp; primitive : edge.second.m_GOPrimitives)\n                    GOPrimitive::Remove(primitive);\n                edge.second.ClearCotas();\n            }\n        }\n        m_TimberInfo.m_Cuts.clear();\n        m_TimberInfo.m_Components.clear();\n    }\n\n    void ACInfoModel::UpdateBboxGOLine() {\n        auto bbox = m_TimberInfo.m_Bbox;\n\n        // update the GOLine references\n        for(auto&amp; line : m_BboxGOLines)\n            GOLine::Remove(line);\n\n        // bottom\n        auto vec = glm::normalize(bbox[1] - bbox[0]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[0], bbox[0] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[1], bbox[1] - vec, 2.0f));\n        vec = glm::normalize(bbox[2] - bbox[1]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[1], bbox[1] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[2], bbox[2] - vec, 2.0f));\n        vec = glm::normalize(bbox[3] - bbox[2]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[2], bbox[2] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[3], bbox[3] - vec, 2.0f));\n        vec = glm::normalize(bbox[0] - bbox[3]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[3], bbox[3] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[0], bbox[0] - vec, 2.0f));\n        // m_BboxGOLines.push_back(GOLine::Add(bbox[0], bbox[1], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[1], bbox[2], 2.0f));\n        // m_BboxGOLines.push_back(GOLine::Add(bbox[2], bbox[3], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[3], bbox[0], 2.0f));\n\n        // top\n        vec = glm::normalize(bbox[5] - bbox[4]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[4], bbox[4] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[5], bbox[5] - vec, 2.0f));\n        vec = glm::normalize(bbox[6] - bbox[5]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[5], bbox[5] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[6], bbox[6] - vec, 2.0f));\n        vec = glm::normalize(bbox[7] - bbox[6]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[6], bbox[6] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[7], bbox[7] - vec, 2.0f));\n        vec = glm::normalize(bbox[4] - bbox[7]);\n        m_BboxGOLines.push_back(GOLine::Add(bbox[7], bbox[7] + vec, 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[4], bbox[4] - vec, 2.0f));\n        // m_BboxGOLines.push_back(GOLine::Add(bbox[4], bbox[5], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[5], bbox[6], 2.0f));\n        // m_BboxGOLines.push_back(GOLine::Add(bbox[6], bbox[7], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[7], bbox[4], 2.0f));\n\n        // side\n        m_BboxGOLines.push_back(GOLine::Add(bbox[0], bbox[4], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[1], bbox[5], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[2], bbox[6], 2.0f));\n        m_BboxGOLines.push_back(GOLine::Add(bbox[3], bbox[7], 2.0f));\n\n        // color of the bounding box\n        for(auto line : m_BboxGOLines)\n            line-&gt;SetColor(GOColor::PURPLE);\n\n        SetBboxVisibility(false);\n    }\n\n    void ACInfoModel::Transform(glm::mat4x4 transformMat) {\n        // bounding box\n        auto bbox = m_TimberInfo.m_Bbox;\n        for(int i = 0 ; i &lt; bbox.size() ; i++){\n            m_TimberInfo.m_Bbox[i] = glm::vec3(transformMat * glm::vec4(bbox[i], 1.0f));\n        }\n        bbox = m_TimberInfo.m_Bbox;\n        UpdateBboxGOLine();\n\n        // holes\n        for(auto&amp; kv : m_TimberInfo.m_Holes){\n            auto&amp; holeInfo = kv.second;\n            for(auto&amp; objs : holeInfo.m_GOPrimitives){\n                objs-&gt;Transform(transformMat);\n            }\n            holeInfo.m_Start = glm::vec3(transformMat * glm::vec4(holeInfo.m_Start, 1.0f));\n            holeInfo.m_End = glm::vec3(transformMat * glm::vec4(holeInfo.m_End, 1.0f));\n            holeInfo.m_Center = (holeInfo.m_Start + holeInfo.m_End) * 0.5f;\n        }\n\n        // cuts\n        for(auto&amp; kv : m_TimberInfo.m_Cuts){\n            auto&amp; cutInfo = kv.second;\n            for(auto&amp; objs : cutInfo.m_GOPrimitives){\n                objs-&gt;Transform(transformMat);\n            }\n            cutInfo.m_Center = glm::vec3(transformMat * glm::vec4(cutInfo.m_Center, 1.0f));\n\n            // Face\n            for(auto&amp; kv : cutInfo.m_Faces){\n                auto&amp; faceInfo = kv.second;\n                for(auto&amp; objs : faceInfo.m_GOPrimitives){\n                    objs-&gt;Transform(transformMat);\n                }\n                // FIXME: Add GOVec so we can use GO to manage everything.\n                // Normal, Center, and Corners are glm::vec3\n                for(auto&amp; corner : faceInfo.m_Corners){\n                    corner = glm::vec3(transformMat * glm::vec4(corner, 1.0f));\n                }\n                faceInfo.m_Center = glm::vec3(transformMat * glm::vec4(faceInfo.m_Center, 1.0f));\n                faceInfo.m_Normal = glm::normalize(glm::cross(faceInfo.m_Corners[1] - faceInfo.m_Corners[0],\n                                                              faceInfo.m_Corners[2] - faceInfo.m_Corners[0]));\n            }\n            // Edge\n            for(auto&amp; kv : cutInfo.m_Edges){\n                auto edgeInfo = kv.second;\n                for(auto&amp; objs : edgeInfo.m_GOPrimitives){\n                    objs-&gt;Transform(transformMat);\n                }\n            }\n        }\n    }\n\n    float ACInfoModel::GetLength(){\n        auto bbox = m_TimberInfo.m_Bbox;\n\n        float dist = 0.0f;\n        dist += glm::distance(bbox[0], bbox[1]);\n        dist += glm::distance(bbox[2], bbox[3]);\n        dist += glm::distance(bbox[4], bbox[5]);\n        dist += glm::distance(bbox[6], bbox[7]);\n        dist /= 4.0f;\n\n        return dist;\n    }\n\n    void ACInfoModel::SetBboxVisibility(bool visible){\n        for(auto line : m_BboxGOLines){\n            line-&gt;SetVisibility(visible);\n        }\n    }\n\n    void ACInfoModel::AddMeasuredBboxLength(const float diff) {\n        m_MeasuredBboxLength += diff;\n    }\n\n    void ACInfoModel::AdjustScale(){\n        float newScale = (GetLength() / m_Scale) / m_MeasuredBboxLength * m_Scale;\n        m_Scale = newScale;\n        AIAC::Config::UpdateEntry(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, newScale);\n    }\n\n    ACIMState StringToState(std::string state){\n        std::string notDoneStr = \"NotDone\";\n        std::string doneStr = \"Done\";\n        std::string currentStr = \"Current\";\n        if(!state.compare(0, notDoneStr.length(), notDoneStr)){\n            return ACIMState::NOT_DONE;\n        }\n        else if(!state.compare(0, doneStr.length(), doneStr)){\n            return ACIMState::DONE;\n        }\n        else if(!state.compare(0, currentStr.length(), currentStr)){\n            return ACIMState::CURRENT;\n        }\n        else {\n            AIAC_ERROR(\"Invalid state string: \\\"{0}\\\"\", state);\n            return ACIMState::NOT_DONE;\n        }\n    }\n\n    glm::vec3 StringToVec3(std::string str){\n        glm::vec3 vec;\n        auto ss = stringstream(str);\n        ss &gt;&gt; vec.x &gt;&gt; vec.y &gt;&gt; vec.z;\n        return vec;\n    }\n\n    std::vector&lt;std::string&gt; StringToTokens(std::string str){\n        std::vector&lt;std::string&gt; tokens;\n        std::string token;\n        std::istringstream tokenStream(str);\n        while (std::getline(tokenStream, token, ' ')){\n            tokens.push_back(token);\n        }\n        return tokens;\n    }\n\n    std::set&lt;std::string&gt; StringToSet(std::string str){\n        std::set&lt;std::string&gt; set;\n        std::string token;\n        std::istringstream tokenStream(str);\n        while (std::getline(tokenStream, token, ' ')){\n            set.insert(token);\n        }\n        return set;\n    }\n\n    bool StringToBool(std::string str){\n        // convert str to lowercase\n        std::transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n        std::string trueStr = \"true\";\n        std::string falseStr = \"false\";\n        if(!str.compare(0, trueStr.length(), trueStr)){\n            return true;\n        }\n        else if(!str.compare(0, falseStr.length(), falseStr)){\n            return false;\n        }\n        else {\n            AIAC_ERROR(\"Invalid bool string: {0}\", str);\n            return false;\n        }\n    }\n\n    std::string Vec3ToString(glm::vec3 vec){\n        std::stringstream ss;\n        ss &lt;&lt; vec.x &lt;&lt; \" \" &lt;&lt; vec.y &lt;&lt; \" \" &lt;&lt; vec.z;\n        return ss.str();\n    }\n} // namespace AIAC\n</code></pre>"},{"location":"acdoxygen/ACInfoModel_8h/","title":"File ACInfoModel.h","text":"<p>FileList &gt; AIAC &gt; ACInfoModel.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include \"pugixml.hpp\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> </ul>"},{"location":"acdoxygen/ACInfoModel_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/ACInfoModel_8h/#classes","title":"Classes","text":"Type Name class ACInfoModel class TimberInfo class Component class Cut class Edge class Face class Hole <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoModel.h</code></p>"},{"location":"acdoxygen/ACInfoModel_8h_source/","title":"File ACInfoModel.h","text":"<p>File List &gt; AIAC &gt; ACInfoModel.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;glm/glm.hpp&gt;\n\n#include \"pugixml.hpp\"\n\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/Config.h\"\n\nnamespace AIAC{\n\nenum class ACIMState{\n    NOT_DONE,\n    CURRENT,\n    DONE\n};\n\nstatic std::map&lt;ACIMState, glm::vec4&gt; HOLE_AXIS_COLOR = {\n    {ACIMState::NOT_DONE, glm::vec4(0.1f, 0.9f, 0.9f, 1.0f)},\n    {ACIMState::CURRENT, glm::vec4(0.1f, 0.9f, 0.5f, 1.0f)},\n    {ACIMState::DONE, glm::vec4(0.3f, 0.3f, 0.3f, 0.5f)}\n};\n\nstatic std::map&lt;ACIMState, glm::vec4&gt; HOLE_CYLINDER_COLOR = {\n    {ACIMState::NOT_DONE, glm::vec4(0.1f, 0.9f, 0.9f, 0.2f)},\n    {ACIMState::CURRENT, glm::vec4(0.1f, 0.9f, 0.5f, 0.2f)},\n    {ACIMState::DONE, glm::vec4(0.3f, 0.3f, 0.3f, 0.2f)}\n};\n\nstatic std::map&lt;ACIMState, glm::vec4&gt; CUT_FACE_COLOR = {\n    {ACIMState::NOT_DONE, glm::vec4(0.9f, 0.6f, 0.2f, 0.2f)},\n    {ACIMState::CURRENT, glm::vec4(0.1f, 0.9f, 0.5f, 0.2f)},\n    {ACIMState::DONE, glm::vec4(0.3f, 0.3f, 0.3f, 0.2f)}\n};\n\nstatic std::map&lt;ACIMState, glm::vec4&gt; CUT_EDGE_COLOR = {\n    {ACIMState::NOT_DONE, glm::vec4(0.9f, 0.6f, 0.2f, 1.0f)},\n    {ACIMState::CURRENT, glm::vec4(0.1f, 0.9f, 0.5f, 1.0f)},\n    {ACIMState::DONE, glm::vec4(0.3f, 0.3f, 0.3f, 0.5f)}\n};\n\nstatic ACIMState StringToState(std::string m_State);\n\nstatic glm::vec3 StringToVec3(std::string str);\n\nstatic std::vector&lt;std::string&gt; StringToTokens(std::string str);\n\nstatic std::set&lt;std::string&gt; StringToSet(std::string str);\n\nstatic bool StringToBool(std::string str);\n\nstatic std::string Vec3ToString(glm::vec3 vec3);\n\nclass TimberInfo{\npublic:\n    class Component {\n    public:\n        Component(std::string type) : m_Type(type) {\n#ifndef HEADLESS_TEST\n            m_Scale = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n#endif\n        }\n        virtual void SetAsCurrent();\n        virtual void SetAsDone();\n        virtual void SetAsNotDone();\n        virtual void SetVisibility(bool visible);\n        virtual glm::vec3 GetCenter() const;\n\n    public:\n        bool IsMarkedDone; // This one is for UI\n\n    public:  __always_inline\n        std::string GetTypeString() const { return m_Type; }\n\n    protected:\n        float m_Scale; // When converting to SLAM world's coordinate, multiply this scale\n        ACIMState m_State;\n        std::string m_Type;\n        pugi::xml_node m_ACIMDocNode;\n        std::string m_ID;\n        glm::vec3 m_Center;\n\n        std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; m_GOPrimitives;\n\n    friend class ACInfoModel;\n    friend class TimberInfo;\n    };\n\n    class Hole: public Component{\n    public:\n        Hole() : Component(\"HOLE\") {}\n    public:\n        virtual void SetAsCurrent();\n        virtual void SetAsDone();\n        virtual void SetAsNotDone();\n        virtual void SetVisibility(bool visible);\n        glm::vec3 GetCenter() const override { return (m_Start + m_End) * 0.5f; };\n        void SwapStartEnd();\n\n\n    public:  __always_inline\n        std::shared_ptr&lt;GOPoint&gt; GetStartPointGO() { return m_StartPointGO; }\n        std::shared_ptr&lt;GOPoint&gt; GetEndPointGO() { return m_EndPointGO; }\n\n    public:  __always_inline\n        double GetRadius() const { return m_Radius; }\n\n    private:\n        // These values uses original coordinate in xml file\n        // i.e. not transformation (rotation / translation) is applied\n        glm::vec3 m_Start;\n        bool m_StartExposed;\n        glm::vec3 m_End;\n        bool m_EndExposed;\n        double m_Radius;\n        std::set&lt;std::string&gt; m_Neighbors;\n\n        // GOPrimitives\n        std::shared_ptr&lt;GOLine&gt; m_AxisGO;\n        std::shared_ptr&lt;GOCylinder&gt; m_CylinderGO;\n        std::shared_ptr&lt;GOPoint&gt; m_StartPointGO;\n        std::shared_ptr&lt;GOPoint&gt; m_EndPointGO;\n        std::shared_ptr&lt;GOText&gt; m_IDLabelGO;\n\n        friend class ACInfoModel;\n    };\n\n    class Cut: public Component{\n    public:\n        Cut() : Component(\"CUT\") {}\n\n        virtual void SetAsCurrent();\n        virtual void SetAsDone();\n        virtual void SetAsNotDone();\n        virtual void SetVisibility(bool visible);\n        glm::vec3 GetCenter() const override { return m_Center; };\n\n        // Sub-class Face\n        class Face: public Component{\n        public:\n            Face() : Component(\"FACE\") {}\n            glm::vec3 GetCenter() const override { return m_Center; };\n\n            bool IsExposed() const { return m_Exposed; }\n            glm::vec3 GetNormal() const { return m_Normal; }\n            std::vector&lt;glm::vec3&gt; GetCorners() const { return m_Corners; }\n            std::set&lt;std::string&gt; GetEdges() const { return m_Edges; }\n            std::set&lt;std::string&gt; GetNeighbors() const { return m_Neighbors; }\n\n        private:\n            bool m_Exposed;\n            glm::vec3 m_Normal;\n            std::vector&lt;glm::vec3&gt; m_Corners;\n            std::set&lt;std::string&gt; m_Edges;\n            std::set&lt;std::string&gt; m_Neighbors;\n            std::shared_ptr&lt;GOMesh&gt; m_GO;\n\n            friend class Cut;\n            friend class TimberInfo;\n            friend class ACInfoModel;\n        };\n\n        // Sub-class Edge\n        class Edge: public Component{\n        public:\n            GOPoint GetStartPt() { return m_GO-&gt;GetPStart(); }\n            GOPoint GetEndPt() { return m_GO-&gt;GetPEnd(); }\n            Edge() : Component(\"EDGE\") {}\n\n            inline void SetCotasVisibility(bool visible) {\n                for(auto&amp; cota : m_Cotas) cota-&gt;SetVisibility(visible);\n                for(auto&amp; cotaLine : m_CotaLines) cotaLine-&gt;SetVisibility(visible);\n                for(auto&amp; cotaPt : m_CotaPts) cotaPt-&gt;SetVisibility(visible);\n            }\n            inline void ClearCotas() {\n                m_Cotas.clear();\n                m_CotaLines.clear();\n                m_CotaPts.clear();\n            }\n\n        private:\n            // These Start and End are original value (not transformed)\n            glm::vec3 m_Start;\n            glm::vec3 m_End;\n            std::set&lt;std::string&gt; m_Neighbors;\n            std::shared_ptr&lt;GOLine&gt; m_GO;\n\n            std::vector&lt;std::shared_ptr&lt;GOText&gt;&gt; m_Cotas;\n            std::vector&lt;std::shared_ptr&lt;GOLine&gt;&gt; m_CotaLines;\n            std::vector&lt;std::shared_ptr&lt;GOPoint&gt;&gt; m_CotaPts;\n\n            friend class Cut;\n            friend class TimberInfo;\n            friend class ACInfoModel;\n        };\n\n        inline bool IsSingleFace() const { return m_NonExposedFaceIDs.size() == 1; }\n        inline Face&amp; GetFace(std::string id) { if(m_Faces.count(id) == 0) throw std::invalid_argument(\"Face ID does not exist.\"); return m_Faces[id]; }\n        inline Edge&amp; GetEdge(std::string id) { if(m_Edges.count(id) == 0) throw std::invalid_argument(\"Edge ID does not exist.\"); return m_Edges[id]; }\n        inline std::map&lt;std::string, Face&gt;&amp; GetAllFaces() { return m_Faces; }\n        inline std::map&lt;std::string, Edge&gt;&amp; GetAllEdges() { return m_Edges; }\n        inline std::set&lt;std::string&gt;&amp; GetAllNonExposedFaceIDs() { return m_NonExposedFaceIDs; }\n        inline std::set&lt;std::string&gt;&amp; GetAllNonExposedEdgeIDs() { return m_NonExposedEdgeIDs; }\n\n        void HighlightFace(const std::string&amp; faceId, glm::vec4 color = glm::vec4(0));\n        inline std::string GetHighlightedFaceID() const { return m_HighlightedFaceID; }\n        inline TimberInfo::Cut::Face GetHighlightedFace() { return m_Faces[m_HighlightedFaceID]; }\n\n        inline std::map&lt;std::string, Face&gt; GetFaceNeighbors(std::string faceID) {\n            std::map&lt;std::string, Face&gt; neighbors;\n            for(auto&amp; neighborID : m_Faces[faceID].m_Neighbors){\n                neighbors[neighborID] = m_Faces[neighborID];\n            }\n            return neighbors;\n        }\n        inline std::map&lt;std::string, Face&gt; GetHighlightedFaceNeighbors() {\n            return GetFaceNeighbors(m_HighlightedFaceID);\n        }\n\n        inline void SetVisibilityAllCotas(bool visible) {\n            for(auto&amp; edge : m_Edges){\n                edge.second.SetCotasVisibility(visible);\n            }\n        }\n\n    private:\n        std::string m_HighlightedFaceID;\n        std::map&lt;std::string, Face&gt; m_Faces;\n        std::map&lt;std::string, Edge&gt; m_Edges;\n        std::set&lt;std::string&gt; m_NonExposedFaceIDs;\n        std::set&lt;std::string&gt; m_NonExposedEdgeIDs;\n        std::shared_ptr&lt;GOText&gt; m_IDLabelGO;\n\n        friend class ACInfoModel;\n    };\n\n    inline std::string GetID() const { return m_ID; }\n    std::vector&lt;std::string&gt; GetAllComponentsIDs() const;\n\n    inline Component* GetComponent(const std::string&amp; id) { return m_Components[id]; }\n    inline Component* GetCurrentComponent() { \n        if(m_Components.find(m_CurrentComponentID) == m_Components.end())\n            return nullptr;\n        return m_Components[m_CurrentComponentID];\n    }\n    std::string GetCurrentComponentID() { return m_CurrentComponentID; }\n    void SetCurrentComponentTo(std::string id);\n    void SetNextComponentAsCurrent();\n    void SetPrevComponentAsCurrent();\n\n    inline std::vector&lt;glm::vec3&gt; GetBoundingBox() const { return m_Bbox; }\n    inline std::vector&lt;std::pair&lt;int, int&gt; &gt; GetBboxEdgesIndices() const { return m_BboxEdgesIndices; }\n\n    void HideAllComponentsExceptCurrent();\n    void ShowAllComponents();\n    void UpdateCotasVisibility(bool visible);\n\npublic: \n    inline int GetFabricatedComponents() {\n        int count = 0;\n        for(auto&amp; comp : m_Components){\n            if(comp.second-&gt;m_State == ACIMState::DONE)\n                count++;\n        }\n        return count;\n    }\n    inline int GetTotalComponents() { return m_Components.size(); }\n    inline float GetFabricationProgress() {\n        return (float)GetFabricatedComponents() / GetTotalComponents() * 100;\n    }\n\nprivate:  \n    std::string ShortenComponentID(std::string id);\n\npublic:\n    bool IsShowingAllComponents = false;\n    bool IsShowingCotas = false;\n\nprivate:\n    std::string m_ID;\n\n    // The bounding box has this structure\n    //\n    //   (7)------------------------(6)\n    //   / |                       / |  \n    // (4)-----------------------(5) |\n    //  |  |                      |  |\n    //  | (3)---------------------|-(2)\n    //  |/                        |/\n    // (0)-----------------------(1)\n    //\n    std::vector&lt;glm::vec3&gt; m_Bbox;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; m_BboxEdgesIndices = {\n        {0, 1}, {1, 2}, {2, 3}, {3, 0}, // bottom\n        {4, 5}, {5, 6}, {6, 7}, {7, 4}, // top\n        {0, 4}, {1, 5}, {2, 6}, {3, 7}  // vertical\n    };\n    ACIMState m_State = ACIMState::NOT_DONE; // TODO: states instead of executed?\n    std::map&lt;std::string, Hole&gt; m_Holes;\n    std::map&lt;std::string, Cut&gt; m_Cuts;\n    std::map&lt;std::string, Component*&gt; m_Components;  // FIXME: refactor with smart pointers\n    std::string m_CurrentComponentID = \"\";\n\n    friend class ACInfoModel;\n};\n\nclass ACInfoModel\n{\npublic:\n    ACInfoModel(){\n#ifndef HEADLESS_TEST\n        m_Scale = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n#endif\n    };\n    ~ACInfoModel(){};\n\n    bool Load(std::string path);\n\n    void Save();\n\n    inline const std::string&amp; GetFilePath() const { return m_FilePath; }\n\n    inline const std::string GetName() const {\n        auto nameWithExtension = m_FilePath.substr(m_FilePath.find_last_of(\"/\\\\\") + 1);\n        std::string nameWithoutExtension = nameWithExtension.substr(0, nameWithExtension.find_last_of(\".\"));\n        return nameWithoutExtension; }\n\n    inline pugi::xml_document&amp; GetDoc() { return m_ACIMDoc; }\n\n    void Clear();\n\n    inline TimberInfo&amp; GetTimberInfo() { return m_TimberInfo; }\n\n    void UpdateBboxGOLine();\n\n    // /**\n    //  * @brief Update the cotas\n    //  */\n    // void UpdateCotas();\n\n    void Transform(glm::mat4x4 transformMat);\n\n    float GetLength();\n\n    inline float GetRealWorldLength() { return GetLength() / m_Scale; }\n\n    void SetBboxVisibility(bool visible);\n\n    void AddMeasuredBboxLength(const float diff);\n\n    inline float GetMeasuredBboxLength() const { return m_MeasuredBboxLength; };\n\n    void AdjustScale();\n\nprivate:\n    float m_EdgeWeight = 1.1f;\n    float m_LabelSize = 0.75f;\n\n    float m_Scale = 1.0f;\n    float m_MeasuredBboxLength;\n\n    std::string m_FilePath;\n    pugi::xml_document m_ACIMDoc;\n\n    TimberInfo m_TimberInfo;\n\n    std::vector&lt;std::shared_ptr&lt;GOLine&gt;&gt; m_BboxGOLines;\n};\n\n}\n</code></pre>"},{"location":"acdoxygen/ACInfoToolhead_8cpp/","title":"File ACInfoToolhead.cpp","text":"<p>FileList &gt; AIAC &gt; ACInfoToolhead.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ACInfoToolhead.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"GeometryUtils.h\"</code></li> <li><code>#include \"pugixml.hpp\"</code></li> </ul>"},{"location":"acdoxygen/ACInfoToolhead_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.cpp</code></p>"},{"location":"acdoxygen/ACInfoToolhead_8cpp_source/","title":"File ACInfoToolhead.cpp","text":"<p>File List &gt; AIAC &gt; ACInfoToolhead.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"ACInfoToolhead.h\"\n#include \"AIAC/Log.h\"\n#include \"GeometryUtils.h\"\n\n#include \"pugixml.hpp\"\n\nnamespace AIAC\n{\n    void ToolHeadData::LoadACIT(std::string acitPath)\n    {\n        AIAC_INFO(\"Loading ACIT from {0}\", acitPath);\n        pugi::xml_document doc;\n        pugi::xml_parse_result result = doc.load_file(acitPath.c_str());\n        if (!result) { AIAC_ERROR(\"Could not load ACIT from {0}\", acitPath); return; }\n\n        pugi::xml_node root = doc.child(\"acit\");\n        pugi::xml_node toolhead = root.child(\"toolhead\");\n\n        std::string type = toolhead.attribute(\"type\").as_string();\n        if (type == \"drillbit\")\n        {\n            m_Type = ACToolHeadType::DRILLBIT;\n            m_Name = toolhead.attribute(\"name\").as_string();\n\n            m_DrillBitD.ToolbaseACIT = ParseString2GlmVector(toolhead.child(\"toolbase\").child_value()) * this-&gt;GetScaleF();\n            m_DrillBitD.TooltipACIT = ParseString2GlmVector(toolhead.child(\"tooltip\").child_value()) * this-&gt;GetScaleF();\n            m_DrillBitD.EattipACIT = ParseString2GlmVector(toolhead.child(\"eattip\").child_value()) * this-&gt;GetScaleF();\n            m_DrillBitD.ChucktipACIT = ParseString2GlmVector(toolhead.child(\"chucktip\").child_value()) * this-&gt;GetScaleF();\n            m_DrillBitD.RadiusACIT = toolhead.child(\"radius\").text().as_float() * this-&gt;GetScaleF();\n        }\n        else if (type == \"circularsaw\")\n        {\n            m_Type = ACToolHeadType::CIRCULARSAW;\n            m_Name = toolhead.attribute(\"name\").as_string();\n            m_CircularSawD.CenterACIT = ParseString2GlmVector(toolhead.child(\"center\").child_value()) * this-&gt;GetScaleF();\n\n            m_CircularSawD.NormStartACIT = ParseString2GlmVector(toolhead.child(\"normalstart\").child_value()) * this-&gt;GetScaleF();\n            m_CircularSawD.NormEndACIT = ParseString2GlmVector(toolhead.child(\"normalend\").child_value()) * this-&gt;GetScaleF();\n            m_CircularSawD.RadiusACIT = toolhead.child(\"radius\").text().as_float() * this-&gt;GetScaleF();\n            m_CircularSawD.ThicknessACIT = toolhead.child(\"bladeThickness\").text().as_float() * this-&gt;GetScaleF();\n            m_CircularSawD.OverhangACIT = toolhead.child(\"bladeOverhang\").text().as_float() * this-&gt;GetScaleF();\n        }\n        else if (type == \"chainsaw\")\n        {\n            m_Type = ACToolHeadType::CHAINSAW;\n            m_Name = toolhead.attribute(\"name\").as_string();\n\n            m_ChainSawD.ChainBaseACIT = ParseString2GlmVector(toolhead.child(\"chainbase\").child_value()) * this-&gt;GetScaleF();\n            m_ChainSawD.ChainMidACIT = ParseString2GlmVector(toolhead.child(\"chainmid\").child_value()) * this-&gt;GetScaleF();\n            m_ChainSawD.ChainNormEndACIT = ParseString2GlmVector(toolhead.child(\"chainend\").child_value()) * this-&gt;GetScaleF();\n            m_ChainSawD.NormStartACIT = ParseString2GlmVector(toolhead.child(\"normalstart\").child_value()) * this-&gt;GetScaleF();\n            m_ChainSawD.NormEndACIT = ParseString2GlmVector(toolhead.child(\"normalend\").child_value()) * this-&gt;GetScaleF();\n            m_ChainSawD.WidthACIT = toolhead.child(\"width\").text().as_float() * this-&gt;GetScaleF();\n            m_ChainSawD.ThicknessACIT = toolhead.child(\"bladeThickness\").text().as_float() * this-&gt;GetScaleF();\n            m_ChainSawD.OverhangACIT = toolhead.child(\"bladeOverhang\").text().as_float() * this-&gt;GetScaleF();\n        }\n        else if (type == \"sabersaw\")\n        {\n            m_Type = ACToolHeadType::SABERSAW;\n            m_Name = toolhead.attribute(\"name\").as_string();\n\n            m_SaberSawD.ToolbaseACIT = ParseString2GlmVector(toolhead.child(\"toolbase\").child_value()) * this-&gt;GetScaleF();\n            m_SaberSawD.TooltipACIT = ParseString2GlmVector(toolhead.child(\"tooltip\").child_value()) * this-&gt;GetScaleF();\n            m_SaberSawD.NormStartACIT = ParseString2GlmVector(toolhead.child(\"normalstart\").child_value()) * this-&gt;GetScaleF();\n            m_SaberSawD.NormEndACIT = ParseString2GlmVector(toolhead.child(\"normalend\").child_value()) * this-&gt;GetScaleF();\n        }\n        else { AIAC_ERROR(\"Toolhead type {0} not supported\", type); }\n        return;\n    }\n\n    glm::vec3 ToolHeadData::ParseString2GlmVector(std::string str)\n    {\n        glm::vec3 vec;\n        auto ss = std::stringstream(str);\n        ss &gt;&gt; vec.x &gt;&gt; vec.y &gt;&gt; vec.z;\n        return vec;\n    }\n\n    ACInfoToolhead::ACInfoToolhead(std::string acitPath, std::string objPath, int id)\n        : m_ACITPath(acitPath), m_OBJPath(objPath), m_ID(id)\n    {\n        this-&gt;m_Data.LoadACIT(acitPath);\n        this-&gt;AddGOsInfo(this-&gt;m_Data);\n        this-&gt;m_GOPrimitivesInfoOriginal.clear();\n        this-&gt;CopyGOsInfoOriginal();\n        this-&gt;TransformSync();\n        this-&gt;SetVisibility(true);\n    }\n\n    void ACInfoToolhead::AddGOsInfo(ToolHeadData&amp; data)\n    {\n        switch (data.m_Type)\n        {\n            case ACToolHeadType::DRILLBIT:\n                this-&gt;AddGOsInfoDrillBit(data);\n                break;\n            case ACToolHeadType::CIRCULARSAW:\n                this-&gt;AddGOsInfoCircularSaw(data);\n                break;\n            case ACToolHeadType::CHAINSAW:\n                this-&gt;AddGOsInfoChainSaw(data);\n                break;\n            case ACToolHeadType::SABERSAW:\n                this-&gt;AddGOsInfoSaberSaw(data);\n                break;\n            default:\n                AIAC_ERROR(\"Toolhead type not supported\");\n                break;\n        }\n        return;\n    }\n\n    void ACInfoToolhead::AddGOsInfoDrillBit(ToolHeadData&amp; data)\n    {\n        data.m_DrillBitD.ToolbaseGO = GOPoint::Add(data.m_DrillBitD.ToolbaseACIT.x,\n                                       data.m_DrillBitD.ToolbaseACIT.y,\n                                       data.m_DrillBitD.ToolbaseACIT.z,\n                                       GOWeight::Thick);\n        data.m_DrillBitD.ToolbaseGO-&gt;SetColor(GOColor::RED);\n        data.m_DrillBitD.TooltipGO = GOPoint::Add(data.m_DrillBitD.TooltipACIT.x, \n                                      data.m_DrillBitD.TooltipACIT.y,\n                                      data.m_DrillBitD.TooltipACIT.z,\n                                      GOWeight::Thick);\n        data.m_DrillBitD.TooltipGO-&gt;SetColor(GOColor::GREEN);\n        data.m_DrillBitD.EattipGO = GOPoint::Add(data.m_DrillBitD.EattipACIT.x,\n                                     data.m_DrillBitD.EattipACIT.y,\n                                     data.m_DrillBitD.EattipACIT.z,\n                                     GOWeight::Thick);\n        data.m_DrillBitD.EattipGO-&gt;SetColor(GOColor::BLUE);\n        data.m_DrillBitD.ChucktipGO = GOPoint::Add(data.m_DrillBitD.ChucktipACIT.x,\n                                       data.m_DrillBitD.ChucktipACIT.y,\n                                       data.m_DrillBitD.ChucktipACIT.z,\n                                       GOWeight::Thick);\n        data.m_DrillBitD.ChucktipGO-&gt;SetColor(GOColor::YELLOW);\n\n        auto lnAxis = GOLine::Add(*data.m_DrillBitD.ToolbaseGO, *data.m_DrillBitD.TooltipGO);\n        lnAxis-&gt;SetColor(GOColor::MAGENTA);\n\n        lnAxis-&gt;SetVisibility(false);\n\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_DrillBitD.ToolbaseGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_DrillBitD.TooltipGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_DrillBitD.EattipGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_DrillBitD.ChucktipGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(lnAxis);\n\n        for (auto&amp; go : this-&gt;m_GOPrimitivesInfo)\n            go-&gt;SetVisibility(false);\n    }\n    void ACInfoToolhead::AddGOsInfoCircularSaw(ToolHeadData&amp; data)\n    {\n        data.m_CircularSawD.CenterGO = GOPoint::Add(data.m_CircularSawD.CenterACIT.x,\n                                         data.m_CircularSawD.CenterACIT.y,\n                                         data.m_CircularSawD.CenterACIT.z,\n                                         GOWeight::Thick);\n        data.m_CircularSawD.CenterGO-&gt;SetColor(GOColor::RED);\n        data.m_CircularSawD.NormEndGO = GOPoint::Add(data.m_CircularSawD.NormEndACIT.x,\n                                                 data.m_CircularSawD.NormEndACIT.y,\n                                                 data.m_CircularSawD.NormEndACIT.z,\n                                                 GOWeight::Thick);\n        data.m_CircularSawD.NormEndGO-&gt;SetColor(GOColor::GREEN);\n        auto lnNormal = GOLine::Add(*data.m_CircularSawD.CenterGO, *data.m_CircularSawD.NormEndGO);\n        lnNormal-&gt;SetColor(GOColor::MAGENTA);\n\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_CircularSawD.CenterGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_CircularSawD.NormEndGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(lnNormal);\n\n        for (auto&amp; go : this-&gt;m_GOPrimitivesInfo)\n            go-&gt;SetVisibility(false);\n    }\n    void ACInfoToolhead::AddGOsInfoChainSaw(ToolHeadData&amp; data)\n    {\n        data.m_ChainSawD.ChainBaseGO = GOPoint::Add(data.m_ChainSawD.ChainBaseACIT.x,\n                                        data.m_ChainSawD.ChainBaseACIT.y,\n                                        data.m_ChainSawD.ChainBaseACIT.z,\n                                        GOWeight::Thick);\n        data.m_ChainSawD.ChainBaseGO-&gt;SetColor(GOColor::RED);\n        data.m_ChainSawD.ChainMidGO = GOPoint::Add(data.m_ChainSawD.ChainMidACIT.x,\n                                                   data.m_ChainSawD.ChainMidACIT.y,\n                                                   data.m_ChainSawD.ChainMidACIT.z,\n                                                   GOWeight::Thick);\n        data.m_ChainSawD.ChainMidGO-&gt;SetColor(GOColor::GREEN);\n        data.m_ChainSawD.ChainEndGO = GOPoint::Add(data.m_ChainSawD.ChainNormEndACIT.x,\n                                       data.m_ChainSawD.ChainNormEndACIT.y,\n                                       data.m_ChainSawD.ChainNormEndACIT.z,\n                                       GOWeight::Thick);\n        data.m_ChainSawD.ChainEndGO-&gt;SetColor(GOColor::BLUE);\n        data.m_ChainSawD.NormStartGO = GOPoint::Add(data.m_ChainSawD.NormStartACIT.x,\n                                                data.m_ChainSawD.NormStartACIT.y,\n                                                data.m_ChainSawD.NormStartACIT.z,\n                                                GOWeight::Thick);\n        data.m_ChainSawD.NormStartGO-&gt;SetColor(GOColor::YELLOW);\n        data.m_ChainSawD.NormEndGO = GOPoint::Add(data.m_ChainSawD.NormEndACIT.x,\n                                              data.m_ChainSawD.NormEndACIT.y,\n                                              data.m_ChainSawD.NormEndACIT.z,\n                                              GOWeight::Thick);\n        data.m_ChainSawD.NormEndGO-&gt;SetColor(GOColor::CYAN);\n        auto lnBaseMid = GOLine::Add(*data.m_ChainSawD.ChainBaseGO, *data.m_ChainSawD.ChainMidGO);\n        lnBaseMid-&gt;SetColor(GOColor::MAGENTA);\n        auto lnMidEnd = GOLine::Add(*data.m_ChainSawD.ChainMidGO, *data.m_ChainSawD.ChainEndGO);\n        lnMidEnd-&gt;SetColor(GOColor::MAGENTA);\n\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_ChainSawD.ChainBaseGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_ChainSawD.ChainMidGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_ChainSawD.ChainEndGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_ChainSawD.NormStartGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_ChainSawD.NormEndGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(lnBaseMid);\n        this-&gt;m_GOPrimitivesInfo.push_back(lnMidEnd);\n\n        for (auto&amp; go : this-&gt;m_GOPrimitivesInfo)\n            go-&gt;SetVisibility(false);\n    }\n    void ACInfoToolhead::AddGOsInfoSaberSaw(ToolHeadData&amp; data)\n    {\n        data.m_SaberSawD.ToolbaseGO = GOPoint::Add(data.m_SaberSawD.ToolbaseACIT.x,\n                                       data.m_SaberSawD.ToolbaseACIT.y,\n                                       data.m_SaberSawD.ToolbaseACIT.z,\n                                       GOWeight::Thick);\n        data.m_SaberSawD.ToolbaseGO-&gt;SetColor(GOColor::RED);\n        data.m_SaberSawD.TooltipGO = GOPoint::Add(data.m_SaberSawD.TooltipACIT.x,\n                                      data.m_SaberSawD.TooltipACIT.y,\n                                      data.m_SaberSawD.TooltipACIT.z,\n                                      GOWeight::Thick);\n        data.m_SaberSawD.TooltipGO-&gt;SetColor(GOColor::GREEN);\n        data.m_SaberSawD.NormStartGO = GOPoint::Add(data.m_SaberSawD.NormStartACIT.x,\n                                                data.m_SaberSawD.NormStartACIT.y,\n                                                data.m_SaberSawD.NormStartACIT.z,\n                                                GOWeight::Thick);\n        data.m_SaberSawD.NormStartGO-&gt;SetColor(GOColor::BLUE);\n        data.m_SaberSawD.NormEndGO = GOPoint::Add(data.m_SaberSawD.NormEndACIT.x,\n                                              data.m_SaberSawD.NormEndACIT.y,\n                                              data.m_SaberSawD.NormEndACIT.z,\n                                              GOWeight::Thick);\n        data.m_SaberSawD.NormEndGO-&gt;SetColor(GOColor::YELLOW);\n        auto lineAxis = GOLine::Add(*data.m_SaberSawD.ToolbaseGO, *data.m_SaberSawD.TooltipGO);\n        lineAxis-&gt;SetColor(GOColor::MAGENTA);\n\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_SaberSawD.ToolbaseGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_SaberSawD.TooltipGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_SaberSawD.NormStartGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(data.m_SaberSawD.NormEndGO);\n        this-&gt;m_GOPrimitivesInfo.push_back(lineAxis);\n\n        for (auto&amp; go : this-&gt;m_GOPrimitivesInfo)\n            go-&gt;SetVisibility(false);\n    }\n\n    void ACInfoToolhead::SetVisibility(bool visible)\n    {\n        for (auto&amp; go : m_GOPrimitivesInfo)\n            go-&gt;SetVisibility(visible);\n    }\n\n    void ACInfoToolhead::Transform(glm::mat4 transform)\n    {\n        for (uint i = 0; i &lt; this-&gt;m_GOPrimitivesInfo.size(); i++)\n            this-&gt;TransformGO(this-&gt;m_GOPrimitivesInfo[i], this-&gt;m_GOPrimitivesInfoOriginal[i], transform);\n    }\n    void ACInfoToolhead::TransformGO(std::shared_ptr&lt;GOPrimitive&gt; goPtr,\n                                     std::shared_ptr&lt;GOPrimitive&gt; goOriginalPtr,\n                                     glm::mat4 transform)\n    {\n        switch (goPtr-&gt;GetType())\n        {\n            case _GOPoint:\n            {\n                std::shared_ptr&lt;GOPoint&gt; go = std::dynamic_pointer_cast&lt;GOPoint&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOPoint&gt; goCopied = std::make_shared&lt;GOPoint&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOLine:\n            {\n                std::shared_ptr&lt;GOLine&gt; go = std::dynamic_pointer_cast&lt;GOLine&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOLine&gt; goCopied = std::make_shared&lt;GOLine&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOCircle:\n            {\n                std::shared_ptr&lt;GOCircle&gt; go = std::dynamic_pointer_cast&lt;GOCircle&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOCircle&gt; goCopied = std::make_shared&lt;GOCircle&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOCylinder:\n            {\n                std::shared_ptr&lt;GOCylinder&gt; go = std::dynamic_pointer_cast&lt;GOCylinder&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOCylinder&gt; goCopied = std::make_shared&lt;GOCylinder&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOPolyline:\n            {\n                std::shared_ptr&lt;GOPolyline&gt; go = std::dynamic_pointer_cast&lt;GOPolyline&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOPolyline&gt; goCopied = std::make_shared&lt;GOPolyline&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOTriangle:\n            {\n                std::shared_ptr&lt;GOTriangle&gt; go = std::dynamic_pointer_cast&lt;GOTriangle&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOTriangle&gt; goCopied = std::make_shared&lt;GOTriangle&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOMesh:\n            {\n                std::shared_ptr&lt;GOMesh&gt; go = std::dynamic_pointer_cast&lt;GOMesh&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOMesh&gt; goCopied = std::make_shared&lt;GOMesh&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            case _GOText:\n            {\n                std::shared_ptr&lt;GOText&gt; go = std::dynamic_pointer_cast&lt;GOText&gt;(goOriginalPtr);\n                std::shared_ptr&lt;GOText&gt; goCopied = std::make_shared&lt;GOText&gt;(*go);\n                goCopied-&gt;Transform(transform);\n                goPtr-&gt;SetValueFrom(goCopied);\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    void ACInfoToolhead::TransformSync()\n    {\n        // Derive the bounding boxes of the info\n        glm::vec3 lbn = glm::vec3(FLT_MAX, FLT_MAX, FLT_MAX);\n        glm::vec3 rtf = glm::vec3(-FLT_MAX, -FLT_MAX, -FLT_MAX);\n\n        // Getting the bounding box of the info\n        // Here, we filter in only the points\n        for (auto&amp; go : this-&gt;m_GOPrimitivesInfoOriginal)\n        {\n            if (go-&gt;GetType() != _GOPoint)\n                continue;\n            std::shared_ptr&lt;GOPoint&gt; goPoint = std::dynamic_pointer_cast&lt;GOPoint&gt;(go);\n            glm::vec3 position = goPoint-&gt;GetPosition();\n            lbn.x = std::min(lbn.x, position.x);\n            lbn.y = std::min(lbn.y, position.y);\n            lbn.z = std::min(lbn.z, position.z);\n            rtf.x = std::max(rtf.x, position.x);\n            rtf.y = std::max(rtf.y, position.y);\n            rtf.z = std::max(rtf.z, position.z);\n        }\n\n        glm::vec3 center = (lbn + rtf) / 2.0f;\n\n        glm::mat4x4 transformToCenter, transformBackFromCenter;\n        transformToCenter = GetTranslationMatrix(-center);\n        transformBackFromCenter = GetTranslationMatrix(center);\n\n        glm::mat4x4 rotation = glm::mat4x4(GetRotationMatrix(glm::vec3(1, 0, 0), 90.0f * M_PI / 180.0f));\n\n        for (auto&amp; go : this-&gt;m_GOPrimitivesInfoOriginal)\n            go-&gt;Transform(transformBackFromCenter * rotation * transformToCenter);\n    }\n\n    void ACInfoToolhead::CopyGOsInfoOriginal()\n    {\n        for (const auto&amp; go : this-&gt;m_GOPrimitivesInfo) \n        {\n            switch (go-&gt;GetType())\n            {\n            case _GOPoint:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOPoint&gt;(*std::dynamic_pointer_cast&lt;GOPoint&gt;(go))); \n                break;\n            case _GOLine:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOLine&gt;(*std::dynamic_pointer_cast&lt;GOLine&gt;(go))); \n                break;\n            case _GOCircle:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOCircle&gt;(*std::dynamic_pointer_cast&lt;GOCircle&gt;(go))); \n                break;\n            case _GOCylinder:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOCylinder&gt;(*std::dynamic_pointer_cast&lt;GOCylinder&gt;(go))); \n                break;\n            case _GOPolyline:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOPolyline&gt;(*std::dynamic_pointer_cast&lt;GOPolyline&gt;(go))); \n                break;\n            case _GOTriangle:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOTriangle&gt;(*std::dynamic_pointer_cast&lt;GOTriangle&gt;(go))); \n                break;\n            case _GOMesh:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOMesh&gt;(*std::dynamic_pointer_cast&lt;GOMesh&gt;(go))); \n                break;\n            case _GOText:\n                this-&gt;m_GOPrimitivesInfoOriginal.push_back(std::make_shared&lt;GOText&gt;(*std::dynamic_pointer_cast&lt;GOText&gt;(go)));\n                break;\n            default:\n                break;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"acdoxygen/ACInfoToolhead_8h/","title":"File ACInfoToolhead.h","text":"<p>FileList &gt; AIAC &gt; ACInfoToolhead.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"AIAC/GOSys/GO.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"Config.h\"</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"acdoxygen/ACInfoToolhead_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/ACInfoToolhead_8h/#classes","title":"Classes","text":"Type Name class ACInfoToolhead the class holding the information of the toolhead (GOs, metadata, etc) struct ChainSawData struct CircularSawData struct DrillBitData struct SaberSawData class ToolHeadData Class holding and parse and create data from the .acit file of the toolhead. <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolhead.h</code></p>"},{"location":"acdoxygen/ACInfoToolhead_8h_source/","title":"File ACInfoToolhead.h","text":"<p>File List &gt; AIAC &gt; ACInfoToolhead.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;type_traits&gt;\n\n#include \"AIAC/GOSys/GO.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"Config.h\"\n\n#include &lt;glm/glm.hpp&gt;\n\nnamespace AIAC\n{\n    enum class ACToolHeadType\n    {\n        DRILLBIT,\n        CIRCULARSAW,\n        SABERSAW,\n        CHAINSAW\n    };\n\n    struct DrillBitData\n    {\n        std::string NameACIT;\n        float RadiusACIT;\n\n        glm::vec3 ToolbaseACIT;\n        glm::vec3 TooltipACIT;\n        glm::vec3 EattipACIT;\n        glm::vec3 ChucktipACIT;\n        std::shared_ptr&lt;GOPoint&gt; ToolbaseGO;\n        std::shared_ptr&lt;GOPoint&gt; TooltipGO;\n        std::shared_ptr&lt;GOPoint&gt; EattipGO;\n        std::shared_ptr&lt;GOPoint&gt; ChucktipGO;\n\n        DrillBitData()\n        {\n            ToolbaseGO = std::make_shared&lt;GOPoint&gt;();\n            TooltipGO = std::make_shared&lt;GOPoint&gt;();\n            EattipGO = std::make_shared&lt;GOPoint&gt;();\n            ChucktipGO = std::make_shared&lt;GOPoint&gt;();\n        }\n    };\n    struct CircularSawData\n    {\n        std::string NameACIT;\n        float RadiusACIT;\n        float ThicknessACIT;\n        float OverhangACIT;\n\n        glm::vec3 CenterACIT;\n        glm::vec3 NormStartACIT;\n        glm::vec3 NormEndACIT;\n        std::shared_ptr&lt;GOPoint&gt; CenterGO;\n        std::shared_ptr&lt;GOPoint&gt; NormStartGO;\n        std::shared_ptr&lt;GOPoint&gt; NormEndGO;\n\n        CircularSawData()\n        {\n            CenterGO = std::make_shared&lt;GOPoint&gt;();\n            NormStartGO = std::make_shared&lt;GOPoint&gt;();\n            NormEndGO = std::make_shared&lt;GOPoint&gt;();\n        }\n    };\n    struct ChainSawData\n    {\n        std::string NameACIT;\n        float WidthACIT;\n        float ThicknessACIT;\n        float OverhangACIT;\n\n        glm::vec3 ChainBaseACIT;\n        glm::vec3 ChainMidACIT;\n        glm::vec3 ChainNormEndACIT;\n        glm::vec3 NormStartACIT;\n        glm::vec3 NormEndACIT;\n        std::shared_ptr&lt;GOPoint&gt; ChainBaseGO;\n        std::shared_ptr&lt;GOPoint&gt; ChainMidGO;\n        std::shared_ptr&lt;GOPoint&gt; ChainEndGO;\n        std::shared_ptr&lt;GOPoint&gt; NormStartGO;\n        std::shared_ptr&lt;GOPoint&gt; NormEndGO;\n\n        ChainSawData()\n        {\n            ChainBaseGO = std::make_shared&lt;GOPoint&gt;();\n            ChainMidGO = std::make_shared&lt;GOPoint&gt;();\n            ChainEndGO = std::make_shared&lt;GOPoint&gt;();\n            NormStartGO = std::make_shared&lt;GOPoint&gt;();\n            NormEndGO = std::make_shared&lt;GOPoint&gt;();\n        }\n    };\n    struct SaberSawData\n    {\n        std::string NameACIT;\n\n        glm::vec3 ToolbaseACIT;\n        glm::vec3 TooltipACIT;\n        glm::vec3 NormStartACIT;\n        glm::vec3 NormEndACIT;\n        std::shared_ptr&lt;GOPoint&gt; ToolbaseGO;\n        std::shared_ptr&lt;GOPoint&gt; TooltipGO;\n        std::shared_ptr&lt;GOPoint&gt; NormStartGO;\n        std::shared_ptr&lt;GOPoint&gt; NormEndGO;\n\n        SaberSawData()\n        {\n            ToolbaseGO = std::make_shared&lt;GOPoint&gt;();\n            TooltipGO = std::make_shared&lt;GOPoint&gt;();\n            NormStartGO = std::make_shared&lt;GOPoint&gt;();\n            NormEndGO = std::make_shared&lt;GOPoint&gt;();\n        }\n    };\n\n    class ToolHeadData\n    {\n        public:\n            ToolHeadData(){\n                this-&gt;m_ScaleF = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n            }\n            ~ToolHeadData() = default;\n        private:\n            void LoadACIT(std::string path);\n            glm::vec3 ParseString2GlmVector(std::string str);\n\n        private: __always_inline\n            ACToolHeadType GetType() const { return m_Type; }\n            std::string GetTypeString() const\n            {\n                if (this-&gt;GetType() == ACToolHeadType::DRILLBIT)\n                    return \"DRILLBIT\";\n                else if (this-&gt;GetType() == ACToolHeadType::CIRCULARSAW)\n                    return \"CIRCULARSAW\";\n                else if (this-&gt;GetType() == ACToolHeadType::CHAINSAW)\n                    return \"CHAINSAW\";\n                else if (this-&gt;GetType() == ACToolHeadType::SABERSAW)\n                    return \"SABERSAW\";\n                else\n                    throw std::out_of_range(\"Tool head type unknown\");\n            }\n            std::string GetName() const { return m_Name; }\n            template &lt;typename T&gt;\n            T GetData() const\n            {\n                if constexpr (std::is_same_v&lt;T, DrillBitData&gt;)\n                    return m_DrillBitD;\n                else if constexpr (std::is_same_v&lt;T, CircularSawData&gt;)\n                    return m_CircularSawD;\n                else if constexpr (std::is_same_v&lt;T, ChainSawData&gt;)\n                    return m_ChainSawD;\n                else if constexpr (std::is_same_v&lt;T, SaberSawData&gt;)\n                    return m_SaberSawD;\n            }\n\n            float GetScaleF() const { return m_ScaleF; }\n\n        public: __always_inline \n            std::string ToString() const { return m_Name;}\n\n        private:\n            float m_ScaleF = 0.0f;\n\n            ACToolHeadType m_Type;\n            std::string m_Name;\n\n            DrillBitData m_DrillBitD;\n            CircularSawData m_CircularSawD;\n            ChainSawData m_ChainSawD;\n            SaberSawData m_SaberSawD;\n\n            friend class ACInfoToolhead;\n    };\n\n    class ACInfoToolhead\n    {\n        public:\n            ACInfoToolhead() = default;\n            ACInfoToolhead(std::string acitPath, std::string meshObjPath, int id);\n\n        public: __always_inline\n            ACToolHeadType GetType() const { return m_Data.GetType(); }\n            std::string GetTypeString() const { return m_Data.GetTypeString();}\n            std::string GetName() const { return m_Data.GetName(); }\n            int GetId() const { return m_ID; }\n\n            template &lt;typename T&gt;\n            T GetData() const\n            {\n                if constexpr (std::is_same_v&lt;T, DrillBitData&gt;)\n                    return m_Data.GetData&lt;DrillBitData&gt;();\n                else if constexpr (std::is_same_v&lt;T, CircularSawData&gt;)\n                    return m_Data.GetData&lt;CircularSawData&gt;();\n                else if constexpr (std::is_same_v&lt;T, ChainSawData&gt;)\n                    return m_Data.GetData&lt;ChainSawData&gt;();\n                else if constexpr (std::is_same_v&lt;T, SaberSawData&gt;)\n                    return m_Data.GetData&lt;SaberSawData&gt;();\n            }\n\n        public:\n            void AddGOsInfo(ToolHeadData&amp; data);\n            void AddGOsInfoDrillBit(ToolHeadData&amp; data);\n            void AddGOsInfoCircularSaw(ToolHeadData&amp; data);\n            void AddGOsInfoChainSaw(ToolHeadData&amp; data);\n            void AddGOsInfoSaberSaw(ToolHeadData&amp; data);\n\n        public:\n            void SetVisibility(bool visible);\n\n        public:\n            void Transform(glm::mat4 transform);\n            void TransformGO(std::shared_ptr&lt;GOPrimitive&gt; goPtr,\n                             std::shared_ptr&lt;GOPrimitive&gt; goOriginalPtr,\n                             glm::mat4 transform);\n            void TransformSync();\n\n            void CopyGOsInfoOriginal();\n\n        public: __always_inline\n            std::string ToString() const { return m_Data.GetName(); }\n\n        private:\n            std::string m_ACITPath;\n            std::string m_OBJPath;\n            ToolHeadData m_Data;\n            int m_ID;\n\n        private:\n            std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; m_GOPrimitivesInfo;\n            std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; m_GOPrimitivesInfoOriginal;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/ACInfoToolheadManager_8cpp/","title":"File ACInfoToolheadManager.cpp","text":"<p>FileList &gt; AIAC &gt; ACInfoToolheadManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/ACInfoToolheadManager.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"utils/utils.h\"</code></li> </ul>"},{"location":"acdoxygen/ACInfoToolheadManager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolheadManager.cpp</code></p>"},{"location":"acdoxygen/ACInfoToolheadManager_8cpp_source/","title":"File ACInfoToolheadManager.cpp","text":"<p>File List &gt; AIAC &gt; ACInfoToolheadManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"AIAC/ACInfoToolheadManager.h\"\n#include \"AIAC/Config.h\"\n#include \"utils/utils.h\"\n\n\nnamespace AIAC\n{\n    void ACInfoToolheadManager::LoadToolheadModels()\n    {\n        if (!this-&gt;m_ACInfoToolheadMap.empty())\n            this-&gt;m_ACInfoToolheadMap.clear();\n\n        std::string configPath = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL,\n                                                                AIAC::Config::CONFIG_FILE,\n                                                                \"deps/TTool/assets/config.yml\");\n        std::string ttoolRootPath = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL,\n                                                                   AIAC::Config::TTOOL_ROOT_PATH,\n                                                                   \"deps/TTool/assets/toolheads\");\n        std::vector&lt;std::string&gt; toolheadACITPaths = ParseConfigFile(configPath, \"acitFiles\");\n        std::vector&lt;std::string&gt; toolheadOBJPaths = ParseConfigFile(configPath, \"modelFiles\");\n\n        for (int i = 0; i &lt; toolheadOBJPaths.size(); i++)\n        {\n            std::shared_ptr&lt;ACInfoToolhead&gt; acInfoToolhead = std::make_shared&lt;ACInfoToolhead&gt;(ttoolRootPath + \"/\" + toolheadACITPaths[i],\n                                                                                              ttoolRootPath + \"/\" + toolheadOBJPaths[i],\n                                                                                              (i+1));\n            AIAC_INFO(\"Loading toolhead model: {}\", acInfoToolhead-&gt;GetName());\n            acInfoToolhead-&gt;SetVisibility(false);\n            this-&gt;m_ACInfoToolheadMap.insert(std::make_pair(acInfoToolhead-&gt;GetName(), acInfoToolhead));\n        }\n        if (this-&gt;m_ACInfoToolheadMap.empty())\n            AIAC_ERROR(\"No toolhead models loaded!\");\n\n        // if the config has no names, set the first one as active\n        auto cachedToolhead = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::CACHED_TOOLHEAD);\n        if (cachedToolhead.empty())\n            this-&gt;SetActiveToolhead(this-&gt;m_ACInfoToolheadMap.begin()-&gt;first);\n        else\n            this-&gt;SetActiveToolhead(cachedToolhead);\n    }\n\n    void ACInfoToolheadManager::SetActiveToolhead(const std::string&amp; toolheadName)\n    {\n        this-&gt;m_ActiveACInfoToolhead-&gt;SetVisibility(false);\n        if (this-&gt;m_ACInfoToolheadMap.find(toolheadName) != this-&gt;m_ACInfoToolheadMap.end())\n        {\n            *this-&gt;m_ActiveACInfoToolhead = *this-&gt;m_ACInfoToolheadMap[toolheadName];\n            AIAC::Config::UpdateEntry(\"TTool\", \"CachedToolhead\", toolheadName);\n        }\n        else\n            AIAC_ERROR(\"Toolhead model {} not found!\", toolheadName);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/ACInfoToolheadManager_8h/","title":"File ACInfoToolheadManager.h","text":"<p>FileList &gt; AIAC &gt; ACInfoToolheadManager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/ACInfoToolhead.h\"</code></li> </ul>"},{"location":"acdoxygen/ACInfoToolheadManager_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/ACInfoToolheadManager_8h/#classes","title":"Classes","text":"Type Name class ACInfoToolheadManager <p>The documentation for this class was generated from the following file <code>src/AIAC/ACInfoToolheadManager.h</code></p>"},{"location":"acdoxygen/ACInfoToolheadManager_8h_source/","title":"File ACInfoToolheadManager.h","text":"<p>File List &gt; AIAC &gt; ACInfoToolheadManager.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/ACInfoToolhead.h\"\n\nnamespace AIAC\n{\n    class ACInfoToolheadManager\n    {\n        public:\n            ACInfoToolheadManager()\n                // : m_ActiveACInfoToolhead(nullptr)\n            {\n                m_ActiveACInfoToolhead = std::make_shared&lt;ACInfoToolhead&gt;(); \n            };\n\n        public:\n            void LoadToolheadModels();\n\n        public:\n            void SetActiveToolhead(const std::string&amp; toolheadName);\n            inline std::shared_ptr&lt;ACInfoToolhead&gt; GetActiveToolhead() const { return this-&gt;m_ActiveACInfoToolhead; }\n            inline std::shared_ptr&lt;ACInfoToolhead&gt; GetToolhead(const std::string&amp; toolheadName) const { return this-&gt;m_ACInfoToolheadMap.at(toolheadName); }\n            inline std::string GetActiveToolheadName() const { return this-&gt;m_ActiveACInfoToolhead-&gt;GetName(); }\n            inline ACToolHeadType GetToolheadType(const std::string&amp; toolheadName) const { return this-&gt;m_ACInfoToolheadMap.at(toolheadName)-&gt;GetType(); }\n            inline ACToolHeadType GetActiveToolheadType() const { return this-&gt;m_ActiveACInfoToolhead-&gt;GetType(); }\n\n\n            inline std::vector&lt;std::string&gt; GetToolheadNames() const\n            {\n                std::vector&lt;std::string&gt; toolheadNames;\n                for (auto&amp; toolhead : this-&gt;m_ACInfoToolheadMap)\n                {\n                    toolheadNames.push_back(toolhead.first);\n                }\n                return toolheadNames;\n            }\n\n        private:\n            std::map&lt;std::string, std::shared_ptr&lt;ACInfoToolhead&gt;&gt; m_ACInfoToolheadMap;\n            std::shared_ptr&lt;ACInfoToolhead&gt; m_ActiveACInfoToolhead;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Application_8cpp/","title":"File Application.cpp","text":"<p>FileList &gt; AIAC &gt; Application.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/LayerUI.h\"</code></li> </ul>"},{"location":"acdoxygen/Application_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Application.cpp</code></p>"},{"location":"acdoxygen/Application_8cpp_source/","title":"File Application.cpp","text":"<p>File List &gt; AIAC &gt; Application.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Application.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/LayerUI.h\"\n\n\nnamespace AIAC\n{\n    GLuint VertexArrayID;\n\n    Application* Application::s_Instance = nullptr;\n    Application::Application(const ApplicationSpecification&amp; appSpec)\n        : m_AppSpec(appSpec)\n    {\n        AIAC_ASSERT(!s_Instance, \"Application already exists!\");\n        s_Instance = this;\n        Init();\n    }\n\n    Application::~Application()\n    {\n        Shutdown();\n    }\n\n\n    void Application::Init()\n    {\n        m_Window = new Window(\n            WindowProps(\n                m_AppSpec.Name,\n                m_AppSpec.WinWidth,\n                m_AppSpec.WinHeight,\n                m_AppSpec.IsResizable,\n                m_AppSpec.VSync\n            ));\n\n        m_EventBus = new EventBus();\n\n        m_GORegistry = new GORegistry();\n\n        m_Renderer = new Renderer();\n    }\n\n    void Application::Run()\n    {\n        m_IsRunning = true;\n\n        while (m_Window-&gt;IsOpen())\n        {\n            if(!m_EventBus-&gt;IsEventQueueEmpty())\n                m_EventBus-&gt;ProcessQueue();\n\n            for (auto&amp; layer : m_LayerStack)\n                layer-&gt;OnFrameAwake();\n\n            for (auto&amp; layer : m_LayerStack)\n                layer-&gt;OnFrameStart(); \n\n            m_Window-&gt;OnUpdate();\n#ifndef HEADLESS_TEST\n            m_Renderer-&gt;OnRender();\n\n            GetLayer&lt;AIAC::LayerUI&gt;()-&gt;OnUIRender();\n#endif\n\n            for (auto&amp; layer : m_LayerStack)\n                layer-&gt;OnFrameEnd();\n\n            m_Window-&gt;OnBufferSwap();\n\n\n            for (auto&amp; layer : m_LayerStack)\n                layer-&gt;OnFrameFall();\n\n        }\n    }\n\n    void Application::Close()\n    {\n        m_IsRunning = false;\n        Shutdown();\n    }\n\n    void Application::Shutdown()\n    {\n        for (auto&amp; layer : m_LayerStack)\n            layer-&gt;OnDetach();\n\n        m_LayerStack.clear();\n\n        m_Window-&gt;Shutdown();\n\n        AIAC::Log::Shutdown();\n\n\n\n        exit(EXIT_SUCCESS);\n    }\n\n    // Function to capture the frame and return pixel data\n    std::vector&lt;GLubyte&gt; CaptureFramePixels(const ApplicationSpecification&amp; appSpec) {\n        // Assuming your window is m_Window and framebuffer size is known (640x480 in this case)\n        std::vector&lt;GLubyte&gt; pixels(appSpec.WinWidth * appSpec.WinHeight * 4); // Assuming RGBA\n\n        glReadPixels(0, 0, appSpec.WinWidth, appSpec.WinHeight, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());\n\n        return pixels;\n    }\n\n}\n</code></pre>"},{"location":"acdoxygen/Application_8h/","title":"File Application.h","text":"<p>FileList &gt; AIAC &gt; Application.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Camera.h\"</code></li> <li><code>#include \"AIAC/Render/Renderer.h\"</code></li> <li><code>#include \"AIAC/Assert.h\"</code></li> <li><code>#include \"AIAC/Window.h\"</code></li> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/LayerSlam.h\"</code></li> <li><code>#include \"AIAC/LayerCamera.h\"</code></li> <li><code>#include \"AIAC/LayerModel.h\"</code></li> <li><code>#include \"AIAC/LayerToolhead.h\"</code></li> <li><code>#include \"AIAC/LayerFeedback.h\"</code></li> <li><code>#include \"AIAC/EventSys/EventBus.h\"</code></li> <li><code>#include \"AIAC/GOSys/GO.h\"</code></li> </ul>"},{"location":"acdoxygen/Application_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Application_8h/#classes","title":"Classes","text":"Type Name class Application struct ApplicationSpecification"},{"location":"acdoxygen/Application_8h/#macros","title":"Macros","text":"Type Name define AIAC_APP <code>AIAC::Application::GetInstance()</code> define AIAC_EBUS <code>AIAC\\_APP.GetEventBus()</code> define AIAC_GOREG <code>AIAC\\_APP.GetGORegistry()</code>"},{"location":"acdoxygen/Application_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Application_8h/#define-aiac_app","title":"define AIAC_APP","text":"<pre><code>#define AIAC_APP `AIAC::Application::GetInstance()`\n</code></pre>"},{"location":"acdoxygen/Application_8h/#define-aiac_ebus","title":"define AIAC_EBUS","text":"<pre><code>#define AIAC_EBUS `AIAC_APP.GetEventBus()`\n</code></pre>"},{"location":"acdoxygen/Application_8h/#define-aiac_goreg","title":"define AIAC_GOREG","text":"<pre><code>#define AIAC_GOREG `AIAC_APP.GetGORegistry()`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Application.h</code></p>"},{"location":"acdoxygen/Application_8h_source/","title":"File Application.h","text":"<p>File List &gt; AIAC &gt; Application.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Camera.h\"\n#include \"AIAC/Render/Renderer.h\"\n\n#include \"AIAC/Assert.h\"\n#include \"AIAC/Window.h\"\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/LayerSlam.h\"\n#include \"AIAC/LayerCamera.h\"\n#include \"AIAC/LayerModel.h\"\n#include \"AIAC/LayerToolhead.h\"\n#include \"AIAC/LayerFeedback.h\"\n\n#include \"AIAC/EventSys/EventBus.h\"\n\n#include \"AIAC/GOSys/GO.h\"\n\nnamespace AIAC\n{\n    struct ApplicationSpecification\n        {\n            const char* Name;\n            uint32_t WinWidth;\n            uint32_t WinHeight;\n            bool IsResizable;\n            bool VSync;\n            ImVec4 WindowBackColor;\n        };\n\n    class Application\n    {\n    public:\n        Application(const ApplicationSpecification&amp; appSpec);\n        virtual ~Application();\n\n        void Run();\n        void Close();\n\n        template&lt;typename T&gt;\n        void PushLayer()\n        {\n            static_assert(std::is_base_of&lt;AIAC::Layer, T&gt;::value, \"Pushed type is not subclass of Layer!\");\n            std::shared_ptr&lt;T&gt; layer = std::make_shared&lt;T&gt;();\n            m_LayerMap[typeid(T)] = layer;\n            m_LayerStack.emplace_back(layer);\n            layer-&gt;OnAttach();\n        }\n\n        template&lt;typename T&gt;\n        std::shared_ptr&lt;T&gt; GetLayer()\n        {\n            static_assert(std::is_base_of&lt;AIAC::Layer, T&gt;::value, \"Pushed type is not subclass of Layer!\");\n            if(std::dynamic_pointer_cast&lt;T&gt;(m_LayerMap[typeid(T)]))\n            {\n                return std::dynamic_pointer_cast&lt;T&gt;(m_LayerMap[typeid(T)]);\n            }\n            AIAC_ERROR(\"Layer not found!\");\n            AIAC_BREAK();\n            return nullptr;\n        }\n\n        inline AIAC::Window*&amp; GetWindow() { return m_Window; }  //FIXME: bad practice to return reference of internal variable\n        inline Renderer*&amp; GetRenderer() { return m_Renderer; }  //FIXME: bad practice to return reference of internal variable\n        inline EventBus*&amp; GetEventBus() { return m_EventBus; }  //FIXME: bad practice to return reference of internal variable\n        inline GORegistry* GetGORegistry() { return m_GORegistry; }  //FIXME: bad practice to return reference of internal variable\n\n        inline static Application&amp; GetInstance() { return *s_Instance; }\n\n        inline const ApplicationSpecification&amp; GetSpecification() const { return m_AppSpec; }\n\n    private:\n        void Init();\n        void Shutdown();\n\n    private:\n        ApplicationSpecification m_AppSpec;\n\n        Window* m_Window;\n        EventBus* m_EventBus;\n        Renderer* m_Renderer;\n        GORegistry* m_GORegistry;\n\n        bool m_IsRunning = false;\n\n        std::vector&lt;std::shared_ptr&lt;AIAC::Layer&gt;&gt; m_LayerStack;\n        std::unordered_map&lt;std::type_index, std::shared_ptr&lt;AIAC::Layer&gt;&gt; m_LayerMap;\n\n        static Application* s_Instance;\n    };\n}\n\n#define AIAC_APP AIAC::Application::GetInstance()\n#define AIAC_EBUS AIAC_APP.GetEventBus()\n#define AIAC_GOREG AIAC_APP.GetGORegistry()\n</code></pre>"},{"location":"acdoxygen/Assert_8h/","title":"File Assert.h","text":"<p>FileList &gt; AIAC &gt; Assert.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Base.h\"</code></li> </ul>"},{"location":"acdoxygen/Assert_8h/#macros","title":"Macros","text":"Type Name define AIAC_ASSERT (...)"},{"location":"acdoxygen/Assert_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Assert_8h/#define-aiac_assert","title":"define AIAC_ASSERT","text":"<pre><code>#define AIAC_ASSERT (\n    ...\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Assert.h</code></p>"},{"location":"acdoxygen/Assert_8h_source/","title":"File Assert.h","text":"<p>File List &gt; AIAC &gt; Assert.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/Base.h\"\n\n#ifdef AIAC_ENABLE_ASSERTS\n// Alteratively we could use the same \"default\" message for both \"WITH_MSG\" and \"NO_MSG\" and\n    // provide support for custom formatting by concatenating the formatting string instead of having the format inside the default message\n    #define AIAC_INTERNAL_ASSERT_IMPL(type, check, msg, ...) { if(!(check)) { (msg, __VA_ARGS__); AIAC_BREAK(); } }\n    #define AIAC_INTERNAL_ASSERT_WITH_MSG(type, check, ...) AIAC_INTERNAL_ASSERT_IMPL(type, check, \"Assertion failed: {0}\", __VA_ARGS__)\n    #define AIAC_INTERNAL_ASSERT_NO_MSG(type, check) AIAC_INTERNAL_ASSERT_IMPL(type, check, \"Assertion '{0}' failed at {1}:{2}\", AIAC_STRINGIFY_MACRO(check), std::filesystem::path(__FILE__).filename().string(), __LINE__)\n\n    #define AIAC_INTERNAL_ASSERT_GET_MACRO_NAME(arg1, arg2, macro, ...) macro\n    #define AIAC_INTERNAL_ASSERT_GET_MACRO(...) AIAC_EXPAND_MACRO( AIAC_INTERNAL_ASSERT_GET_MACRO_NAME(__VA_ARGS__, AIAC_INTERNAL_ASSERT_WITH_MSG, AIAC_INTERNAL_ASSERT_NO_MSG) )\n\n    #define AIAC_ASSERT(...) AIAC_EXPAND_MACRO( AIAC_INTERNAL_ASSERT_GET_MACRO(__VA_ARGS__)(_, __VA_ARGS__) )\n#else\n    #define AIAC_ASSERT(...)\n#endif\n</code></pre>"},{"location":"acdoxygen/Base_8h/","title":"File Base.h","text":"<p>FileList &gt; AIAC &gt; Base.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Assert.h\"</code></li> </ul>"},{"location":"acdoxygen/Base_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Base_8h/#macros","title":"Macros","text":"Type Name define AIAC_BIND_EVENT_FN (fn) <code>[this](auto&amp;&amp;... args) -&amp;gt; decltype(auto) { return this-&amp;gt;fn(std::forward&amp;lt;decltype(args)&amp;gt;(args)...); }</code> define AIAC_EXPAND_MACRO (x) <code>x</code> define AIAC_STRINGIFY_MACRO (x) <code>#x</code> define BIT (x) <code>(1 &amp;lt;&amp;lt; x)</code>"},{"location":"acdoxygen/Base_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Base_8h/#define-aiac_bind_event_fn","title":"define AIAC_BIND_EVENT_FN","text":"<pre><code>#define AIAC_BIND_EVENT_FN (\n    fn\n) `[this](auto&amp;&amp;... args) -&gt; decltype(auto) { return this-&gt;fn(std::forward&lt;decltype(args)&gt;(args)...); }`\n</code></pre>"},{"location":"acdoxygen/Base_8h/#define-aiac_expand_macro","title":"define AIAC_EXPAND_MACRO","text":"<pre><code>#define AIAC_EXPAND_MACRO (\n    x\n) `x`\n</code></pre>"},{"location":"acdoxygen/Base_8h/#define-aiac_stringify_macro","title":"define AIAC_STRINGIFY_MACRO","text":"<pre><code>#define AIAC_STRINGIFY_MACRO (\n    x\n) `#x`\n</code></pre>"},{"location":"acdoxygen/Base_8h/#define-bit","title":"define BIT","text":"<pre><code>#define BIT (\n    x\n) `(1 &lt;&lt; x)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Base.h</code></p>"},{"location":"acdoxygen/Base_8h_source/","title":"File Base.h","text":"<p>File List &gt; AIAC &gt; Base.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#if __linux__\n    #define AIAC_BREAK() EXIT_FAILURE\n#endif\n\n#define AIAC_EXPAND_MACRO(x) x\n#define AIAC_STRINGIFY_MACRO(x) #x\n\n#define BIT(x) (1 &lt;&lt; x)\n\n#define AIAC_BIND_EVENT_FN(fn) [this](auto&amp;&amp;... args) -&gt; decltype(auto) { return this-&gt;fn(std::forward&lt;decltype(args)&gt;(args)...); }\n\nnamespace AIAC {\n\n    template&lt;typename T&gt;\n    using Scope = std::unique_ptr&lt;T&gt;;\n    template&lt;typename T, typename ... Args&gt;\n    constexpr Scope&lt;T&gt; CreateScope(Args&amp;&amp; ... args)\n    {\n        return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T&gt;\n    using Ref = std::shared_ptr&lt;T&gt;;\n    template&lt;typename T, typename ... Args&gt;\n    constexpr Ref&lt;T&gt; CreateRef(Args&amp;&amp; ... args)\n    {\n        return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n}\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/Assert.h\"\n</code></pre>"},{"location":"acdoxygen/Camera_8cpp/","title":"File Camera.cpp","text":"<p>FileList &gt; AIAC &gt; Camera.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"AIAC/Camera.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"utils/utils.h\"</code></li> <li><code>#include \"Application.h\"</code></li> </ul>"},{"location":"acdoxygen/Camera_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Camera_8cpp/#macros","title":"Macros","text":"Type Name define _USE_MATH_DEFINES"},{"location":"acdoxygen/Camera_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Camera_8cpp/#define-_use_math_defines","title":"define _USE_MATH_DEFINES","text":"<pre><code>#define _USE_MATH_DEFINES \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Camera.cpp</code></p>"},{"location":"acdoxygen/Camera_8cpp_source/","title":"File Camera.cpp","text":"<p>File List &gt; AIAC &gt; Camera.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#define _USE_MATH_DEFINES\n#include &lt;cmath&gt;\n#include &lt;stdexcept&gt;\n\n#include \"AIAC/Config.h\"\n#include \"AIAC/Camera.h\"\n#include \"AIAC/Log.h\"\n#include \"utils/utils.h\"\n#include \"Application.h\"\n\nnamespace AIAC\n{\n    Camera::Camera() {}\n\n    void Camera::Open(int id)\n    {\n#ifdef HEADLESS_TEST\n        AIAC_INFO(\"Running in headless mode, load video from \" + AIAC::Config::VIDEO_PATH);\n        std::string videoPath = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TEST, AIAC::Config::VIDEO_PATH, \"\");\n        if (videoPath.empty()) {\n            throw std::invalid_argument(\"Video path for test is empty!\");\n        }\n        if(!std::filesystem::exists(videoPath)){\n            throw std::invalid_argument(\"No video file found at \" + videoPath);\n        }\n        m_VideoCapture = cv::VideoCapture(videoPath);\n#else\n        m_VideoCapture = cv::VideoCapture(id);\n#endif\n        if(!m_VideoCapture.isOpened())\n        {\n            throw std::runtime_error(\"Camera \" + std::to_string(id) + \" can't be opened.\");\n        }\n        else\n        {\n            m_IsOpened = true;\n\n            m_PhysicalWidth = m_VideoCapture.get(cv::CAP_PROP_FRAME_WIDTH);\n            m_PhysicalHeight = m_VideoCapture.get(cv::CAP_PROP_FRAME_HEIGHT);\n\n            AIAC_INFO(\"Camera Resolution: {0}x{1}.\", m_PhysicalWidth, m_PhysicalHeight);\n        }\n\n        m_CalibFilePath = AIAC::Config::Get&lt;std::string&gt;(Config::SEC_AIAC,\n                                                         Config::CAM_PARAMS_FILE,\n                                                         \"assets/tslam/calibration_orange_A_1280_720_000B.yml\");\n        LoadCameraParams(m_CalibFilePath);\n\n        FlipHorizontal = AIAC::Config::Get&lt;bool&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_FLIP_HORIZONTAL, false);\n        FlipVertical = AIAC::Config::Get&lt;bool&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_FLIP_VERTICAL, false);\n    }\n\n    inline void Camera::UpdateFov(){\n        // Update fov at the same time\n        m_FovX = 2 * atan(m_ParamWidth / 2 / GetCameraMatrix().at&lt;float&gt;(0, 0));\n        m_FovY = 2 * atan(m_ParamHeight / 2 / GetCameraMatrix().at&lt;float&gt;(1, 1));\n    }\n\n    bool Camera::LoadCameraParams(const std::string &amp;filePath){\n        m_CalibFilePath = filePath;\n        cv::FileStorage fs(filePath, cv::FileStorage::READ);\n        if(!fs.isOpened()){\n            throw std::runtime_error(std::string(__FILE__)+\"LoadCameraParams() could not open file:\" + filePath);\n        }\n\n        fs[\"image_width\"] &gt;&gt; m_ParamWidth;\n        fs[\"image_height\"] &gt;&gt; m_ParamHeight;\n        fs[\"distortion_coefficients\"] &gt;&gt; m_DistortionCoef;\n        fs[\"camera_matrix\"] &gt;&gt; m_CameraMatrix;\n\n        m_DistortionCoef.convertTo(m_DistortionCoef, CV_32F);\n        m_CameraMatrix.convertTo(m_CameraMatrix, CV_32F);\n\n        if(m_DistortionCoef.rows == 4) {\n            m_IsFisheye = true;\n            cv::fisheye::initUndistortRectifyMap(m_CameraMatrix, m_DistortionCoef, cv::Mat(),\n                                                 m_CameraMatrix, cv::Size(m_PhysicalWidth, m_PhysicalHeight),\n                                                 CV_32FC1, m_UndistortMap[0], m_UndistortMap[1]);\n        } else {\n            cv::initUndistortRectifyMap(m_CameraMatrix, m_DistortionCoef, cv::Mat(),\n                                        m_CameraMatrix, cv::Size(m_PhysicalWidth, m_PhysicalHeight),\n                                        CV_32FC1, m_UndistortMap[0], m_UndistortMap[1]);\n        }\n\n        return true;\n    }\n\n    const AIAC::Image Camera::GetNextFrame()\n    {\n        if (!m_IsOpened) { AIAC_CRITICAL(\"Camera is not opened\"); exit(-1); }\n\n        cv::Mat frame;\n        m_VideoCapture &gt;&gt; frame;\n\n        if (frame.empty()) {\n            AIAC_APP.Close();\n        }\n\n        if (FlipHorizontal) cv::flip(frame, frame, 1);\n        if (FlipVertical) cv::flip(frame, frame, 0);\n\n        m_RawCurrentFrame = frame;\n\n        cv::Mat resizedFrame, calibratedFrame;\n        cv::remap(frame, calibratedFrame, m_UndistortMap[0], m_UndistortMap[1], cv::INTER_LINEAR);\n\n        if(!IsPhysicalAndParamWidthHeightMatched()){\n            cv::resize(calibratedFrame, resizedFrame, cv::Size(m_ParamWidth, m_ParamHeight));\n        } else {\n            calibratedFrame.copyTo(resizedFrame);\n        }\n\n        cv::Mat tempGrayMat;\n        cv::cvtColor(calibratedFrame, tempGrayMat, cv::COLOR_BGR2GRAY);\n        cv::cvtColor(tempGrayMat, tempGrayMat, cv::COLOR_GRAY2BGR);\n        m_GrayCalibratedCurrentFrame = tempGrayMat;\n        m_CalibratedCurrentFrame = calibratedFrame;\n        return m_GrayCalibratedCurrentFrame;\n    }\n\n\n    AIAC::Image &amp;Camera::GetCenterCroppedCurrentFrame(float ratioX, float ratioY){\n        cv::Mat centerCroppedFrame(m_PhysicalHeight, m_PhysicalWidth,\n                                   CV_8UC3, cv::Scalar(0, 0, 0));\n\n        int xLeft = m_PhysicalWidth * (1 - ratioX) / 2;\n        int xRight = m_PhysicalWidth - xLeft;\n        int yTop = m_PhysicalHeight * (1 - ratioY) / 2;\n        int yBottom = m_PhysicalHeight - yTop;\n\n        for (int x = 0 ; x &lt; m_PhysicalWidth ; x++) {\n            for (int y = 0 ; y &lt; m_PhysicalHeight ; y++) {\n                if (x &gt;= xLeft &amp;&amp; x &lt; xRight &amp;&amp; y &gt;= yTop &amp;&amp; y &lt; yBottom) {\n                    centerCroppedFrame.at&lt;cv::Vec3b&gt;(y, x) = m_RawCurrentFrame.GetCvMat().at&lt;cv::Vec3b&gt;(y, x);\n                }\n            }\n        }\n\n        m_CenterCroppedCurrentFrame = centerCroppedFrame;\n        return m_CenterCroppedCurrentFrame;\n    }\n\n    void Camera::UpdateCameraParamFromFile(const std::string &amp;filePath)\n    {\n        m_IsCamMatrixInit = true;\n        LoadCameraParams(filePath);\n\n        stringstream ss;\n        ss &lt;&lt; \"Camera Parameter Updated (using config file): \\n\" &lt;&lt; m_CameraMatrix;\n        AIAC_INFO(ss.str());\n    }\n\n    void Camera::UpdateCameraParamFromSlamMap(const int paramWidth, const int paramHeight, const cv::Mat &amp;cameraMatrix) {\n        m_IsCamMatrixInit = true;\n        m_ParamWidth = paramWidth;\n        m_ParamHeight = paramHeight;\n        m_CameraMatrix = cameraMatrix;\n        UpdateFov();\n\n        stringstream ss;\n        ss &lt;&lt; \"Camera Parameter Updated (using slam map): \\n\" &lt;&lt; m_CameraMatrix;\n        AIAC_INFO(ss.str());\n    }\n}\n</code></pre>"},{"location":"acdoxygen/Camera_8h/","title":"File Camera.h","text":"<p>FileList &gt; AIAC &gt; Camera.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Image.h\"</code></li> </ul>"},{"location":"acdoxygen/Camera_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Camera_8h/#classes","title":"Classes","text":"Type Name class Camera <p>The documentation for this class was generated from the following file <code>src/AIAC/Camera.h</code></p>"},{"location":"acdoxygen/Camera_8h_source/","title":"File Camera.h","text":"<p>File List &gt; AIAC &gt; Camera.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Image.h\"\n\nnamespace AIAC\n{\n    class Camera\n    {\n    public:\n        Camera();\n        ~Camera() {};\n        void Open(int id);\n\n        bool LoadCameraParams(const std::string &amp;filePath);\n\n        inline void UpdateFov();\n\n        const AIAC::Image GetNextFrame();\n\n        inline AIAC::Image &amp;GetColorCurrentFrame() { return m_CalibratedCurrentFrame; }\n        inline AIAC::Image &amp;GetCurrentFrame() { return m_GrayCalibratedCurrentFrame; }\n        inline AIAC::Image &amp;GetRawCurrentFrame() { return m_RawCurrentFrame; }\n        AIAC::Image &amp;GetCenterCroppedCurrentFrame(float ratioX = 0.6f, float ratioY = 0.75f);\n\n        inline const std::string GetCalibrationFilePath() const { return m_CalibFilePath; }\n\n        void UpdateCameraParamFromFile(const std::string &amp;filePath);\n\n        void UpdateCameraParamFromSlamMap(const int paramWidth, const int paramHeight, const cv::Mat &amp;cameraMatrix);\n\n        inline const cv::Mat GetCameraMatrix() { return m_CameraMatrix;};\n        inline const cv::Mat GetDistortionCoef() { return m_DistortionCoef; }\n\n        inline const uint32_t GetRawWidth() const {return m_PhysicalWidth; }\n\n        inline const uint32_t GetRawHeight() const {return m_PhysicalHeight; }\n\n        inline const uint32_t GetWidth() const { return m_ParamWidth; }\n\n        inline const uint32_t GetHeight() const { return m_ParamHeight; }\n\n        inline const std::pair&lt;float, float&gt; GetFov() const { return std::make_pair(m_FovX, m_FovY); }\n\n        bool IsOpened() const { return m_IsOpened; }\n\n        bool IsPhysicalAndParamWidthHeightMatched() const { return m_PhysicalWidth == m_ParamWidth &amp;&amp; m_PhysicalHeight == m_ParamHeight; }\n\n    public:\n        bool FlipHorizontal = false;\n        bool FlipVertical = false;\n\n    private:\n        bool m_IsCamMatrixInit = false;\n        bool m_IsFisheye = false;\n        std::string m_CalibFilePath;\n        cv::Mat m_CameraMatrix;\n        cv::Mat m_DistortionCoef;\n        cv::Mat m_UndistortMap[2];\n\n        int m_PhysicalWidth, m_PhysicalHeight;\n        int m_ParamWidth, m_ParamHeight;\n        float m_FovX = -1.0f, m_FovY = -1.0f;\n\n        Image m_RawCurrentFrame;\n        Image m_CenterCroppedCurrentFrame;\n        Image m_CalibratedCurrentFrame;\n        Image m_GrayCalibratedCurrentFrame;\n\n        cv::VideoCapture m_VideoCapture;\n        bool m_IsOpened = false;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/CameraCalibrator_8cpp/","title":"File CameraCalibrator.cpp","text":"<p>FileList &gt; AIAC &gt; CameraCalibrator.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CameraCalibrator.h\"</code></li> </ul>"},{"location":"acdoxygen/CameraCalibrator_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/CameraCalibrator.cpp</code></p>"},{"location":"acdoxygen/CameraCalibrator_8cpp_source/","title":"File CameraCalibrator.cpp","text":"<p>File List &gt; AIAC &gt; CameraCalibrator.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"CameraCalibrator.h\"\n\nnamespace AIAC {\nvoid CameraCalibrator::CalcBoardCornerPositions(\n    std::vector&lt;cv::Point3f&gt; &amp; corners) const {\n  corners.clear();\n\n  switch (calibrationPattern) {\n  case CameraCalibrator::CHESSBOARD:\n  case CameraCalibrator::CIRCLES_GRID:\n    for (int i = 0; i &lt; boardSize.height; ++i)\n      for (int j = 0; j &lt; boardSize.width; ++j)\n        corners.push_back(cv::Point3f(j * squareSize, i * squareSize, 0));\n    break;\n\n  case CameraCalibrator::ASYMMETRIC_CIRCLES_GRID:\n    for (int i = 0; i &lt; boardSize.height; i++)\n      for (int j = 0; j &lt; boardSize.width; j++)\n        corners.push_back(\n            cv::Point3f((2 * j + i % 2) * squareSize, i * squareSize, 0));\n    break;\n  default:\n    break;\n  }\n}\n\nbool CameraCalibrator::RunCalibration(cv::Mat * imgForDisplay) {\n  ValidateAndUpdateFlag();\n  DetectPattern(imgForDisplay);\n\n  if (imagePoints.size() &lt; 2) {\n    throw std::runtime_error(\"Not enough points to run calibration\");\n    return false; // Return after exception is useless !!\n  }\n\n  cameraMatrix = cv::Mat::eye(3, 3, CV_32F);\n  if (!useFisheye &amp;&amp; calibFlag &amp; cv::CALIB_FIX_ASPECT_RATIO)\n    cameraMatrix.at&lt;double&gt;(0, 0) = aspectRatio;\n  if (useFisheye) {\n    distCoeffs = cv::Mat::zeros(4, 1, CV_32F);\n  } else {\n    distCoeffs = cv::Mat::zeros(8, 1, CV_32F);\n  }\n\n  std::vector&lt;std::vector&lt;cv::Point3f&gt;&gt; objectPoints(1);\n  CalcBoardCornerPositions(objectPoints[0]);\n  objectPoints[0][boardSize.width - 1].x = objectPoints[0][0].x + gridWidth;\n  auto newObjPoints = objectPoints[0];\n\n  objectPoints.resize(imagePoints.size(), objectPoints[0]);\n\n  // Reprojection error\n  double rms;\n\n  if (useFisheye) {\n    cv::fisheye::calibrate(objectPoints, imagePoints, imageSize, cameraMatrix,\n                           distCoeffs, rvecs, tvecs, calibFlag);\n  } else {\n    int iFixedPoint = -1;\n    if (useFixedPoint)\n      iFixedPoint = boardSize.width - 1;\n    calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint,\n                      cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints,\n                      calibFlag | cv::CALIB_USE_LU);\n  }\n  return true;\n}\n\nvoid CameraCalibrator::ValidateAndUpdateFlag() {\n  goodInput = true;\n  if (boardSize.width &lt;= 0 || boardSize.height &lt;= 0) {\n    std::cerr &lt;&lt; \"Invalid Board size: \" &lt;&lt; boardSize.width &lt;&lt; \" \"\n              &lt;&lt; boardSize.height &lt;&lt; std::endl;\n    goodInput = false;\n  }\n  if (squareSize &lt;= 10e-6) {\n    std::cerr &lt;&lt; \"Invalid square size \" &lt;&lt; squareSize &lt;&lt; std::endl;\n    goodInput = false;\n  }\n\n  calibFlag = 0;\n\n  if (calibFixPrincipalPoint)\n    calibFlag |= cv::CALIB_FIX_PRINCIPAL_POINT;\n  if (calibZeroTangentDist)\n    calibFlag |= cv::CALIB_ZERO_TANGENT_DIST;\n  if (aspectRatio)\n    calibFlag |= cv::CALIB_FIX_ASPECT_RATIO;\n  if (fixDistortion)\n    calibFlag |= cv::CALIB_FIX_K1 | cv::CALIB_FIX_K2 | cv::CALIB_FIX_K3 |\n                 cv::CALIB_FIX_K4 | cv::CALIB_FIX_K5;\n\n  if (useFisheye) {\n    // the cv::fisheye model has its own enum, so overwrite the flags\n    calibFlag =\n        cv::fisheye::CALIB_FIX_SKEW | cv::fisheye::CALIB_RECOMPUTE_EXTRINSIC;\n    if (fixDistortion)\n      calibFlag |= cv::fisheye::CALIB_FIX_K1;\n    if (fixDistortion)\n      calibFlag |= cv::fisheye::CALIB_FIX_K2;\n    if (fixDistortion)\n      calibFlag |= cv::fisheye::CALIB_FIX_K3;\n    if (fixDistortion)\n      calibFlag |= cv::fisheye::CALIB_FIX_K4;\n    if (calibFixPrincipalPoint)\n      calibFlag |= cv::fisheye::CALIB_FIX_PRINCIPAL_POINT;\n  }\n}\n\nvoid CameraCalibrator::AddImage(const cv::Mat &amp; image) {\n  imageList.push_back(cv::Mat());\n  image.copyTo(imageList.back());\n}\n\nvoid CameraCalibrator::DetectPattern(cv::Mat * imgForDisplay) {\n  //------------------------- Camera Calibration ------------------------\n  int chessBoardFlags =\n      cv::CALIB_CB_ADAPTIVE_THRESH | cv::CALIB_CB_NORMALIZE_IMAGE;\n\n  if (!useFisheye) {\n    // fast check erroneously fails with high distortions like cv::fisheye\n    chessBoardFlags |= cv::CALIB_CB_FAST_CHECK;\n  }\n\n  for (const auto &amp; img : imageList) {\n    imageSize = img.size(); // Format input image.\n    if (flipVertical)\n      flip(img, img, 0);\n\n    std::vector&lt;cv::Point2f&gt; pointBuf;\n\n    bool found;\n\n    switch (calibrationPattern) // Find feature points on the input format\n    {\n    case Pattern::CHESSBOARD:\n      found = findChessboardCorners(img, boardSize, pointBuf, chessBoardFlags);\n      break;\n    case Pattern::CIRCLES_GRID:\n      found = findCirclesGrid(img, boardSize, pointBuf);\n      break;\n    case Pattern::ASYMMETRIC_CIRCLES_GRID:\n      found = findCirclesGrid(img, boardSize, pointBuf,\n                              cv::CALIB_CB_ASYMMETRIC_GRID);\n      break;\n    default:\n      found = false;\n      break;\n    }\n\n    if (found) // If done with success,\n    {\n      // improve the found corners' coordinate accuracy for chessboard\n      if (calibrationPattern == Pattern::CHESSBOARD) {\n        cv::Mat viewGray;\n        cvtColor(img, viewGray, cv::COLOR_BGR2GRAY);\n        cornerSubPix(\n            viewGray, pointBuf, cv::Size(winSize, winSize), cv::Size(-1, -1),\n            cv::TermCriteria(cv::TermCriteria::EPS + cv::TermCriteria::COUNT,\n                             30, 0.0001));\n      }\n\n      imagePoints.push_back(pointBuf);\n\n      // Draw the corners.\n      drawChessboardCorners(img, boardSize, cv::Mat(pointBuf), found);\n    }\n\n    if (imgForDisplay) {\n      img.copyTo(*imgForDisplay);\n    }\n  }\n}\n\nvoid CameraCalibrator::Save(const std::string &amp; filename) {\n  cv::FileStorage fs(filename, cv::FileStorage::WRITE);\n  fs &lt;&lt; \"image_width\" &lt;&lt; imageSize.width;\n  fs &lt;&lt; \"image_height\" &lt;&lt; imageSize.height;\n  cameraMatrix.convertTo(cameraMatrix, CV_32F);\n  distCoeffs.convertTo(distCoeffs, CV_32F);\n  fs &lt;&lt; \"camera_matrix\" &lt;&lt; cameraMatrix;\n  fs &lt;&lt; \"distortion_coefficients\" &lt;&lt; distCoeffs;\n  fs.release();\n}\n} // namespace AIAC\n</code></pre>"},{"location":"acdoxygen/CameraCalibrator_8h/","title":"File CameraCalibrator.h","text":"<p>FileList &gt; AIAC &gt; CameraCalibrator.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;opencv2/core.hpp&gt;</code></li> <li><code>#include &lt;opencv2/core/utility.hpp&gt;</code></li> <li><code>#include &lt;opencv2/imgproc.hpp&gt;</code></li> <li><code>#include &lt;opencv2/calib3d.hpp&gt;</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> <li><code>#include &lt;opencv2/videoio.hpp&gt;</code></li> <li><code>#include &lt;opencv2/highgui.hpp&gt;</code></li> </ul>"},{"location":"acdoxygen/CameraCalibrator_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/CameraCalibrator_8h/#classes","title":"Classes","text":"Type Name class CameraCalibrator <p>The documentation for this class was generated from the following file <code>src/AIAC/CameraCalibrator.h</code></p>"},{"location":"acdoxygen/CameraCalibrator_8h_source/","title":"File CameraCalibrator.h","text":"<p>File List &gt; AIAC &gt; CameraCalibrator.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n# pragma once\n#include &lt;iostream&gt;\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdio&gt;\n\n#include &lt;opencv2/core.hpp&gt;\n#include &lt;opencv2/core/utility.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;\n#include &lt;opencv2/calib3d.hpp&gt;\n#include &lt;opencv2/imgcodecs.hpp&gt;\n#include &lt;opencv2/videoio.hpp&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n\nnamespace AIAC{\n    class CameraCalibrator {\n    public:\n        enum Pattern { NOT_EXISTING, CHESSBOARD, CIRCLES_GRID, ASYMMETRIC_CIRCLES_GRID };\n\n        CameraCalibrator() {};\n        ~CameraCalibrator() {};\n\n        void AddImage(const cv::Mat&amp; image);\n        bool RunCalibration(cv::Mat *imgForDisplay = nullptr);\n        void Save(const std::string&amp; filename);\n        int GetImageAmount() const { return imageList.size(); }\n        void ClearImages() { imageList.clear(); imagePoints.clear(); }\n\n    private:\n        void ValidateAndUpdateFlag();\n        void DetectPattern(cv::Mat *imgForDisplay = nullptr);\n        void CalcBoardCornerPositions(std::vector&lt;cv::Point3f&gt;&amp; corners) const;\n\n    public:\n        cv::Size boardSize = cv::Size(19, 13);  // The size of the board -&gt; Number of items by width and height\n        Pattern calibrationPattern = Pattern::CHESSBOARD;   // One of the Chessboard, circles, or asymmetric circle pattern\n        float squareSize = 20.0f;                           // The size of a square in your defined unit (point, millimeter,etc).\n        float aspectRatio = 0.0f;                           // The aspect ratio, can be 0 if no need\n        bool writeExtrinsics = true;                        // Write extrinsic parameters\n        bool calibZeroTangentDist = false;                  // Assume zero tangential distortion\n        bool calibFixPrincipalPoint = false;                // Fix the principal point at the center\n        bool flipVertical = false;                          // Flip the captured images around the horizontal axis\n        bool useFisheye = false;                            // use fisheye camera model for calibration\n        bool fixDistortion = false;                         // fix K1 distortion coefficient\n\n        bool useFixedPoint = false;                           // Enable this will use different algorithm for calibration\n        float gridWidth = squareSize * (boardSize.width - 1); // The width of the board -&gt; number of items in width * squareSize\n        int winSize = 11;                                     // The size of the window capturing\n\n        // image Param\n        cv::Size imageSize;\n\n        // result\n        cv::Mat cameraMatrix;\n        cv::Mat distCoeffs;\n        cv::Mat rvecs, tvecs;\n        double totalAvgErr;\n        std::vector&lt;float&gt; reprojErrs;\n\n    private:\n        std::vector&lt;cv::Mat&gt; imageList;\n        bool goodInput;\n        int calibFlag;\n\n        std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; imagePoints;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Config_8cpp/","title":"File Config.cpp","text":"<p>FileList &gt; AIAC &gt; Config.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> </ul>"},{"location":"acdoxygen/Config_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Config.cpp</code></p>"},{"location":"acdoxygen/Config_8cpp_source/","title":"File Config.cpp","text":"<p>File List &gt; AIAC &gt; Config.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Config.h\"\n\nnamespace AIAC\n{\nConfig* Config::s_Instance = nullptr;\n}\n</code></pre>"},{"location":"acdoxygen/Config_8h/","title":"File Config.h","text":"<p>FileList &gt; AIAC &gt; Config.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Assert.h\"</code></li> <li><code>#include \"utils/Ini.h\"</code></li> </ul>"},{"location":"acdoxygen/Config_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Config_8h/#classes","title":"Classes","text":"Type Name class Config <p>The documentation for this class was generated from the following file <code>src/AIAC/Config.h</code></p>"},{"location":"acdoxygen/Config_8h_source/","title":"File Config.h","text":"<p>File List &gt; AIAC &gt; Config.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n#include &lt;string&gt;\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/Assert.h\"\n\n#include \"utils/Ini.h\"\n\nnamespace AIAC{\nclass Config\n{\npublic:\n    //-------------------------------------------------------\n    inline static const std::string SEC_AIAC = \"AIAC\";\n\n    inline static const std::string CAM_ID = \"CamID\";\n    inline static const std::string CAM_PARAMS_FILE = \"CamParamsFile\";\n    inline static const std::string CAM_FLIP_HORIZONTAL = \"CamFlipHorizontal\";\n    inline static const std::string CAM_FLIP_VERTICAL = \"CamFlipVertical\";\n    inline static const std::string AC_INFO_MODEL = \"ACInfoModel\";\n    inline static const std::string SCANNED_MODEL = \"ScannedModel\";\n    inline static const std::string ALIGN_OFFSET = \"AlignOffset\";\n    inline static const std::string ALIGN_ROTATION = \"AlignRotation\";\n    inline static const std::string ALIGN_FLIP = \"AlignFlip\";\n    inline static const std::string SCALE_FACTOR = \"ScaleFactor\";\n\n    //-------------------------------------------------------\n    inline static const std::string SEC_TSLAM = \"TSlam\";\n\n    inline static const std::string MAP_FILE = \"MapFile\";\n    inline static const std::string VocFile = \"VocFile\";\n    inline static const std::string RECONSTRUCT_CONFIG_DEFAULT_FILE = \"ReconstructConfigDefaultFile\";\n    inline static const std::string SAVE_DIR_MAPS = \"SaveDirMaps\";\n    inline static const std::string STABILIZATION_FRAME_COUNT = \"SaveDirMaps\";\n\n    //-------------------------------------------------------\n    inline static const std::string SEC_TTOOL = \"TTool\";\n\n    inline static const std::string CONFIG_FILE = \"ConfigFile\";\n    inline static const std::string DATASET_DIR = \"DatasetDir\";\n    inline static const std::string TTOOL_ROOT_PATH = \"TToolRootPath\";\n    inline static const std::string CACHED_TOOLHEAD = \"CachedToolhead\";\n\n    //-------------------------------------------------------\n    inline static const std::string SEC_TOUCH_MONITOR_SPECS = \"TouchMonitorSpecs\";\n\n    inline static const std::string NAME = \"Name\";\n    inline static const std::string LINK_MODE = \"LinkMode\";\n    inline static const std::string RESOLUTION = \"Resolution\";\n\n\n    //-------------------------------------------------------\n    inline static const std::string SEC_UTILS = \"Utils\";\n\n    inline static const std::string UTILS_PATH = \"UtilsPath\";\n\n    //-------------------------------------------------------\n    inline static const std::string SEC_TEST = \"Test\";\n\n    inline static const std::string VIDEO_PATH = \"VideoPath\";\n\npublic:\n    Config(std::string filename, bool updateFile=true):\n        m_Filename(filename),\n        m_UpdateFile(updateFile)\n    {\n        AIAC_ASSERT(!s_Instance, \"Config already exists!\");\n        s_Instance = this;\n\n        m_IniReader = inih::INIReader(m_Filename);\n    }\n\n    template &lt;typename T&gt;\n    inline static T Get(const std::string&amp; section, const std::string&amp; name)\n    {\n        AIAC_ASSERT(s_Instance, \"Config not initialized!\");\n        try {\n            return s_Instance-&gt;m_IniReader.Get&lt;T&gt;(section, name);\n        } catch (std::runtime_error&amp; e) {\n            AIAC_ERROR(\"Failed to get value from config: {0}\", e.what());\n            return nullptr;\n        }\n    }\n\n    template &lt;typename T&gt;\n    inline static T Get(const std::string&amp; section, const std::string&amp; name, T&amp;&amp; default_v)\n    {\n        AIAC_ASSERT(s_Instance, \"Config not initialized!\");\n        try {\n            return s_Instance-&gt;m_IniReader.Get&lt;T&gt;(section, name);\n        } catch (std::runtime_error&amp; e) {\n            s_Instance-&gt;m_IniReader.InsertEntry(section, name, default_v);\n            if(s_Instance-&gt;m_UpdateFile) s_Instance-&gt;WriteToFile();\n            return default_v;\n        }\n    }\n\n    template &lt;typename T&gt;\n    inline static std::vector&lt;T&gt; GetVector(const std::string&amp; section,\n                             const std::string&amp; name,\n                             const std::vector&lt;T&gt;&amp; default_v)\n    {\n        AIAC_ASSERT(s_Instance, \"Config not initialized!\");\n        try {\n            return s_Instance-&gt;m_IniReader.GetVector&lt;T&gt;(section, name);\n        } catch (std::runtime_error&amp; e) {\n            s_Instance-&gt;m_IniReader.InsertEntry(section, name, default_v);\n            if(s_Instance-&gt;m_UpdateFile) s_Instance-&gt;WriteToFile();\n            return default_v;\n        }\n    }\n\n    template &lt;typename T = std::string&gt;\n    inline static void InsertEntry(const std::string&amp; section, const std::string&amp; name, const T&amp; v)\n    {\n        AIAC_ASSERT(s_Instance != NULL, \"Config not initialized!\");\n        AIAC_INFO(\"Insert config value: [{}] {} = {}\", section, name, v);\n        s_Instance-&gt;m_IniReader.InsertEntry(section, name, v);\n        if(s_Instance-&gt;m_UpdateFile) s_Instance-&gt;WriteToFile();\n    };\n\n    template &lt;typename T = std::string&gt;\n    inline static void InsertEntry(const std::string&amp; section, const std::string&amp; name, const std::vector&lt;T&gt;&amp; vs)\n    {\n        AIAC_ASSERT(s_Instance != NULL, \"Config not initialized!\");\n        AIAC_INFO(\"Insert config value: [{}] {} = {}...\", section, name, vs[0]);\n        s_Instance-&gt;m_IniReader.InsertEntry(section, name, vs);\n        if(s_Instance-&gt;m_UpdateFile) s_Instance-&gt;WriteToFile();\n    };\n\n    template &lt;typename T = std::string&gt;\n    inline static void UpdateEntry(const std::string&amp; section, const std::string&amp; name, const T&amp; v)\n    {\n        AIAC_ASSERT(s_Instance != NULL, \"Config not initialized!\");\n        AIAC_INFO(\"Update config value: [{}] {} = {}\", section, name, v);\n        s_Instance-&gt;m_IniReader.UpdateEntry(section, name, v);\n        if(s_Instance-&gt;m_UpdateFile) s_Instance-&gt;WriteToFile();\n    }\n\n    template &lt;typename T = std::string&gt;\n    inline static void UpdateEntry(const std::string&amp; section, const std::string&amp; name,\n                     const std::vector&lt;T&gt;&amp; vs)\n    {\n        AIAC_ASSERT(s_Instance, \"Config not initialized!\");\n        AIAC_INFO(\"Update config value: [{}] {} = {}...\", section, name, vs[0]);\n        s_Instance-&gt;m_IniReader.UpdateEntry(section, name, vs);\n        if(s_Instance-&gt;m_UpdateFile) s_Instance-&gt;WriteToFile();\n    };\n\n    inline static void WriteToFile(std::string writeFilename=\"\")\n    {\n        if(writeFilename.empty()) writeFilename = s_Instance-&gt;m_Filename;\n        inih::INIWriter::write(writeFilename, s_Instance-&gt;m_IniReader);\n    };\n\nprivate:\n    inih::INIReader m_IniReader;\n    std::string m_Filename;\n    bool m_UpdateFile = true;\n\n    static Config* s_Instance;\n};\n}\n</code></pre>"},{"location":"acdoxygen/DLoader_8cpp/","title":"File DLoader.cpp","text":"<p>FileList &gt; AIAC &gt; DLoader.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/DLoader.h\"</code></li> </ul>"},{"location":"acdoxygen/DLoader_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/DLoader_8cpp/#macros","title":"Macros","text":"Type Name define ASSIMP_LOAD_FLAGS <code>(aiProcess\\_Triangulate \\| aiProcess\\_GenSmoothNormals \\| aiProcess\\_FlipUVs \\| aiProcess\\_CalcTangentSpace)</code>"},{"location":"acdoxygen/DLoader_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/DLoader_8cpp/#define-assimp_load_flags","title":"define ASSIMP_LOAD_FLAGS","text":"<pre><code>#define ASSIMP_LOAD_FLAGS `(aiProcess_Triangulate | aiProcess_GenSmoothNormals | aiProcess_FlipUVs | aiProcess_CalcTangentSpace)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/DLoader.cpp</code></p>"},{"location":"acdoxygen/DLoader_8cpp_source/","title":"File DLoader.cpp","text":"<p>File List &gt; AIAC &gt; DLoader.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/DLoader.h\"\n\n#define ASSIMP_LOAD_FLAGS (aiProcess_Triangulate | aiProcess_GenSmoothNormals | aiProcess_FlipUVs | aiProcess_CalcTangentSpace)\n\nnamespace AIAC\n{\n    bool DLoader::LoadGOMesh(const char* path, GOMesh&amp; goMesh)\n    {\n        Assimp::Importer importer;\n        const aiScene* scene = importer.ReadFile(path, ASSIMP_LOAD_FLAGS);\n        if (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)\n        {\n            AIAC_ERROR(\"Assimp failed to load {0}\", importer.GetErrorString());\n            return false;\n        }\n        const aiMesh* mesh = scene-&gt;mMeshes[0];\n        unsigned int numVerticecs = mesh-&gt;mNumVertices;\n\n        CvtAssimpMeshToGOMesh(mesh, goMesh);\n\n        return true;\n    }\n\n    bool DLoader::CvtAssimpMeshToGOMesh(const aiMesh* mesh, GOMesh&amp; goMesh)\n    {\n        std::vector&lt;glm::vec3&gt; glmVertices;\n        CvtAssimpMeshVerticesToGlmVector(mesh, glmVertices);\n        goMesh.SetVertices(glmVertices);\n\n        std::vector&lt;uint32_t&gt; glmIndices;\n        CvtAssimpMeshFacesToGlmVector(mesh, glmIndices);\n        goMesh.SetIndices(glmIndices);\n\n        std::vector&lt;glm::vec3&gt; glmNormals;\n        CvtAssimpMeshNormalsToGlmVector(mesh, glmNormals);\n        goMesh.SetNormals(glmNormals);\n\n        return true;\n    }\n\n    void DLoader::CvtAssimpMeshVerticesToGlmVector(const aiMesh* mesh, std::vector&lt;glm::vec3&gt;&amp; glmVertices)\n    {\n        unsigned int numVerticecs = mesh-&gt;mNumVertices;\n        for (unsigned int i = 0; i &lt; numVerticecs; i++)\n        {\n            glm::vec3 vertex;\n            vertex.x = mesh-&gt;mVertices[i].x;\n            vertex.y = mesh-&gt;mVertices[i].y;\n            vertex.z = mesh-&gt;mVertices[i].z;\n            glmVertices.push_back(vertex);\n        }\n    }\n\n    void DLoader::CvtAssimpMeshFacesToGlmVector(const aiMesh* mesh, std::vector&lt;uint32_t&gt;&amp; glmIndices)\n    {\n        unsigned int numFaces = mesh-&gt;mNumFaces;\n        for (unsigned int i = 0; i &lt; numFaces; i++)\n        {\n            glmIndices.push_back(static_cast&lt;uint32_t&gt;(mesh-&gt;mFaces[i].mIndices[0]));\n            glmIndices.push_back(static_cast&lt;uint32_t&gt;(mesh-&gt;mFaces[i].mIndices[1]));\n            glmIndices.push_back(static_cast&lt;uint32_t&gt;(mesh-&gt;mFaces[i].mIndices[2]));\n        }\n    }\n\n    void DLoader::CvtAssimpMeshNormalsToGlmVector(const aiMesh* mesh, std::vector&lt;glm::vec3&gt;&amp; glmNormals)\n    {\n        unsigned int numNormals = mesh-&gt;mNumVertices;\n        for (unsigned int i = 0; i &lt; numNormals; i++)\n        {\n            glm::vec3 normal = glm::vec3(mesh-&gt;mNormals[i].x,\n                                            mesh-&gt;mNormals[i].y,\n                                            mesh-&gt;mNormals[i].z);\n            glmNormals.push_back(normal);\n        }\n    }\n\n    void DLoader::CvtAssimpMeshColorsToGlmVector(const aiMesh* mesh, std::vector&lt;glm::vec3&gt;&amp; glmColors)\n    {\n        unsigned int numColors = mesh-&gt;mNumVertices;\n        for (unsigned int i = 0; i &lt; numColors; i++)\n        {\n            glm::vec3 color = glm::vec3(mesh-&gt;mColors[i]-&gt;r,\n                                        mesh-&gt;mColors[i]-&gt;g,\n                                        mesh-&gt;mColors[i]-&gt;b);\n            glmColors.push_back(color);\n        }\n    }\n}\n</code></pre>"},{"location":"acdoxygen/DLoader_8h/","title":"File DLoader.h","text":"<p>FileList &gt; AIAC &gt; DLoader.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GOSys/GO.h\"</code></li> <li><code>#include \"assimp/Importer.hpp\"</code></li> <li><code>#include \"assimp/scene.h\"</code></li> <li><code>#include \"assimp/postprocess.h\"</code></li> </ul>"},{"location":"acdoxygen/DLoader_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/DLoader_8h/#classes","title":"Classes","text":"Type Name class DLoader <p>The documentation for this class was generated from the following file <code>src/AIAC/DLoader.h</code></p>"},{"location":"acdoxygen/DLoader_8h_source/","title":"File DLoader.h","text":"<p>File List &gt; AIAC &gt; DLoader.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/GOSys/GO.h\"\n\n#include \"assimp/Importer.hpp\"      // C++ importer interface\n#include \"assimp/scene.h\"           // Output data structure\n#include \"assimp/postprocess.h\"     // Post processing flags\n\n\nnamespace AIAC\n{\n    class DLoader\n    {\n    public:\n        DLoader() = default;\n        ~DLoader() = default;\n\n        bool LoadGOMesh(const char* path, GOMesh&amp; goMesh);\n\n        bool CvtAssimpMeshToGOMesh(const aiMesh* mesh, GOMesh&amp; goMesh);\n\n        void CvtAssimpMeshVerticesToGlmVector(const aiMesh* mesh, std::vector&lt;glm::vec3&gt;&amp; glmVertices);\n        void CvtAssimpMeshFacesToGlmVector(const aiMesh* mesh, std::vector&lt;uint32_t&gt;&amp; glmIndices);\n        void CvtAssimpMeshNormalsToGlmVector(const aiMesh* mesh, std::vector&lt;glm::vec3&gt;&amp; glmNormals);\n        void CvtAssimpMeshColorsToGlmVector(const aiMesh* mesh, std::vector&lt;glm::vec3&gt;&amp; glmColors);\n    };\n}\n</code></pre>"},{"location":"acdoxygen/GeometryUtils_8cpp/","title":"File GeometryUtils.cpp","text":"<p>FileList &gt; AIAC &gt; GeometryUtils.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GeometryUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/GeometryUtils_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/GeometryUtils.cpp</code></p>"},{"location":"acdoxygen/GeometryUtils_8cpp_source/","title":"File GeometryUtils.cpp","text":"<p>File List &gt; AIAC &gt; GeometryUtils.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"GeometryUtils.h\"\n\nnamespace AIAC{\n    glm::mat3x3 GetRotationMatrix(glm::vec3 axis, float theta){\n        // normalize axis\n        axis = glm::normalize(axis);\n\n        float a = cos(theta / 2.0f);\n        float b = -axis.x * sin(theta / 2.0f);\n        float c = -axis.y * sin(theta / 2.0f);\n        float d = -axis.z * sin(theta / 2.0f);\n        float aa = a * a;\n        float bb = b * b;\n        float cc = c * c;\n        float dd = d * d;\n        float bc = b * c;\n        float ad = a * d;\n        float ac = a * c;\n        float ab = a * b;\n        float bd = b * d;\n        float cd = c * d;\n\n        glm::mat3x3 mat;\n        mat[0][0] = aa + bb - cc - dd;\n        mat[0][1] = 2 * (bc + ad);\n        mat[0][2] = 2 * (bd - ac);\n        mat[1][0] = 2 * (bc - ad);\n        mat[1][1] = aa + cc - bb - dd;\n        mat[1][2] = 2 * (cd + ab);\n        mat[2][0] = 2 * (bd + ac);\n        mat[2][1] = 2 * (cd - ab);\n        mat[2][2] = aa + dd - bb - cc;\n\n        return mat;\n    }\n\n    glm::mat4x4 GetTranslationMatrix(glm::vec3 translationVector)\n    {\n        return glm::mat4x4(\n            1, 0, 0, translationVector.x,\n            0, 1, 0, translationVector.y,\n            0, 0, 1, translationVector.z,\n            0, 0, 0, 1\n        );\n    }\n\n    glm::mat4x4 GetRigidTransformationMatrix(std::vector&lt;glm::vec3&gt; srcPts, std::vector&lt;glm::vec3&gt; dstPts) {\n        glm::mat4x4 rigidTransformMatrix = glm::mat4x4(1.0f);\n\n        // find mean column wise\n        glm::vec3 centroidSrc = glm::vec3(0.0f);\n        glm::vec3 centroidDst = glm::vec3(0.0f);\n        for (int i = 0; i &lt; srcPts.size(); i++) {\n            centroidSrc += srcPts[i];\n            centroidDst += dstPts[i];\n        }\n        centroidSrc /= srcPts.size();\n        centroidDst /= dstPts.size();\n\n        // subtract mean\n        std::vector&lt;glm::vec3&gt; srcPtsM = srcPts;\n        std::vector&lt;glm::vec3&gt; dstPtsM = dstPts;\n        for (int i = 0; i &lt; srcPts.size(); i++) {\n            srcPtsM[i] -= centroidSrc;\n            dstPtsM[i] -= centroidDst;\n        }\n\n        // find H\n        glm::mat3x3 H = glm::mat3x3(0.0f);\n        for (int i = 0; i &lt; srcPts.size(); i++) {\n            H += glm::outerProduct(srcPtsM[i], dstPtsM[i]);\n        }\n\n        // convert H to opencv for SVD\n        H = glm::transpose(H);\n        cv::Mat cvH = cv::Mat(3, 3, CV_32FC1);\n        for (int i = 0; i &lt; 3; i++) {\n            cvH.at&lt;float&gt;(i, 0) = H[i][0];\n            cvH.at&lt;float&gt;(i, 1) = H[i][1];\n            cvH.at&lt;float&gt;(i, 2) = H[i][2];\n        }\n\n        // find rotation\n        cv::Mat cvU, cvVt, cvS;\n        cv::SVD::compute(cvH, cvS, cvU, cvVt);\n\n        // convert back to glm\n        glm::mat3x3 U = glm::mat3x3(0.0f);\n        glm::mat3x3 Vt = glm::mat3x3(0.0f);\n        for (int i = 0; i &lt; 3; i++) {\n            U[i][0] = cvU.at&lt;float&gt;(i, 0);\n            U[i][1] = cvU.at&lt;float&gt;(i, 1);\n            U[i][2] = cvU.at&lt;float&gt;(i, 2);\n            Vt[i][0] = cvVt.at&lt;float&gt;(i, 0);\n            Vt[i][1] = cvVt.at&lt;float&gt;(i, 1);\n            Vt[i][2] = cvVt.at&lt;float&gt;(i, 2);\n        }\n//        Since we are using opencv, we don't need to transpose\n//        U = glm::transpose(U);\n//        Vt = glm::transpose(Vt);\n\n        glm::mat3x3 R = Vt * U;\n\n        // special reflection case\n        if (glm::determinant(R) &lt; 0) {\n            Vt[2] *= -1;\n            R = Vt * U;\n        }\n\n        glm::vec3 t = -R * centroidSrc + centroidDst;\n\n        rigidTransformMatrix = glm::mat4x4(R);\n        rigidTransformMatrix[3] = glm::vec4(t, 1.0f);\n\n        return rigidTransformMatrix;\n    }\n\n}\n</code></pre>"},{"location":"acdoxygen/AIAC_2GeometryUtils_8h/","title":"File GeometryUtils.h","text":"<p>FileList &gt; AIAC &gt; GeometryUtils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"acdoxygen/AIAC_2GeometryUtils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/GeometryUtils.h</code></p>"},{"location":"acdoxygen/AIAC_2GeometryUtils_8h_source/","title":"File GeometryUtils.h","text":"<p>File List &gt; AIAC &gt; GeometryUtils.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n# pragma once\n# include &lt;glm/glm.hpp&gt;\n\nnamespace AIAC{\n    glm::mat3x3 GetRotationMatrix(glm::vec3 axis, float theta);\n\n    glm::mat4x4 GetTranslationMatrix(glm::vec3 translationVector);\n\n    glm::mat4x4 GetRigidTransformationMatrix(std::vector&lt;glm::vec3&gt; srcPts, std::vector&lt;glm::vec3&gt; dstPts);\n}\n</code></pre>"},{"location":"acdoxygen/GlHeader_8h/","title":"File GlHeader.h","text":"<p>FileList &gt; AIAC &gt; GlHeader.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GL/freeglut.h&gt;</code></li> <li><code>#include &lt;GL/glut.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include \"imgui.h\"</code></li> <li><code>#include \"backends/imgui_impl_glfw.h\"</code></li> <li><code>#include \"backends/imgui_impl_opengl3.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/AIAC/GlHeader.h</code></p>"},{"location":"acdoxygen/GlHeader_8h_source/","title":"File GlHeader.h","text":"<p>File List &gt; AIAC &gt; GlHeader.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n// TODO: put this in the precompiled aiacpch.h file (?)\n\n// &lt;GL/glew.h&gt; has to be included before &lt;GLFW/glfw3.h&gt;\n#include &lt;GL/glew.h&gt;\n\n#include &lt;GL/freeglut.h&gt;\n#include &lt;GL/glut.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n\n#include \"glm/glm.hpp\"\n\n#include \"imgui.h\"\n\n#include \"backends/imgui_impl_glfw.h\"\n#include \"backends/imgui_impl_opengl3.h\"\n</code></pre>"},{"location":"acdoxygen/Image_8cpp/","title":"File Image.cpp","text":"<p>FileList &gt; AIAC &gt; Image.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"stb/stb_image.h\"</code></li> <li><code>#include \"stb/stb_image_write.h\"</code></li> </ul>"},{"location":"acdoxygen/Image_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Image.cpp</code></p>"},{"location":"acdoxygen/Image_8cpp_source/","title":"File Image.cpp","text":"<p>File List &gt; AIAC &gt; Image.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Image.h\"\n\n#include \"stb/stb_image.h\"\n#include \"stb/stb_image_write.h\"\n\nnamespace AIAC\n{\n    Image::Image() {}\n    Image::Image(cv::Mat cvImg) { UpdateData(cvImg); }\n    Image::Image(AIAC::Image &amp;img) { UpdateData(img.m_CvMat); }\n    Image::Image(const char *path, int cvImReadFlag) {\n        cv::Mat cvImg = cv::imread(path, cvImReadFlag);\n        UpdateData(cvImg);\n    }\n\n    Image::~Image() { DeleteGlTexture(); }\n\n    void Image::UpdateData(cv::Mat cvImg)\n    {\n        cvImg.copyTo(m_CvMat);\n        cvImg.copyTo(m_PureCvMat);\n\n        switch (cvImg.channels())\n        {\n        case 1:\n            m_Format = ImageFormat::GRAYSCALE; break;\n        case 3:\n            cv::cvtColor(m_CvMat, m_CvMat, cv::COLOR_BGR2RGB);\n            m_Format = ImageFormat::RGB; break;\n        case 4:\n            cv::cvtColor(m_CvMat, m_CvMat, cv::COLOR_BGRA2RGBA);\n            m_Format = ImageFormat::RGBA; break;\n        default:\n            m_Format = ImageFormat::None; break;\n        }\n\n        m_DataUpdatedAfterGenImTexture = true;\n        m_DataUpdatedAfterGenGlTexture = true;\n\n        DeleteGlTexture();\n    }\n\n\n    GLuint Image::GetGlTextureObj()\n    {\n        if(!HasGlTextureObj() || m_DataUpdatedAfterGenGlTexture){\n            UpdateGlTextureObj();\n        }\n        return m_GlTextureObj;\n    }\n\n    ImTexture Image::GetImTexture(ImVec2 size){\n        if(!HasImTexture() || m_DataUpdatedAfterGenImTexture){\n            UpdateGlTextureObj();\n            UpdateImTexture();\n        }\n        if(size.x != 0 &amp;&amp; size.y != 0)\n            SetImTextureSize(size);\n\n        return m_ImTexture;\n    }\n\n    void Image::UpdateGlTextureObj(){\n        if(m_CvMat.empty()) { AIAC_ERROR(\"Image's cv::Mat is empty!\"); return ; }\n\n        GLint glInternalFormat;\n        switch(m_Format){\n        case ImageFormat::GRAYSCALE:\n            glInternalFormat = GL_LUMINANCE; break;\n        case ImageFormat::RGB:\n            glInternalFormat = GL_RGB; break;\n        case ImageFormat::RGBA:\n            glInternalFormat = GL_RGBA; break;\n        default:\n            glInternalFormat = GL_RGB; break;\n        }\n        CvtCvMat2GlTextureObj(m_CvMat, m_GlTextureObj, glInternalFormat);\n        m_DataUpdatedAfterGenGlTexture = false;\n    }\n\n    void Image::UpdateImTexture(){\n        if(m_CvMat.empty()) { AIAC_ERROR(\"Image's cv::Mat is empty!\"); return ; }\n        UpdateGlTextureObj();\n        CvtGlTextureObj2ImTexture(m_GlTextureObj, m_ImTexture);\n        m_DataUpdatedAfterGenImTexture = false;\n    }\n\n    // &gt;&gt;Operator for cv video reading API\n    void operator&gt;&gt;(cv::VideoCapture cap, AIAC::Image &amp;img)\n    {\n        cv::Mat cvImg;\n        cap &gt;&gt; cvImg;\n        img.UpdateData(cvImg);\n    }\n\n    // Utilities functions\n    void CvtGlTextureObj2ImTexture(GLuint glTextureObj, ImTexture&amp; imTexture, ImVec2 size)\n    {\n        imTexture.ID = (void*)(intptr_t)glTextureObj;\n        imTexture.Size = size;\n    }\n\n    void CvtCvMat2GlTextureObj(cv::Mat&amp; cvMat, GLuint&amp; glTextureObj, GLint glInternalFormat)\n    {\n        if(cvMat.empty()) { AIAC_ERROR(\"cvMat empty\"); return; }\n        else\n        {\n            if(glTextureObj != 0) { glDeleteTextures(1, &amp;glTextureObj); }\n            cv::Mat flippedCvMat;\n            cv::flip(cvMat, flippedCvMat, 0);  // OpenGL flip images by default?\n            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n            glGenTextures(1, &amp;glTextureObj);\n            glBindTexture(GL_TEXTURE_2D, glTextureObj);\n\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);\n\n            glTexImage2D(GL_TEXTURE_2D,\n                         0,\n                         glInternalFormat,\n                         flippedCvMat.cols,\n                         flippedCvMat.rows,\n                         0,\n                         glInternalFormat,\n                         GL_UNSIGNED_BYTE,\n                         flippedCvMat.ptr());\n        }\n    }\n\n    void CvtCvMat2ImTexture(cv::Mat&amp; cvMat, ImTexture&amp; imTexture, GLuint &amp;glTextureObj, GLint glInternalFormat)\n    {\n        CvtCvMat2GlTextureObj(cvMat, glTextureObj, glInternalFormat);\n        CvtGlTextureObj2ImTexture(glTextureObj, imTexture);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/Image_8h/","title":"File Image.h","text":"<p>FileList &gt; AIAC &gt; Image.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"GlHeader.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> </ul>"},{"location":"acdoxygen/Image_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Image_8h/#classes","title":"Classes","text":"Type Name struct ImTexture Structure representing an ImGui texture. class Image Class representing the main iamge object for AC. <p>The documentation for this class was generated from the following file <code>src/AIAC/Image.h</code></p>"},{"location":"acdoxygen/Image_8h_source/","title":"File Image.h","text":"<p>File List &gt; AIAC &gt; Image.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;utility&gt;\n\n#include \"GlHeader.h\"\n#include \"AIAC/Log.h\"\n\nnamespace AIAC\n{\n    enum class ImageFormat\n    {\n        None = 0,\n        RGB,\n        RGBA,\n        GRAYSCALE\n    };\n\n    struct ImTexture\n    {\n        ImTextureID ID; \n        ImVec2 Size;    \n    };\n\n    class Image\n    {\n    public:\n        Image();\n\n        Image(cv::Mat cvImg);\n\n        Image(AIAC::Image &amp;img);\n\n        Image(const char *path, int cvImReadFlag = cv::IMREAD_UNCHANGED);\n\n        ~Image();\n\n        void UpdateData(cv::Mat cvImg);\n\n        void Resize(int newWidth, int newHeight) { cv::resize(m_CvMat, m_CvMat, cv::Size(newWidth, newHeight)); }\n\n        // General Getters\n\n        inline bool HasGlTextureObj() { return m_GlTextureObj != 0; }\n\n        inline bool HasImTexture() { return m_ImTexture.Size.x != 0 || m_ImTexture.Size.y != 0; }\n\n        inline std::string_view GetPath() const { return m_Path; }\n\n        inline int GetWidth() const { return m_CvMat.rows ; }\n\n        inline int GetHeight() const { return m_CvMat.cols; }\n\n        inline const cv::Mat GetCvMat() const { cv::cvtColor(m_CvMat, m_CvMat, cv::COLOR_RGB2BGR); return m_CvMat; }\n\n        inline const cv::Mat GetPureCvMat() const { return m_PureCvMat; }\n\n        // Image Getter of different types and corresponding helpers\n\n        ImTexture GetImTexture(ImVec2 size = ImVec2(0, 0));\n\n        GLuint GetGlTextureObj();\n\n        void UpdateImTexture();\n\n        void UpdateGlTextureObj();\n\n        inline void SetImTextureSize(ImVec2 size) { m_ImTexture.Size = size; }\n\n        inline void DeleteGlTexture() { glDeleteTextures(1, &amp;m_GlTextureObj); m_GlTextureObj = 0;}\n\n        inline void ReplaceCvMat(cv::Mat cvMat) { m_CvMat = cvMat; }\n\n        Image&amp; operator=(cv::Mat cvImg){ UpdateData(std::move(cvImg)); return *this; }\n\n    private:\n        const char* m_Path; \n\n        cv::Mat m_CvMat = cv::Mat(); \n        cv::Mat m_PureCvMat = cv::Mat(); \n        GLuint m_GlTextureObj = 0; \n        ImTexture m_ImTexture = { 0, ImVec2(0, 0) }; \n\n        ImageFormat m_Format = ImageFormat::None; \n\n        bool m_DataUpdatedAfterGenImTexture, m_DataUpdatedAfterGenGlTexture; \n\n    friend void operator&gt;&gt;(cv::VideoCapture cap, AIAC::Image &amp;img);\n    };\n\n    // Utility functions\n\n    void CvtCvMat2GlTextureObj(cv::Mat&amp; cvMat, GLuint&amp; glTextureObj, GLint glInternalFormat = GL_RGB);\n\n    void CvtGlTextureObj2ImTexture(GLuint glTextureID, ImTexture&amp; imTexture, ImVec2 size = ImVec2(0, 0));\n\n    void CvtCvMat2ImTexture(cv::Mat&amp; cvMat, ImTexture&amp; imTexture, GLuint &amp;glTextureObj, GLint glInternalFormat);\n\n}\n</code></pre>"},{"location":"acdoxygen/Layer_8h/","title":"File Layer.h","text":"<p>FileList &gt; AIAC &gt; Layer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Log.h\"</code></li> </ul>"},{"location":"acdoxygen/Layer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Layer_8h/#classes","title":"Classes","text":"Type Name class Layer <p>The documentation for this class was generated from the following file <code>src/AIAC/Layer.h</code></p>"},{"location":"acdoxygen/Layer_8h_source/","title":"File Layer.h","text":"<p>File List &gt; AIAC &gt; Layer.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Log.h\"\n\nnamespace AIAC\n{\n    class Layer\n    {\n    public:\n        virtual ~Layer() = default;\n\n        virtual void OnAttach() {}\n\n        virtual void OnFrameAwake() {}\n\n        virtual void OnFrameStart() {}\n\n        virtual void OnFrameEnd() {}\n\n        virtual void OnFrameFall() {}\n\n        virtual void OnDetach() {}\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerCamera_8cpp/","title":"File LayerCamera.cpp","text":"<p>FileList &gt; AIAC &gt; LayerCamera.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/LayerCamera.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"utils/glob.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerCamera_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerCamera.cpp</code></p>"},{"location":"acdoxygen/LayerCamera_8cpp_source/","title":"File LayerCamera.cpp","text":"<p>File List &gt; AIAC &gt; LayerCamera.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/LayerCamera.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Application.h\"\n#include \"AIAC/Config.h\"\n#include \"utils/glob.h\"\n\nnamespace AIAC\n{\n    void LayerCamera::OnAttach()\n    {\n        try\n        {\n            if(UpdateAvailableDevices()){\n                m_CurrentDeviceIndex = AIAC::Config::Get&lt;int&gt;(\"AIAC\", \"CamID\", 0);\n                SetCurrentDeviceIndex(m_CurrentDeviceIndex);\n            } else {\n                throw std::runtime_error(\"No camera found, connect a camera\");\n            }\n        }\n        catch(const std::runtime_error&amp; e)\n        {\n            AIAC_ERROR(e.what());\n            AIAC::Application::GetInstance().Close();\n        }\n    }\n\n    void LayerCamera::OnFrameStart()\n    {\n        MainCamera.GetNextFrame();\n    }\n\n    void LayerCamera::SetCurrentDevice(std::string path) {\n        auto it = std::find(AvailableDevices.begin(), AvailableDevices.end(), path);\n        if (it != AvailableDevices.end()) {\n            int prevDeviceIdx = m_CurrentDeviceIndex;\n            m_CurrentDeviceIndex = std::distance(AvailableDevices.begin(), it);\n            try {\n                MainCamera.Open(m_CurrentDeviceIndex);\n                AIAC::Config::UpdateEntry(\"AIAC\", \"CamID\", m_CurrentDeviceIndex);\n            } catch (const std::runtime_error&amp; e) {\n                m_CurrentDeviceIndex = prevDeviceIdx;\n                MainCamera.Open(m_CurrentDeviceIndex);\n                AIAC_ERROR(e.what() + std::string(\" Revert to previous device\"));\n            }\n        } else {\n            AIAC_ERROR(\"Device {} not found\", path);\n        }\n    }\n\n    void LayerCamera::SetCurrentDeviceIndex(int index) {\n#ifdef HEADLESS_TEST\n        MainCamera.Open(0);\n#else\n        try {\n            if (index &gt;= 0 &amp;&amp; index &lt; AvailableDevices.size()) {\n                MainCamera.Open(index);\n                m_CurrentDeviceIndex = index;\n            } else {\n                AIAC_ERROR(\"Camera device index {} out of range (0~{})\", index, AvailableDevices.size() - 1);\n                MainCamera.Open(0);\n                m_CurrentDeviceIndex = 0;\n            }\n            AIAC::Config::UpdateEntry(\"AIAC\", \"CamID\", m_CurrentDeviceIndex);\n        } catch (const std::runtime_error &amp;e) {\n            AIAC_ERROR(e.what());\n        }\n#endif\n    }\n\n    bool LayerCamera::UpdateAvailableDevices(){\n#ifdef HEADLESS_TEST\n        return true;\n#endif\n        AvailableDevices.clear();\n        glob::glob glob(\"/dev/video*\");\n        while(glob){\n            AvailableDevices.push_back(glob.current_match());\n            glob.next();\n        }\n        if(AvailableDevices.empty()){\n            AIAC_ERROR(\"No camera device found\");\n            return false;\n        }\n        sort(AvailableDevices.begin(), AvailableDevices.end());\n        return true;\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerCamera_8h/","title":"File LayerCamera.h","text":"<p>FileList &gt; AIAC &gt; LayerCamera.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"AIAC/Camera.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerCamera_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerCamera_8h/#classes","title":"Classes","text":"Type Name class LayerCamera <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerCamera.h</code></p>"},{"location":"acdoxygen/LayerCamera_8h_source/","title":"File LayerCamera.h","text":"<p>File List &gt; AIAC &gt; LayerCamera.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/Image.h\"\n#include \"AIAC/Camera.h\"\n\nnamespace AIAC\n{\n    class LayerCamera : public AIAC::Layer\n    {\n    public:\n        LayerCamera() = default;\n        virtual ~LayerCamera() = default;\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n        inline std::string GetCurrentDevice() const { return AvailableDevices[m_CurrentDeviceIndex]; }\n        inline int GetCurrentDeviceIndex() const { return m_CurrentDeviceIndex; }\n        void SetCurrentDevice(std::string path);\n        void SetCurrentDeviceIndex(int index);\n\n        bool UpdateAvailableDevices();\n\n    public:\n        std::vector&lt;std::string&gt; AvailableDevices;\n        AIAC::Camera MainCamera;\n\n    private:\n        int m_CurrentDeviceIndex = 0;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerCameraCalib_8cpp/","title":"File LayerCameraCalib.cpp","text":"<p>FileList &gt; AIAC &gt; LayerCameraCalib.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LayerCameraCalib.h\"</code></li> <li><code>#include \"Application.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerCameraCalib.cpp</code></p>"},{"location":"acdoxygen/LayerCameraCalib_8cpp_source/","title":"File LayerCameraCalib.cpp","text":"<p>File List &gt; AIAC &gt; LayerCameraCalib.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"LayerCameraCalib.h\"\n#include \"Application.h\"\n\nvoid AIAC::LayerCameraCalib::OnAttach() {\n    // nothing to do here\n}\n\nvoid AIAC::LayerCameraCalib::OnFrameStart() {\n    if (!m_IsCalibrating) {\n        return;\n    }\n\n    std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();\n    JustCaptured = false;\n    if (AutoCapture &amp;&amp; m_IsCapturing &amp;&amp; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - prevCaptureTimestamp).count() &gt; Delay) {\n        cv::Mat currentFrame;\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetRawCurrentFrame().GetCvMat().copyTo(currentFrame);\n        m_CameraCalibrator.AddImage(currentFrame);\n\n        prevCaptureTimestamp = now;\n        JustCaptured = true;\n        AIAC_INFO(\"Captured frame: {0} / {1}\", m_CameraCalibrator.GetImageAmount(), NumOfFrame);\n    }\n\n    if(m_CameraCalibrator.GetImageAmount() &gt;= NumOfFrame) {\n        try {\n            if(m_CameraCalibrator.RunCalibration()){\n                m_CameraCalibrator.Save(SaveFilename);\n                AIAC_INFO(\"Calibration finished, file is saved to {0}\", SaveFilename);\n            }\n        } catch (std::exception const&amp; err){\n            AIAC_ERROR(err.what());\n        }\n        m_IsCapturing = false;\n        m_CameraCalibrator.ClearImages();\n    }\n}\n\nvoid AIAC::LayerCameraCalib::StartCalibration() {\n    AIAC_INFO(\"Starting calibration\");\n    m_IsCalibrating = true;\n    Clear();\n}\n\nvoid AIAC::LayerCameraCalib::Clear() {\n    m_CameraCalibrator.ClearImages();\n    prevCaptureTimestamp = std::chrono::steady_clock::now();\n}\n</code></pre>"},{"location":"acdoxygen/LayerCameraCalib_8h/","title":"File LayerCameraCalib.h","text":"<p>FileList &gt; AIAC &gt; LayerCameraCalib.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"AIAC/Camera.h\"</code></li> <li><code>#include \"CameraCalibrator.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerCameraCalib_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerCameraCalib_8h/#classes","title":"Classes","text":"Type Name class LayerCameraCalib <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerCameraCalib.h</code></p>"},{"location":"acdoxygen/LayerCameraCalib_8h_source/","title":"File LayerCameraCalib.h","text":"<p>File List &gt; AIAC &gt; LayerCameraCalib.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/Image.h\"\n#include \"AIAC/Camera.h\"\n#include \"CameraCalibrator.h\"\n\nnamespace AIAC\n{\n    class LayerCameraCalib : public AIAC::Layer\n    {\n    public:\n        LayerCameraCalib() = default;\n        ~LayerCameraCalib() override = default;\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n        void Clear();\n        void StartCalibration();\n        void StopCalibration() { m_IsCalibrating = false;};\n        bool IsCalibrating() const { return m_IsCalibrating; }\n        void StartCapturing() { Clear(); m_IsCapturing = true; }\n        bool IsCapturing() const { return m_IsCapturing; }\n        void SetSaveFilename(const std::string&amp; filename) { SaveFilename = filename; }\n        CameraCalibrator &amp;GetCameraCalibrator() { return m_CameraCalibrator; }\n\n    public:\n        bool AutoCapture = true;\n        bool JustCaptured = false;\n        int Delay = 1500;\n        int NumOfFrame = 100;\n        std::string SaveFilename = \"assets/tslam/calibration.yml\";\n\n    private:\n        CameraCalibrator m_CameraCalibrator;\n        bool m_IsCalibrating = false;\n        bool m_IsCapturing = false;\n        std::chrono::steady_clock::time_point prevCaptureTimestamp = std::chrono::steady_clock::now();\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerFeedback_8cpp/","title":"File LayerFeedback.cpp","text":"<p>FileList &gt; AIAC &gt; LayerFeedback.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/LayerFeedback.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Feedback/FabFeedback.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerFeedback_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerFeedback.cpp</code></p>"},{"location":"acdoxygen/LayerFeedback_8cpp_source/","title":"File LayerFeedback.cpp","text":"<p>File List &gt; AIAC &gt; LayerFeedback.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Application.h\"\n#include \"AIAC/LayerFeedback.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Feedback/FabFeedback.h\"\n\nnamespace AIAC\n{\n    LayerFeedback::LayerFeedback() {}\n\n    void LayerFeedback::OnAttach()\n    {\n    }\n    void LayerFeedback::OnFrameStart()\n    {\n        if(m_CurrentFabFeedbackPtr != nullptr) m_CurrentFabFeedbackPtr-&gt;Deactivate();\n        if(AC_FF_COMP == nullptr) {\n            m_CurrentFabFeedbackPtr = nullptr;\n            return;\n        }\n\n        if (AC_FF_TOOL-&gt;GetTypeString() == \"DRILLBIT\"){\n            if (AC_FF_COMP-&gt;GetTypeString() == \"HOLE\") {\n                m_CurrentFabFeedbackPtr = &amp;m_HoleFeedback;\n            } else {\n                m_CurrentFabFeedbackPtr = nullptr;\n            }\n        }\n        else if (AC_FF_TOOL-&gt;GetTypeString() == \"CIRCULARSAW\"){\n            if (AC_FF_COMP-&gt;GetTypeString() == \"CUT\") {\n                m_CurrentFabFeedbackPtr = &amp;m_CutCircularSawFeedback;\n            } else {\n                m_CurrentFabFeedbackPtr = nullptr;\n            }\n        }\n        else if (AC_FF_TOOL-&gt;GetTypeString() == \"SABERSAW\"){\n            if (AC_FF_COMP-&gt;GetTypeString() == \"CUT\") {\n                // TODO\n            } else {\n                m_CurrentFabFeedbackPtr = nullptr;\n            }\n        }\n        else if (AC_FF_TOOL-&gt;GetTypeString() == \"CHAINSAW\"){\n            if (AC_FF_COMP-&gt;GetTypeString() == \"CUT\") {\n                m_CurrentFabFeedbackPtr = &amp;m_CutChainSawFeedback;\n            } else {\n                m_CurrentFabFeedbackPtr = nullptr;\n            }\n        }\n        else{\n            m_CurrentFabFeedbackPtr = nullptr;\n            AIAC_WARN(\"no matching tool and component found\");\n        }\n\n        if(m_CurrentFabFeedbackPtr != nullptr)\n        {\n            if (m_IsCurrentFabFeedbackVisible)\n            {\n                m_CurrentFabFeedbackPtr-&gt;Activate();\n                m_CurrentFabFeedbackPtr-&gt;Update();\n            }\n            else\n                m_CurrentFabFeedbackPtr-&gt;Deactivate();\n        }\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerFeedback_8h/","title":"File LayerFeedback.h","text":"<p>FileList &gt; AIAC &gt; LayerFeedback.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/ACInfoToolheadManager.h\"</code></li> <li><code>#include \"AIAC/ACInfoToolhead.h\"</code></li> <li><code>#include \"AIAC/ACInfoModel.h\"</code></li> <li><code>#include \"AIAC/Feedback/CutChainSawFeedback.h\"</code></li> <li><code>#include \"AIAC/Feedback/CutCircularSawFeedback.h\"</code></li> <li><code>#include \"AIAC/Feedback/HoleFeedback.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerFeedback_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerFeedback_8h/#classes","title":"Classes","text":"Type Name class LayerFeedback <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerFeedback.h</code></p>"},{"location":"acdoxygen/LayerFeedback_8h_source/","title":"File LayerFeedback.h","text":"<p>File List &gt; AIAC &gt; LayerFeedback.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/ACInfoToolheadManager.h\"\n#include \"AIAC/ACInfoToolhead.h\"\n#include \"AIAC/ACInfoModel.h\"\n#include \"AIAC/Feedback/CutChainSawFeedback.h\"\n#include \"AIAC/Feedback/CutCircularSawFeedback.h\"\n#include \"AIAC/Feedback/HoleFeedback.h\"\n\nnamespace AIAC\n{\n    class LayerFeedback : public AIAC::Layer\n    {\n    public:\n        LayerFeedback();\n        virtual ~LayerFeedback() = default;\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n    public:\n        bool ToShowCutPlane = false;\n        void EnableCutPlane(bool enable)\n        {\n            ToShowCutPlane = enable;\n            m_CutChainSawFeedback.EnableCutPlane(enable);\n            m_CutCircularSawFeedback.EnableCutPlane(enable);\n        };\n\n        inline void DeactivateCurrentFeedbackVisibility() { m_IsCurrentFabFeedbackVisible = false; }\n        inline void ActivateCurrentFeedbackVisibility() { m_IsCurrentFabFeedbackVisible = true; }\n\n        FabFeedback* GetCurrentFabFeedback() { return m_CurrentFabFeedbackPtr; };\n\n    private:\n        HoleFeedback m_HoleFeedback;\n        CutChainSawFeedback m_CutChainSawFeedback;\n        CutCircularSawFeedback m_CutCircularSawFeedback;\n\n        FabFeedback* m_CurrentFabFeedbackPtr = nullptr;\n        bool m_IsCurrentFabFeedbackVisible = true;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerLogRecorder_8cpp/","title":"File LayerLogRecorder.cpp","text":"<p>FileList &gt; AIAC &gt; LayerLogRecorder.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LayerLogRecorder.h\"</code></li> <li><code>#include \"Application.h\"</code></li> <li><code>#include \"utils/MatrixUtils.h\"</code></li> <li><code>#include \"utils/utils.h\"</code></li> <li><code>#include \"utils/SystemUtils.h\"</code></li> <li><code>#include \"LayerUtils.h\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerLogRecorder.cpp</code></p>"},{"location":"acdoxygen/LayerLogRecorder_8cpp_source/","title":"File LayerLogRecorder.cpp","text":"<p>File List &gt; AIAC &gt; LayerLogRecorder.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"LayerLogRecorder.h\"\n#include \"Application.h\"\n#include \"utils/MatrixUtils.h\"\n#include \"utils/utils.h\"\n#include \"utils/SystemUtils.h\"\n#include \"LayerUtils.h\"\n\n#include &lt;utility&gt;\n\nvoid AIAC::LayerLogRecorder::OnAttach() {\n#ifdef HEADLESS_TEST\n    StartRecording();\n#endif\n}\n\nvoid AIAC::LayerLogRecorder::OnFrameStart() {\n    if (!m_IsRecording || m_IsPaused) return;\n\n    bool isTracked = AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;IsTracked();\n\n    m_LogFile &lt;&lt; \"#\" &lt;&lt; m_FrameCount &lt;&lt; \" \" &lt;&lt; GetCurrentTimestamp() &lt;&lt; std::endl;\n    if (isTracked) LogSlamStatus();\n    LogTToolHead();\n    if (isTracked) LogTToolPose();\n    LogACIM();\n    m_FrameCount++;\n}\n\nvoid AIAC::LayerLogRecorder::StartRecording(std::string logRootFolderPath) {\n    if (m_IsRecording) {\n        AIAC_WARN(\"Already recording, stop the current recording first.\");\n        return;\n    }\n\n    // The default log file path will be './temp/log_recorders/&lt;logName&gt;/log.txt'\n    // Where &lt;logName&gt; is the &lt;acim_model_name&gt;_&lt;current_date_time&gt;\n\n    std::string acimModelName = GetFileNameFromPath(AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModelPath(), false);\n    std::string currentDateTime = GetCurrentDateTime();\n#ifdef HEADLESS_TEST\n    const std::string logName = acimModelName;\n#else\n    std::string logName = acimModelName + \"_\" + currentDateTime;\n#endif\n\n    if (logRootFolderPath.empty()) {\n        logRootFolderPath = AIAC_APP.GetLayer&lt;AIAC::LayerUtils&gt;()-&gt;GetSaveFolderPath();\n        if (logRootFolderPath.empty()) {\n            logRootFolderPath = \"./temp/\";\n        }\n        if (logRootFolderPath.back() != '/') {\n            logRootFolderPath += \"/\";\n        }\n        logRootFolderPath += \"log_recorders/\";\n    }\n    if (logRootFolderPath.back() != '/') {\n        logRootFolderPath += \"/\";\n    }\n\n    m_LogFolderPath = logRootFolderPath + logName;\n\n    // create the directory if not exist\n    if (!std::filesystem::exists(m_LogFolderPath)) {\n        std::filesystem::create_directories(m_LogFolderPath);\n    }\n\n    // copy the dependency files to the log folder\n    std::string acimModelPath = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModelPath();\n    std::string scannedModelPath = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetScannedModelPath();\n    std::string ttoolModelPath = AIAC::Config::Get&lt;std::string&gt;(\n            AIAC::Config::SEC_TTOOL, AIAC::Config::CONFIG_FILE, \"deps/TTool/assets/config.yml\");\n    CopyFile(acimModelPath, m_LogFolderPath + \"/AC_info_model.acim\");\n    CopyFile(scannedModelPath, m_LogFolderPath + \"/scanned_model.ply\");\n\n    // start recording\n    m_LogFilePath = m_LogFolderPath + \"/log.txt\";\n\n    AIAC_INFO(\"Start recording log to: {}\", m_LogFilePath);\n    m_IsRecording = true;\n    m_LogFile.open(m_LogFilePath, std::ios::out);\n    m_FrameCount = 0;\n\n    LogHeader();\n    m_LogFile &lt;&lt; \"[Content]\" &lt;&lt; std::endl;\n}\n\nvoid AIAC::LayerLogRecorder::StopRecording() {\n    if (!m_IsRecording) return;\n\n    m_IsRecording = false;\n    m_LogFile &lt;&lt; \"[End]\" &lt;&lt; std::endl;\n    m_LogFile.close();\n    AIAC_INFO(\"Stop recording log to: {}\", m_LogFilePath);\n\n    // compress to a zip file\n    AIAC_INFO(\"Compressing the log folder...\");\n    std::string zipPath = m_LogFolderPath + \".zip\";\n    std::string cmd = \"zip -r -j \" + zipPath + \" \" + m_LogFolderPath;\n    AIAC_INFO(\"Run zip Command: {}\", cmd);\n    ExecuteSystemCommand(cmd.c_str());\n    AIAC_INFO(\"Compressed log folder to: {}\", zipPath);\n\n    // remove the original log folder\n    AIAC_INFO(\"Removing the log folder...\");\n    cmd = \"rm -rf \" + m_LogFolderPath;\n    ExecuteSystemCommand(cmd.c_str());\n\n    AIAC_INFO(\"Done!\");\n}\n\nvoid AIAC::LayerLogRecorder::PauseRecording() {\n    m_IsPaused = true;\n    m_LogFile &lt;&lt; \"Pause\" &lt;&lt; std::endl;\n}\n\nvoid AIAC::LayerLogRecorder::ResumeRecording() {\n    m_IsPaused = false;\n    InitACIMStatus();\n    InitTToolStatus();\n}\nvoid AIAC::LayerLogRecorder::LogHeader() {\n    // get the latest version of the TTool files on Zenodo\n    std::string cmd = \"curl -Ls -o /dev/null -w %{url_effective} https://zenodo.org/doi/10.5281/zenodo.7956930\";\n    std::string ttoolZenodoVersion = ExecuteSystemCommand(cmd.c_str());\n\n\n    m_LogFile &lt;&lt; \"[Header]\" &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"Created Time: \" &lt;&lt; GetCurrentTimestamp() &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"AC Info Model path: \" &lt;&lt; AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModelPath() &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"Scanned Model path: \" &lt;&lt; AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetScannedModelPath() &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"TTool Zenodo Version: \" &lt;&lt; ttoolZenodoVersion &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; std::endl;\n\n    m_LogFile &lt;&lt; \"[Legend]\" &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"SLAM &lt;t.x&gt; &lt;t.y&gt; &lt;t.z&gt; &lt;q.x&gt; &lt;q.y&gt; &lt;q.z&gt; &lt;q.w&gt;                    // SLAM Camera Pose\"         &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"TTool-head &lt;toolhead_name&gt;                                        // TTool Head Changed\"       &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"TTool-pose &lt;status&gt; &lt;t.x&gt; &lt;t.y&gt; &lt;t.z&gt; &lt;q.x&gt; &lt;q.y&gt; &lt;q.z&gt; &lt;q.w&gt;     // TTool Pose\"               &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"ACIM-activate-component &lt;component_id&gt;                            // ACIM Activated Component\" &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"ACIM-component-status &lt;component_id&gt; &lt;status&gt;                     // ACIM Component Status\"    &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"ACIM-transform &lt;t.x&gt; &lt;t.y&gt; &lt;t.z&gt; &lt;q.x&gt; &lt;q.y&gt; &lt;q.z&gt; &lt;q.w&gt;          // ACIM Transformation\"      &lt;&lt; std::endl;\n    m_LogFile &lt;&lt; \"Pause                                                             // Paused by user\"           &lt;&lt; std::endl;\n\n    m_LogFile &lt;&lt; std::endl;\n\n    m_LogFile &lt;&lt; \"[Init]\" &lt;&lt; std::endl;\n    InitACIMStatus();\n    InitTToolStatus();\n    m_LogFile &lt;&lt; std::endl;\n}\n\nvoid AIAC::LayerLogRecorder::LogSlamStatus() {\n    bool isTracked = AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;IsTracked();\n\n    if (!isTracked) {\n        return;\n    }\n\n    // get pose\n    cv::Vec4f quaternion;\n    cv::Vec3f tvec;\n    AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;GetCamPoseQuaternionAndTvec(quaternion, tvec);\n\n    // pose[x, y, z] = (0, 0, 0) and quaternion[x, y, z, w]\n    m_LogFile &lt;&lt; \"SLAM \" &lt;&lt; tvec[0] &lt;&lt; \" \" &lt;&lt; tvec[1] &lt;&lt; \" \" &lt;&lt; tvec[2] &lt;&lt; \" \"\n              &lt;&lt; quaternion[0] &lt;&lt; \" \" &lt;&lt; quaternion[1] &lt;&lt; \" \" &lt;&lt; quaternion[2] &lt;&lt; \" \" &lt;&lt; quaternion[3] &lt;&lt; endl;\n}\n\nvoid AIAC::LayerLogRecorder::LogTToolHead() {\n    std::string toolheadName = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;GetName();\n    if (m_TToolPreviousToolheadName.empty() || (!toolheadName.empty() &amp;&amp; toolheadName != m_TToolPreviousToolheadName)) {\n        m_LogFile &lt;&lt; \"TTool-head \" &lt;&lt; toolheadName &lt;&lt; endl;\n        m_TToolPreviousToolheadName = toolheadName;\n    }\n}\n\nvoid AIAC::LayerLogRecorder::LogTToolPose() {\n    // position\n    std::string status;\n\n    auto ttoolState = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;GetTtoolState();\n    switch (ttoolState) {\n        case ttool::EventType::Tracking:\n            status = \"Tracking\";\n            break;\n        case ttool::EventType::PoseInput:\n            status = \"PoseInput\";\n            break;\n        default:\n            status = \"None\";\n            break;\n    }\n\n    LogTToolTransformation(status);\n}\n\nvoid AIAC::LayerLogRecorder::InitTToolStatus() {\n    m_TToolPreviousToolheadName = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;GetName();\n    m_LogFile &lt;&lt; \"TTool-head \" &lt;&lt; m_TToolPreviousToolheadName &lt;&lt; endl;\n    LogTToolPose();\n}\n\nvoid AIAC::LayerLogRecorder::LogTToolTransformation(const std::string&amp; status){\n    // Get the relative pose to the camera\n    cv::Mat ttoolPose(4, 4, CV_32F);\n    cv::Vec3f tvec;\n    cv::Vec4f qvec;\n    auto ttoolPoseGlm = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;GetWorldPose();\n    CvtGlmMat2CvMat(ttoolPoseGlm, ttoolPose);\n    ConvertTransMatToTvecAndQvec(ttoolPose, tvec, qvec);\n\n    m_LogFile &lt;&lt; \"TTool-pose \" &lt;&lt; status &lt;&lt; \" \" &lt;&lt; tvec[0] &lt;&lt; \" \" &lt;&lt; tvec[1] &lt;&lt; \" \" &lt;&lt; tvec[2] &lt;&lt; \" \"\n              &lt;&lt; qvec[0] &lt;&lt; \" \" &lt;&lt; qvec[1] &lt;&lt; \" \" &lt;&lt; qvec[2] &lt;&lt; \" \" &lt;&lt; qvec[3] &lt;&lt; endl;\n}\n\n\n\nvoid AIAC::LayerLogRecorder::LogACIM() {\n    // if activated component changed\n    std::string componentID = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponentID();\n    if (m_ACIMPreviousActivatedComponentID.empty() || (!componentID.empty() &amp;&amp; componentID != m_ACIMPreviousActivatedComponentID)) {\n        m_LogFile &lt;&lt; \"ACIM-activate-component \" &lt;&lt; componentID &lt;&lt; endl;\n        m_ACIMPreviousActivatedComponentID = componentID;\n\n        m_IsActivatedComponentDone = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetComponent(componentID)-&gt;IsMarkedDone;\n    }\n\n    // if activated is activated done / not done\n    bool isActivatedComponentDone = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()-&gt;IsMarkedDone;\n    if (m_IsActivatedComponentDone != isActivatedComponentDone) {\n        m_LogFile &lt;&lt; \"ACIM-component-status \" &lt;&lt; AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponentID() &lt;&lt; \" \"\n                  &lt;&lt; (isActivatedComponentDone ? \"Done\" : \"NotDone\") &lt;&lt; endl;\n        m_IsActivatedComponentDone = isActivatedComponentDone;\n    }\n\n    // if transformation changed\n    float offset = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignOffset();\n    int rotation = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignRotation();\n    bool flip = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignFlip();\n    if (m_ACIMOffset != offset || m_ACIMRotation != rotation || m_ACIMFlip != flip) {\n        m_ACIMOffset = offset;\n        m_ACIMRotation = rotation;\n        m_ACIMFlip = flip;\n\n        LogACIMTransformation();\n    }\n\n}\n\nvoid AIAC::LayerLogRecorder::InitACIMStatus() {\n    // init variables storing the state\n    m_ACIMComponentStatus.clear();\n\n    m_ACIMPreviousActivatedComponentID = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponentID();\n    m_LogFile &lt;&lt; \"ACIM-activate-component \" &lt;&lt; m_ACIMPreviousActivatedComponentID &lt;&lt; endl;\n\n    auto allComponentIDs = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetAllComponentsIDs();\n    for (const auto &amp;componentID : allComponentIDs) {\n        bool isDone = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetComponent(componentID)-&gt;IsMarkedDone;\n        m_ACIMComponentStatus[componentID] = isDone;\n        m_LogFile &lt;&lt; \"ACIM-component-status \" &lt;&lt; componentID &lt;&lt; \" \" &lt;&lt; (isDone ? \"Done\" : \"NotDone\") &lt;&lt; endl;\n    }\n\n    m_ACIMOffset = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignOffset();\n    m_ACIMRotation = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignRotation();\n    m_ACIMFlip = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignFlip();\n\n    LogACIMTransformation();\n}\n\nvoid AIAC::LayerLogRecorder::LogACIMTransformation() {\n    glm::mat4x4 transformMat = AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetTransformMat();\n    cv::Mat transformMatCv;\n    CvtGlmMat2CvMat(transformMat, transformMatCv);\n    cv::Vec3f tvec;\n    cv::Vec4f qvec;\n    ConvertTransMatToTvecAndQvec(transformMatCv, tvec, qvec);\n    m_LogFile &lt;&lt; \"ACIM-transform \" &lt;&lt; tvec[0] &lt;&lt; \" \" &lt;&lt; tvec[1] &lt;&lt; \" \" &lt;&lt; tvec[2] &lt;&lt; \" \"\n              &lt;&lt; qvec[0] &lt;&lt; \" \" &lt;&lt; qvec[1] &lt;&lt; \" \" &lt;&lt; qvec[2] &lt;&lt; \" \" &lt;&lt; qvec[3] &lt;&lt; endl;\n}\n</code></pre>"},{"location":"acdoxygen/LayerLogRecorder_8h/","title":"File LayerLogRecorder.h","text":"<p>FileList &gt; AIAC &gt; LayerLogRecorder.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"Layer.h\"</code></li> <li><code>#include \"spdlog/sinks/basic_file_sink.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerLogRecorder_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerLogRecorder_8h/#classes","title":"Classes","text":"Type Name class LayerLogRecorder <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerLogRecorder.h</code></p>"},{"location":"acdoxygen/LayerLogRecorder_8h_source/","title":"File LayerLogRecorder.h","text":"<p>File List &gt; AIAC &gt; LayerLogRecorder.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;fstream&gt;\n#include \"Layer.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n\nnamespace AIAC\n{\n    class LayerLogRecorder : public AIAC::Layer\n    {\n    public:\n        LayerLogRecorder() = default;\n        virtual ~LayerLogRecorder() = default;\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n    public:\n        void StartRecording(std::string logRootFolderPath = \"\");\n\n        void StopRecording();\n\n        void PauseRecording();\n\n        void ResumeRecording();\n\n        bool IsRecording() const { return m_IsRecording; }\n\n         bool IsPaused() const { return m_IsPaused; }\n    private:\n        void LogHeader();\n\n        void LogSlamStatus();\n\n        void LogTToolHead();\n\n        void LogTToolPose();\n\n        void InitTToolStatus();\n\n        void LogTToolTransformation(const std::string&amp; status);\n\n        void LogACIM();\n\n        void InitACIMStatus();\n\n        void LogACIMTransformation();\n\n\n    private:\n        bool m_IsRecording = false;\n        bool m_IsPaused = false;\n        std::string m_LogFolderPath;\n        std::string m_LogFilePath;\n        std::ofstream m_LogFile;\n        int m_FrameCount = 0;\n\n        // variables for TTool\n        std::set&lt;std::string&gt; m_TToolStatusToLog = {\n            \"PoseInput\",\n            \"Tracking\",\n        };\n        std::string m_TToolPreviousToolheadName;\n\n        // variables for ACInfoModel\n        std::string m_ACIMPreviousActivatedComponentID;\n        bool m_IsActivatedComponentDone = false;\n        double m_ACIMOffset = INFINITY;\n        int m_ACIMRotation = INT_MAX;\n        bool m_ACIMFlip = false;\n        std::unordered_map&lt;std::string, bool&gt; m_ACIMComponentStatus;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerModel_8cpp/","title":"File LayerModel.cpp","text":"<p>FileList &gt; AIAC &gt; LayerModel.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"Config.h\"</code></li> <li><code>#include \"AIAC/LayerModel.h\"</code></li> <li><code>#include \"AIAC/GOSys/GO.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/DLoader.h\"</code></li> <li><code>#include \"GeometryUtils.h\"</code></li> <li><code>#include \"glm/gtx/string_cast.hpp\"</code></li> </ul>"},{"location":"acdoxygen/LayerModel_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerModel.cpp</code></p>"},{"location":"acdoxygen/LayerModel_8cpp_source/","title":"File LayerModel.cpp","text":"<p>File List &gt; AIAC &gt; LayerModel.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"Config.h\"\n#include \"AIAC/LayerModel.h\"\n#include \"AIAC/GOSys/GO.h\"\n#include \"AIAC/Application.h\"\n#include \"AIAC/DLoader.h\"\n#include \"GeometryUtils.h\"\n#include \"glm/gtx/string_cast.hpp\"\n\n//TODO: add the 3D model importer\n\nnamespace AIAC\n{\n    LayerModel::LayerModel() {}\n\n    void LayerModel::OnAttach()\n    {\n        m_ACInfoModelPath = AIAC::Config::Get&lt;std::string&gt;(\n                AIAC::Config::SEC_AIAC,\n                AIAC::Config::AC_INFO_MODEL,\n                \"assets/ACModel/test.acim\");\n        m_ScannedModelPath = AIAC::Config::Get&lt;std::string&gt;(\n                AIAC::Config::SEC_AIAC,\n                AIAC::Config::SCANNED_MODEL,\n                \"assets/ACModel/28_scanned_model.ply\");\n        m_AlignOffset = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::ALIGN_OFFSET, 0.0f);\n        m_AlignRotation = AIAC::Config::Get&lt;int&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::ALIGN_ROTATION, 0);\n        m_AlignFlip = AIAC::Config::Get&lt;bool&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::ALIGN_FLIP, false);\n\n        bool acimLoaded = m_ACInfoModel.Load(m_ACInfoModelPath);\n        bool scannedModelLoaded = m_ScannedModel.Load(m_ScannedModelPath);\n        if(!acimLoaded || !scannedModelLoaded){\n            AIAC_ERROR(\"LayerModel::OnAttach() failed to load models\");\n            return;\n        }\n        AlignModels();\n    }\n\n    void LayerModel::OnFrameStart() {}\n\n    void LayerModel::LoadACInfoModel(const std::string &amp;path)\n    {\n        bool succeed = m_ACInfoModel.Load(path);\n        if(succeed){\n            m_ACInfoModelPath = path;\n            m_ACIMTransformMat = glm::mat4(1.0f);\n\n            AIAC::Config::UpdateEntry&lt;std::string&gt;(AIAC::Config::SEC_AIAC, AIAC::Config:: AC_INFO_MODEL, path);\n            AlignModels();\n        }\n    }\n\n    void LayerModel::LoadScannedModel(const std::string&amp; path)\n    {\n        bool succeed = m_ScannedModel.Load(path);\n        if(succeed) {\n            m_ScannedModelPath = path;\n            m_ACIMTransformMat = glm::mat4(1.0f);\n\n            AIAC::Config::UpdateEntry&lt;std::string&gt;(AIAC::Config::SEC_AIAC, AIAC::Config:: SCANNED_MODEL, path);\n\n            AlignModels();\n            AIAC_INFO(\"Scanned model from path: \" + path + \" is loaded and alligned.\");\n        }\n    }\n\n    void LayerModel::ReloadACInfoModel()\n    {\n        std::string path = AIAC::Config::Get&lt;std::string&gt;(\n                AIAC::Config::SEC_AIAC, AIAC::Config::AC_INFO_MODEL, \"assets/ACModel/test.acim\");\n        if(!std::filesystem::exists(path))\n        {\n            AIAC_WARN(\"LayerModel::ReloadACInfoModel()from path: \" + path + \" failed to load models\");\n            return;\n        }\n        bool succeed = m_ACInfoModel.Load(path);\n        m_ACIMTransformMat = glm::mat4(1.0f);\n        if (!succeed)\n        {\n            AIAC_WARN(\"LayerModel::ReloadACInfoModel() from path: \" + path + \" failed to load models\");\n            return;\n        }\n        AIAC_INFO(\"ACIM model from path: \" + path + \" is loaded.\");\n        AlignModels();\n    }\n\n    void LayerModel::AlignModels() {\n        bool acimLoaded = m_ACInfoModel.Load(m_ACInfoModelPath);\n        bool scannedModelLoaded = m_ScannedModel.Load(m_ScannedModelPath);\n        m_ACIMTransformMat = glm::mat4(1.0f);\n\n        auto acInfoModelBbox = m_ACInfoModel.GetTimberInfo().GetBoundingBox();\n        auto scannedModelBbox = m_ScannedModel.GetBoundingBox();\n\n        float infoModelLength = m_ACInfoModel.GetLength();\n        float scannedModelLength = m_ScannedModel.GetLength();\n\n        auto subBbox = m_ScannedModel.GetBoundingBox();\n        if(m_AlignOffset &gt; 0){\n            auto usedPortion = (scannedModelLength - m_AlignOffset) / scannedModelLength;;\n            subBbox[0] = (subBbox[0] - subBbox[1]) * usedPortion + subBbox[1];\n            subBbox[3] = (subBbox[3] - subBbox[2]) * usedPortion + subBbox[2];\n            subBbox[4] = (subBbox[4] - subBbox[5]) * usedPortion + subBbox[5];\n            subBbox[7] = (subBbox[7] - subBbox[6]) * usedPortion + subBbox[6];\n        }\n        else if (m_AlignOffset &lt; 0){\n            auto usedPortion = (scannedModelLength + m_AlignOffset) / scannedModelLength;;\n            subBbox[1] = (subBbox[1] - subBbox[0]) * usedPortion + subBbox[0];\n            subBbox[2] = (subBbox[2] - subBbox[3]) * usedPortion + subBbox[3];\n            subBbox[5] = (subBbox[5] - subBbox[4]) * usedPortion + subBbox[4];\n            subBbox[6] = (subBbox[6] - subBbox[7]) * usedPortion + subBbox[7];\n        } else {\n            auto usedPortion = (scannedModelLength + m_AlignOffset) / scannedModelLength;;\n            subBbox[1] = (subBbox[1] - subBbox[0]) * usedPortion + subBbox[0];\n            subBbox[2] = (subBbox[2] - subBbox[3]) * usedPortion + subBbox[3];\n            subBbox[5] = (subBbox[5] - subBbox[4]) * usedPortion + subBbox[4];\n            subBbox[6] = (subBbox[6] - subBbox[7]) * usedPortion + subBbox[7];\n        }\n\n        // rotate the subBox\n        for(int i = 0 ; i &lt; m_AlignRotation; i++){\n            auto tmp = subBbox[0];\n            subBbox[0] = subBbox[4];\n            subBbox[4] = subBbox[7];\n            subBbox[7] = subBbox[3];\n            subBbox[3] = tmp;\n\n            tmp = subBbox[1];\n            subBbox[1] = subBbox[5];\n            subBbox[5] = subBbox[6];\n            subBbox[6] = subBbox[2];\n            subBbox[2] = tmp;\n        }\n        // flip the subBox\n        if(m_AlignFlip){\n            std::swap(subBbox[0], subBbox[5]);\n            std::swap(subBbox[1], subBbox[4]);\n            std::swap(subBbox[2], subBbox[7]);\n            std::swap(subBbox[3], subBbox[6]);\n        }\n\n        m_ACIMTransformMat = GetRigidTransformationMatrix(acInfoModelBbox, subBbox);\n        m_ACInfoModel.Transform(m_ACIMTransformMat);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerModel_8h/","title":"File LayerModel.h","text":"<p>FileList &gt; AIAC &gt; LayerModel.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Config.h\"</code></li> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"ACInfoModel.h\"</code></li> <li><code>#include \"ScannedModel.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerModel_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerModel_8h/#classes","title":"Classes","text":"Type Name class LayerModel <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerModel.h</code></p>"},{"location":"acdoxygen/LayerModel_8h_source/","title":"File LayerModel.h","text":"<p>File List &gt; AIAC &gt; LayerModel.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"Config.h\"\n#include \"AIAC/Layer.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"ACInfoModel.h\"\n#include \"ScannedModel.h\"\n\n\nnamespace AIAC\n{\n    class LayerModel : public AIAC::Layer\n    {\n    public:\n        LayerModel();\n        virtual ~LayerModel() = default;\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n        void AlignModels();\n\n        void LoadACInfoModel(const std::string&amp; path);\n\n        void ReloadACInfoModel();\n\n        void LoadScannedModel(const std::string&amp; path);\n\n        inline const std::string&amp; GetACInfoModelPath() const { return m_ACInfoModelPath; }\n\n        inline const std::string GetACInfoModelName() const { return m_ACInfoModel.GetName(); }\n\n        inline const std::string&amp; GetScannedModelPath() const { return m_ScannedModelPath; }\n\n        inline ACInfoModel&amp; GetACInfoModel() { return m_ACInfoModel; }\n\n        inline ScannedModel&amp; GetScannedModel() { return m_ScannedModel; }\n\n        inline float GetAlignOffset() { return m_AlignOffset; }\n\n        inline int GetAlignRotation() const { return m_AlignRotation; }\n\n        inline bool GetAlignFlip() const { return m_AlignFlip; }\n\n        inline glm::mat4x4 GetTransformMat() const { return m_ACIMTransformMat; }\n\n        inline void AddAlignOffset(float diff) {\n            m_AlignOffset += diff;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_OFFSET, m_AlignOffset);\n        }\n\n        inline void ResetAlignOffset() {\n            m_AlignOffset = 0.0f;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_OFFSET, 0.0f);\n        };\n\n        inline void ForceAlignToEnd(bool leftOrRight) {\n            m_AlignOffset = (m_ACInfoModel.GetLength() - m_ScannedModel.GetLength());\n            if (leftOrRight) m_AlignOffset = -m_AlignOffset;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_OFFSET, m_AlignOffset);\n        }\n\n        inline void ChangeAlignRotation(int diff) {\n            m_AlignRotation += diff;\n            if (m_AlignRotation &lt; 0) m_AlignRotation += 4;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_ROTATION, m_AlignRotation);\n        }\n\n        inline void ResetAlignRotation() {\n            m_AlignRotation = 0;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_ROTATION, 0);\n        }\n\n        inline void FlipAlign() {\n            m_AlignFlip = !m_AlignFlip;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_FLIP, m_AlignFlip);\n        }\n\n        inline void ResetAlignFlip() {\n            m_AlignFlip = false;\n            AlignModels();\n            Config::UpdateEntry(Config::SEC_AIAC, Config::ALIGN_FLIP, false);\n        }\n\n    private:\n        std::string m_ACInfoModelPath;\n        std::string m_ScannedModelPath;\n\n        // ModelLoader m_ModelLoader;\n        ACInfoModel m_ACInfoModel;\n        ScannedModel m_ScannedModel;\n        float m_AlignOffset = 0.0f;\n        int m_AlignRotation = 0;\n        bool m_AlignFlip = false;\n\n        // The cumulative transformation matrix of the model, from ACIM to ScannedModel, regarding the offset, rotation, and flip.\n        // Since the model is transformed multiple times relatively during adjusting, we need to recorded it in this way.\n\n        // Abandon as now everytime when alignment happens it's re-calculated\n        // glm::mat4x4 m_CumulativeTransformMat = glm::mat4(1.0f);\n\n        glm::mat4x4 m_ACIMTransformMat;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerSlam_8cpp/","title":"File LayerSlam.cpp","text":"<p>FileList &gt; AIAC &gt; LayerSlam.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"AIAC/LayerSlam.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"utils/MatrixUtils.h\"</code></li> <li><code>#include \"glm/gtx/string_cast.hpp\"</code></li> </ul>"},{"location":"acdoxygen/LayerSlam_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerSlam.cpp</code></p>"},{"location":"acdoxygen/LayerSlam_8cpp_source/","title":"File LayerSlam.cpp","text":"<p>File List &gt; AIAC &gt; LayerSlam.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Config.h\"\n\n#include \"AIAC/LayerSlam.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Application.h\"\n\n#include \"utils/MatrixUtils.h\"\n\n//for test\n#include \"glm/gtx/string_cast.hpp\"\n\nnamespace AIAC\n{\n    void LayerSlam::OnAttach()\n    {\n        // load camera calibration file (mainly for distortion matrix)\n        auto calibFilePath = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_PARAMS_FILE, \"assets/tslam/calibration_webcam.yml\");\n        Slam.setCamParams(calibFilePath);\n        Slam.imageParams.Distorsion.setTo(cv::Scalar::all(0));\n        Slam.systemParams.enableLoopClosure = false;\n        Slam.systemParams.aruco_minerrratio_valid = 15;\n        Slam.systemParams.KPNonMaximaSuppresion=true;\n        Slam.systemParams.markersOptWeight=1.0; // maximum importance of markers in the final error. Value in range [0,1]. The rest if assigned to points\n        Slam.systemParams.minMarkersForMaxWeight=3;\n        Slam.systemParams.detectKeyPoints=false;\n\n        // load map, the camera matrix will be replaced by the one in the map\n        auto pathToMapFile = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TSLAM, AIAC::Config::MAP_FILE, \"assets/tslam/example.map\");\n        if(std::filesystem::exists(pathToMapFile)){\n            AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMMapLoadedEvent&gt;(pathToMapFile));\n        } else {\n            AIAC_WARN(\"SLAM map file doesn't exist: \\\"{}\\\". Init empty map.\", pathToMapFile);\n            Slam.clearMap();\n        }\n\n        // load vocabulary\n        Slam.setVocabulary(AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TSLAM, AIAC::Config::VocFile, \"assets/tslam/orb.fbow\"));\n        Slam.setInstancing(true);\n    }\n\n    void LayerSlam::OnFrameStart()\n    {\n        if(m_ToStartMapping){\n            Slam.systemParams.detectKeyPoints=true;\n            Slam.clearMap();\n            Slam.setInstancing(false);\n            ToProcess = true;\n            m_IsMapping = true;\n            m_ToStartMapping = false;\n        }\n\n        // Update the Tag visibility setting\n        if(ToShowTag != m_IsShowingTag){\n            if(ToShowTag){\n                for(auto &amp;go : m_SlamMapGOs){\n                    go-&gt;SetVisibility(true);\n                }\n            } else {\n                for(auto &amp;go : m_SlamMapGOs){\n                    go-&gt;SetVisibility(false);\n                }\n            }\n            m_IsShowingTag = ToShowTag;\n        }\n\n        if(!ToProcess){\n            return;\n        }\n\n        cv::Mat currentFrame;\n        cv::Mat resizedFrame;\n\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetCurrentFrame().GetCvMat().copyTo(currentFrame);\n        auto targetSize = Slam.imageParams.CamSize;\n        cv::resize(currentFrame, resizedFrame, targetSize);\n        currentFrame = resizedFrame;\n\n        if(ToEnhance){\n            //Get Intensity image\n            cv::Mat Lab_image;\n            cvtColor(currentFrame, Lab_image, cv::COLOR_BGR2Lab);\n            std::vector&lt;cv::Mat&gt; Lab_planes(3);\n            cv::split(Lab_image, Lab_planes);  // now we have the L image in lab_planes[0]\n\n            // apply the CLAHE algorithm to the L channel\n            cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::createCLAHE();\n            clahe-&gt;setClipLimit(4);\n            // clahe-&gt;setTilesGridSize(cv::Size(10, 10));\n            cv::Mat clahe_L;\n            clahe-&gt;apply(Lab_planes[0], clahe_L);\n\n            // Merge the color planes back into a Lab image\n            clahe_L.copyTo(Lab_planes[0]);\n            cv::merge(Lab_planes, Lab_image);\n\n            // convert back to RGB\n            cv::cvtColor(Lab_image, currentFrame, cv::COLOR_Lab2BGR);\n        }\n\n        m_IsTracked = Slam.process(currentFrame, m_CamPose);\n        m_ProcessedFrame = currentFrame.clone();\n\n        if(m_IsTracked) {\n            m_NumLostFrame = 0;\n\n            // perform stabilization\n            if (m_CamPoseBuffer.empty()) {\n                // if no pose in the buffer, take the current one\n                m_CamPoseBuffer.push_back(m_CamPose.clone());\n                m_LastTrackedCamPose = m_CamPose.clone();\n            } else {\n                // calculate the average of the pose in the buffer\n                cv::Mat avg_pose = cv::Mat::zeros(4, 4, CV_32FC1);\n                for(auto &amp;pose: m_CamPoseBuffer){\n                    avg_pose += pose;\n                }\n                avg_pose = avg_pose / double(m_CamPoseBuffer.size());\n\n                auto poseDifference = cv::norm(m_CamPose - avg_pose);\n                if (poseDifference &lt; 3.0f) {\n                    m_NumLongDistFrame = 0;\n                    m_CamPoseBuffer.push_back(m_CamPose.clone());\n                } else {\n                    m_NumLongDistFrame++;\n                }\n\n                if (m_CamPoseBuffer.size() &gt; m_MaxCamPoseBufferSize) {\n                    m_CamPoseBuffer.pop_front();\n                }\n\n                // perform a linear interpolation to get the stabilized pose\n                m_LastTrackedCamPose = cv::Mat::zeros(4, 4, CV_32FC1);\n\n                // OPTION 1: calculate the weighted average\n                int divider = 0;\n                for(int i = 0 ; i &lt; m_CamPoseBuffer.size() ; i++){\n                    m_LastTrackedCamPose += m_CamPoseBuffer[i] * (i + 1);\n                    divider += (i + 1);\n                }\n                m_LastTrackedCamPose = m_LastTrackedCamPose / divider;\n\n                // OPTION 2: just calculate the average\n//                cout &lt;&lt; \"CamPoseBuffer: \" &lt;&lt; endl;\n//                for(auto &amp;pose : m_CamPoseBuffer){\n//                    cout &lt;&lt; pose &lt;&lt; endl;\n//                    m_LastTrackedCamPose += pose / double(m_CamPoseBuffer.size());\n//                }\n            }\n        } else {\n            m_NumLostFrame ++;\n        }\n\n        if((m_NumLongDistFrame &gt; 1 || m_NumLostFrame &gt; m_MaxCamPoseBufferSize)\n                &amp;&amp; !m_CamPoseBuffer.empty()){\n            m_CamPoseBuffer.clear();\n            m_NumLostFrame = 0;\n            m_NumLongDistFrame = 0;\n        }\n    }\n\n    glm::mat4 LayerSlam::GetCamPoseGlm()\n    {\n        glm::mat4 glmMat;\n        if (m_LastTrackedCamPose.cols != 4 ||m_LastTrackedCamPose.rows != 4 ||m_LastTrackedCamPose.type() != CV_32FC1) {\n            throw std::invalid_argument(\"GetCamPose() error.\");\n        }\n        memcpy(glm::value_ptr(glmMat), m_LastTrackedCamPose.data, 16 * sizeof(float));\n        glmMat = glm::transpose(glmMat);\n        return glmMat;\n    }\n\n    void LayerSlam::GetCamPoseInObjCoord(cv::Mat &amp;rotMat, cv::Mat &amp;tvec){\n        rotMat(cv::Rect(0, 0, 3, 3)) = m_LastTrackedCamPose(cv::Rect(0, 0, 3, 3)).t();\n        tvec(cv::Rect(0, 0, 3, 1)) = m_LastTrackedCamPose(cv::Rect(3, 0, 3, 1));\n        tvec = -rotMat * tvec;\n    }\n\n    glm::mat4 LayerSlam::GetInvCamPoseGlm()\n    {\n        glm::mat4 glmMat;\n        if (m_LastTrackedCamPose.cols != 4 ||m_LastTrackedCamPose.rows != 4 ||m_LastTrackedCamPose.type() != CV_32FC1) {\n            throw std::invalid_argument(\"GetCamPose() error.\");\n        }\n        memcpy(glm::value_ptr(glmMat), m_LastTrackedCamPose.data, 16 * sizeof(float));\n        glmMat = glm::transpose(glmMat);\n\n        glm::mat3 RT; // rotation matrix\n        glm::vec3 tvec; // transpose vector\n        for(int i = 0; i &lt; 3; i++) {\n            for(int j = 0; j &lt; 3; j++) {\n                RT[i][j] = glmMat[j][i]; // Transpose is inverse(R) because R is rotation matrix\n            }\n            tvec[i] = glmMat[3][i];\n        }\n\n        tvec = -RT * tvec;\n        for(int i = 0; i &lt; 3; i++) {\n            for(int j = 0; j &lt; 3; j++) {\n                glmMat[i][j] = RT[i][j];\n            }\n            glmMat[3][i] = tvec[i];\n        }\n        glmMat[3][3] = 1.0f;\n\n        return glmMat;\n    }\n\n    void LayerSlam::StartMapping() {\n        m_ToStartMapping = true;\n        // The rest of the process is done in OnFrameStart()\n    }\n\n    void LayerSlam::StopMapping() {\n        Slam.systemParams.detectKeyPoints=false;\n        Slam.setInstancing(true);\n        m_IsMapping = false;\n    }\n\n    void LayerSlam::UpdateMap(std::string path){\n        Slam.setMap(path, true);\n        InitSlamMapGOs();\n    }\n\n    void LayerSlam::InitSlamMapGOs(){\n        // reset GLObjects\n        for(auto &amp;go: m_SlamMapGOs){\n            GOPrimitive::Remove(go);\n        }\n        m_SlamMapGOs.clear();\n\n        // add new GLObjects\n        // std::vector&lt;glm::vec3&gt; markerEdges; markerEdges.reserve(map-&gt;map_markers.size() * 4 * 2);\n        // std::vector&lt;glm::vec4&gt; markerEdgeColors; markerEdgeColors.reserve(map-&gt;map_markers.size() * 4 * 2);\n        for(const auto&amp; mapMarker: Slam.getMap()-&gt;map_markers){\n            auto points = mapMarker.second.get3DPoints();\n            std::vector&lt;glm::vec3&gt; markerEdges;\n            for(int i = 0 ; i &lt; 4; i++){\n                markerEdges.emplace_back(points[i].x, points[i].y, points[i].z);\n            }\n            auto tag = GOPolyline::Add(markerEdges, true, 1.0f);\n            tag-&gt;SetColor(glm::vec4(1.0f, .0f, .0f, 1.0f));\n            tag-&gt;SetVisibility(false);\n            m_SlamMapGOs.push_back(tag);\n        }\n    }\n\n    void LayerSlam::GetCamPoseQuaternionAndTvec(cv::Vec4f &amp;quaternion, cv::Vec3f &amp;tvec) {\n        cv::Mat R = m_LastTrackedCamPose(cv::Rect(0, 0, 3, 3));\n        quaternion = ConvertRotationMatrixToQuaternion(R);\n        tvec[0] = m_LastTrackedCamPose.at&lt;float&gt;(0, 3);\n        tvec[1] = m_LastTrackedCamPose.at&lt;float&gt;(1, 3);\n        tvec[2] = m_LastTrackedCamPose.at&lt;float&gt;(2, 3);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerSlam_8h/","title":"File LayerSlam.h","text":"<p>FileList &gt; AIAC &gt; LayerSlam.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include \"glm/gtc/type_ptr.hpp\"</code></li> <li><code>#include \"GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"tslam.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"utils/CircularBuffer.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerSlam_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerSlam_8h/#classes","title":"Classes","text":"Type Name class LayerSlam <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerSlam.h</code></p>"},{"location":"acdoxygen/LayerSlam_8h_source/","title":"File LayerSlam.h","text":"<p>File List &gt; AIAC &gt; LayerSlam.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"glm/glm.hpp\"\n#include \"glm/gtc/type_ptr.hpp\"\n\n#include \"GOSys/GOPrimitive.h\"\n#include \"tslam.h\"\n#include \"AIAC/Image.h\"\n#include \"AIAC/Layer.h\"\n#include \"AIAC/Config.h\"\n#include \"utils/CircularBuffer.h\"\n\n\nnamespace AIAC\n{\n    class LayerSlam : public AIAC::Layer\n    {\n    public:\n        LayerSlam() = default;\n        ~LayerSlam() = default;\n\n        void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n        inline const int GetNumLostFrame() { return m_NumLostFrame; }\n        inline const bool IsTracked() { return m_IsTracked; }\n        inline const bool IsMapping() const { return m_IsMapping; }\n        void StartMapping();\n        void StopMapping();\n\n        inline const cv::Mat GetCamPoseCv() { return m_CamPose; }\n        glm::mat4 GetCamPoseGlm();\n        glm::mat4 GetInvCamPoseGlm();\n        void GetCamPoseQuaternionAndTvec(cv::Vec4f &amp;quaternion, cv::Vec3f &amp;tvec);\n\n        inline AIAC::Image &amp;GetProcessedFrame() { return m_ProcessedFrame; }\n\n        void GetCamPoseInObjCoord(cv::Mat &amp;rotationMatrix, cv::Mat &amp;tvec);\n\n        void UpdateMap(std::string path);\n        void InitSlamMapGOs();\n\n    public:\n        tslam::TSlam Slam;\n        bool ToShowTag = false;\n        bool ToEnhance = false;\n        bool ToProcess = true;\n\n    private:\n        AIAC::Image m_ProcessedFrame;\n        cv::Mat m_CamPose = cv::Mat();\n        cv::Mat m_LastTrackedCamPose = cv::Mat::eye(4, 4, CV_32FC1);\n\n        int m_NumLostFrame = 0;\n        int m_NumLongDistFrame = 0;\n        CircularBuffer&lt;cv::Mat&gt; m_CamPoseBuffer{ size_t(AIAC::Config::Get&lt;int&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::STABILIZATION_FRAME_COUNT, 5)) };\n        int m_MaxCamPoseBufferSize = AIAC::Config::Get&lt;int&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::STABILIZATION_FRAME_COUNT, 5);\n\n        bool m_IsTracked = false;\n        bool m_IsMapping = false;\n        bool m_IsShowingTag = false;\n        bool m_ToStartMapping = false;\n        std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; m_SlamMapGOs;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerToolhead_8cpp/","title":"File LayerToolhead.cpp","text":"<p>FileList &gt; AIAC &gt; LayerToolhead.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/LayerToolhead.h\"</code></li> <li><code>#include \"GeometryUtils.h\"</code></li> <li><code>#include \"AIAC/UI/ClrPalette.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerToolhead_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerToolhead.cpp</code></p>"},{"location":"acdoxygen/LayerToolhead_8cpp_source/","title":"File LayerToolhead.cpp","text":"<p>File List &gt; AIAC &gt; LayerToolhead.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Config.h\"\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/Application.h\"\n#include \"AIAC/LayerToolhead.h\"\n#include \"GeometryUtils.h\"\n#include \"AIAC/UI/ClrPalette.h\"\n\nnamespace AIAC\n{\n    void LayerToolhead::OnAttach()\n    {\n        bool initDraw = true;\n\n#ifdef HEADLESS_TEST\n        initDraw = false;\n#endif\n\n        // init ttool\n        TTool = std::make_shared&lt;ttool::TTool&gt;(\n            AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::TTOOL_ROOT_PATH, \"deps/TTool\"),\n            AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::CONFIG_FILE, \"deps/TTool/assets/config.yml\"),\n            AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_PARAMS_FILE, \"assets/tslam/calibration_orange_A_1280_720_000B.yml\"),\n            initDraw\n            );\n\n        // load the datasets acits\n        this-&gt;ACInfoToolheadManager-&gt;LoadToolheadModels();\n        if (this-&gt;IsShowToolheadGOInfo)\n        {\n            this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;SetVisibility(true);\n        }\n        syncTToolAndACInfoToolhead();\n    }\n\n    void LayerToolhead::OnFrameStart()\n    {\n        UpdateToolheadStateUI();\n\n        cv::Mat currentFrame;\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetCurrentFrame().GetCvMat().copyTo(currentFrame);\n\n        cv::Mat currentFramePure;\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetCurrentFrame().GetCvMat().copyTo(currentFramePure);\n        if (m_TtoolState == ttool::EventType::Tracking)\n        {\n            TTool-&gt;RunOnAFrame(currentFrame);\n            if (IsShowSilouhette)\n            {\n                TTool-&gt;DrawSilhouette(currentFrame);\n            }\n            if (IsShowShaded)\n            {\n                TTool-&gt;DrawShaded(currentFrame);\n            }\n            m_Pose = TTool-&gt;GetPose();\n        }\n\n        glm::mat4x4 toWorld = GetWorldPose();\n        this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;Transform(toWorld);\n\n        if (m_TtoolState == ttool::EventType::None)\n        {\n            if (IsShowSilouhette)\n            {\n                // convert ImVec4 to glm::vec3\n                glm::vec3 color = glm::vec3(AIAC_UI_SPARK_ORANGE.x, AIAC_UI_SPARK_ORANGE.y, AIAC_UI_SPARK_ORANGE.z);\n                // (?) if it is not called x2 it does not work on setting pose (?)\n                TTool-&gt;DrawSilhouette(currentFrame, color * 255.0f);\n                TTool-&gt;DrawSilhouette(currentFrame, color * 255.0f);\n            }\n            if (IsShowShaded)\n            {\n                TTool-&gt;DrawShaded(currentFrame);\n            }\n        }\n\n        if (IsSavePoseLog) { TTool-&gt;WritePoseToFile(currentFramePure); }\n        else { TTool-&gt;ResetPoseWriter(); }\n\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetCurrentFrame().ReplaceCvMat(currentFrame);\n    }\n\n    void LayerToolhead::DetectToolhead()\n    {\n        cv::Mat currentFrame;\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetColorCurrentFrame().GetPureCvMat().copyTo(currentFrame);\n\n        m_ClassifierToolList = TTool-&gt;ClassifyWithSortedLabels(currentFrame);\n        std::string toolhead = m_ClassifierToolList[0];\n\n        this-&gt;ACInfoToolheadManager-&gt;SetActiveToolhead(toolhead);\n        this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;SetVisibility(this-&gt;IsShowToolheadGOInfo);\n\n        int id = this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;GetId();\n        this-&gt;TTool-&gt;SetObjectID(id);\n    }\n\n    void LayerToolhead::ReloadCameraFromFile()\n    {\n        TTool-&gt;DestrolView();\n        TTool = std::make_shared&lt;ttool::TTool&gt;(\n                AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::TTOOL_ROOT_PATH, \"deps/TTool\"),\n                AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::CONFIG_FILE, \"deps/TTool/assets/config.yml\"),\n                AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_PARAMS_FILE, \"assets/tslam/calibration_orange_A_1280_720_000B.yml\")\n            );\n        syncTToolAndACInfoToolhead();\n    }\n\n    void LayerToolhead::ReloadCameraFromMatrix(cv::Mat cameraMatrix, cv::Size cameraSize)\n    {\n        TTool-&gt;DestrolView();\n        TTool = std::make_shared&lt;ttool::TTool&gt;(\n                AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::TTOOL_ROOT_PATH, \"deps/TTool\"),\n                AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TTOOL, AIAC::Config::CONFIG_FILE, \"deps/TTool/assets/config.yml\"),\n            cameraMatrix,\n            cameraSize\n            );\n        syncTToolAndACInfoToolhead();\n    }\n\n    glm::mat4x4 LayerToolhead::GetWorldPose()\n    {\n        glm::mat4x4 cameraPose = AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;GetInvCamPoseGlm();\n\n        cv::Matx44f toolheadPose = TTool-&gt;GetPose();\n        toolheadPose(0, 3) *= this-&gt;m_ACScaleFactor;\n        toolheadPose(1, 3) *= this-&gt;m_ACScaleFactor;\n        toolheadPose(2, 3) *= this-&gt;m_ACScaleFactor;\n\n        cv::Matx44f toolheadNormalization = TTool-&gt;GetModelManager()-&gt;GetObject()-&gt;getNormalization();\n        toolheadNormalization(0, 3) *= this-&gt;m_ACScaleFactor;\n        toolheadNormalization(1, 3) *= this-&gt;m_ACScaleFactor;\n        toolheadNormalization(2, 3) *= this-&gt;m_ACScaleFactor;\n\n        glm::mat4x4 toolheadPoseGlm = glm::make_mat4x4((toolheadPose * toolheadNormalization).val);\n\n        glm::mat4x4 worldPose = cameraPose * glm::transpose(toolheadPoseGlm);\n        return worldPose;\n    }\n\n    void LayerToolhead::UpdateToolheadStateUI()\n    {\n        switch (this-&gt;ToolheadStateUI)\n        {\n        case 0:\n            m_TtoolState = ttool::EventType::Tracking;\n            break;\n        default:\n            m_TtoolState = ttool::EventType::None;\n            break;\n        }\n        return;\n    }\n\n    void LayerToolhead::SetCurrentObject(std::string name)\n    {\n        this-&gt;ACInfoToolheadManager-&gt;SetActiveToolhead(name);\n        this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;SetVisibility(this-&gt;IsShowToolheadGOInfo);\n\n        int id = this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;GetId();\n\n        cv::Mat currentFrame;\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetCurrentFrame().GetCvMat().copyTo(currentFrame);\n        TTool-&gt;DrawSilhouette(currentFrame);\n        TTool-&gt;DrawSilhouette(currentFrame);\n\n        this-&gt;TTool-&gt;SetObjectID(id);\n    }\n\n    void LayerToolhead::SavePose()\n    {\n        this-&gt;TTool-&gt;ManipulateModel('y');\n\n        m_TtoolState = ttool::EventType::None;\n        this-&gt;ToolheadStateUI = -1;\n\n    }\n\n    void LayerToolhead::ResetToLastSavedPose()\n    {\n        this-&gt;TTool-&gt;GetModelManager()-&gt;ResetObjectToLastSavePose();\n    }\n\n    void LayerToolhead::ResetPoseFromConfig()\n    {\n        this-&gt;TTool-&gt;GetModelManager()-&gt;ResetObjectToConfigInitialPose();\n    }\n\n    void LayerToolhead::syncTToolAndACInfoToolhead()\n    {\n        int id = this-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;GetId();\n        this-&gt;TTool-&gt;SetObjectID(id);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerToolhead_8h/","title":"File LayerToolhead.h","text":"<p>FileList &gt; AIAC &gt; LayerToolhead.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/ACInfoToolheadManager.h\"</code></li> <li><code>#include &lt;ttool.hh&gt;</code></li> </ul>"},{"location":"acdoxygen/LayerToolhead_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerToolhead_8h/#classes","title":"Classes","text":"Type Name class LayerToolhead <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerToolhead.h</code></p>"},{"location":"acdoxygen/LayerToolhead_8h_source/","title":"File LayerToolhead.h","text":"<p>File List &gt; AIAC &gt; LayerToolhead.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Layer.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/ACInfoToolheadManager.h\"\n\n#include &lt;ttool.hh&gt;\n\n\n\nnamespace AIAC\n{\n    class LayerToolhead : public AIAC::Layer\n    {\n    public:\n        LayerToolhead()\n            : IsShowSilouhette(false),\n              ToolheadStateUI(-1),\n              IsShowToolheadGOInfo(false),\n            m_TtoolState(ttool::EventType::None)\n        {\n            this-&gt;m_ACScaleFactor = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n            this-&gt;ACInfoToolheadManager = std::make_shared&lt;AIAC::ACInfoToolheadManager&gt;();\n        };\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n\n        void ReloadCameraFromFile();\n        void ReloadCameraFromMatrix(cv::Mat cameraMatrix, cv::Size cameraSize);\n\n        void DetectToolhead();\n\n        void UpdateToolheadStateUI();\n\n        void SavePose();\n        void ResetToLastSavedPose();\n        void ResetPoseFromConfig();\n\n        glm::mat4x4 GetWorldPose();\n\n    public: \n        inline ttool::EventType GetTtoolState() const { return this-&gt;m_TtoolState; }\n        void SetCurrentObject(std::string name);\n        cv::Matx44f GetPose() const { return m_Pose; }\n        std::string GetTrackingStatus() const { return TTool ? TTool-&gt;GetTrackingStatus() : \"TTool not initialized\"; }\n        std::string GetClassifierLog() const { return TTool ? TTool-&gt;GetClassifierLog() : \"TTool not initialized\"; }\n        std::vector&lt;std::string&gt; GetClassifierToolheadList() const {return m_ClassifierToolList; }\n\n    private:\n        void syncTToolAndACInfoToolhead();\n\n    public:\n        std::shared_ptr&lt;ttool::TTool&gt; TTool;\n        int ToolheadStateUI;\n        bool IsShowSilouhette;\n        bool IsShowShaded = false;\n        bool IsShowToolheadGOInfo;\n        bool IsSavePoseLog = false;\n\n    private:\n        ttool::EventType m_TtoolState;\n        cv::Matx44f m_Pose;\n        float m_ACScaleFactor;\n        std::vector&lt;std::string&gt; m_ClassifierToolList = {};\n\n    public:\n        std::shared_ptr&lt;AIAC::ACInfoToolheadManager&gt; ACInfoToolheadManager;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerUI_8cpp/","title":"File LayerUI.cpp","text":"<p>FileList &gt; AIAC &gt; LayerUI.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/LayerUI.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"AIAC/Render/Renderer.h\"</code></li> <li><code>#include \"AIAC/UI/ImGuiFileDialog.h\"</code></li> <li><code>#include \"AIAC/UI/ClrPalette.h\"</code></li> <li><code>#include \"AIAC/UI/CustomLogos.h\"</code></li> <li><code>#include \"LayerCameraCalib.h\"</code></li> <li><code>#include \"LayerLogRecorder.h\"</code></li> <li><code>#include \"ttool.hh\"</code></li> <li><code>#include \"utils/utils.h\"</code></li> <li><code>#include \"LayerUtils.h\"</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"acdoxygen/LayerUI_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerUI_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::optional&lt; std::string &gt; GetLatestFilePath (const std::string &amp; directoryPath, const std::string &amp; extension)"},{"location":"acdoxygen/LayerUI_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/LayerUI_8cpp/#function-getlatestfilepath","title":"function GetLatestFilePath","text":"<pre><code>std::optional&lt; std::string &gt; GetLatestFilePath (\n    const std::string &amp; directoryPath,\n    const std::string &amp; extension\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.cpp</code></p>"},{"location":"acdoxygen/LayerUI_8cpp_source/","title":"File LayerUI.cpp","text":"<p>File List &gt; AIAC &gt; LayerUI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/LayerUI.h\"\n#include \"AIAC/Application.h\"\n\n#include \"AIAC/Image.h\"\n#include \"AIAC/Render/Renderer.h\"\n\n#include \"AIAC/UI/ImGuiFileDialog.h\"\n\n#include \"AIAC/UI/ClrPalette.h\"\n#include \"AIAC/UI/CustomLogos.h\"\n#include \"LayerCameraCalib.h\"\n#include \"LayerLogRecorder.h\"\n\n#include \"ttool.hh\"\n\n#include \"utils/utils.h\"\n#include \"LayerUtils.h\"\n\n#include &lt;filesystem&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\nstd::optional&lt;std::string&gt; GetLatestFilePath(const std::string&amp; directoryPath, const std::string&amp; extension);\nstd::optional&lt;std::string&gt; GetLatestFilePath(const std::string&amp; directoryPath, const std::string&amp; extension) {\n    std::optional&lt;std::filesystem::path&gt; latestFilePath;\n    std::filesystem::file_time_type latestModificationTime;\n\n    for (const auto&amp; entry : std::filesystem::directory_iterator(directoryPath)) {\n        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == extension) {\n            auto currentFileModificationTime = std::filesystem::last_write_time(entry);\n            if (!latestFilePath || currentFileModificationTime &gt; latestModificationTime) {\n                latestFilePath = entry.path();\n                latestModificationTime = currentFileModificationTime;\n            }\n        }\n    }\n\n    if (latestFilePath) {\n        return latestFilePath-&gt;string();\n    } else {\n        return std::nullopt;\n    }\n}\n\n\nnamespace AIAC\n{\n    void LayerUI::OnAttach()\n    {\n        IMGUI_CHECKVERSION();\n        ImGui::CreateContext();\n        ImGuiIO&amp; io = ImGui::GetIO(); (void)io;\n\n        //---------------------------------------------------------------------------------\n        // styling of the main window\n        ImGui::StyleColorsDark();\n        ImGuiStyle&amp; style = ImGui::GetStyle();\n\n        style.Colors[ImGuiCol_MenuBarBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.20f);\n        style.Colors[ImGuiCol_WindowBg]              = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);\n        style.Colors[ImGuiCol_Border]                = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_BorderShadow]          = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\n\n        style.Colors[ImGuiCol_FrameBg]               = AIAC_UI_LIGHT_GREY;\n        style.Colors[ImGuiCol_FrameBgHovered]        = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_FrameBgActive]         = AIAC_UI_SPARK_ORANGE;\n\n        style.Colors[ImGuiCol_CheckMark]             = AIAC_UI_SPARK_ORANGE;\n        style.Colors[ImGuiCol_SliderGrab]            = AIAC_UI_SPARK_ORANGE;\n        style.Colors[ImGuiCol_SliderGrabActive]      = AIAC_UI_SPARK_ORANGE;\n\n        style.Colors[ImGuiCol_ResizeGrip]            = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_ResizeGripHovered]     = AIAC_UI_LIGHT_GREY;\n        style.Colors[ImGuiCol_ResizeGripActive]      = AIAC_UI_SPARK_ORANGE;\n\n        style.Colors[ImGuiCol_PlotHistogramHovered]  = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_TextSelectedBg]        = AIAC_UI_SPARK_ORANGE;\n\n        style.Colors[ImGuiCol_TitleBg]               = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_TitleBgCollapsed]      = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_TitleBgActive]         = AIAC_UI_SPARK_ORANGE;\n\n        style.Colors[ImGuiCol_Header]                = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_HeaderHovered]         = AIAC_UI_SPARK_ORANGE;\n        style.Colors[ImGuiCol_HeaderActive]          = AIAC_UI_SPARK_ORANGE;\n\n        style.Colors[ImGuiCol_Button]                = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_ButtonHovered]         = AIAC_UI_SPARK_ORANGE;\n        style.Colors[ImGuiCol_ButtonActive]          = AIAC_UI_SPARK_ORANGE;\n        style.Colors[ImGuiCol_FrameBg]               = AIAC_UI_DARK_GREY;\n\n        style.Colors[ImGuiCol_ScrollbarBg]           = AIAC_UI_LIGHT_GREY;\n        style.Colors[ImGuiCol_ScrollbarGrab]         = AIAC_UI_DARK_GREY;\n        style.Colors[ImGuiCol_ScrollbarGrabHovered]  = AIAC_UI_SPARK_ORANGE;\n        style.Colors[ImGuiCol_ScrollbarGrabActive]   = AIAC_UI_SPARK_ORANGE;\n\n        style.ScrollbarSize = 30.0f;\n        style.WindowRounding = 4.0f;\n        style.ChildRounding = 4.0f;\n        style.FrameRounding = 4.0f;\n        style.PopupRounding = 4.0f;\n        style.ScrollbarRounding = 4.0f;\n        style.GrabRounding = 4.0f;\n        style.TabRounding = 4.0f;\n        style.FramePadding = ImVec2(6, 6);\n\n        //---------------------------------------------------------------------------------\n\n        ImGui_ImplGlfw_InitForOpenGL(AIAC_APP.GetWindow()-&gt;GetGLFWWindow(), true);\n        ImGui_ImplOpenGL3_Init(AIAC_APP.GetWindow()-&gt;GetGlslVersion());\n\n        io.Fonts-&gt;AddFontFromFileTTF(\"assets/fonts/UbuntuMono-R.ttf\", 14.0f);  // default\n\n        // Load images from memory\n        m_LogoLightClr = AIAC::Image(AIAC_LOGO_COLOR);\n\n        // Set panes UI for layers\n        //                Label                    Collapse  PaneContent\n        StackPane(PaneUI(\"Camera\",                 false,    AIAC_BIND_EVENT_FN(SetPaneUICamera)    ));\n        StackPane(PaneUI(\"Mapping\",                false,    AIAC_BIND_EVENT_FN(SetPaneUISlam)      ));\n        StackPane(PaneUI(\"ACIM (Execution model)\", false,    AIAC_BIND_EVENT_FN(SetPaneUIACIM)      ));\n        StackPane(PaneUI(\"Toolhead\",               false,    AIAC_BIND_EVENT_FN(SetPaneUIToolhead), AIAC_BIND_EVENT_FN(OnCollapsingPaneUIToolhead)));\n        StackPane(PaneUI(\"Utils\",                  false,    AIAC_BIND_EVENT_FN(SetPaneUIUtils)     ));\n\n        m_IsOpen = new bool(true);\n    }\n\n    void LayerUI::OnFrameStart()\n    {\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplGlfw_NewFrame();\n        ImGui::NewFrame();\n    }\n\n    void LayerUI::OnUIRender()\n    {\n        IM_ASSERT(ImGui::GetCurrentContext() != NULL &amp;&amp; \"Missing dear imgui context. Refer to examples app!\");\n\n        if (AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;IsMapping()) {\n            ShowMappingPopup();\n        } else if (AIAC_APP.GetLayer&lt;LayerCameraCalib&gt;()-&gt;IsCalibrating()){\n            ShowCamCalibPopup();\n            if (m_IsChoosingCamCalibFileSavePath){\n                ShowSaveCamCalibFileDialog();\n            }\n        } else {\n            ShowMenuBar();\n            ShowMainUI();\n            ShowSceneViewport();\n            ShowLogRecorderUI();\n\n            if(m_IsCombiningMap){\n                ShowCombineMapPopup();\n            }\n\n            if(m_IsReconstructing3D){\n                ShowReconstruct3DPopup();\n            }\n        }\n        ShowFileSelectDialog();\n\n        ImGui::Render();\n        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n    }\n\n    void LayerUI::OnDetach()\n    {\n        ImGui_ImplOpenGL3_Shutdown();\n        ImGui_ImplGlfw_Shutdown();\n        ImGui::DestroyContext();\n    }\n\n    template&lt;typename... Args&gt;\n    void PaneUI::Show(Args &amp;&amp;... args) {\n        bool isOpened = ImGui::CollapsingHeader(m_Label, m_IsCollapsed ? ImGuiTreeNodeFlags_DefaultOpen : 0);\n        if (isOpened) {\n            // if this one is not opened yet, close the previously opened one\n            if (m_CollapseState != CollapseState::OPEN) {\n                auto lastOpenedPaneUI = AIAC_APP.GetLayer&lt;LayerUI&gt;()-&gt;GetOpenedPaneUI();\n                if (lastOpenedPaneUI != nullptr &amp;&amp; lastOpenedPaneUI-&gt;m_Label != m_Label) {\n                    ImGui::GetStateStorage()-&gt;SetInt(ImGui::GetID(lastOpenedPaneUI-&gt;m_Label), 0);\n                    lastOpenedPaneUI-&gt;Show();\n                }\n                AIAC_APP.GetLayer&lt;LayerUI&gt;()-&gt;SetOpenedPaneUI(this);\n            }\n            m_CollapseState = CollapseState::OPEN;\n            m_func(std::forward&lt;Args&gt;(args)...);\n        }\n\n        // check if it's just collapsed\n        if (!isOpened) {\n            if (m_CollapseState == CollapseState::OPEN) {\n                m_CollapseState = CollapseState::ON_COLLAPSING;\n            }\n        }\n    }\n\n    template&lt;typename... Args&gt;\n    void PaneUI::CheckOnCollapsing(Args &amp;&amp;... args) {\n        if (m_CollapseState == CollapseState::ON_COLLAPSING) {\n            m_onCollapseCallback(std::forward&lt;Args&gt;(args)...);\n            m_CollapseState = CollapseState::COLLAPSE;\n        }\n    }\n\n    void LayerUI::ShowMenuBar()\n    {\n        if (ImGui::BeginMainMenuBar())\n        {\n            ImGui::Image(m_LogoLightClr.GetImTexture().ID, ImVec2(18, 18), ImVec2(0, 1), ImVec2(1, 0));\n            ImGui::SameLine();\n\n            if (ImGui::BeginMenu(\"App\"))\n            {\n                if (ImGui::MenuItem(\"Close\"))\n                {\n                    *m_IsOpen = false;\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;AppCloseEvent&gt;());\n                }\n                ImGui::EndMenu();\n            }\n            ImGui::EndMainMenuBar();\n        }\n    }\n\n    void LayerUI::ShowMainUI()\n    {\n        ImGui::Begin(\"augmented_carpentry\", m_IsOpen);\n#ifdef ENABLE_DEV_UI\n        ImGui::Image(m_LogoLightClr.GetImTexture().ID, ImVec2(60, 60), ImVec2(0, 1), ImVec2(1, 0));\n        ImGui::SameLine();\n        ImGui::Text(\"This is a prototype for augmented_carpentry \\n Version 01.00.00 \\n Build 2021-01-01 00:00:00 \\n IBOIS, EPFL\");\n#endif\n\n        for (auto&amp; pane : m_PaneUIStack) {\n            pane.Show();\n            pane.CheckOnCollapsing();\n        }\n\n        ImGui::End();\n    }\n\n    void LayerUI::ShowSceneViewport()\n    {\n        ImGui::Begin(\"Scene Viewport\", m_IsOpen);\n\n        ImVec2 viewportSize = ImGui::GetContentRegionAvail();\n        viewportSize.y -= (ImGui::GetTextLineHeight() + 16);\n        AIAC_APP.GetRenderer()-&gt;SetGlobalViewSize(viewportSize.x, viewportSize.y);\n\n        SetGlobalViewUI(viewportSize);\n\n        ImGui::End();\n    }\n\n    void LayerUI::SetGlobalViewUI(ImVec2 viewportSize)\n    {\n        if(m_IsMouseLDown &amp;&amp; ImGui::IsMouseDragging(0, 0.0f)) {\n            ImVec2 mousePos = ImGui::GetMousePos();\n            switch(m_AdjustTarget){\n                case AdjustTarget::SCALE:\n                    AIAC_APP.GetRenderer()-&gt;UpdateGlobalViewCameraScale(mousePos.x - m_LastMouseLPos.x - mousePos.y + m_LastMouseLPos.y);\n                    break;\n                case AdjustTarget::ROTATION:\n                    AIAC_APP.GetRenderer()-&gt;UpdateGlobalViewCameraRotation(mousePos.x - m_LastMouseLPos.x, mousePos.y - m_LastMouseLPos.y);\n                    break;\n                case AdjustTarget::TRANSLATION:\n                    AIAC_APP.GetRenderer()-&gt;UpdateGlobalViewCameraTranslation(mousePos.x - m_LastMouseLPos.x, mousePos.y - m_LastMouseLPos.y);\n                    break;\n            }\n            m_LastMouseLPos = mousePos;\n        }\n        if(m_IsMouseRDown &amp;&amp; ImGui::IsMouseDragging(1, 0.0f)) {\n            ImVec2 mousePos = ImGui::GetMousePos();\n            AIAC_APP.GetRenderer()-&gt;UpdateGlobalViewCameraTranslation(mousePos.x - m_LastMouseRPos.x, mousePos.y - m_LastMouseRPos.y);\n            m_LastMouseRPos = mousePos;\n        }\n\n        CvtGlTextureObj2ImTexture(AIAC_APP.GetRenderer()-&gt;GetGlobalView(), m_SceneViewportImTexture, viewportSize);\n\n        ImGui::ImageButton(m_SceneViewportImTexture.ID, viewportSize, ImVec2(0, 1), ImVec2(1, 0), 0, ImColor(255, 255, 255, 128));\n        if(ImGui::IsItemHovered()) {\n            if(ImGui::IsMouseDown(0) &amp;&amp; !m_IsMouseLDown) {\n                m_IsMouseLDown = true;\n                m_AdjustTarget = AdjustTarget::ROTATION;\n                m_LastMouseLPos = ImGui::GetMousePos();\n            }\n            if(ImGui::IsMouseDown(1) &amp;&amp; !m_IsMouseRDown) {\n                m_IsMouseRDown = true;\n                m_AdjustTarget = AdjustTarget::TRANSLATION;\n                m_LastMouseRPos = ImGui::GetMousePos();\n            }\n        }\n        if(ImGui::IsMouseReleased(0)) { m_IsMouseLDown = false; }\n        if(ImGui::IsMouseReleased(1)) { m_IsMouseRDown = false; }\n\n        ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_GREY);\n        ImGui::Button(\"Scale\");\n        if(ImGui::IsItemHovered() &amp;&amp; ImGui::IsMouseDown(0) &amp;&amp; !m_IsMouseLDown) {\n            m_AdjustTarget = AdjustTarget::SCALE;\n            m_IsMouseLDown = true;\n            m_LastMouseLPos = ImGui::GetMousePos();\n        }\n        ImGui::SameLine();\n        ImGui::Button(\"Move\");\n        if(ImGui::IsItemHovered() &amp;&amp; ImGui::IsMouseDown(0) &amp;&amp; !m_IsMouseLDown) {\n            m_AdjustTarget = AdjustTarget::TRANSLATION;\n            m_IsMouseLDown = true;\n            m_LastMouseLPos = ImGui::GetMousePos();\n        }\n        ImGui::SameLine();\n        if(ImGui::Button(\"NW\")){\n            AIAC_APP.GetRenderer()-&gt;SetGlobalViewToActivatedComponent(Renderer::StandardView::NW);\n        }\n        ImGui::SameLine();\n        if(ImGui::Button(\"NE\")){\n            AIAC_APP.GetRenderer()-&gt;SetGlobalViewToActivatedComponent(Renderer::StandardView::NE);\n        }\n        ImGui::SameLine();\n        if(ImGui::Button(\"SW\")){\n            AIAC_APP.GetRenderer()-&gt;SetGlobalViewToActivatedComponent(Renderer::StandardView::SW);\n        }\n        ImGui::SameLine();\n        if(ImGui::Button(\"SE\")){\n            AIAC_APP.GetRenderer()-&gt;SetGlobalViewToActivatedComponent(Renderer::StandardView::SE);\n        }\n        ImGui::PopStyleColor();\n    }\n\n\n    void LayerUI::SetPaneUICamera()\n    {\n        string currentItem = AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;GetCurrentDevice();\n        static const char* previewValue = currentItem.c_str();\n        if(ImGui::BeginCombo(\"##AvailableDevices\", previewValue)){\n            for (auto&amp; devicePath : AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;AvailableDevices) {\n                bool isSelected = (currentItem == devicePath);\n                if (ImGui::Selectable(devicePath.c_str(), isSelected)){\n                    AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;SetCurrentDevice(devicePath);\n                }\n                if (isSelected)\n                    ImGui::SetItemDefaultFocus();\n            }\n            ImGui::EndCombo();\n        }\n        ImGui::SameLine();\n        if(ImGui::Button(\"Refresh\")){\n            AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;UpdateAvailableDevices();\n        }\n\n        ImGui::Text(\"Flip \");\n        ImGui::SameLine();\n        if(ImGui::Checkbox(\"Horizontal\", &amp;AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.FlipHorizontal)){\n            AIAC::Config::UpdateEntry(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_FLIP_HORIZONTAL, AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.FlipHorizontal);\n        }\n        ImGui::SameLine();\n        if(ImGui::Checkbox(\"Vertical\", &amp;AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.FlipVertical)){\n            AIAC::Config::UpdateEntry(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_FLIP_VERTICAL, AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.FlipVertical);\n        };\n\n        AIAC::Camera&amp; camera = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera;\n        ImGui::Text(\"Resolution: (%d x %d) &gt; (%d x %d)\", camera.GetRawWidth(), camera.GetRawHeight(), camera.GetWidth(), camera.GetHeight());\n\n        ImGui::BeginChild(\"camera_function_child\", ImVec2(0, 50), true, ImGuiWindowFlags_HorizontalScrollbar);\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_GREY);\n            if(ImGui::Button(\"Start Calibration\")){\n                AIAC_APP.GetLayer&lt;LayerCameraCalib&gt;()-&gt;StartCalibration();\n            }\n            ImGui::SameLine();\n            if (ImGui::Button(\"Open Calib File\")) {\n                ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseCameraCalib\", \"Open calib\", \".yml\", \".\");\n            }\n            if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseCameraCalib\"))\n            {\n                if (ImGuiFileDialog::Instance()-&gt;IsOk())\n                {\n                    std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;CameraCalibrationLoadedEvent&gt;(filePathName));\n                }\n                ImGuiFileDialog::Instance()-&gt;Close();\n            }\n\n            ImGui::PopStyleColor();\n        ImGui::EndChild();\n    }\n\n    void LayerUI::SetPaneUISlam()\n    {\n        ImVec2 sizeButtons = ImVec2(110, 50);\n        ImGui::Text(\"Import files:\");\n        ImGui::BeginChild(\"slam_info_child\", ImVec2(0, 95), true, ImGuiWindowFlags_HorizontalScrollbar);\n            std::string currentSLAMMap = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TSLAM, AIAC::Config::MAP_FILE, \".\");\n            size_t lastSlashPos = currentSLAMMap.find_last_of(\"/\\\\\");\n            if (lastSlashPos != std::string::npos) {\n                currentSLAMMap = currentSLAMMap.substr(lastSlashPos + 1);\n            }\n            ImGui::Text(\"Current SLAM Map: %s\", currentSLAMMap.c_str());\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_BRONZE_ORANGE);\n            if (ImGui::Button(\"Open SLAM map\", sizeButtons))\n            {\n                std::string mapFolderDefault = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TSLAM, AIAC::Config::SAVE_DIR_MAPS, \".\");\n                ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseSLAMmap\", \"Open SLAM map\", \".map\", mapFolderDefault.c_str());\n            }\n            if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseSLAMmap\"))\n            {\n                if (ImGuiFileDialog::Instance()-&gt;IsOk())\n                {\n                    std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMMapLoadedEvent&gt;(filePathName));\n                }\n                ImGuiFileDialog::Instance()-&gt;Close();\n            }\n            ImGui::SameLine();\n            ImGui::PopStyleColor();\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_GRAPE_PURPLE);\n            if (ImGui::Button(\"Open Vocab\", sizeButtons))\n                ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseVocab\", \"Open Vocab\", \".fbow\", \".\");\n\n            if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseVocab\"))\n            {\n                if (ImGuiFileDialog::Instance()-&gt;IsOk())\n                {\n                std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n                AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMVocabularyLoadedEvent&gt;(filePathName));\n                }\n                ImGuiFileDialog::Instance()-&gt;Close();\n            }\n            ImGui::PopStyleColor();\n\n            ImGui::SameLine();\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_PLUM_PURPLE);\n            if (ImGui::Button(\"Open latest Map\", sizeButtons))\n            {\n                std::string mapFolderDefault = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TSLAM, AIAC::Config::SAVE_DIR_MAPS, \".\");\n                auto latestMapFilePathOpt = GetLatestFilePath(mapFolderDefault, \".map\");\n\n                if (latestMapFilePathOpt.has_value())\n                {\n                    std::string latestMapFilePath = latestMapFilePathOpt.value();\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMMapLoadedEvent&gt;(latestMapFilePath));\n                } else {\n                    AIAC_INFO(\"No latest map file found in the directory: {0}\", mapFolderDefault);\n                }\n            }\n            ImGui::PopStyleColor();\n\n        ImGui::EndChild();\n\n        ImGui::Text(\"Mapping Functions:\");\n        ImGui::BeginChild(\"mapping_function_child\", ImVec2(0, 80), true, ImGuiWindowFlags_HorizontalScrollbar);\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_BRONZE_ORANGE);\n            if(ImGui::Button(\"Start Mapping\", sizeButtons)){\n                std::string defaultPath = \"\";\n                defaultPath += \"./scanned_map/map-\";\n                defaultPath += GetCurrentDateTime();\n                defaultPath += \".map\";\n                strncpy(m_MappingParams.MapSavingPath, defaultPath.c_str(), defaultPath.size());\n                AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMStartMappingEvent&gt;());\n            }\n            ImGui::SameLine();\n            ImGui::PopStyleColor();\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_PRUSSIAN_BLUE);\n            if(ImGui::Button(\"Combine Map\", sizeButtons)){\n                m_IsCombiningMap = true;\n            }\n            ImGui::SameLine();\n            if(ImGui::Button(\"Reconstruct 3D\", sizeButtons)){\n                m_IsReconstructing3D = true;\n            }\n            ImGui::PopStyleColor();\n        ImGui::EndChild();\n\n#ifdef ENABLE_DEV_UI\n        ImGui::Checkbox(\"Show Tag\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;ToShowTag);\n        ImGui::Checkbox(\"Process Frames\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;ToProcess);\n        ImGui::Checkbox(\"Enhance Photo\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;ToEnhance);\n\n        ImGui::Text(\"Tracked: %s\", AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;IsTracked() ? \"Yes\" : \"No\");\n#endif\n\n#ifdef ENABLE_DEV_UI\n        std::string camPoseStr; camPoseStr &lt;&lt; AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;GetCamPoseCv();\n        ImGui::Text(\"Estimated Camera Pose: \\n%s\", camPoseStr.c_str());\n#endif\n    }\n\n    void LayerUI::SetPaneUIACIM()\n    {\n        // ACIM file manager (ACIM Loader, Scanned model re/loader)\n        ImGui::Text(\"ACIM File Manager:\");\n        ImGui::BeginChild(\"ACIM File Manager\", ImVec2(0, 60), true, ImGuiWindowFlags_HorizontalScrollbar);\n            std::string currentACIMFileEntry = \"Current ACIM:  \" + AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModelName();\n            ImGui::Text(\"%s\", currentACIMFileEntry.c_str());\n            if(ImGui::Button(\"Load ACIM\")){\n                OpenFileSelectDialog(\"Open ACIM file\", \".acim\", m_TmpPathBuf, [&amp;]{\n                    AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;LoadACInfoModel(m_TmpPathBuf);\n                });\n            }\n            ImGui::SameLine();\n            if(ImGui::Button(\"Reload ACIM\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ReloadACInfoModel();\n            }\n            ImGui::SameLine();\n            if(ImGui::Button(\"Load Scanned Model\")){\n                std::string saveDirMap = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_TSLAM, AIAC::Config::SAVE_DIR_MAPS, \".\");\n                const char* saveDirMapCStr = saveDirMap.c_str();\n                this-&gt;m_TmpPathBuf[0] = '\\0';\n                strcpy(this-&gt;m_TmpPathBuf, saveDirMapCStr);\n                OpenFileSelectDialog(\"Open Scanned Model\", \".ply\", this-&gt;m_TmpPathBuf, [&amp;]{\n                    AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;LoadScannedModel(this-&gt;m_TmpPathBuf);\n                });\n            }\n        ImGui::EndChild();\n\n        // Re-position the ACIM model\n        ImGui::Text(\"ACIM position:\");\n        ImGui::BeginChild(\"adjust_model_alignment\", ImVec2(0, 110), true, ImGuiWindowFlags_HorizontalScrollbar);\n            float sliderVal = 0.f;\n            ImGui::SliderFloat(\"## Model Offset\", &amp;sliderVal, -1.0f, 1.0f, \"Model Offset\", ImGuiSliderFlags_AlwaysClamp);\n                if (sliderVal != 0.f) AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;AddAlignOffset(sliderVal);\n                sliderVal = 0.f;\n            ImGui::SameLine();\n            ImGui::Text(\"%s\", std::to_string(AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;GetAlignOffset()).c_str());\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_ROYAL_PURPLE);\n            if(ImGui::Button(\"Align Center\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ResetAlignOffset();\n            }\n            ImGui::PopStyleColor();\n            ImGui::SameLine();\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LOLLIPOP_PURPLE);\n            if(ImGui::Button(\"Align End 1\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ForceAlignToEnd(1);\n            }\n            ImGui::PopStyleColor();\n            ImGui::SameLine();\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_PLUM_PURPLE);\n            if(ImGui::Button(\"Align End 2\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ForceAlignToEnd(0);\n            }\n            ImGui::PopStyleColor();\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_EGYPTIAN_BLUE);\n            if(ImGui::Button(\"Rotate +\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ChangeAlignRotation(1);\n            }\n            ImGui::PopStyleColor();\n            ImGui::SameLine();\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_EGYPTIAN_BLUE);\n            if(ImGui::Button(\"Rotate -\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ChangeAlignRotation(-1);\n            }\n            ImGui::PopStyleColor();\n            ImGui::SameLine();\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_SAPPHIRE_BLUE);\n            if(ImGui::Button(\"Reset Rotation\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;ResetAlignRotation();\n            }\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_CINNAMON_RED);\n            ImGui::PopStyleColor();\n            ImGui::SameLine();\n            if(ImGui::Button(\"Flip\")){\n                AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;FlipAlign();\n            }\n            ImGui::PopStyleColor();\n        ImGui::EndChild();\n\n        // current component to execute\n        std::string isCurrentDone = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()-&gt;IsMarkedDone ? \"Done\" : \"Not done\";\n        if (AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()-&gt;IsMarkedDone)\n            ImGui::PushStyleColor(ImGuiCol_Text, AIAC_UI_GREEN);\n        else\n            ImGui::PushStyleColor(ImGuiCol_Text, AIAC_UI_RED);\n        ImGui::Text(\"Current Execution: %s\", isCurrentDone.c_str());\n        ImGui::PopStyleColor();\n        ImGui::BeginChild(\"components_control_panel\", ImVec2(0, 216), true, ImGuiWindowFlags_HorizontalScrollbar);\n            // print the progress\n            ImGui::Text(\"Progress: %d / %d ( %.2f%% )\", AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetFabricatedComponents(),\n                                                        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetTotalComponents(),\n                                                        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetFabricationProgress());\n\n            // control the component to fabricate\n            string currentCompoID = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponentID();\n            static const char* previewValue = currentCompoID.c_str();\n            ImGui::SetNextItemWidth(300);\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(7, 7));\n            if(ImGui::BeginCombo(\"##ACIMComponents\", previewValue))\n            {\n                for (auto&amp; componentID : AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetAllComponentsIDs()) {\n                    bool isSelected = (currentCompoID == componentID);\n                    if (AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetComponent(componentID)-&gt;IsMarkedDone)\n                        ImGui::PushStyleColor(ImGuiCol_Text, AIAC_UI_GREEN);\n                    else\n                        ImGui::PushStyleColor(ImGuiCol_Text, AIAC_UI_RED);\n                    if (ImGui::Selectable(componentID.c_str(), isSelected)){\n                        AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().SetCurrentComponentTo(componentID.c_str());\n                        AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;ActivateCurrentFeedbackVisibility();\n                    }\n                    if (isSelected)\n                        ImGui::SetItemDefaultFocus();\n                    ImGui::PopStyleColor();\n                }\n                ImGui::EndCombo();\n            }\n\n            // go to next or previous component (&lt;,&gt;)\n            float halfWidth = ImGui::GetWindowWidth() / 2;\n            if(ImGui::Button(\"&lt;\", ImVec2(halfWidth-30, 0)))\n            {\n                AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().SetPrevComponentAsCurrent();\n                AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;ActivateCurrentFeedbackVisibility();\n            }\n            ImGui::SameLine();\n            if (ImGui::Button(\"&gt;\", ImVec2(halfWidth-30, 0)))\n            {\n                AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().SetNextComponentAsCurrent();\n                AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;ActivateCurrentFeedbackVisibility();\n            }\n\n            // swap ends for holes only\n            auto currentComp = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent();\n            if (auto hole = dynamic_cast&lt;TimberInfo::Hole*&gt;(currentComp)){\n                if(ImGui::Button(\"Swap S/E\")) hole-&gt;SwapStartEnd();\n                ImGui::SameLine();\n                ImGui::Text(\"Diameter: %.f mm\", hole-&gt;GetRadius()*2000);\n            }\n            ImGui::PopStyleVar();\n\n            // this is a button for enable the plane visualizer\n            // for cutting tools show the red plane for cutting guidance\n            if (auto cut = dynamic_cast&lt;TimberInfo::Cut*&gt;(currentComp)){\n                if(ImGui::Checkbox(\"Show Cut Plane\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerFeedback&gt;()-&gt;ToShowCutPlane)){\n                    if(AIAC_APP.GetLayer&lt;AIAC::LayerFeedback&gt;()-&gt;ToShowCutPlane){\n                        AIAC_APP.GetLayer&lt;AIAC::LayerFeedback&gt;()-&gt;EnableCutPlane(true);\n                    } else {\n                        AIAC_APP.GetLayer&lt;AIAC::LayerFeedback&gt;()-&gt;EnableCutPlane(false);\n                    }\n                };\n            }\n            ImGui::SameLine();\n            if(ImGui::Checkbox(\"Show Cotas\", &amp;AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().IsShowingCotas)){\n                if(AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().IsShowingCotas){\n                    AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().UpdateCotasVisibility(true);\n                } else {\n                    AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().UpdateCotasVisibility(false);\n                }\n            }\n\n            if (auto feedback = dynamic_cast&lt;CutCircularSawFeedback*&gt;(AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;GetCurrentFabFeedback())){\n                ImGui::Checkbox(\"Manually Select Face\", &amp;feedback-&gt;IsRefFacesSelectedManually);\n                if (feedback-&gt;IsRefFacesSelectedManually) {\n                    if(ImGui::Button(\"&lt;##FaceSelect\", ImVec2(halfWidth-30, 0)))\n                    {\n                        feedback-&gt;ManuallyScrollRefFace(-1);\n                    }\n                    ImGui::SameLine();\n                    if (ImGui::Button(\"&gt;##FaceSelect\", ImVec2(halfWidth-30, 0)))\n                    {\n                        feedback-&gt;ManuallyScrollRefFace(1);\n                    }\n                }\n            }\n\n            if (auto feedback = dynamic_cast&lt;CutChainSawFeedback*&gt;(AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;GetCurrentFabFeedback())){\n                ImGui::Checkbox(\"Manually Select Face\", &amp;feedback-&gt;IsRefFacesSelectedManually);\n                if (feedback-&gt;IsRefFacesSelectedManually) {\n                    if(ImGui::Button(\"&lt;##FaceSelect\", ImVec2(halfWidth-30, 0)))\n                    {\n                        feedback-&gt;ManuallyScrollRefFace(-1);\n                    }\n                    ImGui::SameLine();\n                    if (ImGui::Button(\"&gt;##FaceSelect\", ImVec2(halfWidth-30, 0)))\n                    {\n                        feedback-&gt;ManuallyScrollRefFace(1);\n                    }\n                }\n            }\n\n\n            ImGui::PushStyleColor(ImGuiCol_CheckMark, AIAC_UI_LIGHT_GREEN);\n            if(ImGui::Checkbox(\"Mark as Done\", &amp;AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()-&gt;IsMarkedDone));\n            ImGui::PopStyleColor();\n            ImGui::SameLine();\n            if(ImGui::Checkbox(\"Show All Components\", &amp;AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().IsShowingAllComponents)){\n                if(AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().IsShowingAllComponents){\n                    AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().ShowAllComponents();\n                    AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().SetBboxVisibility(true);\n                    AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;DeactivateCurrentFeedbackVisibility();\n                } else {\n                    AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().HideAllComponentsExceptCurrent();\n                    AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().SetBboxVisibility(false);\n                    AIAC_APP.GetLayer&lt;LayerFeedback&gt;()-&gt;ActivateCurrentFeedbackVisibility();\n                }\n            }\n        ImGui::EndChild();\n\n        ImGui::Text(\"Scaling Factor Adjustment:\");\n        ImGui::BeginChild(\"adjust_model_scale_factor\", ImVec2(0, 90), true, ImGuiWindowFlags_HorizontalScrollbar);\n            ImGui::Text(\"ACIM BBox Length: %.2f\", AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetRealWorldLength() * 1000);\n            ImGui::SameLine();\n            ImGui::Text(\"/ Measured Length: %.2f\", AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetMeasuredBboxLength() * 1000);\n            sliderVal = 0.f;\n            ImGui::SliderFloat(\"## Adjust measured length\", &amp;sliderVal, -1e-3f, 1e-3f, \"Adjust measured length\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderVal != 0.f) AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().AddMeasuredBboxLength(sliderVal);\n\n            if(ImGui::Button(\"Confirm &amp; Close APP\")){\n                // restart APP\n                AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().AdjustScale();\n                *m_IsOpen = false;\n                AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;AppCloseEvent&gt;());\n            }\n        ImGui::EndChild();\n    }\n\n    void LayerUI::ShowSaveVideoRecorderFileDialog(){\n         ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x * 0.8, ImGui::GetIO().DisplaySize.y * 0.75));\n         if (ImGui::Button(\"Select Save Directory\")) {\n             ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseDirectoryDialog\", \"Choose Directory\", nullptr, \".\");\n         }\n\n         if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseDirectoryDialog\")) {\n             if (ImGuiFileDialog::Instance()-&gt;IsOk()) {\n                 std::string filePathName  = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n                 std::string filePath  = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n                 AIAC_APP.GetLayer&lt;AIAC::LayerUtils&gt;()-&gt;SetSaveFolderPath(filePathName);\n             }\n             ImGuiFileDialog::Instance()-&gt;Close();\n         }\n    }\n    void LayerUI::SetPaneUIUtils(){\n         ImGui::Text(\"Set Utils Folder:\");\n         ImGui::BeginChild(\"Set Utils Folder\", ImVec2(0, 60), true);\n             ShowSaveVideoRecorderFileDialog();\n             std::string displayedPath = AIAC_APP.GetLayer&lt;AIAC::LayerUtils&gt;()-&gt;GetSaveFolderPath();\n             ImGui::Text(\"Selected Path: %s\", displayedPath.c_str());\n         ImGui::EndChild();\n\n         ImGui::Text(\"Video Recorder:\");\n         ImGui::BeginChild(\"Video Recorder\", ImVec2(0, 100), true);\n             static bool isRecordingInProgress = false;\n             ImGui::Text(\"Recording: \");\n             ImGui::SameLine();\n             if(isRecordingInProgress){\n                 ImGui::TextColored(AIAC_UI_GREEN, \"Yes\");\n             } else {\n                 ImGui::TextColored(AIAC_UI_RED, \"No\");\n             }\n\n             ImGui::Text(\"Video is being processed: \");\n             ImGui::SameLine();\n             if(AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;IsProcessing()){\n                 ImGui::TextColored(AIAC_UI_GREEN, \"Yes\");\n             } else {\n                 ImGui::TextColored(AIAC_UI_RED, \"No\");\n             }\n\n             ImGui::Text(\"Video Recorder Controls: \");\n             if (ImGui::Button(\"Start Recording\"))\n             {\n                 if (!isRecordingInProgress &amp;&amp; !AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;IsProcessing())\n                 {\n                     isRecordingInProgress = true;\n                     AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;StartRecording();\n                 }\n             }\n             ImGui::SameLine();\n             if (ImGui::Button(\"Stop Recording\"))\n             {\n                 if (isRecordingInProgress &amp;&amp; !AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;IsProcessing())\n                 {\n                     isRecordingInProgress = false;\n                     AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;StopRecording();\n                 }\n             };\n         ImGui::EndChild();\n\n         ImGui::Text(\"Hole Toolhead Axis Exporter:\");\n         ImGui::BeginChild(\"Hole Toolhead Axis Exporter\", ImVec2(0, 42), true);\n             if (ImGui::Button(\"Export Hole Toolhead Coordinates\"))\n             {\n                 AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;ExportHoleToolheadAxis();\n             }\n         ImGui::EndChild();\n\n         ImGui::Text(\"Window Photo:\");\n         ImGui::BeginChild(\"Window Photo\", ImVec2(0, 42), true);\n         if (ImGui::Button(\"Take a window photo\"))\n         {\n             AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;SetWindowScreenshot(true);\n         }\n         ImGui::SameLine();\n         if (ImGui::Button(\"Take a colored buffer photo\"))\n         {\n             AIAC_APP.GetLayer&lt;LayerUtils&gt;()-&gt;TakeBufferScreenshot();\n         }\n         ImGui::EndChild();\n\n    }\n\n    void LayerUI::SetPaneUIToolhead()\n    {\n        ImGui::Text(\"Toolhead control:\");\n        ImGui::BeginChild(\"toolhead_pose_inputs\", ImVec2(0, 470), true, ImGuiWindowFlags_HorizontalScrollbar);\n\n            ImGui::PushStyleVar(ImGuiStyleVar_ButtonTextAlign, ImVec2(0.5, 0.5));\n\n            ImVec2 sizeShowToolHeadVisualsButton = ImVec2(-1, 60);\n            static bool isButtonVisualsPress = false;\n            std::string buttonVisualLabel = isButtonVisualsPress ? \"Show Silhouette\" : \"Hide Silhouette\";\n            if (!isButtonVisualsPress) \n            {\n                ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_HIBISCUS_RED);\n                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_HIBISCUS_RED);\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsShowSilouhette = true;\n            }\n            else\n            {\n                ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_YALE_BLUE);\n                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_YALE_BLUE);\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsShowSilouhette = false;\n            }\n            if (ImGui::Button(buttonVisualLabel.c_str(), sizeShowToolHeadVisualsButton))\n                isButtonVisualsPress = !isButtonVisualsPress;\n            ImGui::PopStyleColor(2);\n\n            ImVec2 sizeSquareButton = ImVec2(70, 70);\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_SEA_GREEN);\n            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_GREEN);\n            if(ImGui::Button(\"save \\npose\", sizeSquareButton))\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('y');\n            ImGui::SameLine();\n            ImGui::PopStyleColor(2);\n\n            static bool isButtonPressed = false;\n            std::string buttonLabel = isButtonPressed ? \"Stop \\nrefine\" : \"Start \\nrefine\";\n            if (!isButtonPressed) \n            {\n                ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_GRAPE_PURPLE);\n                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_GRAPE_PURPLE);\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ToolheadStateUI = -1;\n            }\n            else\n            {\n                ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_CARMINE_RED);\n                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_CARMINE_RED);\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ToolheadStateUI = 0;\n            }\n            if (ImGui::Button(buttonLabel.c_str(), sizeSquareButton))\n                isButtonPressed = !isButtonPressed;\n            ImGui::SameLine();\n            ImGui::PopStyleColor(2);\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_GREY);\n            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_LIGHT_GREY);\n            if(ImGui::Button(\"reset \\nlast \\npose\", sizeSquareButton))\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ResetToLastSavedPose();\n            ImGui::SameLine();\n            ImGui::PopStyleColor(2);\n\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_GREY);\n            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, AIAC_UI_LIGHT_GREY);\n            if(ImGui::Button(\"reset \\nconfig \\npose\", sizeSquareButton))\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ResetPoseFromConfig();\n            ImGui::PopStyleColor(2);\n\n            ImGui::PopStyleVar();\n\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(200, 15));\n            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 100);\n            ImGui::PushStyleVar(ImGuiStyleVar_GrabRounding, 5);\n            ImGui::PushItemWidth(-30);\n            float sliderF = 0.f;\n            ImGui::SliderFloat(\"Teq\", &amp;sliderF, -0.01f, 0.01f, \"&lt;backward T forward&gt;\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderF != 0.f)\n            {\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;SetModelManipulationTranslationScale(abs(sliderF));\n                if (sliderF &gt; 0.f)\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('e');\n                else\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('q');\n            }\n            sliderF = 0.f;\n            ImGui::SliderFloat(\"Tda\", &amp;sliderF, -0.01f, 0.01f, \"&lt;left T right&gt;\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderF != 0.f)\n            {\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;SetModelManipulationTranslationScale(abs(sliderF));\n                if (sliderF &gt; 0.f)\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('d');\n                else\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('a');\n            }\n            sliderF = 0.f;\n            ImGui::SliderFloat(\"Tws\", &amp;sliderF, -0.01f, 0.01f, \"&lt;down T up&gt;\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderF != 0.f)\n            {\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;SetModelManipulationTranslationScale(abs(sliderF));\n                if (sliderF &gt; 0.f)\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('w');\n                else\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('s');\n            }\n            sliderF = 0.f;\n            ImGui::SliderFloat(\"Rjl\", &amp;sliderF, -3.0f, 3.0f, \"&lt;left R right&gt;\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderF != 0.f)\n            {\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;SetModelManipulationRotationScale(abs(sliderF));\n                if (sliderF &gt; 0.f)\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('j');\n                else\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('l');\n            }\n            sliderF = 0.f;\n            ImGui::SliderFloat(\"Rik\", &amp;sliderF, -3.0f, 3.0f, \"&lt;down R up&gt;\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderF != 0.f)\n            {\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;SetModelManipulationRotationScale(abs(sliderF));\n                if (sliderF &gt; 0.f)\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('i');\n                else\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('k');\n            }\n            sliderF = 0.f;\n            ImGui::SliderFloat(\"Ruo\", &amp;sliderF, -3.0f, 3.0f, \"&lt;backward R forward&gt;\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderF != 0.f)\n            {\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;SetModelManipulationRotationScale(abs(sliderF));\n                if (sliderF &gt; 0.f)\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('u');\n                else\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;TTool-&gt;ManipulateModel('o');\n            }\n            ImGui::PopStyleVar(3);\n            ImGui::PopItemWidth();\n        ImGui::EndChild();\n\n        ImGui::Text(\"Tools graphics:\");\n            ImGui::BeginChild(\"toolhead_graphics\", ImVec2(-1, 40));\n\n#ifdef ENABLE_DEV_UI\n            if(ImGui::Checkbox(\"Draw Shaded\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsShowShaded));\n            if(ImGui::Checkbox(\"Draw Toolhead GOData\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsShowToolheadGOInfo))\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()-&gt;SetVisibility(AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsShowToolheadGOInfo);\n#endif\n        ImGui::EndChild();\n\n#ifdef ENABLE_DEV_UI\n        ImGui::Text(\"Toolhead Classifier:\");\n        ImGui::BeginChild(\"toolhead_classifier\", ImVec2(0, 300), true, ImGuiWindowFlags_HorizontalScrollbar);\n            if(ImGui::Button(\"Detect Toolhead\", ImVec2(-1, 40)))\n                AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;DetectToolhead();\n            std::string classifierLog = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;GetClassifierLog();\n            ImGui::BeginChild(\"toolhead_selection_ml\", ImVec2(0, 150), true, ImGuiWindowFlags_HorizontalScrollbar);\n                std::vector&lt;std::string&gt; toolheadNamesML;\n                for (auto&amp; toolhead : AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;GetClassifierToolheadList())\n                    toolheadNamesML.emplace_back(toolhead);\n                for (int i = 0; i &lt; toolheadNamesML.size(); i++)\n                {\n                    auto toolNameButton = ImGui::Button(toolheadNamesML[i].c_str());\n                    if (toolNameButton)\n                    {\n                        AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;SetCurrentObject(toolheadNamesML[i]);\n                    }\n                }\n            ImGui::EndChild();\n            ImGui::Text(\"Classifier Log: \\n%s\", classifierLog.c_str());\n        ImGui::EndChild();\n#endif\n\n#ifdef ENABLE_DEV_UI\n        std::string poseLogButtonText = \"Log TTool Pose\";\n        bool deferPoseLogUI = false;\n        if(AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsSavePoseLog)\n        {\n            deferPoseLogUI = true;\n            poseLogButtonText = \"Stop Log TTool Pose\";\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_GREEN);\n            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, AIAC_UI_GREEN);\n            ImGui::PushStyleColor(ImGuiCol_ButtonActive, AIAC_UI_GREEN);\n        }\n        if (ImGui::Button(poseLogButtonText.c_str(), ImVec2(-1, 40)))\n            AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsSavePoseLog = !AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsSavePoseLog;\n        if (deferPoseLogUI)\n        {\n            ImGui::PopStyleColor(3);\n        }\n#endif\n\n        // selection of toolhead\n        float windowHeigh = ImGui::GetWindowHeight();\n        float availableHeight = ImGui::GetContentRegionAvail().y;\n        std::string toolheadNameActive = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolheadName();\n        std::vector&lt;std::string&gt; toolheadNames;\n        for (auto&amp; toolhead : AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetToolheadNames())\n            toolheadNames.emplace_back(toolhead);\n        int numbButtonPerRow = 4;\n        ImVec2 sizeButton = ImVec2(80, 80);\n        int totalHeight = toolheadNames.size() / numbButtonPerRow * sizeButton.y;\n\n        ImGui::Text(\"Active toolhead: %s\", toolheadNameActive.c_str());\n        ImGui::BeginChild(\n            \"toolhead_selection\",\n            ImVec2(0, totalHeight+sizeButton.y+30),\n            false,\n            ImGuiWindowFlags_NoScrollbar\n        );\n            for (int i = 0; i &lt; toolheadNames.size(); i++)\n            {\n                if (i % numbButtonPerRow != 0)\n                    ImGui::SameLine();\n\n                std::string label = toolheadNames[i];\n                int charPerLine = sizeButton.x / 10;\n                for (int j = label.length() - 1; j &gt; 0; j--)\n                {\n                    if (j % charPerLine == 0)\n                    {\n                        label.insert(j, \"\\n\");\n                    }\n                }\n\n                ImVec4 buttonClr = AIAC_UI_DARK_GREY;\n                ACToolHeadType toolheadType = AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetToolheadType(toolheadNames[i]);\n                if (toolheadType == ACToolHeadType::DRILLBIT)\n                    ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_PURPLE);\n                else if (toolheadType == ACToolHeadType::CIRCULARSAW)\n                    ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_DARK_GREEN);\n                else if (toolheadType == ACToolHeadType::SABERSAW)\n                    ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_GREY);\n                else if (toolheadType == ACToolHeadType::CHAINSAW)\n                    ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_LIGHT_BLUE);\n                else if (label == toolheadNameActive)\n                    ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_SPARK_ORANGE);\n                else\n                    ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_DARK_GREY);\n\n                if (ImGui::Button(label.c_str(), sizeButton))\n                    AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;SetCurrentObject(toolheadNames[i]);\n\n                ImGui::PopStyleColor();\n            }\n        ImGui::EndChild();\n    }\n\n    void LayerUI::OnCollapsingPaneUIToolhead(){\n        AIAC_APP.GetLayer&lt;AIAC::LayerToolhead&gt;()-&gt;IsShowSilouhette = false;\n    }\n\n    void LayerUI::ShowMappingPopup()\n    {\n        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y));\n        ImGui::SetNextWindowPos(ImVec2(0, 0));\n        ImGui::Begin(\"Mapping\", nullptr, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize);\n\n            CvtGlTextureObj2ImTexture(AIAC_APP.GetRenderer()-&gt;GetMappingView(), m_MappingViewImTexture);\n            // TODO: use config to store the size, and set glViewPort before rendering\n            ImGui::ImageButton(m_MappingViewImTexture.ID, ImVec2(600, 442), ImVec2(0, 1), ImVec2(1, 0), 0, ImColor(255, 255, 255, 128));\n\n            ImGui::SameLine();\n            ImGui::BeginChild(\"mapping_info_child\", ImVec2(0, 0), false);\n                // First part - global view\n                ImVec2 sideBarViewportSize = ImGui::GetContentRegionAvail();\n                ImGui::BeginChild(\"global_view\", ImVec2(sideBarViewportSize.x, sideBarViewportSize.x * 3 / 4 + 20), true);\n                    ImVec2 viewportSize = ImGui::GetContentRegionAvail();\n                    viewportSize = ImVec2(viewportSize.x, viewportSize.y - 24);\n                    AIAC_APP.GetRenderer()-&gt;SetGlobalViewSize(viewportSize.x, viewportSize.y);\n                    SetGlobalViewUI(viewportSize);\n                ImGui::EndChild();\n\n                // Second part - mapping info\n                // sideBarViewportSize = ImGui::GetContentRegionAvail();\n                // ImGui::BeginChild(\"mapping_info\", ImVec2(sideBarViewportSize.x, 0), true);\n                //     ImGui::Text(\"Map Points: %u\", AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.getMap()-&gt;map_points.size());\n                //     ImGui::Text(\"Map Markers: %lu\", AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.getMap()-&gt;map_markers.size());\n                // ImGui::EndChild();\n\n                // Third part - mapping menu for adjusting params\n                sideBarViewportSize = ImGui::GetContentRegionAvail();\n                ImGui::BeginChild(\"mapping_menu\", ImVec2(sideBarViewportSize.x, sideBarViewportSize.y - 48), true);\n                    ImGui::Text(\"Save Path:\");\n                    ImGui::InputText(\"## Map Saving Path\", m_MappingParams.MapSavingPath, PATH_BUF_SIZE, ImGuiInputTextFlags_AutoSelectAll);\n                    ImGui::SameLine();\n                    if(ImGui::Button(\".\", ImVec2(0, 0))){\n                        // m_IsSavingMap = true;\n                        OpenFileSelectDialog(\"Choose Save Map Path\", \".map\", m_MappingParams.MapSavingPath);\n                    }\n                    ImGui::Checkbox(\"Optimize Map\", &amp;m_MappingParams.ToOptimizeMap);\n                    ImGui::Checkbox(\"Save Map\", &amp;m_MappingParams.ToSaveMap);\n\n                    ImGui::Text(\"--------------------\");\n                    ImGui::Text(\"Reconstruct Params:\");\n                    float sliderValFloat = 0.f;\n                    int sliderValInt = 0;\n\n                    sliderValFloat = 0.f;\n                    ImGui::SliderFloat(\"## Radius Search\", &amp;sliderValFloat, -1.0f, 1.0f, \"Radius Search\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValFloat != 0.f) m_ReconstructParams.RadiusSearch += sliderValFloat;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1f\", m_ReconstructParams.RadiusSearch);\n\n                    sliderValFloat = 0.f;\n                    ImGui::SliderFloat(\"## Crease Angle Threshold\", &amp;sliderValFloat, -1.0f, 1.0f, \"Crease Angle Threshold\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValFloat != 0.f) m_ReconstructParams.CreaseAngleThreshold += sliderValFloat;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1f\", m_ReconstructParams.CreaseAngleThreshold);\n\n                    sliderValInt = 0;\n                    ImGui::SliderInt(\"## Min Cluster Size\", &amp;sliderValInt, -3, 3, \"Min Cluster Size\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValInt != 0) m_ReconstructParams.MinClusterSize += sliderValInt;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%d\", m_ReconstructParams.MinClusterSize);\n\n                    sliderValFloat = 0.f;\n                    ImGui::SliderFloat(\"## Max Pln Dist\", &amp;sliderValFloat, -1.0f, 1.0f, \"Max Pln Dist\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValFloat != 0.f) m_ReconstructParams.MaxPlnDist += sliderValFloat;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1f\", m_ReconstructParams.MaxPlnDist);\n\n                    sliderValFloat = 0.f;\n                    ImGui::SliderFloat(\"## Max Pln Angle\", &amp;sliderValFloat, -1.0f, 1.0f, \"Max Pln Angle\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValFloat != 0.f) m_ReconstructParams.MaxPlnAngle += sliderValFloat;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1f\", m_ReconstructParams.MaxPlnAngle);\n\n                    sliderValFloat = 0.f;\n                    ImGui::SliderFloat(\"## AABB Scale Factor\", &amp;sliderValFloat, -1.0f, 1.0f, \"AABB Scale Factor\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValFloat != 0.f) m_ReconstructParams.AABBScaleFactor += sliderValFloat;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1f\", m_ReconstructParams.AABBScaleFactor);\n\n                    sliderValFloat = 0.f;\n                    ImGui::SliderFloat(\"## Max Poly Dist\", &amp;sliderValFloat, -1.0f, 1.0f, \"Max Poly Dist\", ImGuiSliderFlags_AlwaysClamp);\n                    if (sliderValFloat != 0.f) m_ReconstructParams.MaxPolyDist += sliderValFloat;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1f\", m_ReconstructParams.MaxPolyDist);\n\n                    sliderValFloat = 0.f;\n                    ImGui::PushItemWidth(-54);\n                    ImGui::SliderFloat(\"## Eps\", &amp;sliderValFloat, -1.0f, 1.0f, \"Eps\", ImGuiSliderFlags_AlwaysClamp);\n                    ImGui::PopItemWidth();\n                    if (sliderValFloat &gt; 0.f) m_ReconstructParams.Eps *= 2;\n                    else if (sliderValFloat &lt; 0.f) m_ReconstructParams.Eps /= 2;\n                    ImGui::SameLine();\n                    ImGui::Text(\"%.1e\", m_ReconstructParams.Eps);\n\n                ImGui::EndChild();\n                if(ImGui::Button(\"Discard\", ImVec2(ImGui::GetContentRegionAvail().x, 40))){\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMStopMappingEvent&gt;(\n                        false,\n                        m_MappingParams.MapSavingPath,\n                        false,\n                        m_ReconstructParams.RadiusSearch,\n                        m_ReconstructParams.CreaseAngleThreshold,\n                        m_ReconstructParams.MinClusterSize,\n                        m_ReconstructParams.AABBScaleFactor,\n                        m_ReconstructParams.MaxPolyDist,\n                        m_ReconstructParams.MaxPlnDist,\n                        m_ReconstructParams.MaxPlnAngle,\n                        m_ReconstructParams.Eps\n                    ));\n                }\n                if(ImGui::Button(\"Save &amp; Exit\", ImVec2(ImGui::GetContentRegionAvail().x, 40))){\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMStopMappingEvent&gt;(\n                        m_MappingParams.ToSaveMap,\n                        m_MappingParams.MapSavingPath,\n                        m_MappingParams.ToOptimizeMap,\n                        m_ReconstructParams.RadiusSearch,\n                        m_ReconstructParams.CreaseAngleThreshold,\n                        m_ReconstructParams.MinClusterSize,\n                        m_ReconstructParams.AABBScaleFactor,\n                        m_ReconstructParams.MaxPolyDist,\n                        m_ReconstructParams.MaxPlnDist,\n                        m_ReconstructParams.MaxPlnAngle,\n                        m_ReconstructParams.Eps\n                    ));\n                }\n            ImGui::EndChild();\n\n            if (ImGui::BeginPopupContextWindow())\n            {\n                if (ImGui::Selectable(\"Clear\"))\n                {\n                }\n                ImGui::EndPopup();\n            }\n        ImGui::End();\n    }\n\n    void LayerUI::ShowCamCalibPopup()\n    {\n        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x, ImGui::GetIO().DisplaySize.y));\n        ImGui::SetNextWindowPos(ImVec2(0, 0));\n        ImGui::Begin(\"Camera Calibration\", nullptr, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize);\n\n        CvtGlTextureObj2ImTexture(AIAC_APP.GetRenderer()-&gt;GetCamCalibView(), m_CamCalibViewImTexture);\n        ImGui::ImageButton(m_CamCalibViewImTexture.ID, ImVec2(600, 442), ImVec2(0, 1), ImVec2(1, 0), 0, ImColor(255, 255, 255, 128));\n\n        ImGui::SameLine();\n        ImGui::BeginChild(\"cam_calib_info_child\", ImVec2(0, 0), false); {\n            ImVec2 sideBarViewportSize = ImGui::GetContentRegionAvail();\n            ImGui::BeginChild(\"calib_param\", ImVec2(sideBarViewportSize.x, 132), true);\n            {\n                ImGui::Text(\"Board Size:\");\n\n                ImGui::Text(\"Width\");\n                ImGui::SameLine();\n                ImGui::InputInt(\"Board Width\",\n                                &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;GetCameraCalibrator().boardSize.width);\n\n                ImGui::Text(\"Height\");\n                ImGui::SameLine();\n                ImGui::InputInt(\"Board Height\",\n                                &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;GetCameraCalibrator().boardSize.height);\n\n                ImGui::Text(\"Square Size\");\n                ImGui::SameLine();\n                ImGui::InputFloat(\" Square Size\",\n                                  &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;GetCameraCalibrator().squareSize);\n\n                ImGui::Checkbox(\"Use Fisheye\",\n                                &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;GetCameraCalibrator().useFisheye);\n\n            } ImGui::EndChild();\n            ImGui::BeginChild(\"capture_setting\", ImVec2(sideBarViewportSize.x, 108), true);\n            {\n                ImGui::Checkbox(\"Auto Capture\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;AutoCapture);\n\n                ImGui::Text(\"Delay\");\n                ImGui::SameLine();\n                ImGui::InputInt(\"Delay\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;Delay);\n\n                ImGui::Text(\"Num of Frames\");\n                ImGui::SameLine();\n                ImGui::InputInt(\"Num Of Frame\", &amp;AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;NumOfFrame);\n\n                stringstream ss;\n                if (AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;IsCapturing()) {\n                    ss &lt;&lt; \"Capturing: \"\n                        &lt;&lt; AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;GetCameraCalibrator().GetImageAmount() &lt;&lt; \"/\"\n                        &lt;&lt; AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;NumOfFrame;\n                } else {\n                    ss &lt;&lt; \"Click Start to Capture\";\n                }\n                ImGui::Text(\"%s\", ss.str().c_str());\n\n            }ImGui::EndChild();\n            sideBarViewportSize = ImGui::GetContentRegionAvail();\n            ImGui::BeginChild(\"menu\", sideBarViewportSize, true);\n            {\n                // Save Path\n                if(ImGui::Button(\"&gt;\")){\n                    m_IsChoosingCamCalibFileSavePath = true;\n                }\n                ImGui::SameLine();\n                char tmpSavePath[PATH_BUF_SIZE];\n                strcpy(tmpSavePath, AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;SaveFilename.c_str());\n                ImGui::InputText(\"Save Path\", tmpSavePath, PATH_BUF_SIZE);\n                AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;SaveFilename = tmpSavePath;\n\n                if(ImGui::Button(\"Start\")){\n                    AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;StartCapturing();\n                }\n                ImGui::SameLine();\n                if(ImGui::Button(\"Exit\")){\n                    AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;StopCalibration();\n                }\n            } ImGui::EndChild();\n        } ImGui::EndChild();\n\n        ImGui::End();\n    }\n\n    void LayerUI::ShowCombineMapPopup()\n    {\n//        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x * 0.3, ImGui::GetIO().DisplaySize.y * 0.3));\n\n        ImGui::Begin(\"Combine map\", nullptr);\n            ImGui::PushItemWidth(-1);\n\n            ImGui::Text(\"Select File:\");\n            if(ImGui::Button(\"Map 1\", ImVec2(60, 0))){\n                OpenFileSelectDialog(\"Select input map 1 path\", \".map\", m_CombMapParams.MapPathA);\n            }\n            ImGui::SameLine();\n            ImGui::InputText(\"In Map 1\", m_CombMapParams.MapPathA, PATH_BUF_SIZE, ImGuiInputTextFlags_AutoSelectAll);\n\n            if(ImGui::Button(\"Map 2\", ImVec2(60, 0))){\n                OpenFileSelectDialog(\"Select input map 2 path\", \".map\", m_CombMapParams.MapPathB);\n            }\n            ImGui::SameLine();\n            ImGui::InputText(\"In Map 2\", m_CombMapParams.MapPathB, PATH_BUF_SIZE, ImGuiInputTextFlags_AutoSelectAll);\n\n            if(ImGui::Button(\"Output\", ImVec2(60, 0))){\n                OpenFileSelectDialog(\"Select export map path\", \".map\", m_CombMapParams.OutputPath);\n            }\n            ImGui::SameLine();\n            ImGui::InputText(\"In Output Path\", m_CombMapParams.OutputPath, PATH_BUF_SIZE, ImGuiInputTextFlags_AutoSelectAll);\n            ImGui::PopItemWidth();\n\n            ImGui::Text(\" \");\n            ImGui::Text(\" \");\n            ImGui::SameLine(ImGui::GetWindowWidth() - 176);\n            if(ImGui::Button(\"Cancel\", ImVec2(80, 0))){ m_IsCombiningMap = false; }\n            ImGui::SameLine();\n            if(ImGui::Button(\"Confirm\", ImVec2(80, 0))){\n                if(strlen(m_CombMapParams.MapPathA) == 0 || strlen(m_CombMapParams.MapPathB) == 0){\n                    AIAC_ERROR(\"Path not selected.\");\n                } else {\n                    AIAC_EBUS-&gt;EnqueueEvent(std::make_shared&lt;SLAMCombineMapEvent&gt;(\n                            m_CombMapParams.MapPathA,\n                            m_CombMapParams.MapPathB,\n                            m_CombMapParams.OutputPath,\n                            50,\n                            m_ReconstructParams.RadiusSearch,\n                            m_ReconstructParams.CreaseAngleThreshold,\n                            m_ReconstructParams.MinClusterSize,\n                            m_ReconstructParams.AABBScaleFactor,\n                            m_ReconstructParams.MaxPolyDist,\n                            m_ReconstructParams.MaxPlnDist,\n                            m_ReconstructParams.MaxPlnAngle,\n                            m_ReconstructParams.Eps\n                    ));\n\n                    memset(m_CombMapParams.MapPathA, 0, PATH_BUF_SIZE);\n                    memset(m_CombMapParams.MapPathB, 0, PATH_BUF_SIZE);\n                    memset(m_CombMapParams.OutputPath, 0, PATH_BUF_SIZE);\n                    m_IsCombiningMap = false;\n                }\n            }\n\n        ImGui::End();\n    }\n\n    void LayerUI::ShowReconstruct3DPopup()\n    {\n        ImGui::Begin(\"Reconstruct 3D\", nullptr);\n            ImGui::Text(\"Select Path:\");\n            if(ImGui::Button(\"Import .yml\", ImVec2(84, 0))){\n                OpenFileSelectDialog(\"Select map path\", \".yml\", m_ReconstructParams.TagMapPath);\n            }\n            ImGui::SameLine();\n            ImGui::InputText(\"## Tag Map Path\", m_ReconstructParams.TagMapPath, PATH_BUF_SIZE, ImGuiInputTextFlags_AutoSelectAll);\n            if(ImGui::Button(\"Export .ply\", ImVec2(84, 0))){\n                OpenFileSelectDialog(\"Select export .ply path\", \".ply\", m_ReconstructParams.ExportPath);\n            }\n            ImGui::SameLine();\n            ImGui::InputText(\"## Export Path\", m_ReconstructParams.ExportPath, PATH_BUF_SIZE, ImGuiInputTextFlags_AutoSelectAll);\n\n            ImGui::PushItemWidth(-54);\n\n            ImGui::Text(\"Reconstruct Params\");\n            ImGui::SameLine();\n            if(ImGui::Button(\"Load from file\", ImVec2(106, 0)))\n            {\n                std::string defaultConfigDir = AIAC::Config::Get&lt;std::string&gt;(\n                    AIAC::Config::SEC_TSLAM,\n                    AIAC::Config::RECONSTRUCT_CONFIG_DEFAULT_FILE,\n                    \"assets/tslam/reconstruct_default.ini\");\n                if (!defaultConfigDir.empty()) {\n                    AIAC_INFO(\"Default config for reconstruction dir: \");\n                    AIAC_INFO(defaultConfigDir);\n                    const char* defaultConfigDirCStr = defaultConfigDir.c_str();\n                    this-&gt;m_TmpPathBuf[0] = '\\0';\n                    strcpy(this-&gt;m_TmpPathBuf, defaultConfigDirCStr);\n                }\n                else\n                    AIAC_WARN(\"Default config for reconstruction dir is empty.\");\n\n                AIAC_INFO(\"TmpPathBuf1: \");\n                AIAC_INFO(this-&gt;m_TmpPathBuf);\n\n                OpenFileSelectDialog(\"Load Reconstruction Parameter\", \".ini\", m_TmpPathBuf, [&amp;]\n                {\n                    AIAC_INFO(\"TmpPathBuf2: \");\n                    AIAC_INFO(this-&gt;m_TmpPathBuf);\n\n                    LoadReconstructParamsFromFile(m_TmpPathBuf);\n                });\n            }\n            float sliderValFloat = 0.f;\n            int sliderValInt = 0;\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\" (2.0)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## Radius Search\", &amp;sliderValFloat, -1.0f, 1.0f, \"Radius Search\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValFloat != 0.f) m_ReconstructParams.RadiusSearch += sliderValFloat;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1f\", m_ReconstructParams.RadiusSearch);\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\" (5.0)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## Crease Angle Threshold\", &amp;sliderValFloat, -1.0f, 1.0f, \"Crease Angle Threshold\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValFloat != 0.f) m_ReconstructParams.CreaseAngleThreshold += sliderValFloat;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1f\", m_ReconstructParams.CreaseAngleThreshold);\n\n            sliderValInt = 0;\n            ImGui::Text(\"  (1) \");\n            ImGui::SameLine();\n            ImGui::SliderInt(\"## Min Cluster Size\", &amp;sliderValInt, -3, 3, \"Min Cluster Size\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValInt != 0) m_ReconstructParams.MinClusterSize += sliderValInt;\n            ImGui::SameLine();\n            ImGui::Text(\"%d\", m_ReconstructParams.MinClusterSize);\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\" (1.0)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## Max Pln Dist\", &amp;sliderValFloat, -1.0f, 1.0f, \"Max Pln Dist\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValFloat != 0.f) m_ReconstructParams.MaxPlnDist += sliderValFloat;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1f\", m_ReconstructParams.MaxPlnDist);\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\" (5.0)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## Max Pln Angle\", &amp;sliderValFloat, -1.0f, 1.0f, \"Max Pln Angle\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValFloat != 0.f) m_ReconstructParams.MaxPlnAngle += sliderValFloat;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1f\", m_ReconstructParams.MaxPlnAngle);\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\" (1.1)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## AABB Scale Factor\", &amp;sliderValFloat, -1.0f, 1.0f, \"AABB Scale Factor\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValFloat != 0.f) m_ReconstructParams.AABBScaleFactor += sliderValFloat;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1f\", m_ReconstructParams.AABBScaleFactor);\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\" (1.0)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## Max Poly Dist\", &amp;sliderValFloat, -1.0f, 1.0f, \"Max Poly Dist\", ImGuiSliderFlags_AlwaysClamp);\n            if (sliderValFloat != 0.f) m_ReconstructParams.MaxPolyDist += sliderValFloat;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1f\", m_ReconstructParams.MaxPolyDist);\n\n            sliderValFloat = 0.f;\n            ImGui::Text(\"(1e-5)\");\n            ImGui::SameLine();\n            ImGui::SliderFloat(\"## Eps\", &amp;sliderValFloat, -1.0f, 1.0f, \"Eps\", ImGuiSliderFlags_AlwaysClamp);\n            ImGui::PopItemWidth();\n            if (sliderValFloat &gt; 0.f) m_ReconstructParams.Eps *= 2;\n            else if (sliderValFloat &lt; 0.f) m_ReconstructParams.Eps /= 2;\n            ImGui::SameLine();\n            ImGui::Text(\"%.1e\", m_ReconstructParams.Eps);\n\n\n            ImGui::Text(\" \");\n            ImGui::Text(\" \");\n            ImGui::SameLine(ImGui::GetWindowWidth() - 180);\n            if(ImGui::Button(\"Cancel\", ImVec2(80, 0))){ m_IsReconstructing3D = false; }\n            ImGui::SameLine();\n            if(ImGui::Button(\"Confirm\", ImVec2(80, 0))){\n                if(strlen(m_ReconstructParams.TagMapPath) == 0 || strlen(m_ReconstructParams.ExportPath) == 0){\n                    AIAC_ERROR(\"Path not selected.\");\n                } else {                    \n                    // Reconstruct 3D\n                    bool isReconstructed = AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.Reconstruct3DModelAndExportPly(\n                        m_ReconstructParams.TagMapPath,\n                        m_ReconstructParams.ExportPath,\n                        m_ReconstructParams.RadiusSearch,\n                        m_ReconstructParams.CreaseAngleThreshold,\n                        m_ReconstructParams.MinClusterSize,\n                        m_ReconstructParams.AABBScaleFactor,\n                        m_ReconstructParams.MaxPolyDist,\n                        m_ReconstructParams.MaxPlnDist,\n                        m_ReconstructParams.MaxPlnAngle,\n                        m_ReconstructParams.Eps\n                    );\n\n                    // Load reconstructed 3D model\n                    if(isReconstructed) AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;LoadScannedModel(m_ReconstructParams.ExportPath);\n                    else AIAC_WARN(\"Reconstruction failed, skip loading the model\");\n\n                    // memset(m_ReconstructParams.TagMapPath, 0, PATH_BUF_SIZE);\n                    // memset(m_ReconstructParams.ExportPath, 0, PATH_BUF_SIZE);\n                    m_IsReconstructing3D = false;\n                }\n            }\n\n        ImGui::End();\n    }\n\n    // FIXME: This should not be here, the LayerUI should only handle visualization, not logic\n    void LayerUI::LoadReconstructParamsFromFile(const char *filePath){\n        inih::INIReader reader(filePath);\n        auto section = \"Reconstruction Parameters\";\n        m_ReconstructParams.RadiusSearch = reader.Get&lt;float&gt;(section, \"RadiusSearch\");\n        m_ReconstructParams.CreaseAngleThreshold = reader.Get&lt;float&gt;(section, \"CreaseAngleThreshold\");\n        m_ReconstructParams.MinClusterSize = reader.Get&lt;int&gt;(section, \"MinClusterSize\");\n        m_ReconstructParams.AABBScaleFactor = reader.Get&lt;float&gt;(section, \"AABBScaleFactor\");\n        m_ReconstructParams.MaxPolyDist = reader.Get&lt;float&gt;(section, \"MaxPolyDist\");\n        m_ReconstructParams.MaxPlnDist = reader.Get&lt;float&gt;(section, \"MaxPlnDist\");\n        m_ReconstructParams.MaxPlnAngle = reader.Get&lt;float&gt;(section, \"MaxPlnAngle\");\n        m_ReconstructParams.Eps = reader.Get&lt;float&gt;(section, \"Eps\");\n    }\n\n    void LayerUI::ShowSaveCamCalibFileDialog()\n    {\n        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x * 0.8, ImGui::GetIO().DisplaySize.y * 0.75));\n        ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseSaveCalibFilePath\", \"Choose calib file path\", \".yml\", \".\");\n        if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseSaveCalibFilePath\"))\n        {\n            if (ImGuiFileDialog::Instance()-&gt;IsOk())\n            {\n                std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n                std::string filePath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n\n                AIAC_INFO(\"Saving calib file to {0}\", filePathName.c_str());\n                AIAC_APP.GetLayer&lt;AIAC::LayerCameraCalib&gt;()-&gt;SetSaveFilename(filePathName);\n            }\n            ImGuiFileDialog::Instance()-&gt;Close();\n            m_IsChoosingCamCalibFileSavePath = false;\n        }\n    }\n\n    void LayerUI::OpenFileSelectDialog(const char* title, const char* fileExt, char *path, std::function&lt;void()&gt; callback) {\n        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x * 0.8, ImGui::GetIO().DisplaySize.y * 0.75));\n        if (strlen(path) == 0) {\n            ImGuiFileDialog::Instance()-&gt;OpenDialog(\"SelectFileDialog\", title, fileExt, m_FileSelectDefaultPath);\n        }\n        else {\n            char* pathBuf = new char[PATH_BUF_SIZE];\n            memset(pathBuf, 0, PATH_BUF_SIZE);\n            memcpy(pathBuf, path, strlen(path));\n            ImGuiFileDialog::Instance()-&gt;OpenDialog(\"SelectFileDialog\", title, fileExt, pathBuf);\n            ImGuiFileDialog::Instance()-&gt;OpenDialog(\"SelectFileDialog\", title, fileExt, path);\n        }\n        m_FileSelectionTargetBuf = path;\n        m_FileSelectionCallback = callback;\n    }\n\n    void LayerUI::ShowFileSelectDialog(){\n        if (ImGuiFileDialog::Instance()-&gt;Display(\"SelectFileDialog\")) {\n            if (ImGuiFileDialog::Instance()-&gt;IsOk()) {\n                std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n                AIAC_INFO(\"Select: {0}\", filePathName.c_str());\n                memset(m_FileSelectionTargetBuf, 0, PATH_BUF_SIZE);\n                memcpy(m_FileSelectionTargetBuf, filePathName.c_str(), filePathName.length());\n\n                if(m_FileSelectionCallback) m_FileSelectionCallback();\n            }\n            ImGuiFileDialog::Instance()-&gt;Close();\n        }\n        m_FileSelectDefaultPath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n        if (m_FileSelectDefaultPath[m_FileSelectDefaultPath.length()-1] != '/') {\n            m_FileSelectDefaultPath += \"/\";\n        };\n    }\n\n    void LayerUI::ShowLogRecorderUI() {\n        ImGui::Begin(\"Log Recorder\", m_IsOpen);\n        if (!AIAC_APP.GetLayer&lt;AIAC::LayerLogRecorder&gt;()-&gt;IsRecording()){\n//            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_GREEN);\n            if(ImGui::Button(\"Start\", ImVec2(-1, 40))){\n                AIAC_APP.GetLayer&lt;AIAC::LayerLogRecorder&gt;()-&gt;StartRecording();\n            }\n//            ImGui::PopStyleColor();\n        } else {\n            ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_RED);\n            if(ImGui::Button(\"Stop\", ImVec2(-1, 40))){\n                AIAC_APP.GetLayer&lt;AIAC::LayerLogRecorder&gt;()-&gt;StopRecording();\n            }\n            ImGui::PopStyleColor();\n\n            if(AIAC_APP.GetLayer&lt;AIAC::LayerLogRecorder&gt;()-&gt;IsPaused()) {\n                ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_YELLOW);\n                if(ImGui::Button(\"Resume\", ImVec2(-1, 40))){\n                    AIAC_APP.GetLayer&lt;AIAC::LayerLogRecorder&gt;()-&gt;ResumeRecording();\n                }\n                ImGui::PopStyleColor();\n            } else {\n                ImGui::PushStyleColor(ImGuiCol_Button, AIAC_UI_GREY);\n                if(ImGui::Button(\"Pause\", ImVec2(-1, 40))) {\n                    AIAC_APP.GetLayer&lt;AIAC::LayerLogRecorder&gt;()-&gt;PauseRecording();\n                }\n                ImGui::PopStyleColor();\n            }\n        }\n        ImGui::End();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerUI_8h/","title":"File LayerUI.h","text":"<p>FileList &gt; AIAC &gt; LayerUI.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/Image.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"Config.h\"</code></li> <li><code>#include \"tslam.h\"</code></li> <li><code>#include \"GlHeader.h\"</code></li> <li><code>#include \"AIAC/UI/ImGuiFileDialog.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerUI_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerUI_8h/#classes","title":"Classes","text":"Type Name class LayerUI class PaneUI"},{"location":"acdoxygen/LayerUI_8h/#macros","title":"Macros","text":"Type Name define PATH_BUF_SIZE <code>200</code>"},{"location":"acdoxygen/LayerUI_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/LayerUI_8h/#define-path_buf_size","title":"define PATH_BUF_SIZE","text":"<pre><code>#define PATH_BUF_SIZE `200`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUI.h</code></p>"},{"location":"acdoxygen/LayerUI_8h_source/","title":"File LayerUI.h","text":"<p>File List &gt; AIAC &gt; LayerUI.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;utility&gt;\n\n#include \"AIAC/Layer.h\"\n\n#include \"AIAC/Image.h\"\n#include \"AIAC/Log.h\"\n#include \"Config.h\"\n\n#include \"tslam.h\"\n#include \"GlHeader.h\"\n#include \"AIAC/UI/ImGuiFileDialog.h\"\n\n#define PATH_BUF_SIZE 200\n\nnamespace AIAC {\n\n    class PaneUI {\n    public:\n        enum CollapseState {\n            OPEN,\n            ON_COLLAPSING,\n            COLLAPSE\n        };\n\n        typedef std::function&lt;void()&gt; Func;\n\n        PaneUI(const char *label, bool isCollapsed, Func func, Func onCollapseCallback=[]{})\n                : m_Label(label), m_IsCollapsed(isCollapsed), m_func(std::move(func)), m_onCollapseCallback(std::move(onCollapseCallback)) {\n            if (m_IsCollapsed) m_CollapseState = CollapseState::COLLAPSE;\n            else m_CollapseState = CollapseState::OPEN;\n        }\n\n        template&lt;typename... Args&gt;\n        void Show(Args &amp;&amp;... args);\n\n        template&lt;typename... Args&gt;\n        void CheckOnCollapsing(Args &amp;&amp;... args);\n\n    private:\n        CollapseState m_CollapseState;\n        Func m_func;\n        Func m_onCollapseCallback;\n        const char *m_Label;\n        bool m_IsCollapsed;\n    };\n\n    class LayerUI : public AIAC::Layer {\n    public:\n        LayerUI() = default;\n        virtual ~LayerUI() = default;\n\n        virtual void OnAttach() override;\n        virtual void OnFrameStart() override;\n        void OnUIRender();\n        virtual void OnDetach() override;\n\n        void ShowMenuBar();\n        void ShowMainUI();\n        void ShowSceneViewport();\n        void ShowFileSelectDialog();\n        void OpenFileSelectDialog(const char* title, const char* fileExt, char *path, std::function&lt;void()&gt; callback=[]{});\n\n        void ShowCombineMapPopup();\n        void ShowMappingPopup();\n        void ShowSaveMapFileDialog();\n        void ShowMapFileDialog(char *path);\n\n        void ShowReconstruct3DPopup();\n        void ShowReconExportFilePathDialog();\n\n        void ShowCamCalibPopup();\n        void ShowSaveCamCalibFileDialog();\n        void LoadReconstructParams();\n        void ShowSaveVideoRecorderFileDialog();\n\n        void ShowLogRecorderUI();\n\n        inline void StackPane(PaneUI pane) { m_PaneUIStack.emplace_back(std::move(pane)); }\n        void SetPaneUICamera();\n        void SetPaneUISlam();\n        void SetPaneUIToolhead();\n        void OnCollapsingPaneUIToolhead();\n        void SetPaneUIACIM();\n        void SetPaneUIUtils();\n        PaneUI* GetOpenedPaneUI() { return m_OpenedPaneUI; }\n        void SetOpenedPaneUI(PaneUI* paneUI) { m_OpenedPaneUI = paneUI; }\n\n    private:\n        void SetGlobalViewUI(ImVec2 viewportSize);\n\n    private:\n        AIAC::Image m_LogoLightClr;\n\n        AIAC::ImTexture m_SceneViewportImTexture;\n        AIAC::ImTexture m_MappingViewImTexture;\n        AIAC::ImTexture m_CamCalibViewImTexture;\n        AIAC::ImTexture m_ARCameraViewportImTexture;\n\n        ImVec2 m_LastMouseLPos, m_LastMouseRPos;\n        bool m_IsMouseLDown = false, m_IsMouseRDown = false;\n\n        enum class AdjustTarget {\n            SCALE,\n            ROTATION,\n            TRANSLATION\n        } m_AdjustTarget = AdjustTarget::SCALE;\n\n        bool *m_IsOpen = nullptr;\n\n        std::vector&lt;PaneUI&gt; m_PaneUIStack;\n        PaneUI* m_OpenedPaneUI = nullptr;\n\n        // UI File Selection\n        std::string m_FileSelectDefaultPath = \".\";\n        char m_TmpPathBuf[PATH_BUF_SIZE] = {0};\n        char *m_FileSelectionTargetBuf = nullptr;\n        std::function&lt;void()&gt; m_FileSelectionCallback = []{};\n        std::string m_VideoRecorderPathName;\n\n        bool m_IsCombiningMap = false;\n        bool m_IsReconstructing3D = false;\n\n        struct CombineMapParams{\n            char MapPathA[PATH_BUF_SIZE] = {0},\n                 MapPathB[PATH_BUF_SIZE] = {0},\n                 OutputPath[PATH_BUF_SIZE] = {0};\n            char *FilePathTarget;\n        } m_CombMapParams;\n\n        struct MappingParams{\n            bool ToOptimizeMap = true;\n            bool ToSaveMap = true;\n            char MapSavingPath[PATH_BUF_SIZE] = \"./scanned_map/test.map\";\n        } m_MappingParams;\n\n        struct ReconstructParams {\n            char TagMapPath[PATH_BUF_SIZE] = {0};\n            char ExportPath[PATH_BUF_SIZE] = {0};\n            float RadiusSearch = 2.0f;\n            double CreaseAngleThreshold = 5.0f;\n            int MinClusterSize = 1;\n            double AABBScaleFactor = 1.1f;\n            double MaxPolyDist = 1.0f;\n            double MaxPlnDist = 1.0f;\n            double MaxPlnAngle = 5.0f;\n            double Eps = 1e-5f;\n        } m_ReconstructParams;\n        void LoadReconstructParamsFromFile(const char *filePath);\n\n        // Cam Calib\n        bool m_IsChoosingCamCalibFileSavePath = false;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/LayerUtils_8cpp/","title":"File LayerUtils.cpp","text":"<p>FileList &gt; AIAC &gt; LayerUtils.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include \"LayerUtils.h\"</code></li> <li><code>#include \"Config.h\"</code></li> <li><code>#include \"Application.h\"</code></li> <li><code>#include \"utils/VideoRecorder.h\"</code></li> <li><code>#include \"utils/HoleToolheadAxisExporter.h\"</code></li> <li><code>#include \"utils/Screenshot.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerUtils_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUtils.cpp</code></p>"},{"location":"acdoxygen/LayerUtils_8cpp_source/","title":"File LayerUtils.cpp","text":"<p>File List &gt; AIAC &gt; LayerUtils.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include &lt;thread&gt;\n#include \"LayerUtils.h\"\n#include \"Config.h\"\n#include \"Application.h\"\n#include \"utils/VideoRecorder.h\"\n#include \"utils/HoleToolheadAxisExporter.h\"\n#include \"utils/Screenshot.h\"\n\nnamespace AIAC {\n    LayerUtils::LayerUtils() {\n        LayerUtils::CreateFolder(m_UtilsPath);\n    }\n\n    void LayerUtils::OnFrameEnd() {\n        if(this-&gt;m_Recording){\n            this-&gt;m_VideoRecorder-&gt;CaptureFrames();\n        }\n        if(this-&gt;m_WindowScreenshot){\n            this-&gt;TakeWindowScreenshot();\n            this-&gt;m_WindowScreenshot = false;\n        }\n    }\n\n    void LayerUtils::StartRecording(){\n        AIAC_INFO(\"Started Recording\");\n        this-&gt;m_Recording = true;\n        std::string savePath = this-&gt;GetSaveFolderPath();\n        this-&gt;m_VideoRecorder = std::make_unique&lt;AIAC::Utils::VideoRecorder&gt;(savePath);\n    }\n\n    void LayerUtils::StopRecording(){\n        AIAC_INFO(\"Stopped Recording\");\n        this-&gt;m_Recording = false;\n        this-&gt;m_Processing = true;\n        std::thread([this]{\n            this-&gt;m_VideoRecorder-&gt;MakeVideoFromFrames();\n            this-&gt;m_VideoRecorder.reset();\n            this-&gt;m_Processing = false;\n        }).detach();\n    }\n\n    void LayerUtils::SetSaveFolderPath(const std::string&amp; path){\n        if(path.empty()) {\n            AIAC_INFO(\"Using default path: {}\", m_UtilsPath);\n        } else {\n            m_UtilsPath = path;\n            AIAC_INFO(\"Using specified path: {}\", m_UtilsPath);\n        }\n    }\n\n    void LayerUtils::ExportHoleToolheadAxis(){\n        AIAC_INFO(\"Hole and toolhead axis export\");\n        std::string savePath = this-&gt;GetSaveFolderPath();\n        this-&gt;m_HoleToolheadAxisExporter = std::make_unique&lt;AIAC::Utils::HoleToolheadAxisExporter&gt;(savePath);\n        this-&gt;m_HoleToolheadAxisExporter-&gt;ExportCoordinates();\n    }\n\n    bool LayerUtils::CreateFolder(const std::string&amp; path) {\n        if(std::filesystem::exists(path)) {\n            AIAC_INFO(\"{0} folder already exists!\", path);\n            return true;\n        }\n        if(std::filesystem::create_directories(path)) {\n            AIAC_INFO(\"Created {0} folder\", path);\n            return true;\n        } else {\n            AIAC_ERROR(\"Failed to create {0} folder\", path);\n            return false;\n        }\n    }\n\n    void LayerUtils::TakeWindowScreenshot(){\n        std::string savePath = this-&gt;GetSaveFolderPath();\n        AIAC::Utils::Screenshot recorder(savePath);\n        recorder.CaptureWindow();\n        AIAC_INFO(\"Captured screenshot of the current window\");\n    }\n\n    void LayerUtils::TakeBufferScreenshot(){\n        std::string savePath = this-&gt;GetSaveFolderPath();\n        AIAC::Utils::Screenshot recorder(savePath);\n        recorder.CaptureBuffer();\n        AIAC_INFO(\"Captured colored buffer of the current window\");\n    }\n}\n</code></pre>"},{"location":"acdoxygen/LayerUtils_8h/","title":"File LayerUtils.h","text":"<p>FileList &gt; AIAC &gt; LayerUtils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"utils/VideoRecorder.h\"</code></li> <li><code>#include \"utils/HoleToolheadAxisExporter.h\"</code></li> <li><code>#include \"Config.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> </ul>"},{"location":"acdoxygen/LayerUtils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/LayerUtils_8h/#classes","title":"Classes","text":"Type Name class LayerUtils <p>The documentation for this class was generated from the following file <code>src/AIAC/LayerUtils.h</code></p>"},{"location":"acdoxygen/LayerUtils_8h_source/","title":"File LayerUtils.h","text":"<p>File List &gt; AIAC &gt; LayerUtils.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Layer.h\"\n#include \"utils/VideoRecorder.h\"\n#include \"utils/HoleToolheadAxisExporter.h\"\n#include \"Config.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n\nnamespace AIAC {\n\n    class LayerUtils : public AIAC::Layer {\n    public:\n        LayerUtils();\n        void OnFrameEnd() override;\n        static bool CreateFolder(const std::string&amp; path);\n        void SetSaveFolderPath(const std::string&amp; path);\n        std::string GetSaveFolderPath(){return m_UtilsPath;};\n\n    public: \n        void StartRecording();\n        void StopRecording();\n        bool IsProcessing(){return m_Processing;};\n\n    public: \n        void ExportHoleToolheadAxis();\n\n    public: \n        void TakeWindowScreenshot();\n        void TakeBufferScreenshot();\n        void SetWindowScreenshot(bool value){m_WindowScreenshot = value;};\n\n    private:\n        std::string m_UtilsPath = AIAC::Config::Get&lt;std::string&gt;(AIAC::Config::SEC_UTILS,\n                                                                 AIAC::Config::UTILS_PATH,\n                                                                 \"./temp\");\n    private: \n        bool m_Recording = false;\n        bool m_Processing = false;\n        std::unique_ptr&lt;AIAC::Utils::VideoRecorder&gt; m_VideoRecorder;\n\n    private: \n        std::unique_ptr&lt;AIAC::Utils::HoleToolheadAxisExporter&gt; m_HoleToolheadAxisExporter;\n\n    private: \n        bool m_WindowScreenshot = false;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Log_8cpp/","title":"File Log.cpp","text":"<p>FileList &gt; AIAC &gt; Log.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> </ul>"},{"location":"acdoxygen/Log_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Log.cpp</code></p>"},{"location":"acdoxygen/Log_8cpp_source/","title":"File Log.cpp","text":"<p>File List &gt; AIAC &gt; Log.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Log.h\"\n\nnamespace AIAC\n{\n    std::shared_ptr&lt;spdlog::logger&gt; Log::s_Logger;\n\n    void Log::Init()\n    {\n        spdlog::set_pattern(\"[source %s] [function %!] [line %#] %^[%T] %n: %v%$\");\n\n        s_Logger = spdlog::stdout_color_mt(\"APP\");\n        s_Logger-&gt;set_level(spdlog::level::trace);\n    }\n\n    void Log::Shutdown()\n    {\n        spdlog::shutdown();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/Log_8h/","title":"File Log.h","text":"<p>FileList &gt; AIAC &gt; Log.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;spdlog/spdlog.h&gt;</code></li> <li><code>#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;</code></li> </ul>"},{"location":"acdoxygen/Log_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Log_8h/#classes","title":"Classes","text":"Type Name class Log"},{"location":"acdoxygen/Log_8h/#macros","title":"Macros","text":"Type Name define AIAC_CRITICAL define AIAC_ERROR define AIAC_INFO define AIAC_WARN"},{"location":"acdoxygen/Log_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Log_8h/#define-aiac_critical","title":"define AIAC_CRITICAL","text":"<pre><code>#define AIAC_CRITICAL \n</code></pre>"},{"location":"acdoxygen/Log_8h/#define-aiac_error","title":"define AIAC_ERROR","text":"<pre><code>#define AIAC_ERROR \n</code></pre>"},{"location":"acdoxygen/Log_8h/#define-aiac_info","title":"define AIAC_INFO","text":"<pre><code>#define AIAC_INFO \n</code></pre>"},{"location":"acdoxygen/Log_8h/#define-aiac_warn","title":"define AIAC_WARN","text":"<pre><code>#define AIAC_WARN \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Log.h</code></p>"},{"location":"acdoxygen/Log_8h_source/","title":"File Log.h","text":"<p>File List &gt; AIAC &gt; Log.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;spdlog/spdlog.h&gt;\n#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;\n\n\n\nnamespace AIAC\n{\n    class Log\n    {\n    public:\n\n        static void Init();\n        static void Shutdown();\n\n        inline static std::shared_ptr&lt;spdlog::logger&gt;&amp; GetLogger() { return s_Logger; }\n\n    private:\n        static std::shared_ptr&lt;spdlog::logger&gt; s_Logger;\n    };\n}\n\n#if (defined SILENT_LOGGING &amp;&amp; !defined HEADLESS_TEST)\n    #define AIAC_INFO(...)                     SPDLOG_LOGGER_INFO(AIAC::Log::GetLogger(), __VA_ARGS__)\n    #define AIAC_WARN(...)                     SPDLOG_LOGGER_WARN(AIAC::Log::GetLogger(), __VA_ARGS__)\n    #define AIAC_ERROR(...)                    SPDLOG_LOGGER_ERROR(AIAC::Log::GetLogger(), __VA_ARGS__)\n    #define AIAC_CRITICAL(...)                 SPDLOG_LOGGER_CRITICAL(AIAC::Log::GetLogger(), __VA_ARGS__)\n#else\n    #define AIAC_INFO\n    #define AIAC_WARN\n    #define AIAC_ERROR\n    #define AIAC_CRITICAL\n#endif\n</code></pre>"},{"location":"acdoxygen/ScannedModel_8cpp/","title":"File ScannedModel.cpp","text":"<p>FileList &gt; AIAC &gt; ScannedModel.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"GeometryUtils.h\"</code></li> <li><code>#include \"ScannedModel.h\"</code></li> </ul>"},{"location":"acdoxygen/ScannedModel_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/ScannedModel.cpp</code></p>"},{"location":"acdoxygen/ScannedModel_8cpp_source/","title":"File ScannedModel.cpp","text":"<p>File List &gt; AIAC &gt; ScannedModel.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"GeometryUtils.h\"\n#include \"ScannedModel.h\"\n\nnamespace AIAC\n{\n    bool ScannedModel::Load(std::string path) {\n        // check if file is good\n        if(path.empty()){\n            AIAC_ERROR(\"ACInfoModel::Load() path is empty\");\n            return false;\n        }\n        if(!std::filesystem::exists(path)){\n            AIAC_ERROR(\"ACInfoModel::Load() file does not exist\");\n            return false;\n        }\n\n        m_Mesh = GOMesh::LoadPly(path);\n        if(m_Mesh == nullptr) return false;\n\n        m_Mesh-&gt;SetVisibility(false);\n\n        BuildBoundingBox();\n        UpdateBboxGOLine();\n\n        return true;\n    }\n\n    void ScannedModel::BuildBoundingBox() {\n        struct Neighbor{\n            Neighbor(){};\n            Neighbor(float dist, glm::vec3 vec, glm::vec3 pt): dist(dist), vec(vec), pt(pt) {};\n            float dist;\n            glm::vec3 vec;\n            glm::vec3 pt;\n        };\n\n        auto vertices = m_Mesh-&gt;GetVertices();\n        auto basePt = vertices[0];\n        std::vector&lt;Neighbor&gt; neighbors;\n\n        for (auto&amp; v : vertices) {\n            auto vec = v - basePt;\n            auto dist = glm::length(vec);\n            neighbors.emplace_back(dist, vec, v);\n        }\n\n        // sort by distance\n        std::sort(neighbors.begin(), neighbors.end(), [](Neighbor&amp; a, Neighbor&amp; b) {\n            return a.dist &lt; b.dist;\n        });\n\n        // filter out duplicate vertices based on point difference\n        if (neighbors.size() &gt; 8) {\n            for (int i = 0; i &lt; neighbors.size() - 1; i++) {\n                if (glm::length(neighbors[i].pt - neighbors[i + 1].pt) &lt; 0.05) {\n                    neighbors.erase(neighbors.begin() + i);\n                    i--;\n                }\n            }\n        }\n\n        auto rotationMat = GetRotationMatrix(neighbors[4].vec, 3.14159 / 2);\n        auto pt1 = neighbors[1].pt - basePt;\n        auto pt2 = neighbors[2].pt - basePt;\n        auto test1 = glm::length(rotationMat * pt1 - pt2);\n        auto test2 = glm::length(rotationMat * pt2 - pt1);\n        // if it's in the correct order, test1 should be ~0,\n        // therefore, when test1 &gt; test2, it means that the order is wrong\n        if (test1 &gt; test2) {\n            std::swap(neighbors[1], neighbors[2]);\n        }\n\n        basePt = neighbors[4].pt;\n        pt1 = neighbors[5].pt - basePt;\n        pt2 = neighbors[6].pt - basePt;\n        test1 = glm::length(rotationMat * pt1 - pt2);\n        test2 = glm::length(rotationMat * pt2 - pt1);\n        // if it's in the correct order, test1 should be ~0,\n        // therefore, when test1 &gt; test2, it means that the order is wrong\n        if (test1 &gt; test2) {\n            std::swap(neighbors[5], neighbors[6]);\n        }\n\n        // re-order the vertices, making it a counter-clockwise order start from the longer edge\n        // first bottom, then top\n        //\n        //   (7)------------------------(6)\n        //   / |                       / |  \n        // (4)-----------------------(5) |\n        //  |  |                      |  |\n        //  | (3)---------------------|-(2)\n        //  |/                        |/\n        // (0)-----------------------(1)\n        //\n        m_Bbox = {\n            neighbors[0].pt,\n            neighbors[4].pt,\n            neighbors[6].pt,\n            neighbors[2].pt,\n            neighbors[1].pt,\n            neighbors[5].pt,\n            neighbors[7].pt,\n            neighbors[3].pt\n        };\n\n        // testing the rotation is correct\n        float minTotalDist = 1e9;\n        int rotIndex = -1;\n        for(int i = 0 ; i &lt; 4 ; i++){\n            float dist = 0;\n            for(int j = 0 ; j &lt; 8 ; j+=2){\n                dist += glm::length(m_Bbox[j] - m_Bbox[j + 1]);\n            }\n            if(dist &lt; minTotalDist){\n                minTotalDist = dist;\n                rotIndex = i;\n            }\n            // perform rotation\n            auto tmp = m_Bbox[0];\n            m_Bbox[0] = m_Bbox[3];\n            m_Bbox[3] = m_Bbox[7];\n            m_Bbox[7] = m_Bbox[4];\n            m_Bbox[4] = tmp;\n        }\n        // rotate to the correct order\n        for(int i = 0 ; i &lt; rotIndex ; i++){\n            auto tmp = m_Bbox[0];\n            m_Bbox[0] = m_Bbox[3];\n            m_Bbox[3] = m_Bbox[7];\n            m_Bbox[7] = m_Bbox[4];\n            m_Bbox[4] = tmp;\n        }\n    }\n\n    void ScannedModel::UpdateBboxGOLine() {\n        // update the GOLine references\n        for(auto&amp; line : m_BboxGOLines)\n            GOLine::Remove(line);\n\n        for(auto&amp; edge : m_BboxEdgesIndices){\n            auto i = edge.first, k = edge.second;\n            auto vec = glm::normalize(m_Bbox[k] - m_Bbox[i]);\n            m_BboxGOLines.push_back(GOLine::Add(m_Bbox[i], m_Bbox[i] + vec, 2.0f));\n            m_BboxGOLines.push_back(GOLine::Add(m_Bbox[k], m_Bbox[k] - vec, 2.0f));\n        }\n    }\n\n    float ScannedModel::GetLength(){\n        float dist = 0.0f;\n        dist += glm::distance(m_Bbox[0], m_Bbox[1]);\n        dist += glm::distance(m_Bbox[2], m_Bbox[3]);\n        dist += glm::distance(m_Bbox[4], m_Bbox[5]);\n        dist += glm::distance(m_Bbox[6], m_Bbox[7]);\n        dist /= 4.0f;\n\n        return dist;\n    }\n\n} // namespace AIAC\n</code></pre>"},{"location":"acdoxygen/ScannedModel_8h/","title":"File ScannedModel.h","text":"<p>FileList &gt; AIAC &gt; ScannedModel.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> <li><code>#include &lt;glm/gtx/string_cast.hpp&gt;</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"pugixml.hpp\"</code></li> </ul>"},{"location":"acdoxygen/ScannedModel_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/ScannedModel_8h/#classes","title":"Classes","text":"Type Name class ScannedModel <p>The documentation for this class was generated from the following file <code>src/AIAC/ScannedModel.h</code></p>"},{"location":"acdoxygen/ScannedModel_8h_source/","title":"File ScannedModel.h","text":"<p>File List &gt; AIAC &gt; ScannedModel.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;glm/glm.hpp&gt;\n#include &lt;glm/gtx/string_cast.hpp&gt;\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"pugixml.hpp\"\n\nnamespace AIAC{\nclass ScannedModel{\npublic:\n    ScannedModel(){};\n    ~ScannedModel(){};\n\n    bool Load(std::string path);\n\n    void BuildBoundingBox();\n\n    std::vector&lt;glm::vec3&gt; GetBoundingBox() const { return m_Bbox; }\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; GetBboxEdgesIndices() const { return m_BboxEdgesIndices; }\n    void UpdateBboxGOLine();\n\n    float GetLength();\n\nprivate:\n    std::vector&lt;glm::vec3&gt; m_Bbox;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; m_BboxEdgesIndices = {\n        {0, 1}, {1, 2}, {2, 3}, {3, 0}, // bottom\n        {4, 5}, {5, 6}, {6, 7}, {7, 4}, // top\n        {0, 4}, {1, 5}, {2, 6}, {3, 7}  // vertical\n    };\n\n    std::shared_ptr&lt;GOMesh&gt; m_Mesh;\n    std::vector&lt;std::shared_ptr&lt;GOLine&gt; &gt; m_BboxGOLines;\n};\n\n}\n</code></pre>"},{"location":"acdoxygen/TouchMonitor_8cpp/","title":"File TouchMonitor.cpp","text":"<p>FileList &gt; AIAC &gt; TouchMonitor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/TouchMonitor.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"stb/stb_image.h\"</code></li> <li><code>#include \"stb/stb_image_write.h\"</code></li> </ul>"},{"location":"acdoxygen/TouchMonitor_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/TouchMonitor.cpp</code></p>"},{"location":"acdoxygen/TouchMonitor_8cpp_source/","title":"File TouchMonitor.cpp","text":"<p>File List &gt; AIAC &gt; TouchMonitor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/TouchMonitor.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Config.h\"\n\n#include \"stb/stb_image.h\"\n#include \"stb/stb_image_write.h\"\n\nnamespace AIAC\n{\n    static bool IsGlfwInitialized()\n    {\n        (void)glfwGetKeyScancode(0);\n        return glfwGetError(NULL) != GLFW_NOT_INITIALIZED;\n    }\n\n    static void GLFWMonitorCallback(GLFWmonitor* monitor, int event)\n    {\n        if (event == GLFW_CONNECTED) AIAC_INFO(\"Monitor connected: {0}\", glfwGetMonitorName(monitor));\n        else if (event == GLFW_DISCONNECTED) AIAC_INFO(\"Monitor disconnected: {0}\", glfwGetMonitorName(monitor));\n    }\n\n    TouchMonitor::TouchMonitor()\n    {\n        Init();\n    }\n\n    TouchMonitor::TouchMonitor(bool isPrintMonitorsInfo)\n    : m_IsPrintMonitorsInfo(isPrintMonitorsInfo)\n    {\n        Init();\n    }\n\n    void TouchMonitor::PrintInfoMonitors(int count, GLFWmonitor**&amp; monitors)\n    {\n        int width_mm, height_mm;\n        float xScale, yScale;\n        int xPos, yPos;\n        int xpos, ypos, width, height;\n        for (int i = 0; i &lt; count; i++)\n        {\n            GLFWmonitor* monitor = monitors[i];\n\n            const GLFWvidmode* mode = glfwGetVideoMode(monitor);\n            AIAC_INFO(\"Monitor {0}: {1}x{2}@{3}Hz\", i, mode-&gt;width, mode-&gt;height, mode-&gt;refreshRate);\n\n            glfwGetMonitorPhysicalSize(monitor, &amp;width_mm, &amp;height_mm);\n            AIAC_INFO(\"Monitor {0} physical size: {1}x{2}\", i, width_mm, height_mm);\n\n            glfwGetMonitorContentScale(monitor, &amp;xScale, &amp;yScale);\n            AIAC_INFO(\"Monitor {0} content scale: {1}x{2}\", i, xScale, yScale);\n\n            glfwGetMonitorPos(monitor, &amp;xPos, &amp;yPos);\n            AIAC_INFO(\"Monitor {0} position: {1}, {2}\", i, xPos, yPos);\n\n            glfwGetMonitorWorkarea(monitor, &amp;xpos, &amp;ypos, &amp;width, &amp;height);\n            AIAC_INFO(\"Monitor {0} workarea: {1}, {2}, {3}, {4}\", i, xpos, ypos, width, height);\n\n            const char* name = glfwGetMonitorName(monitor);\n            AIAC_INFO(\"Monitor {0} name: {1}\", i, name);\n        }\n    }\n\n    inline std::string TouchMonitor::ImportNameFromConfig() {\n        return  AIAC::Config::Get&lt;std::string&gt;(Config::SEC_TOUCH_MONITOR_SPECS, Config::NAME, \"WaveShare WS170120\"); }\n    inline std::string TouchMonitor::ImportVideoModeFromConfig() {\n        return AIAC::Config::Get&lt;std::string&gt;(Config::SEC_TOUCH_MONITOR_SPECS, Config::LINK_MODE, \"HDMI\"); }\n    inline std::string TouchMonitor::ImportResolutionFromConfig(){\n        return AIAC::Config::Get&lt;std::string&gt;(Config::SEC_TOUCH_MONITOR_SPECS, Config::RESOLUTION, \"800x400\"); }\n\n    void TouchMonitor::Init()\n    {\n        m_Name = ImportNameFromConfig();\n        m_VideoMode = ImportVideoModeFromConfig();\n        m_Resolution = ImportResolutionFromConfig();\n        m_IsConnected = false;\n\n        if (IsGlfwInitialized) { AIAC_ASSERT(glfwInit(), \"Could not initialize GLFW!\"); }\n        else { AIAC_CRITICAL(\"Multiple windows not supported.\"); exit(EXIT_FAILURE); }\n\n        int count;\n        GLFWmonitor** monitors = glfwGetMonitors(&amp;count);\n        if(count&lt;=0) { AIAC_CRITICAL(\"No monitors found.\"); exit(EXIT_FAILURE); }\n        glfwSetMonitorCallback(GLFWMonitorCallback);\n\n        if(m_IsPrintMonitorsInfo) PrintInfoMonitors(count, monitors);\n\n        if(!SiftMonitorsByMode(m_VideoMode, count, monitors)) { AIAC_CRITICAL(\"No video mode specified found in list monitors.\"); exit(EXIT_FAILURE); }\n        if(!SiftMonitorsByResolution(m_Resolution, m_SiftedMonitors)) { AIAC_CRITICAL(\"No resolution specified found in list monitors.\"); exit(EXIT_FAILURE); }\n#if __linux__\n        if(!GetMonitorID(m_Name)) { AIAC_CRITICAL(\"No monitor ID retrieved.\"); exit(EXIT_FAILURE); }\n\n        if(!MapMonitor(m_ID, m_SiftedMonitors[0])) { AIAC_CRITICAL(\"Mapping monitor failed.\"); exit(EXIT_FAILURE); }\n#endif\n        m_IsConnected = true;\n    }\n\n    bool TouchMonitor::SiftMonitorsByMode(std::string videoMode, int count, GLFWmonitor**&amp; monitors)\n    {\n        bool isVideoModPresent = false;\n\n        for (int i = 0; i &lt; count; i++)\n        {  \n            AIAC_INFO(\"Monitor {0} name: {1} looking for {2}\", i, glfwGetMonitorName(monitors[i]), videoMode.c_str());\n            if (strstr(glfwGetMonitorName(monitors[i]), videoMode.c_str()) != NULL)\n            {\n                AIAC_INFO(\"Monitor {0} name: {1} found\", i, glfwGetMonitorName(monitors[i]));\n\n                isVideoModPresent = true;\n                m_SiftedMonitors.push_back(monitors[i]);\n            }\n        }\n        return isVideoModPresent;\n    }\n\n    bool TouchMonitor::SiftMonitorsByResolution(std::string res, std::vector&lt;GLFWmonitor*&gt;&amp; monitors)\n    {\n        bool isResolutionPresent = false;\n        int count = monitors.size();\n        for (int i = 0; i &lt; count; i++)\n        {\n            AIAC_INFO(\"Monitor {0} name: {1} looking for {2}\", i, glfwGetMonitorName(monitors[i]), res.c_str());\n            const GLFWvidmode* mode = glfwGetVideoMode(monitors[i]);\n            AIAC_INFO(\"Mode width: {0} height: {1}. Looking for {2} x {3}\", mode-&gt;width, mode-&gt;height, std::stoi(res.substr(0, res.find('x'))), std::stoi(res.substr(res.find('x') + 1)));\n            if (!(mode-&gt;width == std::stoi(res.substr(0, res.find('x'))) &amp;&amp; mode-&gt;height == std::stoi(res.substr(res.find('x') + 1))))\n            {\n                monitors.erase(monitors.begin() + i);\n            }\n            else isResolutionPresent = true;\n        }\n        if (!isResolutionPresent || monitors.size() &gt; 1) return false; \n        else if (monitors.size() &gt; 1) return false;\n        else return true;\n    }\n\n    bool TouchMonitor::GetMonitorID(std::string MonitorName)\n    {\n        char buffer[1024];\n        FILE* Fpipe;\n\n        const char* command = \"xinput\";\n        if ( Fpipe = (FILE*)popen(command, \"r\") )\n        {\n            while (fgets(buffer, sizeof(buffer), Fpipe))\n            {\n                if (strstr(buffer, MonitorName.c_str()))\n                {\n                    char* MonitorConfig_id_ptr = strstr(buffer, \"id=\");\n                    MonitorConfig_id_ptr = strchr(MonitorConfig_id_ptr, '=') + 1;\n                    MonitorConfig_id_ptr[3] = '\\0';\n                    m_ID = atoi(MonitorConfig_id_ptr);\n                    break;\n                }\n            }\n            pclose(Fpipe);\n        }\n        else { AIAC_CRITICAL(\"popen() failed\"); exit(EXIT_FAILURE);}\n        if (m_ID == -1) return false;\n        return true;\n    }\n\n    bool TouchMonitor::MapMonitor(int32_t monitorID, GLFWmonitor* touchMonitor)\n    {\n        std::string commandMto = \"xinput map-to-output \";\n        commandMto += std::to_string(monitorID);\n        commandMto += \" \";\n        commandMto += std::string(glfwGetMonitorName(touchMonitor));\n\n        int commandMto_result = system(commandMto.c_str());\n        if (commandMto_result != 0) return false;\n        return true;\n    }\n\n}\n</code></pre>"},{"location":"acdoxygen/TouchMonitor_8h/","title":"File TouchMonitor.h","text":"<p>FileList &gt; AIAC &gt; TouchMonitor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GlHeader.h\"</code></li> </ul>"},{"location":"acdoxygen/TouchMonitor_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/TouchMonitor_8h/#classes","title":"Classes","text":"Type Name class TouchMonitor <p>The documentation for this class was generated from the following file <code>src/AIAC/TouchMonitor.h</code></p>"},{"location":"acdoxygen/TouchMonitor_8h_source/","title":"File TouchMonitor.h","text":"<p>File List &gt; AIAC &gt; TouchMonitor.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"GlHeader.h\"\n\n\nnamespace AIAC\n{\n    class TouchMonitor\n    {\n    public:\n        TouchMonitor();\n        TouchMonitor(bool isPrintMonitorsInfo);\n        virtual ~TouchMonitor() = default;\n\n        void PrintInfoMonitors(int count, GLFWmonitor**&amp; monitors);\n\n        GLFWmonitor*&amp; GetGLFWMonitor() { return m_SiftedMonitors[0]; }\n\n    private:\n        inline std::string ImportNameFromConfig();\n        inline std::string ImportVideoModeFromConfig();\n        inline std::string ImportResolutionFromConfig();\n\n        void Init();\n\n        bool SiftMonitorsByMode(std::string videoMode, int count, GLFWmonitor**&amp; monitors);\n        bool SiftMonitorsByResolution(std::string res, std::vector&lt;GLFWmonitor*&gt;&amp; monitors);\n        bool GetMonitorID(std::string MonitorName);\n        bool MapMonitor(int32_t monitorID, GLFWmonitor* touchMonitor);\n\n    private:\n        std::string m_Name;\n        std::string m_VideoMode;\n        std::string m_Resolution;\n\n        int32_t m_ID = -1;\n\n        bool m_IsPrintMonitorsInfo;\n        bool m_IsConnected = false;\n\n        std::vector&lt;GLFWmonitor*&gt; m_SiftedMonitors = {};\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Window_8cpp/","title":"File Window.cpp","text":"<p>FileList &gt; AIAC &gt; Window.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Window.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"stb/stb_image.h\"</code></li> <li><code>#include \"stb/stb_image_write.h\"</code></li> </ul>"},{"location":"acdoxygen/Window_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Window_8cpp/#classes","title":"Classes","text":"Type Name struct Position <p>The documentation for this class was generated from the following file <code>src/AIAC/Window.cpp</code></p>"},{"location":"acdoxygen/Window_8cpp_source/","title":"File Window.cpp","text":"<p>File List &gt; AIAC &gt; Window.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Window.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Config.h\"\n\n#include \"stb/stb_image.h\"\n#include \"stb/stb_image_write.h\"\n\n\nnamespace AIAC\n{\n    static uint8_t s_GLFWWindowCount = 0;\n    static bool s_IsMouseButtonPressed = false;\n    static struct Position { double x, y; } s_CursorPos;\n\n    static void GLFWErrorCallback(int error, const char* description)\n    {\n        AIAC_ERROR(\"GLFW Error ({0}): {1}\", error, description);\n    }\n\n    Window::Window(const WindowProps&amp; props)\n    {\n        m_Data.Title = props.Title;\n        m_Data.Width = props.Width;\n        m_Data.Height = props.Height;\n        m_Data.VSync = props.VSync;\n        m_Data.IsResizable = props.IsResizable;\n    }\n\n    Window::~Window()\n    {\n        Shutdown();\n    }\n\n    void Window::Init()\n    {\n        glfwSetErrorCallback(GLFWErrorCallback);\n\n        if(s_GLFWWindowCount == 0)\n        {\n            AIAC_ASSERT(glfwInit(), \"Could not initialize GLFW!\");\n        } else { AIAC_CRITICAL(\"Multiple windows not supported.\"); exit(EXIT_FAILURE); }\n\n        m_GlslVersion = \"#version 130\";\n\n        int verMajor, verMinor, rev;\n        glfwGetVersion(&amp;verMajor, &amp;verMinor, &amp;rev);\n        std::cout &lt;&lt; \"glfw version: \" &lt;&lt; verMajor &lt;&lt; \".\" &lt;&lt; verMinor &lt;&lt; \".\" &lt;&lt; rev &lt;&lt; std::endl;\n\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef AIAC_DEPLOY_ON_TOUCH\n        glfwWindowHint(GLFW_AUTO_ICONIFY, GLFW_FALSE);\n#else\n        glfwWindowHint(GLFW_AUTO_ICONIFY, GLFW_TRUE);\n        glfwWindowHint(GLFW_RESIZABLE, m_Data.IsResizable);\n#endif\n\n#ifdef AIAC_DEPLOY_ON_TOUCH\n        m_TouchMonitor = new AIAC::TouchMonitor();\n\n        const GLFWvidmode* mode = glfwGetVideoMode(m_TouchMonitor-&gt;GetGLFWMonitor());\n        glfwWindowHint(GLFW_RED_BITS, mode-&gt;redBits);\n        glfwWindowHint(GLFW_GREEN_BITS, mode-&gt;greenBits);\n        glfwWindowHint(GLFW_BLUE_BITS, mode-&gt;blueBits);\n        glfwWindowHint(GLFW_REFRESH_RATE, mode-&gt;refreshRate);\n\n        m_GLFWWindow = glfwCreateWindow(mode-&gt;width, mode-&gt;height, m_Data.Title, m_TouchMonitor-&gt;GetGLFWMonitor(), NULL);\n#else\n        m_GLFWWindow = glfwCreateWindow(m_Data.Width, m_Data.Height, m_Data.Title, NULL, NULL);\n#endif\n\n        if (m_GLFWWindow == NULL) {\n            AIAC_CRITICAL(\"Failed to create GLFW window\");\n            glfwTerminate();\n            exit(EXIT_FAILURE);\n        }\n        ++s_GLFWWindowCount;\n\n        GLFWimage logo[1];\n        logo[0].pixels = stbi_load(\"assets/images/logos/logo_linux_gray_light.png\",\n        &amp;logo[0].width, &amp;logo[0].height, 0, 4);\n        glfwSetWindowIcon(m_GLFWWindow, 1, logo); \n        stbi_image_free(logo[0].pixels);\n\n        glfwMakeContextCurrent(m_GLFWWindow);\n        SetVSync(m_Data.VSync);\n\n        glewExperimental = true;\n        if (glewInit() != GLEW_OK)\n        {\n            AIAC_CRITICAL(\"Failed to initialize GLEW\");\n            exit(EXIT_FAILURE);\n        }\n\n//        glfwSetMouseButtonCallback(m_GLFWWindow, m_MouseButtonCallback);\n//        glfwSetCursorPosCallback(m_GLFWWindow, m_MouseMoveCallback);\n    }\n\n    void Window::Shutdown()\n    {\n        glfwDestroyWindow(m_GLFWWindow);\n        --s_GLFWWindowCount;\n        if (s_GLFWWindowCount == 0)\n        {\n            glfwTerminate();\n        }\n    }\n\n    bool Window::IsOpen()\n    {\n        return !(glfwWindowShouldClose(m_GLFWWindow));\n    }\n\n    void Window::OnUpdate()\n    {\n        glfwPollEvents();\n        glfwGetFramebufferSize(m_GLFWWindow, &amp;m_DisplayW, &amp;m_DisplayH);\n    }\n\n    void Window::OnBufferSwap()\n    {\n        glfwSwapBuffers(m_GLFWWindow);\n    }\n\n    void Window::SetVSync(bool enabled)\n    {\n        if(enabled)\n            glfwSwapInterval(1);\n        else\n            glfwSwapInterval(0);\n        m_Data.VSync = enabled;\n    }\n\n//    void Window::m_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)\n//    {\n//        if (button == GLFW_MOUSE_BUTTON_LEFT) {\n//            if(GLFW_PRESS == action){\n//                s_IsMouseButtonPressed = true;\n//                double x;\n//                double y;\n//                glfwGetCursorPos(window, &amp;x, &amp;y);\n//                s_CursorPos = { x, y };\n//            }\n//            else if(GLFW_RELEASE == action)\n//                s_IsMouseButtonPressed = false;\n//        }\n//    }\n//\n//    void Window::m_MouseMoveCallback(GLFWwindow* window, double x, double y)\n//    {\n//        if(s_IsMouseButtonPressed)\n//        {\n//            double x_diff = x - s_CursorPos.x;\n//            double y_diff = y - s_CursorPos.y;\n//            s_CursorPos = { x, y };\n//        }\n//    }\n}\n</code></pre>"},{"location":"acdoxygen/Window_8h/","title":"File Window.h","text":"<p>FileList &gt; AIAC &gt; Window.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GlHeader.h\"</code></li> <li><code>#include \"AIAC/TouchMonitor.h\"</code></li> </ul>"},{"location":"acdoxygen/Window_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Window_8h/#classes","title":"Classes","text":"Type Name class Window struct WindowProps <p>The documentation for this class was generated from the following file <code>src/AIAC/Window.h</code></p>"},{"location":"acdoxygen/Window_8h_source/","title":"File Window.h","text":"<p>File List &gt; AIAC &gt; Window.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"GlHeader.h\"\n#include \"AIAC/TouchMonitor.h\"\nnamespace AIAC\n{\n    struct WindowProps\n    {\n        const char* Title;\n        uint32_t Width;\n        uint32_t Height;\n        bool VSync;\n        bool IsResizable;\n\n        WindowProps(const char* title = \"augmented_carpentry\",\n                    uint32_t width = 800,\n                    uint32_t height = 480,\n                    bool vSync = true,\n                    bool isResizable = false)\n            : Title(title), Width(width), Height(height), VSync(vSync), IsResizable(isResizable)\n        {}\n    };\n\n\n    class Window\n    {\n    public:\n        Window(const WindowProps&amp; props);\n        virtual ~Window();\n\n        void Init();\n\n        void OnUpdate();\n        void OnBufferSwap();\n        void Shutdown();\n        void MakeCurrent();\n        void ReleaseCurrent();\n\n        bool IsOpen();\n\n        uint32_t GetWidth() const { return m_Data.Width; }\n        uint32_t GetHeight() const { return m_Data.Height; }\n\n        void SetVSync(bool enabled);\n        inline bool IsVSync() const { return m_Data.VSync; }\n\n        inline GLFWwindow* GetGLFWWindow() { return m_GLFWWindow; }\n        inline const char* GetGlslVersion() { return m_GlslVersion; }\n\n        inline int GetDisplayW() { return m_DisplayW; }\n        inline int GetDisplayH() { return m_DisplayH; }\n\n//    private:\n//        static void m_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);\n//        static void m_MouseMoveCallback(GLFWwindow* window, double x, double y);\n\n    private:\n        AIAC::TouchMonitor* m_TouchMonitor;\n\n        GLFWwindow* m_GLFWWindow;\n        const char* m_GlslVersion;\n        bool m_IsWindowOpen;\n\n        struct WindowData\n        {\n            const char* Title;\n            uint32_t Width;\n            uint32_t Height;\n            bool VSync;\n            bool IsResizable;\n        } m_Data = {};\n\n        int m_DisplayW, m_DisplayH;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/dir_bda428afb66b315b23b4e646d7591fb3/","title":"Dir src/AIAC/EventSys","text":"<p>FileList &gt; AIAC &gt; EventSys</p>"},{"location":"acdoxygen/dir_bda428afb66b315b23b4e646d7591fb3/#files","title":"Files","text":"Type Name file ApplicationEvent.cpp file ApplicationEvent.h file CameraEvent.cpp file CameraEvent.h file Event.h file EventBus.h file SLAMEvent.cpp file SLAMEvent.h <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/</code></p>"},{"location":"acdoxygen/ApplicationEvent_8cpp/","title":"File ApplicationEvent.cpp","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; ApplicationEvent.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/EventSys/ApplicationEvent.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> </ul>"},{"location":"acdoxygen/ApplicationEvent_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/ApplicationEvent.cpp</code></p>"},{"location":"acdoxygen/ApplicationEvent_8cpp_source/","title":"File ApplicationEvent.cpp","text":"<p>File List &gt; AIAC &gt; EventSys &gt; ApplicationEvent.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n#include \"AIAC/EventSys/ApplicationEvent.h\"\n#include \"AIAC/Application.h\"\n\nnamespace AIAC\n{\n    void AppCloseEvent::OnAppClose()\n    {\n        AIAC_INFO(\"Application closing\");\n        AIAC_APP.Close();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/ApplicationEvent_8h/","title":"File ApplicationEvent.h","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; ApplicationEvent.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/EventSys/Event.h\"</code></li> </ul>"},{"location":"acdoxygen/ApplicationEvent_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/ApplicationEvent_8h/#classes","title":"Classes","text":"Type Name class AppCloseEvent <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/ApplicationEvent.h</code></p>"},{"location":"acdoxygen/ApplicationEvent_8h_source/","title":"File ApplicationEvent.h","text":"<p>File List &gt; AIAC &gt; EventSys &gt; ApplicationEvent.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/EventSys/Event.h\"\n\nnamespace AIAC\n{\n    class AppCloseEvent : public Event\n    {\n    public:\n        explicit AppCloseEvent()\n            : Event(EventType::AppClose, EventCategory::EventCategoryApplication)\n        {}\n\n        void OnAppClose();\n    };\n}\n</code></pre>"},{"location":"acdoxygen/CameraEvent_8cpp/","title":"File CameraEvent.cpp","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; CameraEvent.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/EventSys/CameraEvent.h\"</code></li> <li><code>#include \"AIAC/EventSys/SLAMEvent.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> </ul>"},{"location":"acdoxygen/CameraEvent_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/CameraEvent.cpp</code></p>"},{"location":"acdoxygen/CameraEvent_8cpp_source/","title":"File CameraEvent.cpp","text":"<p>File List &gt; AIAC &gt; EventSys &gt; CameraEvent.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n#include \"AIAC/EventSys/CameraEvent.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n#include \"AIAC/Application.h\"\n#include \"AIAC/Config.h\"\n\nnamespace AIAC\n{\n    void CameraCalibrationLoadedEvent::OnCameraCalibrationFileLoaded()\n    {\n        // update the config first\n        AIAC::Config::UpdateEntry(AIAC::Config::SEC_AIAC, AIAC::Config::CAM_PARAMS_FILE, m_FilePath);\n\n        AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.UpdateCameraParamFromFile(m_FilePath);\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.setCamParams(m_FilePath);\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.imageParams.Distorsion.setTo(cv::Scalar::all(0));\n        AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ReloadCameraFromFile();\n\n        // Since the camera calibration file has changed, making it uncompilable with the previous SLAM map\n        // we need to stop the SLAM process, or it will crash\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;ToProcess = false;\n\n        // update projection matrix\n        AIAC_APP.GetRenderer()-&gt;InitProjMatrix();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/CameraEvent_8h/","title":"File CameraEvent.h","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; CameraEvent.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/EventSys/Event.h\"</code></li> </ul>"},{"location":"acdoxygen/CameraEvent_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/CameraEvent_8h/#classes","title":"Classes","text":"Type Name class CameraCalibrationLoadedEvent <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/CameraEvent.h</code></p>"},{"location":"acdoxygen/CameraEvent_8h_source/","title":"File CameraEvent.h","text":"<p>File List &gt; AIAC &gt; EventSys &gt; CameraEvent.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/EventSys/Event.h\"\n\n\nnamespace AIAC\n{\n    class CameraCalibrationLoadedEvent : public Event\n    {\n    public:\n        explicit CameraCalibrationLoadedEvent(const std::string filePath)\n            : Event(EventType::CameraCalibrationLoaded, EventCategory::EventCategoryCamera), m_FilePath(filePath)\n        {}\n\n        void OnCameraCalibrationFileLoaded();\n\n    private:\n        std::string m_FilePath;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Event_8h/","title":"File Event.h","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; Event.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Base.h\"</code></li> <li><code>#include \"eventpp/eventqueue.h\"</code></li> <li><code>#include \"eventpp/eventdispatcher.h\"</code></li> <li><code>#include \"eventpp/eventpolicies.h\"</code></li> </ul>"},{"location":"acdoxygen/Event_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Event_8h/#classes","title":"Classes","text":"Type Name class Event struct EventCompare struct EventPolicy <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/Event.h</code></p>"},{"location":"acdoxygen/Event_8h_source/","title":"File Event.h","text":"<p>File List &gt; AIAC &gt; EventSys &gt; Event.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Base.h\"\n#include \"eventpp/eventqueue.h\"\n#include \"eventpp/eventdispatcher.h\"\n#include \"eventpp/eventpolicies.h\"\n\n\nnamespace AIAC\n{\n    enum class EventType\n    {\n        None = 0,\n        AppClose,\n        SLAMMapLoaded, SLAMVocabularyLoaded, SLAMStartMapping, SLAMStopMapping,\n        SLAMCombineMapEvent,\n        CameraCalibrationLoaded\n        /* add types of events here */\n    };\n\n    enum EventCategory\n    {\n        None = 0,\n        EventCategoryApplication =              BIT(0),\n        EventCategorySLAM =                     BIT(1),\n        EventCategoryCamera =                   BIT(2)\n        /* add event category here */\n    };\n\n    class Event\n    {\n    public:\n        explicit Event(const EventType type, const EventCategory category = EventCategory::None, int32_t priority = 0)\n            : m_Type(type), m_Category(category), m_Priority(priority)\n        {}\n        virtual ~Event() = default;\n\n        EventType GetType() const { return m_Type; }\n        EventCategory GetCategory() const { return m_Category; }\n\n    private:\n        EventType m_Type;\n        EventCategory m_Category;\n        int32_t m_Priority;\n    };\n\n    using EventPointer = std::shared_ptr&lt;Event&gt;;\n\n    struct EventCompare\n    {\n        template &lt;typename T&gt;\n        bool operator() (const T &amp; a, const T &amp; b) const\n        {\n            return a-&gt;GetPriority() &gt; b-&gt;GetPriority();\n        }\n    };\n\n    struct EventPolicy\n    {\n        template &lt;typename Item&gt;\n        using PrioriQueueListtyQueue = std::priority_queue&lt;Item, std::vector&lt;Item&gt;, EventCompare&gt;;\n\n        static EventType GetEvent(const EventPointer&amp; event) {\n            return event-&gt;GetType();\n        }\n\n        static EventCategory GetCategory(const EventPointer&amp; event) {\n            return event-&gt;GetCategory();\n        }\n    };\n\n}\n</code></pre>"},{"location":"acdoxygen/EventBus_8h/","title":"File EventBus.h","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; EventBus.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/EventSys/Event.h\"</code></li> <li><code>#include \"AIAC/EventSys/SLAMEvent.h\"</code></li> <li><code>#include \"AIAC/EventSys/CameraEvent.h\"</code></li> <li><code>#include \"AIAC/EventSys/ApplicationEvent.h\"</code></li> </ul>"},{"location":"acdoxygen/EventBus_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/EventBus_8h/#classes","title":"Classes","text":"Type Name class EventBus <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/EventBus.h</code></p>"},{"location":"acdoxygen/EventBus_8h_source/","title":"File EventBus.h","text":"<p>File List &gt; AIAC &gt; EventSys &gt; EventBus.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/EventSys/Event.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n#include \"AIAC/EventSys/CameraEvent.h\"\n#include \"AIAC/EventSys/ApplicationEvent.h\"\n\n\nnamespace AIAC\n{\n    using EQ = eventpp::EventQueue&lt;EventType, void(const EventPointer&amp;), EventPolicy&gt;;\n    class EventBus\n    {\n    public:\n        ~EventBus() = default;\n\n        void Init()\n        {\n            m_EventQueue.appendListener(EventType::SLAMMapLoaded, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;SLAMMapLoadedEvent&amp;&gt;(*event);\n                slamEvent.OnSLAMMapLoaded();\n            });\n            m_EventQueue.appendListener(EventType::SLAMVocabularyLoaded, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;SLAMVocabularyLoadedEvent&amp;&gt;(*event);\n                slamEvent.OnSLAMVocabularyLoaded();\n            });\n            m_EventQueue.appendListener(EventType::SLAMStartMapping, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;SLAMStartMappingEvent&amp;&gt;(*event);\n                slamEvent.OnSLAMStartMapping();\n            });\n            m_EventQueue.appendListener(EventType::SLAMStopMapping, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;SLAMStopMappingEvent&amp;&gt;(*event);\n                slamEvent.OnSLAMStopMapping();\n            });\n            m_EventQueue.appendListener(EventType::SLAMCombineMapEvent, [](const EventPointer&amp; event) {\n                auto&amp; slamEvent = static_cast&lt;SLAMCombineMapEvent&amp;&gt;(*event);\n                slamEvent.OnSLAMCombineMap();\n            });\n            m_EventQueue.appendListener(EventType::CameraCalibrationLoaded, [](const EventPointer&amp; event) {\n                auto&amp; cameraEvent = static_cast&lt;CameraCalibrationLoadedEvent&amp;&gt;(*event);\n                cameraEvent.OnCameraCalibrationFileLoaded();\n            });\n            m_EventQueue.appendListener(EventType::AppClose, [](const EventPointer&amp; event) {\n                auto&amp; appEvent = static_cast&lt;AppCloseEvent&amp;&gt;(*event);\n                appEvent.OnAppClose();\n            });\n        }\n\n        void EnqueueEvent(const EventPointer&amp; sharedPtrEvent)\n        {\n            m_EventQueue.enqueue(sharedPtrEvent-&gt;GetType(), sharedPtrEvent);\n        }\n\n        // Asynchronus\n        void ProcessQueue() { m_EventQueue.process(); }\n\n        // Synchronus\n        void DispatchEvent(const EventPointer&amp; sharedPtrEvent)\n        {\n            m_EventQueue.dispatch(sharedPtrEvent-&gt;GetType(), sharedPtrEvent);\n        }\n\n        inline bool IsEventQueueEmpty() const { return m_EventQueue.emptyQueue(); }\n\n    private:\n        EQ m_EventQueue;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/SLAMEvent_8cpp/","title":"File SLAMEvent.cpp","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; SLAMEvent.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"AIAC/EventSys/SLAMEvent.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> </ul>"},{"location":"acdoxygen/SLAMEvent_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.cpp</code></p>"},{"location":"acdoxygen/SLAMEvent_8cpp_source/","title":"File SLAMEvent.cpp","text":"<p>File List &gt; AIAC &gt; EventSys &gt; SLAMEvent.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n#include \"AIAC/Config.h\"\n#include \"AIAC/EventSys/SLAMEvent.h\"\n#include \"AIAC/Application.h\"\n#include &lt;filesystem&gt;\n#include &lt;cstdlib&gt;\n\nnamespace AIAC\n{\n    void SLAMMapLoadedEvent::OnSLAMMapLoaded()\n    {\n        AIAC_INFO(\"SLAM map file changed to: \\\"{}\\\"\", m_FilePath);\n        // update config\n        AIAC::Config::UpdateEntry(AIAC::Config::SEC_TSLAM, AIAC::Config::MAP_FILE, m_FilePath);\n\n        if(!std::filesystem::exists(m_FilePath)){\n            AIAC_WARN(\"SLAM map file not found: \\\"{}\\\"\", m_FilePath);\n            return;\n        }\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;UpdateMap(m_FilePath);\n\n        // extract the camera calibration file path from the SLAM map and update for camera and SLAM\n        auto paramHeight  = AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.getMap()-&gt;keyframes.begin()-&gt;imageParams.CamSize.height;\n        auto paramWidth   = AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.getMap()-&gt;keyframes.begin()-&gt;imageParams.CamSize.width;\n        auto cameraMatrix = AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.getMap()-&gt;keyframes.begin()-&gt;imageParams.CameraMatrix;\n\n        // update the camera parameters for camera\n        AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.UpdateCameraParamFromSlamMap(paramWidth, paramHeight, cameraMatrix);\n\n        // update the camera parameters for SLAM\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.imageParams.CameraMatrix = cameraMatrix;\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.imageParams.CamSize.height = paramHeight;\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.imageParams.CamSize.width = paramWidth;\n\n        // update the camera parameters for TTool\n        AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ReloadCameraFromMatrix(cameraMatrix, cv::Size(paramWidth, paramHeight));\n\n        // update projection matrix\n        AIAC_APP.GetRenderer()-&gt;InitProjMatrix();\n\n        // enable SLAM\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;ToProcess = true;\n\n        // TODO: Clean up the loaded mesh\n    }\n\n    void SLAMVocabularyLoadedEvent::OnSLAMVocabularyLoaded()\n    {\n        AIAC_INFO(\"SLAM vocabulary file changed to: {}\", m_FilePath);\n\n        // update config\n        AIAC::Config::UpdateEntry(AIAC::Config::SEC_TSLAM, AIAC::Config::VocFile, m_FilePath);\n\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.setVocabulary(m_FilePath);\n    }\n\n    void SLAMStartMappingEvent::OnSLAMStartMapping()\n    {\n        AIAC_INFO(\"Start mapping\");\n\n        // update the camera parameters for SLAM\n        auto camParamFilepath = AIAC::Config::Get&lt;string&gt;(\n                AIAC::Config::SEC_AIAC,\n                AIAC::Config::CAM_PARAMS_FILE,\n                \"assets/tslam/calibration_orange_A_1280_720_000B.yml\");\n        AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.UpdateCameraParamFromFile(camParamFilepath);\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.setCamParams(camParamFilepath);\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.imageParams.Distorsion.setTo(cv::Scalar::all(0));\n        AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ReloadCameraFromFile();\n        // update projection matrix\n        AIAC_APP.GetRenderer()-&gt;InitProjMatrix();\n\n        // start mapping\n        AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;StartMapping();\n    }\n\n    void SLAMStopMappingEvent::OnSLAMStopMapping()\n    {\n        // create folder\n        auto path = m_SavePath.substr(0, m_SavePath.find_last_of(\"/\"));\n        auto folderCreatedSucceed = std::filesystem::create_directories(path);\n        if(folderCreatedSucceed){\n            AIAC_INFO(\"Create folder: {}\", path);\n        }\n\n        AIAC_INFO(\"Stop mapping\");\n        AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;StopMapping();\n\n        // Optimize Map\n        if(m_ToOptimize &amp;&amp; m_ToSave) {\n            AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.getMap()-&gt;optimize();\n        }\n\n        // Save the map &amp; reconstruct 3D\n        if(m_ToSave) {\n            auto basePath = m_SavePath.substr(0, m_SavePath.find_last_of(\".\"));\n            auto ymlTagMapPath = basePath + \".yml\";\n            auto recPlyPath = basePath + \".ply\";\n\n            AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.getMap()-&gt;saveToFile(m_SavePath);\n            if(AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.getMap()-&gt;map_markers.size() == 0){\n                AIAC_WARN(\"No tag in the map, skip rest of the process\");\n                return;\n            }\n            AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.getMap()-&gt;saveToMarkerMap(ymlTagMapPath);\n\n            // Reload Tag to GL for rendering\n            AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;InitSlamMapGOs();\n\n            // Reconstruct 3D\n            bool isReconstructed = AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.Reconstruct3DModelAndExportPly(\n                ymlTagMapPath,\n                recPlyPath,\n                m_RadiusSearch,\n                m_CreaseAngleThreshold,\n                m_MinClusterSize,\n                m_AABBScaleFactor,\n                m_MaxPolyTagDist,\n                m_MaxPlnDist2Merge,\n                m_MaxPlnAngle2Merge,\n                m_EPS\n            );\n\n            // Load reconstructed 3D model\n            if(isReconstructed) AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;LoadScannedModel(recPlyPath);\n            else AIAC_WARN(\"Reconstruction failed, skip loading the model\");\n        }\n    }\n\n    void SLAMCombineMapEvent::OnSLAMCombineMap()\n    {\n        if (m_OutputPath.empty()) {\n            auto basePathA = m_MapPathA.substr(0, m_MapPathA.find_last_of('.'));\n            auto filenameB = m_MapPathB.substr(m_MapPathB.find_last_of('/') + 1);\n            m_OutputPath = basePathA + \"_combined_\" + filenameB;\n        }\n\n        auto basePath = m_OutputPath.substr(0, m_OutputPath.find_last_of(\".\"));\n        auto ymlTagMapPath = basePath + \".yml\";\n        auto recPlyPath = basePath + \"_reconstruct.ply\";\n\n        AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.CombineMap(\n                m_MapPathA, m_MapPathB, m_OutputPath,\n                true, true, nullptr, m_OptimizeIterations);\n\n        // Reconstruct 3D\n        bool isReconstructed = AIAC_APP.GetLayer&lt;AIAC::LayerSlam&gt;()-&gt;Slam.Reconstruct3DModelAndExportPly(\n                ymlTagMapPath,\n                recPlyPath,\n                m_RadiusSearch,\n                m_CreaseAngleThreshold,\n                m_MinClusterSize,\n                m_AABBScaleFactor,\n                m_MaxPolyTagDist,\n                m_MaxPlnDist2Merge,\n                m_MaxPlnAngle2Merge,\n                m_EPS\n        );\n\n        // Load reconstructed 3D model\n        if(isReconstructed) AIAC_APP.GetLayer&lt;AIAC::LayerModel&gt;()-&gt;LoadScannedModel(recPlyPath);\n        else AIAC_WARN(\"Reconstruction failed, skip loading the model\");\n    }\n}\n</code></pre>"},{"location":"acdoxygen/SLAMEvent_8h/","title":"File SLAMEvent.h","text":"<p>FileList &gt; AIAC &gt; EventSys &gt; SLAMEvent.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/EventSys/Event.h\"</code></li> </ul>"},{"location":"acdoxygen/SLAMEvent_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/SLAMEvent_8h/#classes","title":"Classes","text":"Type Name class SLAMCombineMapEvent class SLAMMapLoadedEvent class SLAMStartMappingEvent class SLAMStopMappingEvent class SLAMVocabularyLoadedEvent <p>The documentation for this class was generated from the following file <code>src/AIAC/EventSys/SLAMEvent.h</code></p>"},{"location":"acdoxygen/SLAMEvent_8h_source/","title":"File SLAMEvent.h","text":"<p>File List &gt; AIAC &gt; EventSys &gt; SLAMEvent.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/EventSys/Event.h\"\n\n\nnamespace AIAC\n{\n    class SLAMMapLoadedEvent : public Event\n    {\n    public:\n        explicit SLAMMapLoadedEvent(const std::string filePath)\n            : Event(EventType::SLAMMapLoaded, EventCategory::EventCategorySLAM), m_FilePath(filePath)\n        {}\n\n        void OnSLAMMapLoaded();\n\n    private:\n        std::string m_FilePath;\n    };\n\n    class SLAMVocabularyLoadedEvent : public Event\n    {\n    public:\n        explicit SLAMVocabularyLoadedEvent(const std::string filePath)\n            : Event(EventType::SLAMVocabularyLoaded, EventCategory::EventCategorySLAM), m_FilePath(filePath)\n        {}\n\n        void OnSLAMVocabularyLoaded();\n\n    private:\n        std::string m_FilePath;\n    };\n\n    class SLAMStartMappingEvent : public Event\n    {\n    public:\n        explicit SLAMStartMappingEvent()\n            : Event(EventType::SLAMStartMapping, EventCategory::EventCategorySLAM)\n        {}\n\n        void OnSLAMStartMapping();\n    };\n\n    class SLAMStopMappingEvent : public Event\n    {\n    public:\n        // FIXME: This is a bit ugly, creating a struct for the two sets of parameters may be better?\n        explicit SLAMStopMappingEvent(// Save Map Parameters\n                                      bool toSave,\n                                      std::string savePath,\n                                      bool toOptimize,\n                                      // Reconstruction Parameters\n                                      float radiusSearch,\n                                      double creaseAngleThreshold,\n                                      int minClusterSize,\n                                      double AABBScaleFactor,\n                                      double maxPolyTagDist,\n                                      double maxPlnDist2Merge,\n                                      double maxPlnAngle2Merge,\n                                      double EPS)\n\n            : Event(EventType::SLAMStopMapping, EventCategory::EventCategorySLAM),\n            m_ToSave(toSave), m_SavePath(savePath), m_ToOptimize(toOptimize),\n            m_RadiusSearch(radiusSearch), m_CreaseAngleThreshold(creaseAngleThreshold),\n            m_MinClusterSize(minClusterSize), m_AABBScaleFactor(AABBScaleFactor),\n            m_MaxPolyTagDist(maxPolyTagDist), m_MaxPlnDist2Merge(maxPlnDist2Merge),\n            m_MaxPlnAngle2Merge(maxPlnAngle2Merge), m_EPS(EPS)\n        {}\n\n        void OnSLAMStopMapping();\n\n    private:\n        // Save Map Parameters\n        bool m_ToSave;\n        std::string m_SavePath;\n        bool m_ToOptimize;\n\n        // Reconstruction Parameters\n        float m_RadiusSearch;\n        double m_CreaseAngleThreshold;\n        int m_MinClusterSize;\n        double m_AABBScaleFactor;\n        double m_MaxPolyTagDist;\n        double m_MaxPlnDist2Merge;\n        double m_MaxPlnAngle2Merge;\n        double m_EPS;\n    };\n\n    class SLAMCombineMapEvent : public Event\n    {\n    public:\n        // FIXME: This is a bit ugly, creating a struct for the two sets of parameters may be better?\n        explicit SLAMCombineMapEvent(\n                // Combine Map Parameters\n                std::string mapPathA,\n                std::string mapPathB,\n                std::string outputPath,\n                int optimizeIterations,\n\n                // Reconstruction Parameters\n                float radiusSearch,\n                double creaseAngleThreshold,\n                int minClusterSize,\n                double AABBScaleFactor,\n                double maxPolyTagDist,\n                double maxPlnDist2Merge,\n                double maxPlnAngle2Merge,\n                double EPS)\n\n                : Event(EventType::SLAMCombineMapEvent, EventCategory::EventCategorySLAM),\n                  m_MapPathA(std::move(mapPathA)), m_MapPathB(std::move(mapPathB)), m_OutputPath(std::move(outputPath)),\n                  m_OptimizeIterations(optimizeIterations),\n                  m_RadiusSearch(radiusSearch), m_CreaseAngleThreshold(creaseAngleThreshold),\n                  m_MinClusterSize(minClusterSize), m_AABBScaleFactor(AABBScaleFactor),\n                  m_MaxPolyTagDist(maxPolyTagDist), m_MaxPlnDist2Merge(maxPlnDist2Merge),\n                  m_MaxPlnAngle2Merge(maxPlnAngle2Merge), m_EPS(EPS)\n        {}\n\n        void OnSLAMCombineMap();\n\n    private:\n        // Combine Map Parameters\n        std::string m_MapPathA;\n        std::string m_MapPathB;\n        std::string m_OutputPath;\n        int m_OptimizeIterations;\n\n        // Reconstruction Parameters\n        float m_RadiusSearch;\n        double m_CreaseAngleThreshold;\n        int m_MinClusterSize;\n        double m_AABBScaleFactor;\n        double m_MaxPolyTagDist;\n        double m_MaxPlnDist2Merge;\n        double m_MaxPlnAngle2Merge;\n        double m_EPS;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/dir_2e808e595a766fe55342199a604574e7/","title":"Dir src/AIAC/Feedback","text":"<p>FileList &gt; AIAC &gt; Feedback</p>"},{"location":"acdoxygen/dir_2e808e595a766fe55342199a604574e7/#files","title":"Files","text":"Type Name file CutBladeThicknessVisualizer.cpp file CutBladeThicknessVisualizer.h file CutChainSawFeedback.cpp file CutChainSawFeedback.h file CutCircularSawFeedback.cpp file CutCircularSawFeedback.h file CutPlaneVisualizer.cpp file CutPlaneVisualizer.h file FabFeedback.h file FeedbackVisualizer.cpp file FeedbackVisualizer.h file HoleFeedback.cpp file HoleFeedback.h <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/</code></p>"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8cpp/","title":"File CutBladeThicknessVisualizer.cpp","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutBladeThicknessVisualizer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CutBladeThicknessVisualizer.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> </ul>"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutBladeThicknessVisualizer.cpp</code></p>"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8cpp_source/","title":"File CutBladeThicknessVisualizer.cpp","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutBladeThicknessVisualizer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"CutBladeThicknessVisualizer.h\"\n#include \"AIAC/Application.h\"\n\n\nnamespace AIAC\n{\n    CutBladeThicknessVisualizer::CutBladeThicknessVisualizer()\n    {\n        this-&gt;m_LongestIntersectSegmenDetectToolPlane = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_LongestIntersectSegmentTowardsCameraA = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_LongestIntersectSegmentTowardsCameraB = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_LongestIntersectSegmentAwayFromCameraA = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_LongestIntersectSegmentAwayFromCameraB = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        this-&gt;m_LongestIntersectSegmenDetectToolPlane-&gt;SetWeight(GOWeight::Light);\n        this-&gt;m_LongestIntersectSegmentTowardsCameraA-&gt;SetWeight(GOWeight::Light);\n        this-&gt;m_LongestIntersectSegmentTowardsCameraB-&gt;SetWeight(GOWeight::Light);\n        this-&gt;m_LongestIntersectSegmentAwayFromCameraA-&gt;SetWeight(GOWeight::Light);\n        this-&gt;m_LongestIntersectSegmentAwayFromCameraB-&gt;SetWeight(GOWeight::Light);\n\n        this-&gt;m_LongestIntersectSegmenDetectToolPlane-&gt;SetColor(GOColor::CYAN);\n        this-&gt;m_LongestIntersectSegmentTowardsCameraA-&gt;SetColor(GOColor::RED);\n        this-&gt;m_LongestIntersectSegmentTowardsCameraB-&gt;SetColor(GOColor::RED);\n        this-&gt;m_LongestIntersectSegmentAwayFromCameraA-&gt;SetColor(GOColor::RED);\n        this-&gt;m_LongestIntersectSegmentAwayFromCameraB-&gt;SetColor(GOColor::RED);\n\n        this-&gt;m_LongestIntersectSegmenDetectToolPlane-&gt;SetVisibility(IsSegmenDetectToolPlaneVisible);\n\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_LongestIntersectSegmenDetectToolPlane);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_LongestIntersectSegmentTowardsCameraA);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_LongestIntersectSegmentTowardsCameraB);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_LongestIntersectSegmentAwayFromCameraA);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_LongestIntersectSegmentAwayFromCameraB);\n\n        this-&gt;Deactivate();\n    }\n} // namespace AIAC\n</code></pre>"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8h/","title":"File CutBladeThicknessVisualizer.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutBladeThicknessVisualizer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FeedbackVisualizer.h\"</code></li> <li><code>#include \"utils/GeometryUtils.h\"</code></li> <li><code>#include \"AIAC/ACInfoModel.h\"</code></li> </ul>"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8h/#classes","title":"Classes","text":"Type Name class CutBladeThicknessVisualizer The idea behind the CutBladeThicknessVisualizer is to give a visual feedback on the thickness of the blade. We do this by intersecting the two neighbours faces of the current highlighted face. <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutBladeThicknessVisualizer.h</code></p>"},{"location":"acdoxygen/CutBladeThicknessVisualizer_8h_source/","title":"File CutBladeThicknessVisualizer.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutBladeThicknessVisualizer.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#ifndef CUTBLADETHICKNESSVISUALIZER_H\n#define CUTBLADETHICKNESSVISUALIZER_H\n\n#include \"FeedbackVisualizer.h\"\n#include \"utils/GeometryUtils.h\"\n#include \"AIAC/ACInfoModel.h\"\n\nnamespace AIAC\n{\n    class CutBladeThicknessVisualizer : public FeedbackVisualizer\n    {\n    public:\n        CutBladeThicknessVisualizer();\n\n    protected:\n        virtual void UpdateToolheadsData() = 0;\n\n        virtual bool IntersectBladeWithNeighbours(\n            AIAC::TimberInfo::Cut* cut, \n            AIAC::TimberInfo::Cut::Face&amp; face,\n            bool isTowardsCamera,\n            bool isDetectToolPlane,\n            std::shared_ptr&lt;GOLine&gt;&amp; lineIntersection) = 0;\n\n    public:\n        bool IsSegmenDetectToolPlaneVisible = false;\n\n    protected:\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmenDetectToolPlane;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentTowardsCameraA;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentTowardsCameraB;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentAwayFromCameraA;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentAwayFromCameraB;\n\n        float m_BladeTotalThicknessScaled;\n        float m_BladeOverhangScaled;\n\n        glm::vec3 m_ToolheadRefNormStart;\n        glm::vec3 m_ToolheadRefNormEnd;\n        glm::vec3 m_ToolheadRefCenter;\n\n        glm::vec3 m_NormalUnitized;\n        glm::vec3 m_NormalOppositeUnitized;\n        glm::vec3 m_DisplacedCenterTowardsCamera;\n        glm::vec3 m_DisplacedCenterAwayFromCamera;\n    };\n} // namespace AIAC\n#endif // CUTBLADETHICKNESSVISUALIZER_H\n</code></pre>"},{"location":"acdoxygen/CutChainSawFeedback_8cpp/","title":"File CutChainSawFeedback.cpp","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutChainSawFeedback.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"CutChainSawFeedback.h\"</code></li> <li><code>#include \"utils/GeometryUtils.h\"</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> </ul>"},{"location":"acdoxygen/CutChainSawFeedback_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.cpp</code></p>"},{"location":"acdoxygen/CutChainSawFeedback_8cpp_source/","title":"File CutChainSawFeedback.cpp","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutChainSawFeedback.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n#include \"AIAC/Application.h\"\n#include \"CutChainSawFeedback.h\"\n#include \"utils/GeometryUtils.h\"\n\n#include &lt;sstream&gt;\n#include &lt;iomanip&gt;\n\nnamespace AIAC\n{\n    CutOrientationVisualizer::CutOrientationVisualizer()\n    {\n        // Normal face line \n        m_LineFaceNormal = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineBladeNormal = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugA = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugB = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugC = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugD = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugE = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LinePitchFeed = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f), GOWeight::MediumThick);\n        m_GuideTxtRollPitch = GOText::Add(\"RollPitch\", GOPoint(0.f, 0.f, 0.f));\n\n        m_GuideTxtRollPitch-&gt;SetTextSize(GOTextSize::Average);\n\n        m_LineFaceNormal-&gt;SetColor(GOColor::BLUE);\n        m_LineBladeNormal-&gt;SetColor(GOColor::MAGENTA);\n        m_LineDebugA-&gt;SetColor(GOColor::ORANGE);\n        m_LineDebugB-&gt;SetColor(GOColor::GREEN);\n        m_LineDebugC-&gt;SetColor(GOColor::RED);\n        m_LineDebugD-&gt;SetColor(GOColor::YELLOW);\n        m_LineDebugE-&gt;SetColor(GOColor::WHITE);\n        m_LinePitchFeed-&gt;SetColor(GOColor::RED);\n        m_GuideTxtRollPitch-&gt;SetColor(GOColor::WHITE);\n\n        m_LineFaceNormal-&gt;SetVisibility(false);\n        m_LineBladeNormal-&gt;SetVisibility(false);\n        m_LineDebugA-&gt;SetVisibility(false);\n        m_LineDebugB-&gt;SetVisibility(false);\n        m_LineDebugC-&gt;SetVisibility(false);\n        m_LineDebugD-&gt;SetVisibility(false);\n        m_LineDebugE-&gt;SetVisibility(false);\n\n        m_AllPrimitives.push_back(m_LinePitchFeed);\n        m_AllPrimitives.push_back(m_GuideTxtRollPitch);\n\n        Deactivate();\n    }\n\n    CutChainSawAngleFeedVisualizer::CutChainSawAngleFeedVisualizer()\n    {\n        // Line\n        m_LineEnd = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineChainBase = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineChainEnd = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        m_LineEnd-&gt;SetColor(GOColor::WHITE);\n        m_LineChainBase-&gt;SetColor(GOColor::WHITE);\n        m_LineChainEnd-&gt;SetColor(GOColor::WHITE);\n\n        m_LineEnd-&gt;SetWeight(GOWeight::Bold);\n        m_LineChainBase-&gt;SetWeight(GOWeight::MediumThick);\n        m_LineChainEnd-&gt;SetWeight(GOWeight::MediumThick);\n\n        m_AllPrimitives.push_back(m_LineEnd);\n        m_AllPrimitives.push_back(m_LineChainBase);\n        m_AllPrimitives.push_back(m_LineChainEnd);\n\n        Deactivate();\n    }\n\n    CutChainSawDepthFeedVisualizer::CutChainSawDepthFeedVisualizer()\n    {\n        // Line\n        m_LineIntersect = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineIntersectThickness = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        m_LineDepthFaceEdge1 = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDepthFaceEdge2 = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        m_LineIntersect-&gt;SetWeight(GOWeight::Light);\n        m_LineIntersectThickness-&gt;SetWeight(GOWeight::Light);\n\n        m_LineIntersect-&gt;SetColor(GOColor::RED);\n        m_LineIntersectThickness-&gt;SetColor(GOColor::RED);\n        m_LineDepthFaceEdge1-&gt;SetColor(GOColor::YELLOW);\n        m_LineDepthFaceEdge2-&gt;SetColor(GOColor::YELLOW);\n\n        m_LineIntersect-&gt;SetWeight(GOWeight::Medium);\n        m_LineIntersectThickness-&gt;SetWeight(GOWeight::Medium);\n        m_LineDepthFaceEdge1-&gt;SetWeight(GOWeight::MediumThick);\n        m_LineDepthFaceEdge2-&gt;SetWeight(GOWeight::MediumThick);\n\n        m_AllPrimitives.push_back(m_LineIntersect);\n        m_AllPrimitives.push_back(m_LineIntersectThickness);\n        m_AllPrimitives.push_back(m_LineDepthFaceEdge1);\n        m_AllPrimitives.push_back(m_LineDepthFaceEdge2);\n\n        Deactivate();\n    }\n\n    CutChainSawFeedVisualizer::CutChainSawFeedVisualizer()\n    {\n        // Text\n        m_GuideTxtChainBase = GOText::Add(\"ChainBase\", GOPoint(0.f, 0.f, 0.f));\n        m_GuideTxtFaceEdgeDepth = GOText::Add(\"FaceEdgeDepth2\", GOPoint(0.f, 0.f, 0.f));\n\n        m_GuideTxtChainBase-&gt;SetTextSize(GOTextSize::Small);\n        m_GuideTxtFaceEdgeDepth-&gt;SetTextSize(GOTextSize::Average);\n\n        m_GuideTxtChainBase-&gt;SetColor(GOColor::BLACK);\n        m_GuideTxtFaceEdgeDepth-&gt;SetColor(GOColor::BLACK);\n\n        m_AllPrimitives.push_back(m_GuideTxtChainBase);\n        m_AllPrimitives.push_back(m_GuideTxtFaceEdgeDepth);\n\n        Deactivate();\n    }\n\n    void CutChainSawFeedback::UpdateCutPlane ()\n    {\n        if(m_ToShowCutPlane) m_CutPlaneVisualizer.Update(m_NormalVec, m_NormStart);\n    }\n\n    void CutChainSawFeedback::UpdateRefFaces() {\n        if (IsRefFacesSelectedManually) {\n            // In manually selection mode, when the m_cut is switched, we have to update the face\n            if (m_Cut-&gt;GetAllFaces().find(m_NearestParallelFaceID) == m_Cut-&gt;GetAllFaces().end()){\n                m_NearestParallelFaceID = m_Cut-&gt;GetAllFaces().begin()-&gt;first;\n            }\n\n            // get the first closest neighbour face to the highlighted face as the perpendicular face\n            // ** As we're limiting the cut to have maximum 3 faces, it doesn't really matter how to calculate.\n            // the perpendicular plane. I think a better idea is to take the furthest neighbor of the nearest parallel\n            // face or the face that maximum the length of the projection line formed by the m_ChainBase and m_ChainEnd.\n            // However, since it's working, I'm not dare to touch it :3\n            m_NearestPerpendicularFaceID = \"\";\n            std::map&lt;std::string, AIAC::TimberInfo::Cut::Face&gt; neighbouringFaces =\n                    this-&gt;m_Cut-&gt;GetFaceNeighbors(m_NearestParallelFaceID);\n            float minDist = std::numeric_limits&lt;float&gt;::max();\n            for (auto const&amp; [faceID, faceInfo] : neighbouringFaces)\n            {\n                auto projCenter = GetProjectionPointOnPlane(\n                        faceInfo.GetNormal(),\n                        faceInfo.GetCenter(),\n                        m_ChainMid);\n                float distAbs = glm::abs(glm::distance(m_ChainMid, projCenter));\n                if (distAbs &lt; minDist)\n                {\n                    minDist = distAbs;\n                    m_NearestPerpendicularFaceID = faceID;\n                }\n            }\n        } else {\n            // Find the nearest parallel/perpendicular face to highlight\n            float nearestParallelFaceDist = 1e9f;\n            float nearestPerpendicularFaceDist = 1e9f;\n            std::vector&lt;std::string&gt; parallelFaceIDs;\n            std::vector&lt;std::string&gt; perpendicularFaceIDs;\n\n            for (auto const &amp;[faceID, faceInfo]: m_Cut-&gt;GetAllFaces()) {\n                if (faceInfo.IsExposed()) continue;\n                auto faceNormal = faceInfo.GetNormal();\n                auto theta = glm::acos(\n                        glm::dot(faceNormal, m_NormalVec) / (glm::length(faceNormal) * glm::length(m_NormalVec)));\n\n                auto distChainBase = glm::distance(faceInfo.GetCenter(), m_ChainBase);\n                auto distChainEnd = glm::distance(faceInfo.GetCenter(), m_ChainEnd);\n                auto totalDist = distChainBase + distChainEnd;\n\n                // for parallel faces, find the nearest one\n                auto threshold = 0.7853f; // 45 degrees\n                if (theta &lt; threshold || (3.14159 - theta) &lt; threshold) {\n                    parallelFaceIDs.push_back(faceID);\n                    // update nearest parallel face\n                    if (m_NearestParallelFaceID.empty() || totalDist &lt; nearestParallelFaceDist) {\n                        m_NearestParallelFaceID = faceID;\n                        nearestParallelFaceDist = totalDist;\n                    }\n                } else {\n                    perpendicularFaceIDs.push_back(faceID);\n                    // update nearest perpendicular face\n                    if (m_NearestPerpendicularFaceID.empty() || totalDist &lt; nearestPerpendicularFaceDist) {\n                        m_NearestPerpendicularFaceID = faceID;\n                        nearestPerpendicularFaceDist = totalDist;\n                    }\n                }\n            }\n        }\n    }\n\n    void CutChainSawFeedback::ManuallyScrollRefFace(int scrollDirection) {\n        auto iter = m_Cut-&gt;GetAllFaces().find(m_NearestParallelFaceID);\n\n        // if scroll direction &gt; 0 =&gt; goes to next, otherwise, goes back\n        if (scrollDirection &gt; 0) {\n            iter++;\n            if (iter == m_Cut-&gt;GetAllFaces().end()){\n                iter = m_Cut-&gt;GetAllFaces().begin();\n            }\n        } else {\n            if (iter == m_Cut-&gt;GetAllFaces().begin()){\n                iter = m_Cut-&gt;GetAllFaces().end();\n            }\n            iter--;\n        }\n\n        m_NearestParallelFaceID = iter-&gt;first;\n\n    }\n\n    void CutChainSawFeedback::Update()\n    {\n        // calculate tool normal\n        m_NormStart = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().NormStartGO-&gt;GetPosition();\n        m_NormEnd = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().NormEndGO-&gt;GetPosition();\n        m_ChainBase = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().ChainBaseGO-&gt;GetPosition();\n        m_ChainMid = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().ChainMidGO-&gt;GetPosition();\n        m_ChainEnd = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().ChainEndGO-&gt;GetPosition();\n        m_NormalVec = glm::normalize(m_NormEnd - m_NormStart);\n\n        m_Cut = dynamic_cast&lt;TimberInfo::Cut*&gt;(AC_FF_COMP);\n        auto&amp; angleVisualizer = this-&gt;m_Visualizer.GetAngleFeedVisualizer();\n        auto&amp; depthVisualizer = this-&gt;m_Visualizer.GetDepthFeedVisualizer();\n\n        if(m_ToShowCutPlane) UpdateCutPlane();\n\n        // if it's a single face show the cutting plane\n        if(m_Cut-&gt;IsSingleFace()) {\n            this-&gt;EnableCutPlane(true);\n        }\n\n        this-&gt;UpdateRefFaces();\n\n        // Highlight the face\n        if (!m_Cut-&gt;IsSingleFace())\n            m_Cut-&gt;HighlightFace(m_NearestParallelFaceID);\n\n        // Update the m_Visualizer for the closest parallel face\n        bool hasParallelFace = false, hasPerpendicularFace = false;\n\n        double parallelEndDist = 0.0f;\n        double parallelChainBaseDist = 0.0f;\n        double perpendicularFaceEdge1Dist = 0.0f;\n        double perpendicularFaceEdge2Dist = 0.0f;\n        glm::vec3 perpIntersectLineSegPt1, perpIntersectLineSegPt2; // for depth text anchor\n\n        // update angle visualizer\n        if(!m_NearestParallelFaceID.empty())\n        {\n            hasParallelFace = true;\n            angleVisualizer.Activate();\n\n            // find the projection point of the three points on the face\n            auto faceInfo = m_Cut-&gt;GetFace(m_NearestParallelFaceID);\n            auto faceNormal = faceInfo.GetNormal();\n            auto faceCenter = faceInfo.GetCenter();\n\n            auto projNormStart = GetProjectionPointOnPlane(faceNormal, faceCenter, m_NormStart);\n            auto projChainBase = GetProjectionPointOnPlane(faceNormal, faceCenter, m_ChainBase);\n\n            // update the m_Visualizer\n            angleVisualizer.m_LineChainBase-&gt;SetPts(m_ChainBase, projChainBase);\n            parallelChainBaseDist = glm::distance(m_ChainBase, projChainBase);\n            angleVisualizer.m_LineChainBase-&gt;SetColor(parallelChainBaseDist &lt; 0.5f ? GOColor::GREEN : GOColor::WHITE);\n        }\n        else\n        {\n            angleVisualizer.Deactivate();\n        }\n\n        // extra orientation\n        if (!m_NearestParallelFaceID.empty() or m_Cut-&gt;IsSingleFace())\n        {\n            m_CutOrientationVisualizer.Activate();\n\n            // face and blade normal\n            auto faceInfo = m_Cut-&gt;GetFace(m_NearestParallelFaceID);\n            auto faceNormal = faceInfo.GetNormal();\n            auto faceCenter = faceInfo.GetCenter();\n            m_CutOrientationVisualizer.m_LineFaceNormal-&gt;SetPts(faceCenter, faceCenter + faceNormal);\n\n            auto bladeNormal = glm::normalize(m_NormEnd - m_NormStart);\n            m_CutOrientationVisualizer.m_LineBladeNormal-&gt;SetPts(faceCenter, faceCenter + bladeNormal);\n\n            // get the axis system of the face with the projection of the blade normal\n            glm::vec3 zVec = glm::normalize(faceNormal);\n            glm::vec3 xVec = glm::normalize(glm::cross(faceNormal, faceCenter));\n            glm::vec3 yVec = glm::normalize(glm::cross(faceNormal, xVec));\n            glm::vec3 bladeNormalProjOnFace = (m_NormEnd - m_NormStart) - glm::dot(m_NormEnd - m_NormStart, zVec) * zVec;\n\n            xVec = glm::normalize(bladeNormalProjOnFace);\n            yVec = glm::normalize(glm::cross(zVec, xVec));\n\n            // draw the rotated x axis as a GOLine\n            m_CutOrientationVisualizer.m_LineDebugB-&gt;SetPts(faceCenter, faceCenter + xVec);\n            m_CutOrientationVisualizer.m_LineDebugC-&gt;SetPts(faceCenter, faceCenter + yVec);\n\n            // draw the line between the end of the m_LineBladeNormal and the end of the lineDebugC\n            float pitch = glm::degrees(atan2(bladeNormalProjOnFace.y, bladeNormalProjOnFace.z));\n            m_CutOrientationVisualizer.m_LineDebugD-&gt;SetPts(\n                m_CutOrientationVisualizer.m_LineBladeNormal-&gt;GetPEnd(),\n                m_CutOrientationVisualizer.m_LineDebugB-&gt;GetPEnd());\n            // draw the line between the end of the m_LineBladeNormal and the end of the lineDebugB\n            m_CutOrientationVisualizer.m_LineDebugE-&gt;SetPts(\n                m_CutOrientationVisualizer.m_LineBladeNormal-&gt;GetPEnd(),\n                m_CutOrientationVisualizer.m_LineDebugC-&gt;GetPEnd());\n\n            // calculare the angle between m_LineDebugE and m_LineDebugC (the pitch)\n            float anglePitch = m_CutOrientationVisualizer.m_LineDebugD-&gt;ComputeSignedAngle(\n                m_CutOrientationVisualizer.m_LineDebugB\n                );\n            float anglePitchDiffNeg = -45.0f - anglePitch;\n            float anglePitchDiffPos = 45.0f - anglePitch;\n            float anglePitchDiff = std::abs(anglePitchDiffNeg) &lt; std::abs(anglePitchDiffPos) ? anglePitchDiffNeg : anglePitchDiffPos;\n            anglePitchDiff = std::round(anglePitchDiff * 10) / 10;\n\n            // Set the axis system on the blade\n            glm::vec3 bladeZVec = glm::normalize(m_NormEnd - m_NormStart);\n            glm::vec3 bladeXVec = glm::normalize(glm::cross(m_ChainMid - m_ChainBase, bladeZVec));\n            glm::vec3 bladeYVec = glm::normalize(glm::cos(1.5708f) * bladeXVec + glm::sin(1.5708f) * bladeZVec);\n\n            // Pitch guidance\n            // show the degree difference in text\n            m_CutOrientationVisualizer.m_GuideTxtRollPitch-&gt;SetAnchor(m_ChainMid + bladeYVec * 0.5f);\n            std::ostringstream stream;\n            stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; anglePitchDiff;\n            std::string anglePitchDiffStr = stream.str();\n            m_CutOrientationVisualizer.m_GuideTxtRollPitch-&gt;SetText(\"r:\" + anglePitchDiffStr +\"\u00b0\");\n            if (anglePitchDiff &gt; -m_CutOrientationVisualizer.m_tolAangleAcceptance &amp;&amp; anglePitchDiff &lt; m_CutOrientationVisualizer.m_tolAangleAcceptance)\n                m_CutOrientationVisualizer.m_GuideTxtRollPitch-&gt;SetColor(GOColor::GREEN);\n            else\n                m_CutOrientationVisualizer.m_GuideTxtRollPitch-&gt;SetColor(GOColor::WHITE);\n\n            // give a visual line feedback on the orientation\n            if (anglePitchDiff &gt; m_CutOrientationVisualizer.m_tolAangleAcceptance)\n            {\n                m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetColor(GOColor::MAGENTA);\n                m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetPts(m_ChainMid, m_ChainMid + bladeYVec * anglePitchDiff);\n            }\n            else if (anglePitchDiff &lt; -m_CutOrientationVisualizer.m_tolAangleAcceptance)\n            {\n                m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetColor(GOColor::RED);\n                m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetPts(m_ChainMid, m_ChainMid + bladeYVec * anglePitchDiff);\n            }\n            else if (anglePitchDiff &gt; -m_CutOrientationVisualizer.m_tolAangleAcceptance &amp;&amp; anglePitchDiff &lt; m_CutOrientationVisualizer.m_tolAangleAcceptance)\n            {\n                m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetColor(GOColor::GREEN);\n                m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetPts(m_ChainMid, m_ChainMid + bladeYVec * 0.3f);\n            }\n\n            // set the visibility off for the debug lines\n            m_CutOrientationVisualizer.m_LinePitchFeed-&gt;SetVisibility(true);\n            m_CutOrientationVisualizer.m_GuideTxtRollPitch-&gt;SetVisibility(true);\n\n        }\n        else\n        {\n            m_CutOrientationVisualizer.Deactivate();\n        }\n\n        // Perpendicular face\n        if(!m_NearestPerpendicularFaceID.empty() and !m_Cut-&gt;IsSingleFace())\n        {\n            hasPerpendicularFace = true;\n\n            // find the projection point of the 2 points on the face\n            auto faceInfo = m_Cut-&gt;GetFace(m_NearestPerpendicularFaceID);\n            auto faceNormal = faceInfo.GetNormal();\n            auto faceCenter = faceInfo.GetCenter();\n\n            // Get the intersection line of the tool plane and the face plane\n            glm::vec3 intersectLineVec, intersectLinePt;\n            if(!GetIntersectLineOf2Planes(faceNormal, faceCenter,\n                                          m_NormalVec, m_ChainBase,\n                                          intersectLineVec, intersectLinePt)){\n                AIAC_ERROR(\"Failed to get the intersect line of two planes\");\n                // Technically this should not happen\n                // TODO: Error handling?\n            }\n\n            // Get the intersection point of the intersect line and the face's edges\n            std::vector&lt;glm::vec3&gt; intersectPts;\n            for(auto const&amp; edgeID: faceInfo.GetEdges()){\n                auto edge = m_Cut-&gt;GetEdge(edgeID);\n                auto edgePt1 = edge.GetStartPt().GetPosition();\n                auto edgePt2 = edge.GetEndPt().GetPosition();\n                ExtendLineSeg(edgePt1, edgePt2, 0.5f);\n                glm::vec3 intersectPt;\n                if(GetIntersectPointOfLineAndLineSeg(intersectLineVec, intersectLinePt, edgePt1, edgePt2, intersectPt)) {\n                    intersectPts.push_back(intersectPt);\n                }\n            }\n            FormLongestLineSeg(intersectPts, perpIntersectLineSegPt1, perpIntersectLineSegPt2);\n\n            // FIXME: here we should intersect instead of translate the lines at the end\n            // TODO: clean up the thickness section\n            // Thicknesses &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n            float bladeThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().ThicknessACIT;\n            float overHangThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().OverhangACIT;\n            float displacementTowardsCamera = overHangThicknessScaled;\n            float displacementAwayFromCamera = bladeThicknessScaled - overHangThicknessScaled;\n\n            // Lines based on tool\n            auto projChainBase = GetNearestPtOnLine(intersectLineVec, intersectLinePt, m_ChainBase);\n            auto projChainEnd = GetNearestPtOnLine(intersectLineVec, intersectLinePt, m_ChainEnd);\n            glm::vec3 normalVec = glm::normalize(m_NormEnd - m_NormStart);\n            auto projChainBaseTranslatedTwardsoCamera = projChainBase + normalVec * displacementTowardsCamera;\n            auto projChainEndTranslatedTwardsoCamera = projChainEnd + normalVec * displacementTowardsCamera;\n            depthVisualizer.m_LineIntersect-&gt;SetPts(projChainBaseTranslatedTwardsoCamera, projChainEndTranslatedTwardsoCamera);\n\n            // depthVisualizer.m_LineIntersect-&gt;SetPts(projChainBase, projChainEnd);\n            glm::vec3 oppositeNormalVec = -(glm::normalize(m_NormEnd - m_NormStart));\n            auto projChainBaseTranslatedAwayFromCamera = projChainBase + oppositeNormalVec * displacementAwayFromCamera;\n            auto projChainEndTranslatedAwayFromCamera = projChainEnd + oppositeNormalVec * displacementAwayFromCamera;\n            depthVisualizer.m_LineIntersectThickness-&gt;SetPts(projChainBaseTranslatedAwayFromCamera, projChainEndTranslatedAwayFromCamera);\n            // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n            // TODO: next is depth?? &lt;&lt;\n            // Lines based on face edge\n            // for face edge dist, we need to find the projection point of the two points on the saw first\n            glm::vec3 pt1ProjPt, pt2ProjPt;\n            auto pt1OnEndMid = GetNearestPtOnLine(m_ChainEnd - m_ChainMid, m_ChainEnd, perpIntersectLineSegPt1);\n            auto pt1OnMidBase = GetNearestPtOnLine(m_ChainMid - m_ChainBase, m_ChainMid, perpIntersectLineSegPt1);\n            auto pt2OnEndMid = GetNearestPtOnLine(m_ChainEnd - m_ChainMid, m_ChainEnd, perpIntersectLineSegPt2);\n            auto pt2OnMidBase = GetNearestPtOnLine(m_ChainMid - m_ChainBase, m_ChainMid, perpIntersectLineSegPt2);\n\n            bool pt1Found = false, pt2Found = false;\n            if(IsPointBetweenLineSeg(pt1OnMidBase, m_ChainMid, m_ChainBase)){\n                pt1ProjPt = pt1OnMidBase;\n                pt1Found = true;\n            } else if(IsPointBetweenLineSeg(pt1OnEndMid, m_ChainEnd, m_ChainMid)){\n                pt1ProjPt = pt1OnEndMid;\n                pt1Found = true;\n            }\n            if(IsPointBetweenLineSeg(pt2OnMidBase, m_ChainMid, m_ChainBase)){\n                pt2ProjPt = pt2OnMidBase;\n                pt2Found = true;\n            } else if(IsPointBetweenLineSeg(pt2OnEndMid, m_ChainEnd, m_ChainMid)){\n                pt2ProjPt = pt2OnEndMid;\n                pt2Found = true;\n            }\n            if(pt1Found &amp;&amp; pt2Found){\n                depthVisualizer.m_LineDepthFaceEdge1-&gt;SetPts(perpIntersectLineSegPt1, pt1ProjPt);\n                depthVisualizer.m_LineDepthFaceEdge2-&gt;SetPts(perpIntersectLineSegPt2, pt2ProjPt);\n\n                perpendicularFaceEdge1Dist = glm::distance(perpIntersectLineSegPt1, pt1ProjPt);\n                perpendicularFaceEdge2Dist = glm::distance(perpIntersectLineSegPt2, pt2ProjPt);\n                float scaleFactor = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n                float realPerpendicularFaceEdge1Dist = perpendicularFaceEdge1Dist / scaleFactor;\n                float realPerpendicularFaceEdge2Dist = perpendicularFaceEdge2Dist / scaleFactor;\n\n                // get the direction of tool\n                auto toolUpVec = glm::normalize(m_NormStart - m_ChainBase);\n                auto chainBaseVec = glm::normalize(m_ChainBase - projChainBase);\n                auto chainEndVec = glm::normalize(m_ChainEnd - projChainEnd);\n                auto faceEdge1Vec = glm::normalize(pt1ProjPt - perpIntersectLineSegPt1);\n                auto faceEdge2Vec = glm::normalize(pt2ProjPt - perpIntersectLineSegPt2);\n\n                if(glm::dot(toolUpVec, faceEdge1Vec) &lt; 0){\n                    depthVisualizer.m_LineDepthFaceEdge1-&gt;SetColor(GOColor::RED);\n                    perpendicularFaceEdge1Dist = -perpendicularFaceEdge1Dist;\n                } else {\n                    depthVisualizer.m_LineDepthFaceEdge1-&gt;SetColor(GOColor::YELLOW);\n                }\n                if(glm::dot(toolUpVec, faceEdge2Vec) &lt; 0){\n                    depthVisualizer.m_LineDepthFaceEdge2-&gt;SetColor(GOColor::RED);\n                    perpendicularFaceEdge2Dist = -perpendicularFaceEdge2Dist;\n                } else {\n                    depthVisualizer.m_LineDepthFaceEdge2-&gt;SetColor(GOColor::YELLOW);\n                }\n\n                // if the two guide lines have a close same distance than mark as yellow\n                float diffPerpendicularFaceEdgeDist = std::abs(realPerpendicularFaceEdge1Dist - realPerpendicularFaceEdge2Dist);\n                if(diffPerpendicularFaceEdgeDist &lt; this-&gt;m_Visualizer.m_DistDepthAcceptance){\n                    depthVisualizer.m_LineDepthFaceEdge1-&gt;SetColor(GOColor::GREEN);\n                    depthVisualizer.m_LineDepthFaceEdge2-&gt;SetColor(GOColor::GREEN);\n                }\n\n\n                depthVisualizer.Activate();\n            } else {\n                depthVisualizer.Deactivate();\n            }\n        } else\n        {\n            depthVisualizer.Deactivate();\n        }\n\n        if(hasParallelFace || hasPerpendicularFace)\n        {\n            m_Visualizer.Activate();\n\n            auto strEnd = FeedbackVisualizer::toString(parallelEndDist);\n            auto strChainBase = FeedbackVisualizer::toString(parallelChainBaseDist);\n\n            this-&gt;m_Visualizer.m_GuideTxtChainBase-&gt;SetText(\"s:\"+strChainBase);\n            this-&gt;m_Visualizer.m_GuideTxtFaceEdgeDepth-&gt;SetText(\"d:\"+FeedbackVisualizer::toString(perpendicularFaceEdge2Dist));\n            this-&gt;m_Visualizer.m_GuideTxtChainBase-&gt;SetAnchor(m_ChainBase);\n            this-&gt;m_Visualizer.m_GuideTxtFaceEdgeDepth-&gt;SetAnchor(perpIntersectLineSegPt1);\n\n            auto endColor = GOColor::WHITE;\n            auto chainBaseColor = GOColor::WHITE;\n            auto chainEndColor = GOColor::WHITE;\n\n            auto faceEdgeTxt1Color = GOColor::BLACK;\n            auto faceEdgeTxt2Color = GOColor::BLACK;\n\n            if(parallelEndDist != 0 &amp;&amp; parallelEndDist &lt; 0.5f){\n                endColor = GOColor::GREEN;\n            }\n            if(parallelChainBaseDist != 0 &amp;&amp; parallelChainBaseDist &lt; 0.5f){\n                chainBaseColor = GOColor::GREEN;\n            }\n\n            if(perpendicularFaceEdge1Dist &gt; 0 &amp;&amp; perpendicularFaceEdge1Dist &lt; 0.5f){\n                faceEdgeTxt1Color = GOColor::GREEN;\n            } else if (perpendicularFaceEdge1Dist &lt; 0){\n                faceEdgeTxt1Color = GOColor::RED;\n            }\n            if(perpendicularFaceEdge2Dist &gt; 0 &amp;&amp; perpendicularFaceEdge2Dist &lt; 0.5f){\n                faceEdgeTxt2Color = GOColor::ORANGE;\n            } else if (perpendicularFaceEdge2Dist &lt; 0){\n                faceEdgeTxt2Color = GOColor::RED;\n            }\n\n            this-&gt;m_Visualizer.m_GuideTxtChainBase-&gt;SetColor(chainBaseColor);\n            this-&gt;m_Visualizer.m_GuideTxtFaceEdgeDepth-&gt;SetColor(faceEdgeTxt2Color);\n        }\n        else m_Visualizer.Deactivate();\n    }\n\n    void CutChainSawFeedback::Activate()\n    {\n        Update();\n        if(m_ToShowCutPlane)\n        {\n            this-&gt;m_CutPlaneVisualizer.Activate();\n        }\n    }\n\n    void CutChainSawFeedback::Deactivate()\n    {\n        this-&gt;m_Visualizer.Deactivate();\n\n        this-&gt;m_CutPlaneVisualizer.Deactivate();\n        this-&gt;m_Visualizer.m_AngleFeedVisualizer.Deactivate();\n        this-&gt;m_Visualizer.m_DepthFeedVisualizer.Deactivate();\n\n        this-&gt;m_CutOrientationVisualizer.Deactivate();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/CutChainSawFeedback_8h/","title":"File CutChainSawFeedback.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutChainSawFeedback.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Feedback/CutPlaneVisualizer.h\"</code></li> <li><code>#include \"AIAC/Feedback/FeedbackVisualizer.h\"</code></li> <li><code>#include \"AIAC/Feedback/FabFeedback.h\"</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"acdoxygen/CutChainSawFeedback_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/CutChainSawFeedback_8h/#classes","title":"Classes","text":"Type Name class ChainSawCutPlaneVisualizer class CutChainSawAngleFeedVisualizer class CutChainSawDepthFeedVisualizer class CutChainSawFeedVisualizer class CutChainSawFeedback class CutOrientationVisualizer This visualizer gives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutChainSawFeedback.h</code></p>"},{"location":"acdoxygen/CutChainSawFeedback_8h_source/","title":"File CutChainSawFeedback.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutChainSawFeedback.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n#pragma once\n\n#include \"AIAC/Feedback/CutPlaneVisualizer.h\"\n#include \"AIAC/Feedback/FeedbackVisualizer.h\"\n#include \"AIAC/Feedback/FabFeedback.h\"\n\n#include &lt;vector&gt;\n\nnamespace AIAC\n{\n    class CutOrientationVisualizer : public FeedbackVisualizer\n    {\n        public:\n            CutOrientationVisualizer();\n\n        private:\n            std::shared_ptr&lt;GOLine&gt; m_LineFaceNormal;  // BLUE (face_z)\n            std::shared_ptr&lt;GOLine&gt; m_LineBladeNormal;  // MAGENTA\n\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugA;  // ORANGE\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugB;  // GREEN (face_y)\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugC;  // RED (face_x)\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugD;  // YELLOW\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugE;  // WHITE\n\n            std::shared_ptr&lt;GOLine&gt; m_LinePitchFeed;  // RED or MAGENTA\n\n            std::shared_ptr&lt;GOText&gt; m_GuideTxtRollPitch;  // WHITE\n\n        private:\n            float m_tolAangleAcceptance = 0.4f;  // decimal fraction of a degree\n\n        friend class CutChainSawFeedback;\n\n    };\n\n    class CutChainSawAngleFeedVisualizer : public FeedbackVisualizer\n    {\n        public:\n            CutChainSawAngleFeedVisualizer();\n\n        private:\n            std::shared_ptr&lt;GOLine&gt; m_LineEnd;\n            std::shared_ptr&lt;GOLine&gt; m_LineChainBase;\n            std::shared_ptr&lt;GOLine&gt; m_LineChainEnd;\n\n        friend class CutChainSawFeedback;\n        };\n\n        class CutChainSawDepthFeedVisualizer : public FeedbackVisualizer\n        {\n        public:\n            CutChainSawDepthFeedVisualizer();\n\n        private:\n            std::shared_ptr&lt;GOLine&gt; m_LineIntersect;\n            std::shared_ptr&lt;GOLine&gt; m_LineIntersectThickness;\n            std::shared_ptr&lt;GOLine&gt; m_LineDepthFaceEdge1;\n            std::shared_ptr&lt;GOLine&gt; m_LineDepthFaceEdge2;\n\n        friend class CutChainSawFeedback;\n    };\n\n    class ChainSawCutPlaneVisualizer: public CutPlaneVisualizer\n    {\n        public:\n            ChainSawCutPlaneVisualizer() = default;\n\n        friend class CutChainSawFeedback;\n        };\n\n        class CutChainSawFeedVisualizer : public FeedbackVisualizer\n        {\n        public:\n            CutChainSawFeedVisualizer();\n\n            CutChainSawAngleFeedVisualizer&amp; GetAngleFeedVisualizer() { return m_AngleFeedVisualizer; }\n            CutChainSawDepthFeedVisualizer&amp; GetDepthFeedVisualizer() { return m_DepthFeedVisualizer; }\n\n        private:\n            CutChainSawAngleFeedVisualizer m_AngleFeedVisualizer;\n            CutChainSawDepthFeedVisualizer m_DepthFeedVisualizer;\n\n            std::shared_ptr&lt;GOText&gt; m_GuideTxtEnd;\n            std::shared_ptr&lt;GOText&gt; m_GuideTxtChainBase;\n            std::shared_ptr&lt;GOText&gt; m_GuideTxtChainEnd;\n\n            std::shared_ptr&lt;GOText&gt; m_GuideTxtFaceEdgeDepth;\n\n            float m_DistDepthAcceptance = 0.0025f;\n\n            friend class CutChainSawFeedback;\n    };\n\n    class CutChainSawFeedback : public FabFeedback\n    {\n        public:\n            CutChainSawFeedback() = default;\n\n            void Update() override;\n            void Activate() override;\n            void Deactivate() override;\n\n            // FIXME: maybe we can have a \"CutFeedback\" class for such fuctions\n            inline void EnableCutPlane(bool enable) { \n                m_ToShowCutPlane = enable;\n                if(enable) m_CutPlaneVisualizer.Activate();\n                else m_CutPlaneVisualizer.Deactivate();\n            }\n\n            void ManuallyScrollRefFace(int scrollDirection);\n\n        public:\n            // config exposed to UI\n            bool IsRefFacesSelectedManually = false;\n\n        private:\n            void UpdateCutPlane();\n            void UpdateRefFaces();\n\n            glm::vec3 m_NormStart;\n            glm::vec3 m_NormEnd;\n            glm::vec3 m_NormalVec;\n            glm::vec3 m_ChainBase;\n            glm::vec3 m_ChainMid;\n            glm::vec3 m_ChainEnd;\n\n            bool m_ToShowCutPlane = false;\n\n        private:\n            TimberInfo::Cut* m_Cut;\n            std::string m_NearestParallelFaceID;\n            std::string m_NearestPerpendicularFaceID;\n\n            CutChainSawFeedVisualizer m_Visualizer;\n            ChainSawCutPlaneVisualizer m_CutPlaneVisualizer;\n            CutOrientationVisualizer m_CutOrientationVisualizer;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/CutCircularSawFeedback_8cpp/","title":"File CutCircularSawFeedback.cpp","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutCircularSawFeedback.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"CutCircularSawFeedback.h\"</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;climits&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"acdoxygen/CutCircularSawFeedback_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.cpp</code></p>"},{"location":"acdoxygen/CutCircularSawFeedback_8cpp_source/","title":"File CutCircularSawFeedback.cpp","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutCircularSawFeedback.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n\n#include \"AIAC/Application.h\"\n#include \"CutCircularSawFeedback.h\"\n\n#include &lt;sstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;climits&gt; // For INT_MIN and INT_MAX\n#include &lt;cmath&gt; // For std::isfinite\u263a\n\n\nnamespace AIAC\n{\n    CutCircularSawDepthVisualizer::CutCircularSawDepthVisualizer()\n    {\n        m_LineDepth = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_TxtDepth = GOText::Add(\"0.0\", GOPoint(0.f, 0.f, 0.f));\n        m_PtBlade2ThicknessLineA = GOPoint::Add(GOPoint(0.f, 0.f, 0.f));\n        m_PtBlade2ThicknessLineB = GOPoint::Add(GOPoint(0.f, 0.f, 0.f));\n\n        m_LineDepth-&gt;SetColor(GOColor::PINK_TRANSP);\n        m_TxtDepth-&gt;SetColor(GOColor::YELLOW);\n        m_PtBlade2ThicknessLineA-&gt;SetColor(GOColor::PURPLE_TRANSP07);\n        m_PtBlade2ThicknessLineB-&gt;SetColor(GOColor::PINK_TRANSP07);\n\n        m_PtBlade2ThicknessLineA-&gt;SetWeight(GOWeight::MediumThick);\n        m_PtBlade2ThicknessLineB-&gt;SetWeight(GOWeight::MediumThick);\n\n        m_TxtDepth-&gt;SetTextSize(GOTextSize::BitSmall);\n\n        m_AllPrimitives.push_back(m_LineDepth);\n        m_AllPrimitives.push_back(m_TxtDepth);\n        m_AllPrimitives.push_back(m_PtBlade2ThicknessLineA);\n        m_AllPrimitives.push_back(m_PtBlade2ThicknessLineB);\n\n        Deactivate();\n    }\n\n    CutCircularSawPositionStartVisualizer::CutCircularSawPositionStartVisualizer()\n    {\n        this-&gt;m_LineDistStart = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f), GOWeight::Thick);\n        this-&gt;m_TxtDistStart = GOText::Add(\"0.0\", GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_LineToBottomPt = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        this-&gt;m_LineDistStart-&gt;SetColor(GOColor::YELLOW);\n        this-&gt;m_TxtDistStart-&gt;SetColor(GOColor::WHITE);\n        this-&gt;m_LineToBottomPt-&gt;SetColor(GOColor::YELLOW);\n        this-&gt;m_LineToBottomPt-&gt;SetVisibility(false);  // only for debugging\n\n        this-&gt;m_TxtDistStart-&gt;SetTextSize(GOTextSize::BitSmall);\n\n        this-&gt;m_AllPrimitives.push_back(m_LineDistStart);\n        this-&gt;m_AllPrimitives.push_back(m_TxtDistStart);\n\n        Deactivate();\n    }\n\n    CutCircularOrientationVisualizer::CutCircularOrientationVisualizer()\n    {\n        m_LineFaceNormal = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineBladeNormal = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugA = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugB = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugC = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugD = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LineDebugE = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LinePitchFeed = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f), GOWeight::ExtraThick);\n        m_GuideTxtRollPitch = GOText::Add(\"0.0\", GOPoint(0.f, 0.f, 0.f));\n\n        m_LineFaceNormal-&gt;SetColor(GOColor::BLUE);\n        m_LineBladeNormal-&gt;SetColor(GOColor::MAGENTA);\n        m_LineDebugA-&gt;SetColor(GOColor::ORANGE);\n        m_LineDebugB-&gt;SetColor(GOColor::GREEN);\n        m_LineDebugC-&gt;SetColor(GOColor::RED);\n        m_LineDebugD-&gt;SetColor(GOColor::YELLOW);\n        m_LineDebugE-&gt;SetColor(GOColor::WHITE);\n        m_LinePitchFeed-&gt;SetColor(GOColor::RED);\n        m_GuideTxtRollPitch-&gt;SetColor(GOColor::WHITE);\n\n        m_GuideTxtRollPitch-&gt;SetTextSize(GOTextSize::BitSmall);\n\n        m_LineFaceNormal-&gt;SetVisibility(false);\n        m_LineBladeNormal-&gt;SetVisibility(false);\n        m_LineDebugA-&gt;SetVisibility(false);\n        m_LineDebugB-&gt;SetVisibility(false);\n        m_LineDebugC-&gt;SetVisibility(false);\n        m_LineDebugD-&gt;SetVisibility(false);\n        m_LineDebugE-&gt;SetVisibility(false);\n\n        m_AllPrimitives.push_back(m_LinePitchFeed);\n        m_AllPrimitives.push_back(m_GuideTxtRollPitch);\n\n        Deactivate();\n    }\n\n    void CutCircularSawFeedback::Update() {\n        m_Cut = dynamic_cast&lt;TimberInfo::Cut*&gt;(AC_FF_COMP);\n\n        if(m_Cut-&gt;IsSingleFace()) {\n            this-&gt;EnableCutPlane(true);\n        }\n\n        UpdateToolPosition();\n        UpdateRefFaces();\n        UpdateFeedback();\n    }\n\n    void CutCircularSawFeedback::Activate() {\n        m_OrientationVisualizer.Activate();\n        m_PositionStartVisualizer.Activate();\n        m_ThicknessVisualizer.Activate();\n        m_DepthVisualizer.Activate();\n        Update();\n    }\n\n    void CutCircularSawFeedback::Deactivate() {\n        m_CutPlaneVisualizer.Deactivate();\n        m_OrientationVisualizer.Deactivate();\n        m_PositionStartVisualizer.Deactivate();\n        m_ThicknessVisualizer.Deactivate();\n        m_DepthVisualizer.Deactivate();\n    }\n\n    void CutCircularSawFeedback::UpdateToolPosition() {\n        m_Radius = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().RadiusACIT;\n        m_Center = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().CenterGO-&gt;GetPosition();\n        m_NormalStart = m_Center; // AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().NormStartGO-&gt;GetPosition(); // this value is not initialized\n        m_NormalEnd = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().NormEndGO-&gt;GetPosition();\n        m_Normal = glm::normalize(m_NormalEnd - m_NormalStart);\n    }\n\n    void CutCircularSawFeedback::ManuallyScrollRefFace(int scrollDirection) {\n        auto iter = m_Cut-&gt;GetAllFaces().find(m_NearestParallelFaceID);\n\n        // if scroll direction &gt; 0 =&gt; goes to next, otherwise, goes back\n        if (scrollDirection &gt; 0) {\n            iter++;\n            if (iter == m_Cut-&gt;GetAllFaces().end()){\n                iter = m_Cut-&gt;GetAllFaces().begin();\n            }\n        } else {\n            if (iter == m_Cut-&gt;GetAllFaces().begin()){\n                iter = m_Cut-&gt;GetAllFaces().end();\n            }\n            iter--;\n        }\n\n        m_NearestParallelFaceID = iter-&gt;first;\n\n    }\n\n    void CutCircularSawFeedback::UpdateRefFaces()\n    {\n        // --------------------------------------------------------------------\n        // update the reference faces (parallel / perpendicular)\n        if (IsRefFacesSelectedManually) {\n            // In manually selection mode, when the m_cut is switched, we have to update the face\n            if (m_Cut-&gt;GetAllFaces().find(m_NearestParallelFaceID) == m_Cut-&gt;GetAllFaces().end()){\n                m_NearestParallelFaceID = m_Cut-&gt;GetAllFaces().begin()-&gt;first;\n            }\n        } else {\n            // automatically determine the reference faces\n            std::string nearestParallelFaceID;\n            std::vector&lt;std::pair&lt;std::string, float&gt;&gt; allValidFaces;\n            std::vector&lt;std::pair&lt;std::string, float&gt;&gt; perpenFaces;\n\n            // get the distances to the blade circle\n            for(auto const&amp; [faceID, faceInfo]: m_Cut-&gt;GetAllFaces()){\n                if (faceInfo.IsExposed()) continue;\n                glm::vec3 ptOnCircleBlade = GOCircle::ClosestPointToCircle(\n                        faceInfo.GetCenter(),\n                        m_Center,\n                        m_Normal,\n                        m_Radius\n                );\n                auto dist = glm::abs(glm::distance(ptOnCircleBlade, faceInfo.GetCenter()));\n                allValidFaces.push_back(std::make_pair(faceID, dist));\n            }\n            // filter the vector with an angle threshold, erase those elements in the vector that do not respect the check\n            auto thresholdAngle = 0.7853f; // 45 degrees\n            allValidFaces.erase(\n                    std::remove_if(allValidFaces.begin(), allValidFaces.end(), [this, thresholdAngle](auto const&amp; a){\n                        auto faceInfo = m_Cut-&gt;GetFace(a.first);\n                        auto faceNormal = faceInfo.GetNormal();\n                        auto theta = glm::acos(\n                                glm::dot(faceNormal, m_Normal) /\n                                (glm::length(faceNormal) * glm::length(m_Normal))\n                        );\n                        return theta &gt; thresholdAngle &amp;&amp; (3.14159 - theta) &gt; thresholdAngle;\n                    }),\n                    allValidFaces.end()\n            );\n            // reorder the faces by the abs distance\n            std::sort(allValidFaces.begin(), allValidFaces.end(), [](auto const&amp; a, auto const&amp; b){\n                return a.second &lt; b.second;\n            });\n            // put the rest in the perpendicular faces\n            for (auto const&amp; [faceID, dist]: allValidFaces){\n                if(faceID == nearestParallelFaceID) continue;\n                perpenFaces.push_back(std::make_pair(faceID, dist));\n            }\n            // if it is the first time, nearestParallelFaceID.empty() gives the first face as the nearest parallel face\n            nearestParallelFaceID = nearestParallelFaceID.empty() ? allValidFaces[0].first : nearestParallelFaceID;\n            // sort perpendicular faces by distance\n            std::sort(perpenFaces.begin(), perpenFaces.end(), [](auto const&amp; a, auto const&amp; b){\n                return a.second &lt; b.second;\n            });\n\n            // --------------------------------------------------------------------\n            // update class members\n\n            // Case 1: If the saw is place on the side for adjusting the height, there should be no parallel face\n            // Therefore, the closest face would be considered as the face to be cut,\n            // and the secondly closest face would be considered as the perpendicular surface that sits\n            // at the bottom of the blade.\n            // Case 2: During cut, everything is defined as normal\n            if(nearestParallelFaceID.empty())\n            {\n                if(perpenFaces.size() &lt; 2) {\n                    // TODO: catch error\n                    return;\n                }\n                m_NearestParallelFaceID = perpenFaces[0].first;\n            } else {\n                m_NearestParallelFaceID = nearestParallelFaceID;\n            }\n        }\n\n        // --------------------------------------------------------------------\n        // get the first and secondly closest neighbour face to the highlighted face and to the blade's center\n        std::map&lt;std::string, AIAC::TimberInfo::Cut::Face&gt; neighbouringFaces = \n            this-&gt;m_Cut-&gt;GetFaceNeighbors(m_NearestParallelFaceID);\n        float minDist = std::numeric_limits&lt;float&gt;::max();\n        for (auto const&amp; [faceID, faceInfo] : neighbouringFaces)\n        {\n            auto projCenter = GetProjectionPointOnPlane(\n                faceInfo.GetNormal(),\n                faceInfo.GetCenter(),\n                m_Center);\n            float distAbs = glm::abs(glm::distance(m_Center, projCenter));\n            if (distAbs &lt; minDist &amp;&amp; distAbs &gt; m_Radius)\n            {\n                minDist = distAbs;\n                m_NearestNeighbourFaceIDToParallelFace = faceID;\n            }\n        }\n        minDist = std::numeric_limits&lt;float&gt;::max();\n        for (auto const&amp; [faceID, faceInfo] : neighbouringFaces)\n        {\n            if (faceID == m_NearestNeighbourFaceIDToParallelFace) continue;\n            auto projCenter = GetProjectionPointOnPlane(\n                faceInfo.GetNormal(),\n                faceInfo.GetCenter(),\n                m_Center);\n            float distAbs = glm::abs(glm::distance(m_Center, projCenter));\n            if (distAbs &lt; minDist &amp;&amp; distAbs &gt; m_Radius)\n            {\n                minDist = distAbs;\n                m_SecondNearestNeighbourFaceIDToParallelFace = faceID;\n            }\n        }\n    }\n\n    void CutCircularSawFeedback::UpdateFeedback() {\n        if(this-&gt;m_ToShowCutPlane || this-&gt;m_Cut-&gt;IsSingleFace())\n        {\n            this-&gt;m_CutPlaneVisualizer.Activate();\n            UpdateCutPlaneFeedback();\n        }\n        else\n            this-&gt;m_CutPlaneVisualizer.Deactivate();\n\n        this-&gt;UpdateOrientationFeedback();\n        this-&gt;UpdateThicknessFeedback();\n        this-&gt;UpdateDepthFeedback();\n        this-&gt;UpdateStartPosFeedback();\n    }\n\n    void CutCircularSawFeedback::UpdateOrientationFeedback()\n    {\n        if (!this-&gt;m_NearestParallelFaceID.empty())\n        {\n            this-&gt;m_Cut-&gt;HighlightFace(m_NearestParallelFaceID);\n            auto faceInfo = m_Cut-&gt;GetFace(m_NearestParallelFaceID);\n            auto faceNormal = faceInfo.GetNormal();\n            auto faceCenter = faceInfo.GetCenter();\n            this-&gt;m_OrientationVisualizer.m_LineFaceNormal-&gt;SetPts(faceCenter, faceCenter + faceNormal);\n\n            auto bladeNormal = glm::normalize(m_Normal);\n            this-&gt;m_OrientationVisualizer.m_LineBladeNormal-&gt;SetPts(faceCenter, faceCenter + bladeNormal);\n\n            // get the axis system of the face with the projection of the blade normal\n            glm::vec3 zVec = glm::normalize(faceNormal);\n            glm::vec3 xVec = glm::normalize(glm::cross(faceNormal, faceCenter));\n            glm::vec3 yVec = glm::normalize(glm::cross(faceNormal, xVec));\n            glm::vec3 bladeNormalProjOnFace = (m_NormalEnd - m_NormalStart) - glm::dot(m_NormalEnd - m_NormalStart, zVec) * zVec;\n\n            xVec = glm::normalize(bladeNormalProjOnFace);\n            yVec = glm::normalize(glm::cross(zVec, xVec));\n\n            // draw the rotated x axis as a GOLine\n            this-&gt;m_OrientationVisualizer.m_LineDebugB-&gt;SetPts(faceCenter, faceCenter + xVec);\n            this-&gt;m_OrientationVisualizer.m_LineDebugC-&gt;SetPts(faceCenter, faceCenter + yVec);\n\n            // draw the line between the end of the m_LineBladeNormal and the end of the lineDebugC\n            float pitch = glm::degrees(atan2(bladeNormalProjOnFace.y, bladeNormalProjOnFace.z));\n            this-&gt;m_OrientationVisualizer.m_LineDebugD-&gt;SetPts(\n                this-&gt;m_OrientationVisualizer.m_LineBladeNormal-&gt;GetPEnd(),\n                this-&gt;m_OrientationVisualizer.m_LineDebugB-&gt;GetPEnd());\n            // draw the line between the end of the m_LineBladeNormal and the end of the lineDebugB\n            this-&gt;m_OrientationVisualizer.m_LineDebugE-&gt;SetPts(\n                this-&gt;m_OrientationVisualizer.m_LineBladeNormal-&gt;GetPEnd(),\n                this-&gt;m_OrientationVisualizer.m_LineDebugC-&gt;GetPEnd());\n\n            // calculare the angle between m_LineDebugE and m_LineDebugC (the pitch)\n            float anglePitch = this-&gt;m_OrientationVisualizer.m_LineDebugD-&gt;ComputeSignedAngle(\n                this-&gt;m_OrientationVisualizer.m_LineDebugB\n                );\n            float anglePitchDiffNeg = -45.0f - anglePitch;\n            float anglePitchDiffPos = 45.0f - anglePitch;\n            float anglePitchDiff = std::abs(anglePitchDiffNeg) &lt; std::abs(anglePitchDiffPos) ? anglePitchDiffNeg : anglePitchDiffPos;\n            anglePitchDiff = std::round(anglePitchDiff * 10) / 10;\n\n            // Set the axis system on the blade\n            glm::vec3 bladeZVec = glm::normalize(m_NormalEnd - m_NormalStart);\n            glm::vec3 bladeXVec = glm::normalize(glm::cross(m_Center - m_BottomPoint, bladeZVec));\n            glm::vec3 bladeYVec = glm::normalize(glm::cos(1.5708f) * bladeXVec + glm::sin(1.5708f) * bladeZVec);\n\n            // Pitch guidance\n            // show the degree difference in text\n            this-&gt;m_OrientationVisualizer.m_GuideTxtRollPitch-&gt;SetAnchor(m_Center + bladeYVec * 0.5f);\n            std::ostringstream stream;\n            stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; anglePitchDiff;\n            std::string anglePitchDiffStr = stream.str();\n            this-&gt;m_OrientationVisualizer.m_GuideTxtRollPitch-&gt;SetText(\"r:\" + anglePitchDiffStr);\n            if (anglePitchDiff &gt; -this-&gt;m_OrientationVisualizer.m_tolAangleAcceptance &amp;&amp; anglePitchDiff &lt; this-&gt;m_OrientationVisualizer.m_tolAangleAcceptance)\n                this-&gt;m_OrientationVisualizer.m_GuideTxtRollPitch-&gt;SetColor(GOColor::GREEN);\n            else\n                this-&gt;m_OrientationVisualizer.m_GuideTxtRollPitch-&gt;SetColor(GOColor::WHITE);\n\n            // give a visual line feedback on the orientation\n            if (anglePitchDiff &gt; this-&gt;m_OrientationVisualizer.m_tolAangleAcceptance)\n            {\n                this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetColor(GOColor::MAGENTA);\n                this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetPts(m_Center, m_Center + bladeYVec * anglePitchDiff);\n            }\n            else if (anglePitchDiff &lt; -this-&gt;m_OrientationVisualizer.m_tolAangleAcceptance)\n            {\n                this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetColor(GOColor::RED);\n                this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetPts(m_Center, m_Center + bladeYVec * anglePitchDiff);\n            }\n            else if (anglePitchDiff &gt; -this-&gt;m_OrientationVisualizer.m_tolAangleAcceptance &amp;&amp; anglePitchDiff &lt; this-&gt;m_OrientationVisualizer.m_tolAangleAcceptance)\n            {\n                this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetColor(GOColor::GREEN);\n                this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetPts(m_Center, m_Center + bladeYVec * 0.3f);\n            }\n\n            // set the visibility off for the debug lines\n            this-&gt;m_OrientationVisualizer.m_LineFaceNormal-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LineBladeNormal-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LineDebugA-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LineDebugB-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LineDebugC-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LineDebugD-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LineDebugE-&gt;SetVisibility(false);\n            this-&gt;m_OrientationVisualizer.m_LinePitchFeed-&gt;SetVisibility(true);\n            this-&gt;m_OrientationVisualizer.m_GuideTxtRollPitch-&gt;SetVisibility(true);\n        }\n        else\n        {\n            this-&gt;m_OrientationVisualizer.Deactivate();\n        }\n\n    }\n\n    void CutCircularSawFeedback::UpdateCutPlaneFeedback()\n    {\n        if(m_ToShowCutPlane) m_CutPlaneVisualizer.Update(m_Normal, m_Center);\n    }\n\n    void CircularSawCutBladeThicknessVisualizer::UpdateToolheadsData()\n    {\n        this-&gt;m_BladeTotalThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().ThicknessACIT;\n        this-&gt;m_BladeOverhangScaled = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().OverhangACIT;\n        this-&gt;m_ToolheadRefCenter = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().CenterGO-&gt;GetPosition();\n        this-&gt;m_ToolheadRefNormStart = this-&gt;m_ToolheadRefCenter;\n        this-&gt;m_ToolheadRefNormEnd = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().NormEndGO-&gt;GetPosition();\n        this-&gt;m_NormalUnitized = glm::normalize(this-&gt;m_ToolheadRefNormEnd - this-&gt;m_ToolheadRefNormStart);\n        this-&gt;m_NormalOppositeUnitized = -this-&gt;m_NormalUnitized;\n        this-&gt;m_DisplacedCenterTowardsCamera = this-&gt;m_ToolheadRefCenter + this-&gt;m_NormalUnitized * this-&gt;m_BladeOverhangScaled;\n        this-&gt;m_DisplacedCenterAwayFromCamera = this-&gt;m_ToolheadRefCenter + this-&gt;m_NormalOppositeUnitized * (this-&gt;m_BladeTotalThicknessScaled - this-&gt;m_BladeOverhangScaled);\n    }\n\n    bool CircularSawCutBladeThicknessVisualizer::IntersectBladeWithNeighbours(\n        TimberInfo::Cut* cut,\n        TimberInfo::Cut::Face&amp; face,\n        bool isTowardsCamera,\n        bool isDetectToolPlane,\n        std::shared_ptr&lt;GOLine&gt;&amp; lineIntersection)\n    {\n        glm::vec3 centerBlade;\n        glm::vec3 normalBlade;\n        if (!isDetectToolPlane)\n        {\n            if (isTowardsCamera)\n            {\n                normalBlade = this-&gt;m_NormalUnitized;\n                centerBlade = this-&gt;m_DisplacedCenterTowardsCamera;\n            }\n            else\n            {\n                normalBlade = this-&gt;m_NormalOppositeUnitized;\n                centerBlade = this-&gt;m_DisplacedCenterAwayFromCamera;\n            }\n        }\n        else\n        {\n            normalBlade = this-&gt;m_NormalUnitized;\n            centerBlade = this-&gt;m_ToolheadRefCenter;\n        }\n        glm::vec3 downVecBlade;\n        auto prepFaceACenter = face.GetCenter();\n        auto perpFaceANormal = face.GetNormal();\n        glm::vec3 perpFaceOfBladeVec = glm::normalize(glm::cross(normalBlade, perpFaceANormal));\n        glm::vec3 _ptPlaceHolder;\n        GetIntersectLineOf2Planes(\n            normalBlade,\n            centerBlade,\n            perpFaceOfBladeVec,\n            centerBlade,\n            downVecBlade,\n            _ptPlaceHolder\n        );\n\n        auto sidePt1 = centerBlade + perpFaceOfBladeVec * AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().RadiusACIT;\n        auto sidePt2 = centerBlade - perpFaceOfBladeVec * AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().RadiusACIT;\n        glm::vec3 projSidePt1, projSidePt2;\n        GetIntersectPointOfLineAndPlane(downVecBlade, sidePt1, perpFaceANormal, prepFaceACenter, projSidePt1);\n        GetIntersectPointOfLineAndPlane(downVecBlade, sidePt2, perpFaceANormal, prepFaceACenter, projSidePt2);\n        if (projSidePt1 == projSidePt2)\n        {\n            lineIntersection-&gt;SetPts(glm::vec3(0.f, 0.f, 0.f), glm::vec3(0.f, 0.f, 0.f));\n            return false;\n        }\n\n        std::vector&lt;glm::vec3&gt; intersectPts;\n        glm::vec3 perpIntersectLineSegPt1, perpIntersectLineSegPt2;\n        for(auto const&amp; edgeID: face.GetEdges()){\n            auto edge = cut-&gt;GetEdge(edgeID);\n            auto edgePt1 = edge.GetStartPt().GetPosition();\n            auto edgePt2 = edge.GetEndPt().GetPosition();\n            ExtendLineSeg(edgePt1, edgePt2, 1.0f);\n            glm::vec3 intersectPt;\n            if(GetIntersectPointOfLineAndLineSeg((projSidePt2 - projSidePt1), projSidePt1, edgePt1, edgePt2, intersectPt)) {\n                intersectPts.push_back(intersectPt);\n            }\n        }\n        FormLongestLineSeg(intersectPts, perpIntersectLineSegPt1, perpIntersectLineSegPt2);\n\n        if (intersectPts.size() == 0)\n        {\n            lineIntersection-&gt;SetPts(glm::vec3(0.f, 0.f, 0.f), glm::vec3(0.f, 0.f, 0.f));\n            return false;\n        }\n        lineIntersection-&gt;SetPts(perpIntersectLineSegPt1, perpIntersectLineSegPt2);\n        return true;\n    }\n\n    void CutCircularSawFeedback::UpdateThicknessFeedback()\n    {\n        this-&gt;m_ThicknessVisualizer.Deactivate();\n        this-&gt;m_ThicknessVisualizer.UpdateToolheadsData();\n\n        std::map&lt;std::string, AIAC::TimberInfo::Cut::Face&gt; neighbouringFaces = \n            this-&gt;m_Cut-&gt;GetHighlightedFaceNeighbors();\n        if (neighbouringFaces.size() &gt; 2)\n        {\n            AIAC_WARN(\"The neighbouring faces are more than 2, this is not possible to show the thickness feedback\");\n            return;\n        }\n\n        AIAC::TimberInfo::Cut::Face faceNeighbour1 = this-&gt;m_Cut-&gt;GetFace(this-&gt;m_NearestNeighbourFaceIDToParallelFace);\n        if (neighbouringFaces.size() == 1)\n        {\n            bool isfaceNeighbour1Intersected = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour1, true, true, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmenDetectToolPlane);\n            bool isfaceNeighbour1IntersectedOnce = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour1, true, false, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraA);\n            bool isfaceNeighbour1IntersectedTwice = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour1, false, false, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentAwayFromCameraA);\n\n            if (this-&gt;m_ThicknessVisualizer.IsSegmenDetectToolPlaneVisible)\n                this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmenDetectToolPlane-&gt;SetVisibility(isfaceNeighbour1Intersected);\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraA-&gt;SetVisibility((isfaceNeighbour1IntersectedOnce &amp;&amp; isfaceNeighbour1IntersectedTwice));\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentAwayFromCameraA-&gt;SetVisibility((isfaceNeighbour1IntersectedOnce &amp;&amp; isfaceNeighbour1IntersectedTwice));\n        }\n        else if (neighbouringFaces.size() == 2)\n        {\n            AIAC::TimberInfo::Cut::Face faceNeighbour2 = this-&gt;m_Cut-&gt;GetFace(this-&gt;m_SecondNearestNeighbourFaceIDToParallelFace);\n            bool isfaceNeighbour1Intersected = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour1, true, true, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmenDetectToolPlane);\n            bool isfaceNeighbour1IntersectedOnce = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour1, true, false, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraA);\n            bool isfaceNeighbour1IntersectedTwice = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour1, false, false, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentAwayFromCameraA);\n            bool isfaceNeighbour2IntersectedOnce = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour2, true, false, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraB);\n            bool isfaceNeighbour2IntersectedTwice = this-&gt;m_ThicknessVisualizer.IntersectBladeWithNeighbours(\n                this-&gt;m_Cut, faceNeighbour2, false, false, this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentAwayFromCameraB);\n\n            if (this-&gt;m_ThicknessVisualizer.IsSegmenDetectToolPlaneVisible)\n                this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmenDetectToolPlane-&gt;SetVisibility(isfaceNeighbour1Intersected);\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraA-&gt;SetVisibility((isfaceNeighbour1IntersectedOnce &amp;&amp; isfaceNeighbour1IntersectedTwice));\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentAwayFromCameraA-&gt;SetVisibility((isfaceNeighbour1IntersectedOnce &amp;&amp; isfaceNeighbour1IntersectedTwice));\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraB-&gt;SetVisibility((isfaceNeighbour2IntersectedOnce &amp;&amp; isfaceNeighbour2IntersectedTwice));\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentAwayFromCameraB-&gt;SetVisibility((isfaceNeighbour2IntersectedOnce &amp;&amp; isfaceNeighbour2IntersectedTwice));\n        }\n        else\n        {\n            this-&gt;m_ThicknessVisualizer.Deactivate();\n        }\n    }\n\n    void CutCircularSawFeedback::UpdateStartPosFeedback()\n    {\n        if (!this-&gt;m_NearestParallelFaceID.empty())\n        {\n            this-&gt;m_PositionStartVisualizer.Activate();\n\n            AIAC::TimberInfo::Cut::Face faceInfo = this-&gt;m_Cut-&gt;GetFace(this-&gt;m_NearestParallelFaceID);\n            glm::vec3 faceNormal = faceInfo.GetNormal();\n            glm::vec3 faceCenter = faceInfo.GetCenter();\n\n            // closest displaced center of the blade (towards or away from the camera)\n            glm::vec3 projBladeNorm;\n            glm::vec3 centerBlade;\n            glm::vec3 projBladeCenterTowards2Face = GetProjectionPointOnPlane(\n                faceNormal,\n                faceCenter,\n                this-&gt;m_ThicknessVisualizer.m_DisplacedCenterTowardsCamera\n            );\n            glm::vec3 projBladeCenterAway2Face = GetProjectionPointOnPlane(\n                faceNormal,\n                faceCenter,\n                this-&gt;m_ThicknessVisualizer.m_DisplacedCenterAwayFromCamera\n            );\n            // get the closest one\n            float distTowards = glm::abs(glm::distance(this-&gt;m_ThicknessVisualizer.m_DisplacedCenterTowardsCamera, projBladeCenterTowards2Face));\n            float distAway = glm::abs(glm::distance(this-&gt;m_ThicknessVisualizer.m_DisplacedCenterAwayFromCamera, projBladeCenterAway2Face));\n            if (distTowards &lt; distAway)\n            {\n                projBladeNorm = projBladeCenterTowards2Face;\n                centerBlade = this-&gt;m_ThicknessVisualizer.m_DisplacedCenterTowardsCamera;\n            }\n            else\n            {\n                projBladeNorm = projBladeCenterAway2Face;\n                centerBlade = this-&gt;m_ThicknessVisualizer.m_DisplacedCenterAwayFromCamera;\n            }\n            // calculate the distance\n            glm::vec3 centerBladeProjOnFace = GetProjectionPointOnPlane(\n                faceNormal,\n                faceCenter,\n                centerBlade);\n            float parallelDistCtrBlade2PtFace = glm::distance(\n                centerBlade,\n                centerBladeProjOnFace);\n\n            // Visualization\n            // set the visuals and print the distance feed\n            // move the center down of half the radius\n            auto prepFaceInfo = m_Cut-&gt;GetFace(this-&gt;m_NearestNeighbourFaceIDToParallelFace);\n            auto prepPlnCenter = prepFaceInfo.GetCenter();\n            auto perpPlnNormal = prepFaceInfo.GetNormal();\n            glm::vec3 perpFaceOfBladeVec = glm::normalize(glm::cross(m_Normal, perpPlnNormal));\n            glm::vec3 _ptPlaceHolder;\n            GetIntersectLineOf2Planes(\n                m_Normal, m_Center,\n                perpFaceOfBladeVec, m_Center,\n                m_DownVec, _ptPlaceHolder\n            );\n\n            if(glm::distance(m_Center + m_DownVec * m_Radius, faceInfo.GetCenter()) &gt;\n            glm::distance(m_Center - m_DownVec * m_Radius, faceInfo.GetCenter())){\n                m_DownVec = -m_DownVec;\n            }\n\n            // get the bottom point and update\n            glm::vec3 bottomPoint = m_Center + m_DownVec * m_Radius;\n            this-&gt;m_PositionStartVisualizer.m_LineToBottomPt-&gt;SetPts(m_Center, bottomPoint);\n\n            // set the visuals and print the distance feed\n            glm::vec3 midPt = this-&gt;m_PositionStartVisualizer.m_LineToBottomPt-&gt;GetMidPointValues();\n            glm::vec3 midPtProj = GetProjectionPointOnPlane(\n                faceNormal,\n                faceCenter,\n                midPt);\n            this-&gt;m_PositionStartVisualizer.m_LineDistStart-&gt;SetPts(\n                midPt,\n                midPtProj);\n\n            std::ostringstream stream;\n            stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; parallelDistCtrBlade2PtFace;\n            std::string parallelDistCtrBlade2PtFaceStr = stream.str();\n            this-&gt;m_PositionStartVisualizer.m_TxtDistStart-&gt;SetAnchor(\n                midPtProj\n                );\n            this-&gt;m_PositionStartVisualizer.m_TxtDistStart-&gt;SetText(\"s:\" + parallelDistCtrBlade2PtFaceStr);\n            this-&gt;m_PositionStartVisualizer.m_TxtDistStart-&gt;SetColor(\n                parallelDistCtrBlade2PtFace &lt; this-&gt;m_PositionStartVisualizer.ToleranceStartThreshold ? GOColor::GREEN : GOColor::YELLOW);\n            this-&gt;m_PositionStartVisualizer.m_LineDistStart-&gt;SetColor(\n                parallelDistCtrBlade2PtFace &lt; this-&gt;m_PositionStartVisualizer.ToleranceStartThreshold ? GOColor::GREEN : GOColor::YELLOW);\n        }\n        else\n        {\n            this-&gt;m_PositionStartVisualizer.Deactivate();\n        }\n    }\n\n    void CutCircularSawFeedback::UpdateDepthFeedback()\n    {\n        if (!this-&gt;m_NearestParallelFaceID.empty() &amp;&amp; !m_Cut-&gt;IsSingleFace())\n        {\n            // calculate distances (closest point to line/segment to circle)\n            float distLineDepth = GOCircle::ClosestDistanceFromLineToCircle(\n            this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmenDetectToolPlane,\n                m_Center,\n                m_Radius\n            );\n            std::pair&lt;float, std::pair&lt;glm::vec3, glm::vec3&gt;&gt; res = GOCircle::ClosestDistanceFromSegmentToCircle(\n                this-&gt;m_ThicknessVisualizer.m_LongestIntersectSegmentTowardsCameraA,\n                m_Center,\n                m_Radius\n            );\n            float distSegDepth = res.first;\n            float distLineDepthAbs = glm::abs(distLineDepth);\n            float distSegDepthAbs = glm::abs(distSegDepth);\n\n            // visualization\n            auto prepFaceInfo = m_Cut-&gt;GetFace(this-&gt;m_NearestNeighbourFaceIDToParallelFace);\n            auto prepPlnCenter = prepFaceInfo.GetCenter();\n            auto perpPlnNormal = prepFaceInfo.GetNormal();\n            auto projBladeCenter = GetProjectionPointOnPlane(\n                perpPlnNormal,\n                prepPlnCenter,\n                m_Center);\n            this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetAnchor(projBladeCenter);\n            this-&gt;m_DepthVisualizer.m_LineDepth-&gt;SetPts(m_Center, projBladeCenter);\n\n            this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetText(\n                \"d:\" + FeedbackVisualizer::toString(distLineDepth) +\n                \"|\" + FeedbackVisualizer::toString(distSegDepthAbs) + \"\"\n                );\n            if (std::isfinite(distLineDepth) &amp;&amp; distLineDepth &gt; static_cast&lt;float&gt;(INT_MIN) &amp;&amp; distLineDepth &lt; static_cast&lt;float&gt;(INT_MAX))\n            {\n                if (distLineDepthAbs &lt; this-&gt;m_DepthVisualizer.m_ToleranceDepthThreshold)\n                    this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetColor(GOColor::GREEN);\n                else if (distLineDepthAbs &lt; this-&gt;m_DepthVisualizer.m_ToleranceDepthThreshold * 20)\n                    this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetColor(GOColor::YELLOW);\n                else\n                    this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetColor(GOColor::RED);\n            }\n            else\n            {\n                this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetText(\"///\");\n                this-&gt;m_DepthVisualizer.m_TxtDepth-&gt;SetColor(GOColor::MAGENTA);\n            }\n\n\n            this-&gt;m_DepthVisualizer.m_PtBlade2ThicknessLineA-&gt;SetPosition(res.second.first);\n            this-&gt;m_DepthVisualizer.m_PtBlade2ThicknessLineB-&gt;SetPosition(res.second.second);\n\n\n        }\n        else\n        {\n            this-&gt;m_DepthVisualizer.Deactivate();\n        }\n    }\n\n}\n</code></pre>"},{"location":"acdoxygen/CutCircularSawFeedback_8h/","title":"File CutCircularSawFeedback.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutCircularSawFeedback.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/ACInfoModel.h\"</code></li> <li><code>#include \"FeedbackVisualizer.h\"</code></li> <li><code>#include \"CutPlaneVisualizer.h\"</code></li> <li><code>#include \"CutBladeThicknessVisualizer.h\"</code></li> <li><code>#include \"FabFeedback.h\"</code></li> <li><code>#include \"utils/GeometryUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/CutCircularSawFeedback_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/CutCircularSawFeedback_8h/#classes","title":"Classes","text":"Type Name class CircularSawCutBladeThicknessVisualizer This is an inherited class to show the thickness of the blade on circular saws. class CircularSawCutPlaneVisualizer class CutCircularOrientationVisualizer This visualizer ggdb ives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. class CutCircularSawDepthVisualizer Visualizer for showing the depth of the cut. class CutCircularSawFeedback class CutCircularSawPositionStartVisualizer This visualizer gives guidance on the start position of the lateral cuts for the circular saw. <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutCircularSawFeedback.h</code></p>"},{"location":"acdoxygen/CutCircularSawFeedback_8h_source/","title":"File CutCircularSawFeedback.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutCircularSawFeedback.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n#ifndef AC_CUTCIRCULARSAWFEEDBACK_H\n#define AC_CUTCIRCULARSAWFEEDBACK_H\n\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/ACInfoModel.h\"\n#include \"FeedbackVisualizer.h\"\n#include \"CutPlaneVisualizer.h\"\n#include \"CutBladeThicknessVisualizer.h\"\n#include \"FabFeedback.h\"\n#include \"utils/GeometryUtils.h\"\n\nnamespace AIAC\n{\n    class CutCircularSawDepthVisualizer : public FeedbackVisualizer\n    {\n    public:\n        CutCircularSawDepthVisualizer();\n\n    private:\n        std::shared_ptr&lt;GOLine&gt; m_LineDepth;\n        std::shared_ptr&lt;GOPoint&gt; m_PtBlade2ThicknessLineA;\n        std::shared_ptr&lt;GOPoint&gt; m_PtBlade2ThicknessLineB;\n        std::shared_ptr&lt;GOText&gt; m_TxtDepth;\n        float m_ToleranceDepthThreshold = 0.1f;\n\n\n\n    friend class CutCircularSawFeedback;\n    };\n\n    class CutCircularSawPositionStartVisualizer : public FeedbackVisualizer\n    {\n        public:\n            CutCircularSawPositionStartVisualizer();\n\n        private:\n            std::shared_ptr&lt;GOLine&gt; m_LineDistStart;\n            std::shared_ptr&lt;GOText&gt; m_TxtDistStart;\n            std::shared_ptr&lt;GOLine&gt; m_LineToBottomPt;\n\n        public:\n            float ToleranceStartThreshold = 0.2f;\n\n        friend class CutCircularSawFeedback;\n    };\n\n    class CutCircularOrientationVisualizer : public FeedbackVisualizer\n    {\n        public:\n            CutCircularOrientationVisualizer();\n\n        private:\n            std::shared_ptr&lt;GOLine&gt; m_LineFaceNormal;  // BLUE (face_z)\n            std::shared_ptr&lt;GOLine&gt; m_LineBladeNormal;  // MAGENTA\n\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugA;  // ORANGE\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugB;  // GREEN (face_y)\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugC;  // RED (face_x)\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugD;  // YELLOW\n            std::shared_ptr&lt;GOLine&gt; m_LineDebugE;  // WHITE\n\n            std::shared_ptr&lt;GOLine&gt; m_LinePitchFeed;  // RED or MAGENTA\n\n            std::shared_ptr&lt;GOText&gt; m_GuideTxtRollPitch;  // WHITE\n\n        private:\n            float m_tolAangleAcceptance = 0.4f;  // decimal fraction of a degree\n\n        friend class CutCircularSawFeedback;\n    };\n\n    class CircularSawCutPlaneVisualizer : public CutPlaneVisualizer\n    {\n    public:\n        CircularSawCutPlaneVisualizer() = default;\n\n    friend class CutCircularSawFeedback;\n    };\n\n    class CircularSawCutBladeThicknessVisualizer : public CutBladeThicknessVisualizer\n    {\n    public:\n        CircularSawCutBladeThicknessVisualizer() = default;\n\n    public:\n        void UpdateToolheadsData() override;\n        bool IntersectBladeWithNeighbours(\n            TimberInfo::Cut* cut,\n            TimberInfo::Cut::Face&amp; face,\n            bool isTowardsCamera,\n            bool isDetectToolPlane,\n            std::shared_ptr&lt;GOLine&gt;&amp; lineIntersection) override;\n\n    friend class CutCircularSawFeedback;\n    };\n\n    class CutCircularSawFeedback : public FabFeedback\n    {\n    public:\n        CutCircularSawFeedback() = default;\n        ~CutCircularSawFeedback() = default;\n\n        void Update() override;\n        void Activate() override;\n        void Deactivate() override;\n\n        inline void EnableCutPlane(bool enable) {\n            m_ToShowCutPlane = enable;\n            if(enable) m_CutPlaneVisualizer.Activate();\n            else m_CutPlaneVisualizer.Deactivate();\n        };\n\n        void ManuallyScrollRefFace(int scrollDirection);\n\n    public:\n        // config exposed to UI\n        bool IsRefFacesSelectedManually = false;\n\n    private:\n        // data\n        TimberInfo::Cut* m_Cut;\n\n        float m_Radius;\n        glm::vec3 m_Center;\n        glm::vec3 m_NormalStart;\n        glm::vec3 m_NormalEnd;\n\n        // derived\n        glm::vec3 m_Normal;\n        glm::vec3 m_DownVec;\n        glm::vec3 m_BottomPoint;\n\n    private:  \n        std::string m_NearestParallelFaceID;\n        std::string m_NearestNeighbourFaceIDToParallelFace;\n        std::string m_SecondNearestNeighbourFaceIDToParallelFace;\n\n        // config\n        bool m_ToShowCutPlane = false;\n\n    private:\n        void UpdateToolPosition();\n        void UpdateRefFaces();\n\n        void UpdateFeedback();\n        void UpdateOrientationFeedback();\n        void UpdateCutPlaneFeedback();\n        void UpdateThicknessFeedback();\n        void UpdateStartPosFeedback();\n        void UpdateDepthFeedback();\n\n        CircularSawCutPlaneVisualizer m_CutPlaneVisualizer;\n        CutCircularOrientationVisualizer m_OrientationVisualizer;\n        CutCircularSawPositionStartVisualizer m_PositionStartVisualizer;\n        CircularSawCutBladeThicknessVisualizer m_ThicknessVisualizer;\n        CutCircularSawDepthVisualizer m_DepthVisualizer;\n    };\n}\n#endif //AC_CUTCIRCULARSAWFEEDBACK_H\n</code></pre>"},{"location":"acdoxygen/CutPlaneVisualizer_8cpp/","title":"File CutPlaneVisualizer.cpp","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutPlaneVisualizer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"FabFeedback.h\"</code></li> <li><code>#include \"CutPlaneVisualizer.h\"</code></li> </ul>"},{"location":"acdoxygen/CutPlaneVisualizer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutPlaneVisualizer.cpp</code></p>"},{"location":"acdoxygen/CutPlaneVisualizer_8cpp_source/","title":"File CutPlaneVisualizer.cpp","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutPlaneVisualizer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"AIAC/Application.h\"\n#include \"FabFeedback.h\"\n#include \"CutPlaneVisualizer.h\"\n\nnamespace AIAC\n{\n    CutPlaneVisualizer::CutPlaneVisualizer(){\n        m_LongestIntersectSegmentAppCenterA = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LongestIntersectSegmentA1 = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LongestIntersectSegmentA2 = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LongestIntersectSegmentAppCenterB = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LongestIntersectSegmentB1 = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        m_LongestIntersectSegmentB2 = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        m_LongestIntersectSegmentB1-&gt;SetWeight(GOWeight::Light);\n        m_LongestIntersectSegmentB2-&gt;SetWeight(GOWeight::Light);\n        m_LongestIntersectSegmentA1-&gt;SetWeight(GOWeight::Light);\n        m_LongestIntersectSegmentA2-&gt;SetWeight(GOWeight::Light);\n\n        m_LongestIntersectSegmentAppCenterA-&gt;SetColor(AIAC::GOColor::CYAN);\n        m_LongestIntersectSegmentA1-&gt;SetColor(AIAC::GOColor::MAGENTA);\n        m_LongestIntersectSegmentA2-&gt;SetColor(AIAC::GOColor::MAGENTA);\n        m_LongestIntersectSegmentAppCenterB-&gt;SetColor(AIAC::GOColor::CYAN);\n        m_LongestIntersectSegmentB1-&gt;SetColor(AIAC::GOColor::MAGENTA);\n        m_LongestIntersectSegmentB2-&gt;SetColor(AIAC::GOColor::MAGENTA);\n\n        m_AllPrimitives.push_back(m_LongestIntersectSegmentAppCenterA);\n        m_AllPrimitives.push_back(m_LongestIntersectSegmentA1);\n        m_AllPrimitives.push_back(m_LongestIntersectSegmentA2);\n        m_AllPrimitives.push_back(m_LongestIntersectSegmentAppCenterB);\n        m_AllPrimitives.push_back(m_LongestIntersectSegmentB1);\n        m_AllPrimitives.push_back(m_LongestIntersectSegmentB2);\n\n        Deactivate();\n    }\n\n    void CutPlaneVisualizer::ReorderIntersectPoints(std::vector&lt;glm::vec3&gt;&amp; intersectPts, const glm::vec3&amp; facePt)\n    {\n        // Reorder intersect points based on angles\n        auto vec0 = intersectPts[0] - intersectPts[3];\n        auto vec1 = intersectPts[1] - intersectPts[3];\n        auto vec2 = intersectPts[2] - intersectPts[3];\n        auto angle01 = GetAngleBetweenVectors(vec0, vec1);\n        auto angle02 = GetAngleBetweenVectors(vec0, vec2);\n        auto angle12 = GetAngleBetweenVectors(vec1, vec2);\n        if (angle01 &gt; angle02 &amp;&amp; angle01 &gt; angle12) {  // 0 2 1 --- 3 =&gt; swap 1 and 2\n            std::swap(intersectPts[1], intersectPts[2]);\n        } else if (angle12 &gt; angle01 &amp;&amp; angle12 &gt; angle02) { // 1 0 2 --- 3 =&gt; swap 0 and 1\n            std::swap(intersectPts[0], intersectPts[1]);\n        }\n\n        // Calculate midpoints of segments\n        glm::vec3 m_SegmentMid1 = (intersectPts[0] + intersectPts[1]) / 2.0f;\n        glm::vec3 m_SegmentMid2 = (intersectPts[1] + intersectPts[2]) / 2.0f;\n        glm::vec3 m_SegmentMid3 = (intersectPts[2] + intersectPts[3]) / 2.0f;\n        glm::vec3 m_SegmentMid4 = (intersectPts[3] + intersectPts[0]) / 2.0f;\n\n        // Calculate distances from face point to midpoints\n        glm::vec3 facePtToMid1 = m_SegmentMid1 - facePt;\n        glm::vec3 facePtToMid2 = m_SegmentMid2 - facePt;\n        glm::vec3 facePtToMid3 = m_SegmentMid3 - facePt;\n        glm::vec3 facePtToMid4 = m_SegmentMid4 - facePt;\n        float dist1 = glm::length(facePtToMid1);\n        float dist2 = glm::length(facePtToMid2);\n        float dist3 = glm::length(facePtToMid3);\n        float dist4 = glm::length(facePtToMid4);\n    }\n\n    void CutPlaneVisualizer::CutPlaneVisualizer::Activate(){\n        FeedbackVisualizer::Activate();\n    }\n\n    void CutPlaneVisualizer::CutPlaneVisualizer::Deactivate(){\n        FeedbackVisualizer::Deactivate();\n        for (auto &amp;p : m_AllPrimitives) {\n            p-&gt;SetVisibility(false);\n        }\n    }\n\n    std::vector&lt;glm::vec3&gt; CutPlaneVisualizer::Update(glm::vec3 faceNorm, glm::vec3 facePt){\n        TimberInfo::Cut* cut = dynamic_cast&lt;TimberInfo::Cut*&gt;(AC_FF_COMP);\n\n        // getting the scanned model bounding box and its edges indices\n        auto bbox = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetScannedModel().GetBoundingBox();\n        auto bboxIndices = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetScannedModel().GetBboxEdgesIndices();\n\n        // current tool type and its normal\n        auto currentToolType = AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolheadType();\n        glm::vec3 normStart;\n        glm::vec3 normEnd;\n        if (currentToolType == ACToolHeadType::CHAINSAW) {\n            normStart = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().NormStartGO-&gt;GetPosition();\n            normEnd = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().NormEndGO-&gt;GetPosition();\n        } else if (currentToolType == ACToolHeadType::CIRCULARSAW) {\n            normStart = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().CenterGO-&gt;GetPosition();\n            normEnd = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().NormEndGO-&gt;GetPosition();\n        }\n\n        // translate the facePt and faceNorm with the thickness of the blade\n        float bladeThicknessScaled;\n        float overHangThicknessScaled;\n        if (currentToolType == ACToolHeadType::CHAINSAW) {\n            bladeThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().ThicknessACIT;\n            overHangThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;().OverhangACIT;\n        } else if (currentToolType == ACToolHeadType::CIRCULARSAW) {\n            bladeThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().ThicknessACIT;\n            overHangThicknessScaled = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;().OverhangACIT;\n        }\n        glm::vec3 normalVec = glm::normalize(normEnd - normStart);\n        glm::vec3 oppositeNormalVec = -normalVec;\n        float displacementTowardsCamera = overHangThicknessScaled;\n        float displacementAwayFromCamera = bladeThicknessScaled - overHangThicknessScaled;\n        glm::vec3 displacementTowardsCameraVec = displacementTowardsCamera * normalVec;\n        glm::vec3 displacementAwayFromCameraVec = displacementAwayFromCamera * oppositeNormalVec;\n\n        glm::vec3 normStartTC = normStart + displacementTowardsCameraVec;\n        glm::vec3 normStartAC = normStart + displacementAwayFromCameraVec;\n        glm::vec3 normEndTC = normEnd + displacementTowardsCameraVec;\n        glm::vec3 normEndAC = normEnd + displacementAwayFromCameraVec;\n\n        glm::vec3 normTC = glm::normalize(normEndTC - normStartTC);\n        glm::vec3 normAC = glm::normalize(normEndAC - normStartAC);\n\n        std::vector&lt;glm::vec3&gt; intersectPtsTowardsCamera;\n        std::vector&lt;glm::vec3&gt; intersectPtsAwayFromCamera;\n        std::vector&lt;glm::vec3&gt; intersectPts;\n        for(auto [i, j] : bboxIndices)\n        {\n            glm::vec3 intersectPt;\n            if(GetIntersectPointOfLineSegAndPlane(bbox[i], bbox[j], faceNorm, facePt, intersectPt)){\n                intersectPts.push_back(intersectPt);\n            }\n            glm::vec3 intersectPtTC;\n            if(GetIntersectPointOfLineSegAndPlane(bbox[i], bbox[j], normTC, normStartTC, intersectPtTC)){\n                intersectPtsTowardsCamera.push_back(intersectPtTC);\n            }\n            glm::vec3 intersectPtAC;\n            if(GetIntersectPointOfLineSegAndPlane(bbox[i], bbox[j], normAC, normStartAC, intersectPtAC)){\n                intersectPtsAwayFromCamera.push_back(intersectPtAC);\n            }\n        }\n\n        if (intersectPts.size() != 4\n        || intersectPtsTowardsCamera.size() != 4\n        || intersectPtsAwayFromCamera.size() != 4) {\n            return std::vector&lt;glm::vec3&gt;();\n        }\n\n        this-&gt;ReorderIntersectPoints(intersectPts, facePt);\n        this-&gt;ReorderIntersectPoints(intersectPtsTowardsCamera, normTC);\n        this-&gt;ReorderIntersectPoints(intersectPtsAwayFromCamera, normAC);\n\n\n        // get the closest segment to the toolhead's face point\n        glm::vec3 m_SegmentMid1 = (intersectPts[0] + intersectPts[1]) / 2.0f;\n        glm::vec3 m_SegmentMid2 = (intersectPts[1] + intersectPts[2]) / 2.0f;\n        glm::vec3 m_SegmentMid3 = (intersectPts[2] + intersectPts[3]) / 2.0f;\n        glm::vec3 m_SegmentMid4 = (intersectPts[3] + intersectPts[0]) / 2.0f;\n        glm::vec3 facePtToMid1 = m_SegmentMid1 - facePt;\n        glm::vec3 facePtToMid2 = m_SegmentMid2 - facePt;\n        glm::vec3 facePtToMid3 = m_SegmentMid3 - facePt;\n        glm::vec3 facePtToMid4 = m_SegmentMid4 - facePt;\n        float dist1 = glm::length(facePtToMid1);\n        float dist2 = glm::length(facePtToMid2);\n        float dist3 = glm::length(facePtToMid3);\n        float dist4 = glm::length(facePtToMid4);\n\n        glm::vec3 closestMidPt;\n\n        if (dist1 &lt; dist2 &amp;&amp; dist1 &lt; dist3 &amp;&amp; dist1 &lt; dist4) {\n            closestMidPt = m_SegmentMid1;\n            m_LongestIntersectSegmentAppCenterA-&gt;SetPts(intersectPts[0], intersectPts[1]);\n            m_LongestIntersectSegmentA1-&gt;SetPts(intersectPtsTowardsCamera[0], intersectPtsTowardsCamera[1]);\n            m_LongestIntersectSegmentA2-&gt;SetPts(intersectPtsAwayFromCamera[0], intersectPtsAwayFromCamera[1]);\n            // find the closest between 2 and 4\n            if (dist2 &lt; dist4) {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[1], intersectPts[2]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[1], intersectPtsTowardsCamera[2]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[1], intersectPtsAwayFromCamera[2]);\n            } else {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[3], intersectPts[0]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[3], intersectPtsTowardsCamera[0]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[3], intersectPtsAwayFromCamera[0]);\n            }\n        } else if (dist2 &lt; dist1 &amp;&amp; dist2 &lt; dist3 &amp;&amp; dist2 &lt; dist4) {\n            closestMidPt = m_SegmentMid2;\n            m_LongestIntersectSegmentAppCenterA-&gt;SetPts(intersectPts[1], intersectPts[2]);\n            m_LongestIntersectSegmentA1-&gt;SetPts(intersectPtsTowardsCamera[1], intersectPtsTowardsCamera[2]);\n            m_LongestIntersectSegmentA2-&gt;SetPts(intersectPtsAwayFromCamera[1], intersectPtsAwayFromCamera[2]);\n            if (dist1 &lt; dist3) {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[0], intersectPts[1]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[0], intersectPtsTowardsCamera[1]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[0], intersectPtsAwayFromCamera[1]);\n            } else {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[2], intersectPts[3]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[2], intersectPtsTowardsCamera[3]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[2], intersectPtsAwayFromCamera[3]);\n            }\n        } else if (dist3 &lt; dist1 &amp;&amp; dist3 &lt; dist2 &amp;&amp; dist3 &lt; dist4) {\n            closestMidPt = m_SegmentMid3;\n            m_LongestIntersectSegmentAppCenterA-&gt;SetPts(intersectPts[2], intersectPts[3]);\n            m_LongestIntersectSegmentA1-&gt;SetPts(intersectPtsTowardsCamera[2], intersectPtsTowardsCamera[3]);\n            m_LongestIntersectSegmentA2-&gt;SetPts(intersectPtsAwayFromCamera[2], intersectPtsAwayFromCamera[3]);\n            if (dist2 &lt; dist4) {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[1], intersectPts[2]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[1], intersectPtsTowardsCamera[2]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[1], intersectPtsAwayFromCamera[2]);\n            } else {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[3], intersectPts[0]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[3], intersectPtsTowardsCamera[0]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[3], intersectPtsAwayFromCamera[0]);\n            }\n        } else {\n            closestMidPt = m_SegmentMid4;\n            m_LongestIntersectSegmentAppCenterA-&gt;SetPts(intersectPts[3], intersectPts[0]);\n            m_LongestIntersectSegmentA1-&gt;SetPts(intersectPtsTowardsCamera[3], intersectPtsTowardsCamera[0]);\n            m_LongestIntersectSegmentA2-&gt;SetPts(intersectPtsAwayFromCamera[3], intersectPtsAwayFromCamera[0]);\n            if (dist1 &lt; dist3) {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[0], intersectPts[1]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[0], intersectPtsTowardsCamera[1]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[0], intersectPtsAwayFromCamera[1]);\n            } else {\n                m_LongestIntersectSegmentAppCenterB-&gt;SetPts(intersectPts[2], intersectPts[3]);\n                m_LongestIntersectSegmentB1-&gt;SetPts(intersectPtsTowardsCamera[2], intersectPtsTowardsCamera[3]);\n                m_LongestIntersectSegmentB2-&gt;SetPts(intersectPtsAwayFromCamera[2], intersectPtsAwayFromCamera[3]);\n            }\n        }\n\n        m_LongestIntersectSegmentAppCenterA-&gt;ExtendBothEnds(2.f);\n        m_LongestIntersectSegmentAppCenterB-&gt;ExtendBothEnds(2.f);\n\n        m_LongestIntersectSegmentAppCenterA-&gt;SetVisibility(false);\n        m_LongestIntersectSegmentAppCenterB-&gt;SetVisibility(false);\n\n        return intersectPts;\n    }\n}\n</code></pre>"},{"location":"acdoxygen/CutPlaneVisualizer_8h/","title":"File CutPlaneVisualizer.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; CutPlaneVisualizer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FeedbackVisualizer.h\"</code></li> <li><code>#include \"utils/GeometryUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/CutPlaneVisualizer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/CutPlaneVisualizer_8h/#classes","title":"Classes","text":"Type Name class CutPlaneVisualizer <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/CutPlaneVisualizer.h</code></p>"},{"location":"acdoxygen/CutPlaneVisualizer_8h_source/","title":"File CutPlaneVisualizer.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; CutPlaneVisualizer.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#ifndef CUTPLANEVISUALIZER_H\n#define CUTPLANEVISUALIZER_H\n\n#include \"FeedbackVisualizer.h\"\n#include \"utils/GeometryUtils.h\"\n\nnamespace AIAC{\n    class CutPlaneVisualizer : public FeedbackVisualizer {\n    public:\n        CutPlaneVisualizer();\n        void Activate() override;\n        void Deactivate() override;\n\n        std::vector&lt;glm::vec3&gt; Update(glm::vec3 faceNorm, glm::vec3 facePt);\n\n    private:  \n        void ReorderIntersectPoints(std::vector&lt;glm::vec3&gt;&amp; intersectPts, const glm::vec3&amp; facePt);\n\n\n    protected:\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentAppCenterA;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentAppCenterB;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentA1;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentA2;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentB1;\n        std::shared_ptr&lt;GOLine&gt; m_LongestIntersectSegmentB2;\n    };\n}\n\n#endif // CUTPLANEVISUALIZER_H\n</code></pre>"},{"location":"acdoxygen/FabFeedback_8h/","title":"File FabFeedback.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; FabFeedback.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Config.h\"</code></li> </ul>"},{"location":"acdoxygen/FabFeedback_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/FabFeedback_8h/#classes","title":"Classes","text":"Type Name class FabFeedback"},{"location":"acdoxygen/FabFeedback_8h/#macros","title":"Macros","text":"Type Name define AC_FF_COMP <code>AIAC\\_APP.GetLayer&amp;lt;LayerModel&amp;gt;()-&amp;gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()</code> define AC_FF_TOOL <code>AIAC\\_APP.GetLayer&amp;lt;LayerToolhead&amp;gt;()-&amp;gt;ACInfoToolheadManager-&amp;gt;GetActiveToolhead()</code>"},{"location":"acdoxygen/FabFeedback_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/FabFeedback_8h/#define-ac_ff_comp","title":"define AC_FF_COMP","text":"<pre><code>#define AC_FF_COMP `AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()`\n</code></pre>"},{"location":"acdoxygen/FabFeedback_8h/#define-ac_ff_tool","title":"define AC_FF_TOOL","text":"<pre><code>#define AC_FF_TOOL `AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/FabFeedback.h</code></p>"},{"location":"acdoxygen/FabFeedback_8h_source/","title":"File FabFeedback.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; FabFeedback.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Config.h\"\n\n#define AC_FF_COMP AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent()\n#define AC_FF_TOOL AIAC_APP.GetLayer&lt;LayerToolhead&gt;()-&gt;ACInfoToolheadManager-&gt;GetActiveToolhead()\n\nnamespace AIAC {\n    class FabFeedback {\n    public:\n        FabFeedback() {\n            this-&gt;m_ScaleFactor = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n        };\n        ~FabFeedback() = default;\n\n        virtual void Update() {};\n        virtual void Activate() {};\n        virtual void Deactivate() {};\n\n    protected:\n        float m_ScaleFactor = 0.0f;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/FeedbackVisualizer_8cpp/","title":"File FeedbackVisualizer.cpp","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; FeedbackVisualizer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FeedbackVisualizer.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/FeedbackVisualizer.cpp</code></p>"},{"location":"acdoxygen/FeedbackVisualizer_8cpp_source/","title":"File FeedbackVisualizer.cpp","text":"<p>File List &gt; AIAC &gt; Feedback &gt; FeedbackVisualizer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n\n#include \"FeedbackVisualizer.h\"\n</code></pre>"},{"location":"acdoxygen/FeedbackVisualizer_8h/","title":"File FeedbackVisualizer.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; FeedbackVisualizer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"vector\"</code></li> <li><code>#include \"memory\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> </ul>"},{"location":"acdoxygen/FeedbackVisualizer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/FeedbackVisualizer_8h/#classes","title":"Classes","text":"Type Name class FeedbackVisualizer <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/FeedbackVisualizer.h</code></p>"},{"location":"acdoxygen/FeedbackVisualizer_8h_source/","title":"File FeedbackVisualizer.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; FeedbackVisualizer.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n\n#ifndef AC_FEEDBACKVISUALIZER_H\n#define AC_FEEDBACKVISUALIZER_H\n\n#include \"vector\"\n#include \"memory\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/Config.h\"\n\nnamespace AIAC{\n    class FeedbackVisualizer {\n    public:\n        FeedbackVisualizer() = default;\n        ~FeedbackVisualizer() = default;\n\n        inline virtual void Activate() {\n            for (auto &amp;p : m_AllPrimitives) {\n                p-&gt;SetVisibility(true);\n            }\n        }\n\n        inline virtual void Deactivate() {\n            for (auto &amp;p : m_AllPrimitives) {\n                p-&gt;SetVisibility(false);\n            }\n        }\n\n        static std::string toString(double val) {\n            // TODO: / 50 * 1000 =&gt; convert to right scale in mm, change this to a variable based on config\n            auto scale = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n            int valInt = (int)(val / scale * 1000);\n            if(valInt &gt; 99) valInt = 99;\n            auto retVal = std::to_string(valInt);\n            if(retVal.length() == 1){\n                return \"0\" + retVal;\n            }\n            return retVal;\n        }\n\n    protected:\n        std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; m_AllPrimitives;\n    };\n\n\n}\n\n#endif //AC_FEEDBACKVISUALIZER_H\n</code></pre>"},{"location":"acdoxygen/HoleFeedback_8cpp/","title":"File HoleFeedback.cpp","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; HoleFeedback.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"HoleFeedback.h\"</code></li> </ul>"},{"location":"acdoxygen/HoleFeedback_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/HoleFeedback.cpp</code></p>"},{"location":"acdoxygen/HoleFeedback_8cpp_source/","title":"File HoleFeedback.cpp","text":"<p>File List &gt; AIAC &gt; Feedback &gt; HoleFeedback.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"AIAC/Application.h\"\n#include \"HoleFeedback.h\"\n\nnamespace AIAC\n{\n    HoleFeedbackText::HoleFeedbackText()\n    {\n        this-&gt;m_InfoText = GOText::Add(\"///\", GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_InfoText-&gt;SetTextSize(GOTextSize::ExtraSmall);\n        this-&gt;m_InfoText-&gt;SetColor(GOColor::WHITE);\n\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_InfoText);\n\n        this-&gt;Deactivate();\n    }\n\n    HoleFeedbackPosition::HoleFeedbackPosition()\n    {\n        this-&gt;m_HoleLine2ToolEnd_A = GOPoint::Add(0.f, 0.f, 0.f);\n        this-&gt;m_HoleLine2ToolEnd_B = GOPoint::Add(0.f, 0.f, 0.f);\n        this-&gt;m_HoleLine2ToolEnd = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        this-&gt;m_HoleLine2ToolStart_A = GOPoint::Add(0.f, 0.f, 0.f);\n        this-&gt;m_HoleLine2ToolStart_B = GOPoint::Add(0.f, 0.f, 0.f);\n        this-&gt;m_HoleLine2ToolStart = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        this-&gt;m_HoleLine2ToolEnd-&gt;SetColor(GOColor::RED_TRANSP07);\n        this-&gt;m_HoleLine2ToolStart-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_HoleLine2ToolEnd_A-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_HoleLine2ToolEnd_B-&gt;SetColor(GOColor::PINK_TRANSP07);\n        this-&gt;m_HoleLine2ToolStart_A-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_HoleLine2ToolStart_B-&gt;SetColor(GOColor::PINK_TRANSP07);\n\n        this-&gt;m_HoleLine2ToolEnd-&gt;SetWeight(GOWeight::Medium);\n        this-&gt;m_HoleLine2ToolStart-&gt;SetWeight(GOWeight::Medium);\n        this-&gt;m_HoleLine2ToolEnd_A-&gt;SetWeight(GOWeight::MediumThick);\n        this-&gt;m_HoleLine2ToolEnd_B-&gt;SetWeight(GOWeight::MediumThick);\n        this-&gt;m_HoleLine2ToolStart_A-&gt;SetWeight(GOWeight::MediumThick);\n        this-&gt;m_HoleLine2ToolStart_B-&gt;SetWeight(GOWeight::MediumThick);\n\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_HoleLine2ToolStart_A);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_HoleLine2ToolStart_B);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_HoleLine2ToolStart);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_HoleLine2ToolEnd_A);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_HoleLine2ToolEnd_B);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_HoleLine2ToolEnd);\n\n        this-&gt;Deactivate();\n    }\n\n    HoleFeedbackRotation::HoleFeedbackRotation()\n    {\n        this-&gt;m_GUILineOrientation_A = GOPoint::Add(0.f, 0.f, 0.f);\n        this-&gt;m_GUILineOrientation_B = GOPoint::Add(0.f, 0.f, 0.f);\n        this-&gt;m_GUILineOrientation = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        this-&gt;m_GUILineOrientation_A-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_GUILineOrientation_B-&gt;SetColor(GOColor::PINK_TRANSP07);\n        this-&gt;m_GUILineOrientation-&gt;SetColor(GOColor::MAGENTA_TRANSP07);\n\n        this-&gt;m_GUILineOrientation_A-&gt;SetWeight(GOWeight::MediumThick);\n        this-&gt;m_GUILineOrientation_B-&gt;SetWeight(GOWeight::MediumThick);\n        this-&gt;m_GUILineOrientation-&gt;SetWeight(GOWeight::Medium);\n\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_GUILineOrientation_A);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_GUILineOrientation_B);\n        this-&gt;m_AllPrimitives.push_back(this-&gt;m_GUILineOrientation);\n\n        this-&gt;Deactivate();\n    }\n\n    HoleFeedback::HoleFeedback()\n    {\n        this-&gt;m_DrillBitLineAxis = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n        this-&gt;m_HoleLineAxis = GOLine::Add(GOPoint(0.f, 0.f, 0.f), GOPoint(0.f, 0.f, 0.f));\n\n        this-&gt;m_DrillBitLineAxis-&gt;SetVisibility(false);\n        this-&gt;m_HoleLineAxis-&gt;SetVisibility(false);\n\n        this-&gt;Deactivate();\n    }\n\n    void HoleFeedback::Update()\n    {\n        auto hole = dynamic_cast&lt;TimberInfo::Hole*&gt;(AC_FF_COMP);\n        float scaleF = AIAC::Config::Get&lt;float&gt;(AIAC::Config::SEC_AIAC, AIAC::Config::SCALE_FACTOR, 1.0f);\n\n        this-&gt;m_VisPosition.m_HoleLine2ToolStart_A-&gt;SetPosition(*AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().TooltipGO);\n        this-&gt;m_VisPosition.m_HoleLine2ToolStart_B-&gt;SetPosition(*hole-&gt;GetStartPointGO());\n        this-&gt;m_VisPosition.m_HoleLine2ToolStart-&gt;SetPts(\n            *AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().TooltipGO,    // start\n            *hole-&gt;GetStartPointGO());                         // end\n        this-&gt;m_VisPosition.m_HoleLine2ToolEnd_A-&gt;SetPosition(*AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().EattipGO);\n        this-&gt;m_VisPosition.m_HoleLine2ToolEnd_B-&gt;SetPosition(*hole-&gt;GetEndPointGO());\n        this-&gt;m_VisPosition.m_HoleLine2ToolEnd-&gt;SetPts(\n            *AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().EattipGO,    // start\n            *hole-&gt;GetEndPointGO());                           // end\n        this-&gt;m_DrillBitLineAxis-&gt;SetPts(\n            *AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().ToolbaseGO,   // start\n            *AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().TooltipGO);   // end\n        this-&gt;m_HoleLineAxis-&gt;SetPts(\n            *hole-&gt;GetStartPointGO(),                          // start\n            *hole-&gt;GetEndPointGO());                           // end\n\n        // angle orientation guidance\n        glm::vec3 midPtToolAxis = this-&gt;m_DrillBitLineAxis-&gt;GetMidPointValues();\n        glm::vec3 translVec = glm::vec3(this-&gt;m_HoleLineAxis-&gt;GetPEnd().X() - this-&gt;m_DrillBitLineAxis-&gt;GetPEnd().X(),\n                                        this-&gt;m_HoleLineAxis-&gt;GetPEnd().Y() - this-&gt;m_DrillBitLineAxis-&gt;GetPEnd().Y(),\n                                        this-&gt;m_HoleLineAxis-&gt;GetPEnd().Z() - this-&gt;m_DrillBitLineAxis-&gt;GetPEnd().Z());\n        this-&gt;m_DrillBitLineAxis-&gt;Translate(translVec);\n        float lengthHole = this-&gt;m_HoleLineAxis-&gt;GetLength();\n        float lengthDrillBit = this-&gt;m_DrillBitLineAxis-&gt;GetLength();\n        float lengthDiff = lengthHole - lengthDrillBit;\n        this-&gt;m_DrillBitLineAxis-&gt;ExtendFromStart(lengthDiff);\n\n        this-&gt;m_VisRotation.m_GUILineOrientation-&gt;SetPts(\n            this-&gt;m_DrillBitLineAxis-&gt;GetPStart(),  // start\n            this-&gt;m_HoleLineAxis-&gt;GetPStart());     // end\n        glm::vec3 vectGUITrans = glm::vec3(midPtToolAxis.x - this-&gt;m_DrillBitLineAxis-&gt;GetPStart().X(),\n                                           midPtToolAxis.y - this-&gt;m_DrillBitLineAxis-&gt;GetPStart().Y(),\n                                           midPtToolAxis.z - this-&gt;m_DrillBitLineAxis-&gt;GetPStart().Z());\n        this-&gt;m_VisRotation.m_GUILineOrientation-&gt;Translate(vectGUITrans);\n        this-&gt;m_VisRotation.m_GUILineOrientation_A-&gt;SetPosition(\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;GetPStart()\n        );\n        this-&gt;m_VisRotation.m_GUILineOrientation_B-&gt;SetPosition(\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;GetPEnd()\n        );\n\n        // (i) start distance\n        float dist = this-&gt;m_VisPosition.m_HoleLine2ToolStart-&gt;GetLength();\n        float distScaled = dist / scaleF;\n        int distScaledMM = std::round(distScaled * 1000.f);\n        if (distScaledMM &gt; 99) distScaledMM = 99;\n        std::string distScaledMMStr = std::to_string(distScaledMM);\n        if (distScaledMMStr.size() == 1)\n            distScaledMMStr = \"0\" + distScaledMMStr;\n\n        // (ii) detect if inside\n        float angle = this-&gt;m_VisPosition.m_HoleLine2ToolStart-&gt;ComputeAngle(this-&gt;m_VisPosition.m_HoleLine2ToolEnd);\n\n        // (iii) angle\n        float angleOrient = this-&gt;m_DrillBitLineAxis-&gt;ComputeAngle(this-&gt;m_HoleLineAxis);\n        int angleOrientRounded = angleOrient;\n        if (angleOrientRounded &gt; 99) angleOrientRounded = 99;\n        std::string angleOrientRoundedStr = std::to_string(angleOrientRounded);\n        if (angleOrientRoundedStr.size() == 1) angleOrientRoundedStr = \"0\" + angleOrientRoundedStr;\n\n        // (iv) depth\n        float depthLeft = this-&gt;m_HoleLineAxis-&gt;GetPStart().DistanceTo(*AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;().EattipGO);\n        float holeLength = this-&gt;m_HoleLineAxis-&gt;GetLength();\n        float depthDrilled = holeLength - depthLeft;\n        float depthDrilledScaled = depthDrilled / scaleF;\n        int depthDrilledScaledMM = std::round(depthDrilledScaled * 1000.f);\n        std::string depthDrilledScaledMMStr = std::to_string(depthDrilledScaledMM);\n\n        // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n        // (v) computed/visual feedbacks\n        this-&gt;m_VisText.m_InfoText-&gt;SetColor(GOColor::WHITE);\n        this-&gt;m_VisPosition.m_HoleLine2ToolEnd_A-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_VisPosition.m_HoleLine2ToolEnd_B-&gt;SetColor(GOColor::PINK_TRANSP07);\n        this-&gt;m_VisPosition.m_HoleLine2ToolStart_A-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_VisPosition.m_HoleLine2ToolStart_B-&gt;SetColor(GOColor::PINK_TRANSP07);\n\n        if ((180.f - this-&gt;m_InsideOutDetection) &lt; angle &amp;&amp; angle &lt; (180.f + m_InsideOutDetection))\n        {\n            this-&gt;m_VisPosition.m_HoleLine2ToolStart-&gt;SetVisibility(false);\n            this-&gt;m_VisPosition.m_HoleLine2ToolStart_A-&gt;SetVisibility(false);\n            this-&gt;m_VisPosition.m_HoleLine2ToolStart_B-&gt;SetVisibility(false);\n\n            // here we are inside the hole\n            distScaledMMStr = \"00\";\n            if (depthDrilled &lt; 0.f)\n            {\n                this-&gt;m_VisPosition.m_HoleLine2ToolEnd-&gt;SetColor(GOColor::RED_TRANSP07);\n                this-&gt;m_VisPosition.m_HoleLine2ToolEnd_A-&gt;SetColor(GOColor::RED_TRANSP07);\n                this-&gt;m_VisPosition.m_HoleLine2ToolEnd_B-&gt;SetColor(GOColor::RED_TRANSP07);\n                this-&gt;m_VisText.m_InfoText-&gt;SetColor(GOColor::RED);\n            }\n            else\n                this-&gt;m_VisPosition.m_HoleLine2ToolEnd-&gt;SetColor(GOColor::GREEN);\n        }\n        else\n        {\n            this-&gt;m_VisPosition.m_HoleLine2ToolEnd-&gt;SetVisibility(false);\n            this-&gt;m_VisPosition.m_HoleLine2ToolEnd_A-&gt;SetVisibility(false);\n            this-&gt;m_VisPosition.m_HoleLine2ToolEnd_B-&gt;SetVisibility(false);\n\n            // here we are still outside\n            if (depthDrilled &gt; 0.f)\n                this-&gt;m_VisPosition.m_HoleLine2ToolStart-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n            else\n            {\n                this-&gt;m_VisPosition.m_HoleLine2ToolStart-&gt;SetColor(GOColor::RED_TRANSP07);\n                this-&gt;m_VisText.m_InfoText-&gt;SetColor(GOColor::RED);\n                this-&gt;m_VisPosition.m_HoleLine2ToolStart_A-&gt;SetColor(GOColor::RED_TRANSP07);\n                this-&gt;m_VisPosition.m_HoleLine2ToolStart_B-&gt;SetColor(GOColor::RED_TRANSP07);\n            }\n        }\n\n        // if the orientation is under 1 degree, change the color to green\n        this-&gt;m_VisRotation.m_GUILineOrientation_A-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        this-&gt;m_VisRotation.m_GUILineOrientation_B-&gt;SetColor(GOColor::PINK_TRANSP07);\n        if (angleOrient &lt; this-&gt;m_OrientationTolerance)\n        {\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;SetColor(GOColor::GREEN);\n            this-&gt;m_VisRotation.m_GUILineOrientation_A-&gt;SetColor(GOColor::GREEN_TRANSP07);\n            this-&gt;m_VisRotation.m_GUILineOrientation_B-&gt;SetColor(GOColor::GREEN_TRANSP07);\n        }\n        else if (this-&gt;m_OrientationTolerance &lt; angleOrient &amp;&amp; angleOrient &lt; 5.f)\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;SetColor(GOColor::YELLOW_TRANSP07);\n        else if (angleOrient &lt; 10.f &amp;&amp; angleOrient &gt;= 5.f)\n        {\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;SetColor(GOColor::ORANGE);\n            this-&gt;m_VisText.m_InfoText-&gt;SetColor(GOColor::ORANGE);\n        }\n        else if (angleOrient &gt;= 10.f)\n        {\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;SetColor(GOColor::RED_TRANSP07);\n            this-&gt;m_VisText.m_InfoText-&gt;SetColor(GOColor::RED);\n        }\n        else\n            this-&gt;m_VisRotation.m_GUILineOrientation-&gt;SetColor(GOColor::MAGENTA_TRANSP07);\n\n        // text setting\n        std::string test = \\\n            \" s:\" + distScaledMMStr + \\\n            \"/a:\" + angleOrientRoundedStr + \\\n            \"/e:\" + depthDrilledScaledMMStr;\n        this-&gt;m_VisText.m_InfoText-&gt;SetText(test);\n        this-&gt;m_VisText.m_InfoText-&gt;SetAnchor(midPtToolAxis);\n    }\n\n    void HoleFeedback::Activate()\n    {\n        this-&gt;m_VisText.Activate();\n        this-&gt;m_VisPosition.Activate();\n        this-&gt;m_VisRotation.Activate();\n    }\n\n    void HoleFeedback::Deactivate()\n    {\n        this-&gt;m_VisText.Deactivate();\n        this-&gt;m_VisPosition.Deactivate();\n        this-&gt;m_VisRotation.Deactivate();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/HoleFeedback_8h/","title":"File HoleFeedback.h","text":"<p>FileList &gt; AIAC &gt; Feedback &gt; HoleFeedback.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/ACInfoModel.h\"</code></li> <li><code>#include \"FeedbackVisualizer.h\"</code></li> <li><code>#include \"FabFeedback.h\"</code></li> <li><code>#include \"utils/GeometryUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/HoleFeedback_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/HoleFeedback_8h/#classes","title":"Classes","text":"Type Name class HoleFeedback The UI widget for providing feedback on orientation Feeds (in chronological order): class HoleFeedbackPosition The UI widget for providing feedback on position. class HoleFeedbackRotation The UI widget for providing feedback on rotation. class HoleFeedbackText The general visualizer for the info displayed as text. <p>The documentation for this class was generated from the following file <code>src/AIAC/Feedback/HoleFeedback.h</code></p>"},{"location":"acdoxygen/HoleFeedback_8h_source/","title":"File HoleFeedback.h","text":"<p>File List &gt; AIAC &gt; Feedback &gt; HoleFeedback.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#ifndef AC_HOLEFEEDBACK_H\n#define AC_HOLEFEEDBACK_H\n\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/ACInfoModel.h\"\n#include \"FeedbackVisualizer.h\"\n#include \"FabFeedback.h\"\n#include \"utils/GeometryUtils.h\"\n\nnamespace AIAC\n{\n    class HoleFeedbackText : public FeedbackVisualizer\n    {\n    public:\n        HoleFeedbackText();\n\n    private:\n        // @brief text visualized for numeric values of start, orientation and depth\n        std::shared_ptr&lt;GOText&gt; m_InfoText;\n\n    friend class HoleFeedback;\n    };\n\n    class HoleFeedbackPosition : public FeedbackVisualizer\n    {\n    public:\n        HoleFeedbackPosition();\n\n    private:\n        std::shared_ptr&lt;GOLine&gt; m_HoleLine2ToolEnd;\n        std::shared_ptr&lt;GOPoint&gt; m_HoleLine2ToolEnd_A;\n        std::shared_ptr&lt;GOPoint&gt; m_HoleLine2ToolEnd_B;\n        std::shared_ptr&lt;GOLine&gt; m_HoleLine2ToolStart;\n        std::shared_ptr&lt;GOPoint&gt; m_HoleLine2ToolStart_A;\n        std::shared_ptr&lt;GOPoint&gt; m_HoleLine2ToolStart_B;\n\n    friend class HoleFeedback;\n    };\n\n    class HoleFeedbackRotation : public FeedbackVisualizer\n    {\n    public:\n        HoleFeedbackRotation();\n\n    private:\n        std::shared_ptr&lt;GOLine&gt; m_GUILineOrientation;\n        std::shared_ptr&lt;GOPoint&gt; m_GUILineOrientation_A;\n        std::shared_ptr&lt;GOPoint&gt; m_GUILineOrientation_B;\n\n    friend class HoleFeedback;\n    };\n\n    class HoleFeedback : public FabFeedback \n    {\n    public:\n        HoleFeedback();\n        ~HoleFeedback() = default;\n\n        void Update() override;\n        void Activate() override;\n        void Deactivate() override;\n\n    private:  \n        std::shared_ptr&lt;GOLine&gt; m_DrillBitLineAxis;\n        std::shared_ptr&lt;GOLine&gt; m_HoleLineAxis;\n\n    private:  \n        HoleFeedbackText m_VisText;\n        HoleFeedbackPosition m_VisPosition;\n        HoleFeedbackRotation m_VisRotation;\n\n    private:  \n        float m_InsideOutDetection = 20.f;\n        float m_OrientationTolerance = 1.1f;\n\n    };\n}\n\n#endif // AC_HOLEFEEDBACK_H\n</code></pre>"},{"location":"acdoxygen/dir_5f167dfbcc50bcf5ffb2c1a7f5cf90ca/","title":"Dir src/AIAC/GOSys","text":"<p>FileList &gt; AIAC &gt; GOSys</p>"},{"location":"acdoxygen/dir_5f167dfbcc50bcf5ffb2c1a7f5cf90ca/#files","title":"Files","text":"Type Name file GO.h file GOPrimitive.cpp file GOPrimitive.h file GORegistry.h <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/</code></p>"},{"location":"acdoxygen/GO_8h/","title":"File GO.h","text":"<p>FileList &gt; AIAC &gt; GOSys &gt; GO.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/GOSys/GORegistry.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GO.h</code></p>"},{"location":"acdoxygen/GO_8h_source/","title":"File GO.h","text":"<p>File List &gt; AIAC &gt; GOSys &gt; GO.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"glm/glm.hpp\"\n\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/GOSys/GORegistry.h\"\n</code></pre>"},{"location":"acdoxygen/GOPrimitive_8cpp/","title":"File GOPrimitive.cpp","text":"<p>FileList &gt; AIAC &gt; GOSys &gt; GOPrimitive.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"assimp/Importer.hpp\"</code></li> <li><code>#include \"assimp/scene.h\"</code></li> <li><code>#include \"assimp/postprocess.h\"</code></li> <li><code>#include \"glm/gtx/string_cast.hpp\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> </ul>"},{"location":"acdoxygen/GOPrimitive_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.cpp</code></p>"},{"location":"acdoxygen/GOPrimitive_8cpp_source/","title":"File GOPrimitive.cpp","text":"<p>File List &gt; AIAC &gt; GOSys &gt; GOPrimitive.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"assimp/Importer.hpp\"      // C++ importer interface\n#include \"assimp/scene.h\"           // Output data structure\n#include \"assimp/postprocess.h\"     // Post processing flags\n\n#include \"glm/gtx/string_cast.hpp\"\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/Application.h\"\n\n\nnamespace AIAC\n{\n    GOPrimitive::GOPrimitive(bool isVisible, glm::vec4 color)\n        : m_IsVisible(isVisible), m_Color(color), m_State(false)\n    {\n        m_Id = GenerateId();\n    }\n\n    uint32_t GOPrimitive::GenerateId()\n    {\n        uint32_t id = std::hash&lt;std::string&gt;{}(std::to_string(std::rand()));\n        if (AIAC_GOREG-&gt;CheckIfKeyExists(id))\n            return GenerateId();\n        else\n            return id;\n    }\n\n    // TODO: delete GL Objects\n    void GOPrimitive::Remove(const uint32_t&amp; id)\n    {\n        AIAC_GOREG-&gt;GetGO&lt;GOPrimitive&gt;(id)-&gt;ClearGLObject();\n        AIAC_GOREG-&gt;Unregister(id);\n    }\n\n    void GOPrimitive::Remove(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO)\n    {\n        ptrGO-&gt;ClearGLObject();\n        AIAC_GOREG-&gt;Unregister(ptrGO-&gt;GetId());\n    }\n\n    void GOPrimitive::ClearGLObject()\n    {\n        for(auto&amp; glObj : m_GLObjects)\n            glObj-&gt;DeleteVBOs();\n        m_GLObjects.clear();\n    }\n\n    GOPoint::GOPoint(float x, float y, float z, float weight)\n    {\n        m_Position = glm::vec3(x, y, z);\n        m_Type = GOTypeFlags::_GOPoint;\n        m_Weight = weight;\n    }\n\n    GOPoint::GOPoint(glm::vec3 position, float weight)\n        : m_Position(position)\n    {\n        m_Type = GOTypeFlags::_GOPoint;\n        m_Weight = weight;\n    }\n\n    std::shared_ptr&lt;GOPoint&gt; GOPoint::Add(float x, float y, float z, float weight)\n    {\n        auto ptrGO = std::make_shared&lt;GOPoint&gt;(GOPoint(x, y, z, weight));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOPoint&gt; GOPoint::Add(glm::vec3 position, float weight)\n    {\n        auto ptrGO = std::make_shared&lt;GOPoint&gt;(GOPoint(position, weight));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    void GOPoint::InitGLObject()\n    {\n        ClearGLObject();\n        std::vector&lt;glm::vec3&gt; vertices;\n        std::vector&lt;glm::vec4&gt; colors;\n        vertices.push_back(m_Position);\n        colors.push_back(m_Color);\n        m_GLObjects.push_back(std::make_shared&lt;GLPointObject&gt;(vertices, colors, m_Weight));\n    }\n\n    std::shared_ptr&lt;GOPoint&gt; GOPoint::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOPoint&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOPoint&gt;&gt; GOPoint::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOPoint&gt;();\n    }\n\n    GOLine::GOLine()\n    {\n        m_Type = GOTypeFlags::_GOLine;\n    }\n\n    GOLine::GOLine(GOPoint p1, GOPoint p2, float weight)\n        : m_PStart(p1), m_PEnd(p2)\n    {\n        m_Weight = weight;\n        m_Type = GOTypeFlags::_GOLine;\n    }\n\n     std::shared_ptr&lt;GOLine&gt; GOLine::Add()\n    {\n        auto ptrGO = std::make_shared&lt;GOLine&gt;(GOLine());\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOLine&gt; GOLine::Add(GOPoint p1, GOPoint p2, float weight)\n    {\n        auto ptrGO = std::make_shared&lt;GOLine&gt;(GOLine(p1, p2, weight));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOLine&gt; GOLine::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOLine&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOLine&gt;&gt; GOLine::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOLine&gt;();\n    }\n\n    float GOLine::ComputeAngle(std::shared_ptr&lt;GOLine&gt; ptrGO2)\n    {\n        glm::vec3 v1 = this-&gt;m_PEnd.GetPosition() - this-&gt;m_PStart.GetPosition();\n        glm::vec3 v2 = ptrGO2-&gt;m_PEnd.GetPosition() - ptrGO2-&gt;m_PStart.GetPosition();\n        auto angle = glm::acos(glm::dot(v1, v2) / (glm::length(v1) * glm::length(v2)));\n        return angle * 180.0f / glm::pi&lt;float&gt;();\n    }\n\n    float GOLine::ComputeSignedAngle(std::shared_ptr&lt;GOLine&gt; ptrGO2)\n    {\n        glm::vec3 v1 = this-&gt;m_PEnd.GetPosition() - this-&gt;m_PStart.GetPosition();\n        glm::vec3 v2 = ptrGO2-&gt;m_PEnd.GetPosition() - ptrGO2-&gt;m_PStart.GetPosition();\n        auto angle = glm::acos(glm::dot(v1, v2) / (glm::length(v1) * glm::length(v2)));\n        auto cross = glm::cross(v1, v2);\n        if (cross.z &lt; 0)\n            angle = -angle;\n        return angle * 180.0f / glm::pi&lt;float&gt;();\n    }\n\n    void GOLine::InitGLObject()\n    {\n        ClearGLObject();\n        std::vector&lt;glm::vec3&gt; vertices;\n        vertices.push_back(m_PStart.GetPosition());\n        vertices.push_back(m_PEnd.GetPosition());\n        m_GLObjects = CreatePolyline(vertices, false, m_Color, m_Weight);\n    }\n\n\n    GOCircle::GOCircle(GOPoint center, float radius)\n        : m_Center(center), m_Radius(radius)\n    {\n        m_Type = GOTypeFlags::_GOCircle;\n    }\n\n    GOCircle::GOCircle(GOPoint center, glm::vec3 normal, float radius)\n        : m_Center(center), m_Normal(normal), m_Radius(radius)\n    {\n        m_Type = GOTypeFlags::_GOCircle;\n    }\n\n    glm::vec3 GOCircle::ClosestPointToPoint(glm::vec3 point)\n    {\n        auto p1 = this-&gt;m_Center.GetPosition();\n        auto p2 = point;\n        auto v = p2 - p1;\n        auto mag = glm::length(v);\n        return p1 + (v / mag) * this-&gt;m_Radius;\n    }\n\n    void GOCircle::InitGLObject()\n    {\n        ClearGLObject();\n        m_GLObjects = CreateCircle(m_Center.GetPosition(), m_Normal, m_Radius, m_Color, m_Color, m_Weight);\n    }\n\n    std::shared_ptr&lt;GOCircle&gt; GOCircle::Add(GOPoint center, float radius)\n    {\n        auto ptrGO = std::make_shared&lt;GOCircle&gt;(GOCircle(center, radius));\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOCircle&gt; GOCircle::Add(GOPoint center, glm::vec3 normal, float radius)\n    {\n        auto ptrGO = std::make_shared&lt;GOCircle&gt;(GOCircle(center, normal, radius));\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOCircle&gt; GOCircle::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOCircle&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOCircle&gt;&gt; GOCircle::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOCircle&gt;();\n    }\n\n\n    GOCylinder::GOCylinder(GOPoint p1, GOPoint p2, float radius)\n        : m_PStart(p1), m_PEnd(p2), m_Radius(radius)\n    {\n        m_Type = GOTypeFlags::_GOCylinder;\n    }\n\n    std::shared_ptr&lt;GOCylinder&gt; GOCylinder::Add(GOPoint p1, GOPoint p2, float radius)\n    {\n        auto ptrGO = std::make_shared&lt;GOCylinder&gt;(GOCylinder(p1, p2, radius));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    void GOCylinder::InitGLObject(){\n        ClearGLObject();\n        m_GLObjects = CreateCylinder(m_PStart.GetPosition(), m_PEnd.GetPosition(), m_Radius,\n                                     m_Color, m_Color);\n    }\n\n    std::shared_ptr&lt;GOCylinder&gt; GOCylinder::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOCylinder&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOCylinder&gt;&gt; GOCylinder::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOCylinder&gt;();\n    }\n\n    GOPolyline::GOPolyline()\n    {\n        m_Type = GOTypeFlags::_GOPolyline;\n    }\n\n    GOPolyline::GOPolyline(std::vector&lt;GOPoint&gt; points, bool isClosed, float weight)\n        : m_Points(points), m_IsClosed(isClosed), m_Weight(weight)\n    {\n        m_Type = GOTypeFlags::_GOPolyline;\n    }\n\n    std::shared_ptr&lt;GOPolyline&gt; GOPolyline::Add()\n    {\n        auto ptrGO = std::make_shared&lt;GOPolyline&gt;(GOPolyline());\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOPolyline&gt; GOPolyline::Add(std::vector&lt;GOPoint&gt; points, bool isClosed, float weight)\n    {\n        auto ptrGO = std::make_shared&lt;GOPolyline&gt;(GOPolyline(points, isClosed, weight));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOPolyline&gt; GOPolyline::Add(std::vector&lt;glm::vec3&gt; points, bool isClosed, float weight)\n    {\n        // convert glm::vec3 to GOPoint\n        std::vector&lt;GOPoint&gt; pts;\n        for (auto&amp; p : points) {\n            pts.push_back(GOPoint(p));\n        }\n\n        auto ptrGO = std::make_shared&lt;GOPolyline&gt;(GOPolyline(pts, isClosed, weight));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n\n    void GOPolyline::InitGLObject() {\n        ClearGLObject();\n        vector&lt;glm::vec3&gt; vertices;\n        for (auto&amp; p : m_Points) {\n            vertices.push_back(p.GetPosition());\n        }\n        m_GLObjects = CreatePolyline(vertices, m_IsClosed, m_Color, m_Weight);\n    }\n\n    std::shared_ptr&lt;GOPolyline&gt; GOPolyline::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOPolyline&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOPolyline&gt;&gt; GOPolyline::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOPolyline&gt;();\n    }\n\n    GOTriangle::GOTriangle(GOPoint p1, GOPoint p2, GOPoint p3)\n        : m_P1(p1), m_P2(p2), m_P3(p3)\n    {\n        m_Type = GOTypeFlags::_GOTriangle;\n    }\n\n    void GOTriangle::InitGLObject() {\n        ClearGLObject();\n\n        std::vector&lt;uint32_t&gt; indices;\n        std::vector&lt;glm::vec3&gt; vertices;\n        std::vector&lt;glm::vec4&gt; colors;\n        indices.push_back(0);\n        indices.push_back(1);\n        indices.push_back(2);\n        vertices.push_back(m_P1.GetPosition());\n        vertices.push_back(m_P2.GetPosition());\n        vertices.push_back(m_P3.GetPosition());\n        colors.push_back(m_Color);\n        colors.push_back(m_Color);\n        colors.push_back(m_Color);\n        m_GLObjects.push_back(std::make_shared&lt;GLMeshObject&gt;(vertices, colors, indices));\n    }\n\n    std::shared_ptr&lt;GOTriangle&gt; GOTriangle::Add(GOPoint p1, GOPoint p2, GOPoint p3)\n    {\n        auto ptrGO = std::make_shared&lt;GOTriangle&gt;(GOTriangle(p1, p2, p3));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOTriangle&gt; GOTriangle::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOTriangle&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOTriangle&gt;&gt; GOTriangle::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOTriangle&gt;();\n    }\n\n\n    GOMesh::GOMesh()\n    {\n        m_Type = GOTypeFlags::_GOMesh;\n    }\n\n    GOMesh::GOMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;uint32_t&gt; indices, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec4&gt; colors)\n        : m_Vertices(vertices), m_Indices(indices), m_Normals(normals), m_Colors(colors)\n    {\n        m_Type = GOTypeFlags::_GOMesh;\n    }\n\n    void GOMesh::InitGLObject(){\n        ClearGLObject();\n        if(m_Vertices.size() == 0){\n            return;\n        }\n        if(m_Indices.size() == 0){\n            return;\n        }\n        m_GLObjects.push_back(std::make_shared&lt;GLMeshObject&gt;(m_Vertices, m_Colors, m_Indices));\n    }\n\n    std::shared_ptr&lt;GOMesh&gt; GOMesh::Add()\n    {\n        auto ptrGO = std::make_shared&lt;GOMesh&gt;(GOMesh());\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOMesh&gt; GOMesh::Add(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;uint32_t&gt; indices)\n    {\n        auto ptrGO = std::make_shared&lt;GOMesh&gt;(GOMesh(vertices, indices));\n        ptrGO-&gt;InitGLObject();\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOMesh&gt; GOMesh::LoadPly(std::string path){\n        Assimp::Importer importer;\n\n        const aiScene* scene = importer.ReadFile(path, aiProcess_JoinIdenticalVertices);\n        if(!scene) {\n            AIAC_ERROR(importer.GetErrorString());\n            return nullptr;\n        }\n\n        const aiMesh* mesh = scene-&gt;mMeshes[0]; // TODO: here we use only the 1st mesh, make more?\n\n        auto ptrGO = std::make_shared&lt;GOMesh&gt;(GOMesh());\n\n        ptrGO-&gt;m_Vertices.reserve(mesh-&gt;mNumVertices);\n        for(unsigned int i=0; i&lt;mesh-&gt;mNumVertices; i++){\n            aiVector3D pos = mesh-&gt;mVertices[i];\n            ptrGO-&gt;m_Vertices.emplace_back(pos.x, pos.y, pos.z);\n        }\n\n        ptrGO-&gt;m_Colors.reserve(mesh-&gt;mNumVertices);\n        for(unsigned int i=0; i&lt;mesh-&gt;mNumVertices; i++){\n            ptrGO-&gt;m_Colors.emplace_back(0.5f, 0.3f, 0.1f, 1.0f);\n        }\n\n        ptrGO-&gt;m_Indices.reserve(mesh-&gt;mNumFaces * 3);\n        for(unsigned int i=0; i&lt;mesh-&gt;mNumFaces; i++){\n            aiFace face = mesh-&gt;mFaces[i];\n            ptrGO-&gt;m_Indices.push_back(face.mIndices[0]);\n            ptrGO-&gt;m_Indices.push_back(face.mIndices[1]);\n            ptrGO-&gt;m_Indices.push_back(face.mIndices[2]);\n        }\n        ptrGO-&gt;InitGLObject();\n\n//        if(mesh-&gt;mNormals != nullptr){\n//            ptrGO-&gt;m_Normals.reserve(mesh-&gt;mNumVertices);\n//            for(unsigned int i=0; i&lt;mesh-&gt;mNumVertices; i++){\n//                aiVector3D norm = mesh-&gt;mNormals[i];\n//                ptrGO-&gt;m_Normals.emplace_back(norm.x, norm.y, norm.z);\n//            }\n//        }\n//\n//        if(mesh-&gt;mColors != nullptr){\n//            ptrGO-&gt;m_Colors.reserve(mesh-&gt;mNumVertices);\n//            for(unsigned int i=0; i&lt;mesh-&gt;mNumVertices; i++){\n//                aiColor4D color = mesh-&gt;mColors[0][i];\n//                ptrGO-&gt;m_Colors.emplace_back(color.r, color.g, color.b, color.a);\n//            }\n//        }\n\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOMesh&gt; GOMesh::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOMesh&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOMesh&gt;&gt; GOMesh::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOMesh&gt;();\n    }\n\n    GOText::GOText()\n    {\n        m_Anchor.SetVisibility(false);\n        m_Type = GOTypeFlags::_GOText;\n    }\n\n    GOText::GOText(std::string text, GOPoint anchor, double size)\n        : m_Text(text), m_Anchor(anchor), m_Size(size)\n    {\n        m_Anchor.SetVisibility(false);\n        m_Type = GOTypeFlags::_GOText;\n    }\n\n    std::shared_ptr&lt;GOText&gt; GOText::Add()\n    {\n        auto ptrGO = std::make_shared&lt;GOText&gt;(GOText());\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOText&gt; GOText::Add(std::string text, GOPoint anchor, double size)\n    {\n        auto ptrGO = std::make_shared&lt;GOText&gt;(GOText(text, anchor, size));\n        AIAC_GOREG-&gt;Register(ptrGO);\n        return ptrGO;\n    }\n\n    std::shared_ptr&lt;GOText&gt; GOText::Get(const uint32_t&amp; id)\n    {\n        return AIAC_GOREG-&gt;GetGO&lt;GOText&gt;(id);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GOText&gt;&gt; GOText::GetAll()\n    {\n        return AIAC_GOREG-&gt;GetAllGOs&lt;GOText&gt;();\n    }\n}\n</code></pre>"},{"location":"acdoxygen/GOPrimitive_8h/","title":"File GOPrimitive.h","text":"<p>FileList &gt; AIAC &gt; GOSys &gt; GOPrimitive.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"AIAC/Render/GLObject.h\"</code></li> <li><code>#include \"AIAC/Base.h\"</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include &lt;glm/gtx/norm.hpp&gt;</code></li> <li><code>#include &lt;glm/gtc/constants.hpp&gt;</code></li> </ul>"},{"location":"acdoxygen/GOPrimitive_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/GOPrimitive_8h/#classes","title":"Classes","text":"Type Name class GOCircle struct GOColor class GOCylinder class GOLine class GOMesh class GOPoint class GOPolyline class GOPrimitive class GOText struct GOTextSize class GOTriangle struct GOWeight <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GOPrimitive.h</code></p>"},{"location":"acdoxygen/GOPrimitive_8h_source/","title":"File GOPrimitive.h","text":"<p>File List &gt; AIAC &gt; GOSys &gt; GOPrimitive.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\n#include \"AIAC/Render/GLObject.h\"\n#include \"AIAC/Base.h\"\n#include \"glm/glm.hpp\"\n#include &lt;glm/glm.hpp&gt;\n#include &lt;glm/gtx/norm.hpp&gt; // For glm::length2\n#include &lt;glm/gtc/constants.hpp&gt; // For glm::pi\n\nnamespace AIAC\n{\n    struct GOColor\n    {\n        static constexpr glm::vec4 RED = glm::vec4(1.0f, 0.0f, 0.0f, 1.0f);\n        static constexpr glm::vec4 RED_TRANSP07 = glm::vec4(1.0f, 0.0f, 0.0f, 0.7f);\n        static constexpr glm::vec4 GREEN = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f);\n        static constexpr glm::vec4 GREEN_TRANSP07 = glm::vec4(0.0f, 1.0f, 0.0f, 0.7f);\n        static constexpr glm::vec4 GREEN_DARKER_TRANSP07 = glm::vec4(0.0f, 0.7f, 0.0f, 0.7f);\n        static constexpr glm::vec4 GREEN_PUNK_TRANSP07 = glm::vec4(0.0f, 0.7f, 0.0f, 0.7f);\n        static constexpr glm::vec4 BLUE = glm::vec4(0.0f, 0.0f, 1.0f, 1.0f);\n        static constexpr glm::vec4 YELLOW = glm::vec4(1.0f, 1.0f, 0.0f, 1.0f);\n        static constexpr glm::vec4 YELLOW_TRANSP07 = glm::vec4(1.0f, 1.0f, 0.0f, 0.7f);\n        static constexpr glm::vec4 MAGENTA = glm::vec4(1.0f, 0.0f, 1.0f, 1.0f);\n        static constexpr glm::vec4 MAGENTA_TRANSP07 = glm::vec4(1.0f, 0.0f, 1.0f, 0.7f);\n        static constexpr glm::vec4 CYAN = glm::vec4(0.0f, 1.0f, 1.0f, 1.0f);\n        static constexpr glm::vec4 WHITE = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);\n        static constexpr glm::vec4 BLACK = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);\n        static constexpr glm::vec4 GRAY = glm::vec4(0.5f, 0.5f, 0.5f, 1.0f);\n        static constexpr glm::vec4 ORANGE = glm::vec4(1.0f, 0.5f, 0.0f, 1.0f);\n        static constexpr glm::vec4 ORANGE_TRANSP = glm::vec4(1.0f, 0.5f, 0.0f, 0.5f);\n        static constexpr glm::vec4 PURPLE = glm::vec4(0.5f, 0.0f, 0.5f, 1.0f);\n        static constexpr glm::vec4 PURPLE_TRANSP = glm::vec4(0.5f, 0.0f, 0.5f, 0.5f);\n        static constexpr glm::vec4 PURPLE_TRANSP07 = glm::vec4(0.5f, 0.0f, 0.5f, 0.7f);\n        static constexpr glm::vec4 PINK = glm::vec4(1.0f, 0.0f, 0.5f, 1.0f);\n        static constexpr glm::vec4 PINK_TRANSP = glm::vec4(1.0f, 0.0f, 0.5f, 0.5f);\n        static constexpr glm::vec4 PINK_TRANSP07 = glm::vec4(1.0f, 0.0f, 0.5f, 0.7f);\n        static constexpr glm::vec4 BROWN = glm::vec4(0.5f, 0.25f, 0.0f, 1.0f);\n    };\n\n    struct GOWeight\n    {\n        static constexpr float Default            = 1.01f;\n        static constexpr float Light              = 1.4f;\n        static constexpr float Medium             = 1.8f;\n        static constexpr float Bold               = 2.5f;\n        static constexpr float Thick              = 5.0f;\n        static constexpr float MediumThick        = 7.0f;\n        static constexpr float ExtraThick         = 10.0f;\n        static constexpr float BoldThick          = 15.0f;\n        static constexpr float MaxThick           = 20.0f;\n    };\n\n    struct GOTextSize\n    {\n        static constexpr double Default            = 1.0;\n        static constexpr double ExtraSmall         = 0.35;\n        static constexpr double BitSmall           = 0.4;\n        static constexpr double Small              = 0.5;\n        static constexpr double Average            = 0.75;\n        static constexpr double Medium             = 5.0;\n        static constexpr double Big                = 10.0;\n    };\n\n    enum GOTypeFlags\n    {\n        _GOPrimitive = 0,\n        _GOPoint,\n        _GOLine,\n        _GOCircle,\n        _GOCylinder,\n        _GOPolyline,\n        _GOTriangle,\n        _GOMesh,\n        _GOText,\n    };\n\n    class GOPrimitive\n    {\n    public:\n        explicit GOPrimitive(bool isVisible = true,\n                             glm::vec4 color = glm::vec4(0, 0, 0, 1.0));\n        virtual ~GOPrimitive() = default;\n        static void Remove(const uint32_t&amp; id);\n        static void Remove(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO);\n\n        uint32_t GenerateId();\n\n        inline bool IsVisible() const { return m_IsVisible; }\n        inline glm::vec4 GetColor() const { return m_Color; }\n        inline bool GetState() { return m_State; }\n        inline GOTypeFlags GetType() { return m_Type; }\n        inline uint32_t GetId() { return m_Id; }\n\n        inline void SetName(std::string name) { m_Name = std::move(name); }\n        inline void SetVisibility(bool isVisible) { m_IsVisible = isVisible; }\n        inline bool GetVisibility() { return m_IsVisible; }\n        inline void SetColor(glm::vec4 color) { m_Color = color; InitGLObject();}\n        inline void SetState(bool state) { m_State = state; }\n\n        inline std::string GetName() const { return m_Name; }\n        inline float GetWeight() const { return m_Weight; }\n        inline int SetWeight(float weight) { m_Weight = weight; InitGLObject(); return m_Id;}\n\n        virtual void Transform(const glm::mat4x4&amp; transformMat) {};\n        virtual void Translate(const glm::vec3&amp; translation) {};\n\n        virtual void SetValueFrom(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO) { AIAC_ERROR(\"Not Implemented\"); };\n        inline void Draw() { for(auto glObject : m_GLObjects) glObject-&gt;Draw(); }\n\n        void ClearGLObject();\n        virtual void InitGLObject() {}\n\n    protected:\n        std::string m_Name;\n        uint32_t m_Id;\n        bool m_IsVisible;\n        glm::vec4 m_Color;\n        bool m_State;\n        GOTypeFlags m_Type;\n        float m_Weight = GOWeight::Default;\n        std::vector&lt;std::shared_ptr&lt;GLObject&gt; &gt; m_GLObjects;\n    };\n\n\n    class GOPoint : public GOPrimitive\n    {\n    public:\n        GOPoint() = default;\n        GOPoint(float x, float y, float z, float weight = GOWeight::Default);\n        GOPoint(glm::vec3 position, float weight = GOWeight::Default);\n\n    public:\n        static std::shared_ptr&lt;GOPoint&gt; Add(float x, float y, float z, float weight = GOWeight::Default);\n        static std::shared_ptr&lt;GOPoint&gt; Add(glm::vec3 position, float weight = GOWeight::Default);\n\n        virtual ~GOPoint() = default;\n\n        static std::shared_ptr&lt;GOPoint&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOPoint&gt;&gt; GetAll();\n\n        inline glm::vec3 GetPosition() const { return m_Position; }\n        inline void SetPosition(glm::vec3 position) { m_Position = position; InitGLObject(); }\n        inline float X() const { return m_Position.x; }\n        inline float Y() const { return m_Position.y; }\n        inline float Z() const { return m_Position.z; }\n        inline void SetX(float x) { m_Position.x = x; InitGLObject(); }\n        inline void SetY(float y) { m_Position.y = y; InitGLObject(); }\n        inline void SetZ(float z) { m_Position.z = z; InitGLObject(); }\n\n        inline void SetWeight(float weight) { m_Weight = weight; InitGLObject(); }\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            m_Position = transformMat * glm::vec4(m_Position, 1.0f);\n            InitGLObject();\n        }\n\n        inline void SetValueFrom(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO) /* override */ {\n            auto ptrPoint = std::dynamic_pointer_cast&lt;GOPoint&gt;(ptrGO);\n            if (ptrPoint != nullptr)\n            {\n                SetPosition(ptrPoint-&gt;GetPosition());\n                InitGLObject();\n                return;\n            }\n            AIAC_ERROR(\"Cannot set value from different type of primitive; The type is {}\", ptrGO-&gt;GetType());\n        }\n        void InitGLObject();\n\n        operator glm::vec3() const { return m_Position; }\n\n    public:\n        inline float DistanceTo(const GOPoint&amp; point) const {\n            return glm::distance(m_Position, point.m_Position);\n        }\n\n    private:\n        glm::vec3 m_Position;\n\n    friend class GOPrimitive;\n    friend class GOLine;\n    friend class GOCircle;\n    friend class GOCylinder;\n    friend class GOPolyline;\n    friend class GOTriangle;\n    friend class GOMesh;\n    friend class GOText;\n    };\n\n    class GOLine : public GOPrimitive\n    {\n    private:\n        GOLine();\n        GOLine(GOPoint p1, GOPoint p2, float weight = GOWeight::Default);\n\n    public:\n        static std::shared_ptr&lt;GOLine&gt; Add();\n        static std::shared_ptr&lt;GOLine&gt; Add(GOPoint p1, GOPoint p2, float weight = GOWeight::Default);\n\n        virtual ~GOLine() = default;\n\n        static std::shared_ptr&lt;GOLine&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOLine&gt;&gt; GetAll();\n\n        inline GOPoint GetPStart() const { return m_PStart; }\n        inline GOPoint GetPEnd() const { return m_PEnd; }\n\n        inline float GetLength() const { return glm::distance(m_PStart.GetPosition(), m_PEnd.GetPosition()); }\n        inline void ExtendFromStart(float length) { m_PStart.SetPosition(m_PStart.GetPosition() - glm::normalize(m_PEnd.GetPosition() - m_PStart.GetPosition()) * length); InitGLObject(); }\n        inline void ExtendFromEnd(float length) { m_PEnd.SetPosition(m_PEnd.GetPosition() + glm::normalize(m_PEnd.GetPosition() - m_PStart.GetPosition()) * length); InitGLObject(); }\n        inline void ExtendBothEnds(float length) { ExtendFromStart(length/2); ExtendFromEnd(length/2); }\n\n        inline glm::vec3 GetMidPointValues() const { return (m_PStart.GetPosition() + m_PEnd.GetPosition()) / 2.0f; }\n        inline GOPoint GetMidPoint() const { return GOPoint(GetMidPointValues()); }\n\n        inline glm::vec3 GetNormalValues() const { return glm::normalize(glm::cross(m_PEnd.GetPosition() - m_PStart.GetPosition(), glm::vec3(0, 0, 1))); }\n\n        inline void SetPStart(GOPoint pStart) { m_PStart = pStart; InitGLObject(); }\n        inline void SetPEnd(GOPoint pEnd) { m_PEnd = pEnd; InitGLObject(); }\n        inline void SetPts(GOPoint pStart, GOPoint pEnd) { m_PStart = pStart; m_PEnd = pEnd; InitGLObject(); }\n\n        float ComputeAngle(std::shared_ptr&lt;GOLine&gt; ptrGO2);\n\n        float ComputeSignedAngle(std::shared_ptr&lt;GOLine&gt; ptrGO2);\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            m_PStart.Transform(transformMat);\n            m_PEnd.Transform(transformMat);\n            InitGLObject();\n        }\n\n        inline void Translate(const glm::vec3&amp; translation) /* override */ {\n            m_PStart.SetPosition(m_PStart.GetPosition() + translation);\n            m_PEnd.SetPosition(m_PEnd.GetPosition() + translation);\n            InitGLObject();\n        }\n\n        inline void SetValueFrom(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO) /* override */ {\n            auto ptrLine = std::dynamic_pointer_cast&lt;GOLine&gt;(ptrGO);\n            if (ptrLine != nullptr)\n            {\n                SetPts(ptrLine-&gt;GetPStart(), ptrLine-&gt;GetPEnd());\n                InitGLObject();\n                return;\n            }\n            AIAC_ERROR(\"Cannot set value from different type of primitive; The type is {}\", ptrGO-&gt;GetType());\n        }\n        void InitGLObject();\n\n    private:\n        GOPoint m_PStart;\n        GOPoint m_PEnd;\n\n    friend class GOPoint;\n    };\n\n    class GOCircle : public GOPrimitive\n    {\n    private:\n        GOCircle(GOPoint center, float radius);\n        GOCircle(GOPoint center, glm::vec3 normal, float radius);\n\n    public:\n        static std::shared_ptr&lt;GOCircle&gt; Add(GOPoint center, float radius);\n        static std::shared_ptr&lt;GOCircle&gt; Add(GOPoint center, glm::vec3 normal, float radius);\n\n        virtual ~GOCircle() = default;\n\n        glm::vec3 ClosestPointToPoint(glm::vec3 point);\n\n    public:  \n        inline static glm::vec3 ClosestPointToCircle(const glm::vec3&amp; point, const glm::vec3&amp; circleCenter, const glm::vec3&amp; circleNormal, float circleRadius) {\n            glm::vec3 normalizedCircleNormal = glm::normalize(circleNormal);\n\n            glm::vec3 circleToPoint = point - circleCenter;\n            glm::vec3 projectionOntoPlane = circleToPoint - normalizedCircleNormal * glm::dot(circleToPoint, normalizedCircleNormal);\n\n            glm::vec3 closestPointOnCircumference = circleCenter + glm::normalize(projectionOntoPlane) * circleRadius;\n\n            return closestPointOnCircumference;\n        }\n\n        inline static float ClosestDistanceFromLineToCircle(\n            std::shared_ptr&lt;GOLine&gt; ptrLine,\n            const glm::vec3&amp; circleCenter,\n            float circleRadius)\n        {\n            glm::vec3 lineStart = ptrLine-&gt;GetPStart().GetPosition();\n            glm::vec3 lineEnd = ptrLine-&gt;GetPEnd().GetPosition();\n            glm::vec3 lineDirection = glm::normalize(lineEnd - lineStart);\n            glm::vec3 lineToCircle = circleCenter - lineStart;\n            glm::vec3 projectionOntoLine = lineStart + lineDirection * glm::dot(lineToCircle, lineDirection);\n            float distance = glm::distance(circleCenter, projectionOntoLine) - circleRadius;\n            return distance;\n        }\n\n        inline static std::pair&lt;float, std::pair&lt;glm::vec3, glm::vec3&gt;&gt; ClosestDistanceFromSegmentToCircle(\n            std::shared_ptr&lt;GOLine&gt; ptrLine,\n            const glm::vec3&amp; circleCenter,\n            float circleRadius)\n        {\n            glm::vec3 lineStart = ptrLine-&gt;GetPStart().GetPosition();\n            glm::vec3 lineEnd = ptrLine-&gt;GetPEnd().GetPosition();\n            glm::vec3 lineDirection = glm::normalize(lineEnd - lineStart);\n            glm::vec3 lineToCircleCenter = circleCenter - lineStart;\n\n            // Project circleCenter onto line, clamping to the segment\n            float t = glm::dot(lineToCircleCenter, lineDirection);\n            t = std::max(0.0f, std::min(t, glm::length(lineEnd - lineStart)));\n            glm::vec3 closestPointOnLine = lineStart + t * lineDirection;\n\n            // Calculate the direction from the circle center to the closest point on the line\n            glm::vec3 directionToClosestPoint = closestPointOnLine - circleCenter;\n            float distanceToLine = glm::length(directionToClosestPoint);\n\n            glm::vec3 closestPointOnCircle;\n            if (distanceToLine &lt; circleRadius) {\n                // The line segment intersects the circle, set the closest point on the circle to the closest point on the line\n                closestPointOnCircle = closestPointOnLine;\n            } else {\n                // Calculate the closest point on the circle to the line segment\n                glm::vec3 direction = glm::normalize(directionToClosestPoint);\n                closestPointOnCircle = circleCenter + direction * circleRadius;\n            }\n\n            // Calculate the final distance from the line segment to the circle\n            float finalDistance = glm::max(0.0f, distanceToLine - circleRadius);\n\n            return std::make_pair(finalDistance, std::make_pair(closestPointOnLine, closestPointOnCircle));\n        }\n\n    public:\n        static std::shared_ptr&lt;GOCircle&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOCircle&gt;&gt; GetAll();\n\n        inline glm::vec3 GetNormal() const { return m_Normal; }\n        inline GOPoint GetCenter() const { return m_Center; }\n        inline float GetRadius() const { return m_Radius; }\n        inline glm::vec4 GetEdgeColor() const { return m_EdgeColor; }\n\n        inline void SetNormal(glm::vec3 normal) { m_Normal = normal; InitGLObject(); }\n        inline void SetCenter(GOPoint center) { m_Center = center; InitGLObject(); }\n        inline void SetRadius(float radius) { m_Radius = radius; InitGLObject(); }\n        inline void SetEdgeColor(glm::vec4 edgeColor) { m_EdgeColor = edgeColor; InitGLObject(); }\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            m_Center.Transform(transformMat);\n            m_Normal = glm::normalize(glm::vec3(transformMat * glm::vec4(m_Normal, 0.0f)));\n            InitGLObject();\n        }\n\n        inline void SetValueFrom(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO) /* override */ {\n            auto ptrCircle = std::dynamic_pointer_cast&lt;GOCircle&gt;(ptrGO);\n            if (ptrCircle)\n            {\n                SetCenter(ptrCircle-&gt;GetCenter());\n                SetNormal(ptrCircle-&gt;GetNormal());\n                SetRadius(ptrCircle-&gt;GetRadius());\n                SetEdgeColor(ptrCircle-&gt;GetEdgeColor());\n                InitGLObject();\n                return;\n            }\n            AIAC_ERROR(\"Cannot set value from different type of primitive; The type is {}\", ptrGO-&gt;GetType());\n        }\n\n        void InitGLObject();\n\n    private:\n        GOPoint m_Center;\n        glm::vec3 m_Normal = glm::vec3(0, 0, 1);\n        glm::vec4 m_EdgeColor = glm::vec4(1, 0, 0, 1);\n        float m_Radius;\n\n    friend class GOPoint;\n    };\n\n    class GOCylinder : public GOPrimitive\n    {\n    private:\n        GOCylinder(GOPoint p1, GOPoint p2, float radius);\n\n    public:\n        static std::shared_ptr&lt;GOCylinder&gt; Add(GOPoint p1, GOPoint p2, float radius);\n\n        virtual ~GOCylinder() = default;\n\n        static std::shared_ptr&lt;GOCylinder&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOCylinder&gt;&gt; GetAll();\n\n        GOPoint GetPStart() const { return m_PStart; }\n        GOPoint GetPEnd() const { return m_PEnd; }\n        float GetRadius() const { return m_Radius; }\n        glm::vec4 GetEdgeColor() const { return m_EdgeColor; }\n\n        void SetPStart(GOPoint pStart) { m_PStart = pStart; InitGLObject(); }\n        void SetPEnd(GOPoint pEnd) { m_PEnd = pEnd; InitGLObject(); }\n        void SetRadius(float radius) { m_Radius = radius; InitGLObject(); }\n        void SetEdgeColor(glm::vec4 edgeColor) { m_EdgeColor = edgeColor; InitGLObject(); }\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            m_PStart.Transform(transformMat);\n            m_PEnd.Transform(transformMat);\n            InitGLObject();\n        }\n\n        inline void SetValueFrom(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO) /* override */ {\n            auto ptrCylinder = std::dynamic_pointer_cast&lt;GOCylinder&gt;(ptrGO);\n            if (ptrCylinder)\n            {\n                SetPStart(ptrCylinder-&gt;GetPStart());\n                SetPEnd(ptrCylinder-&gt;GetPEnd());\n                SetRadius(ptrCylinder-&gt;GetRadius());\n                SetEdgeColor(ptrCylinder-&gt;GetEdgeColor());\n                InitGLObject();\n                return;\n            }\n            AIAC_ERROR(\"Cannot set value from different type of primitive; The type is {}\", ptrGO-&gt;GetType());\n        }\n        void InitGLObject();\n\n    private:\n        GOPoint m_PStart;\n        GOPoint m_PEnd;\n        float m_Radius;\n        glm::vec4 m_EdgeColor = glm::vec4(0, 1, 1, 1);\n\n    friend class GOPoint;\n    };\n\n    // FIXME: the polyline  is not renderered\n    class GOPolyline : public GOPrimitive\n    {\n    private:\n        GOPolyline();\n        GOPolyline(std::vector&lt;GOPoint&gt; points, bool isClosed = false, float weight = GOWeight::Default);\n\n    public:\n        static std::shared_ptr&lt;GOPolyline&gt; Add();\n        static std::shared_ptr&lt;GOPolyline&gt; Add(std::vector&lt;GOPoint&gt; points, bool isClosed = false, float weight = GOWeight::Default);\n        static std::shared_ptr&lt;GOPolyline&gt; Add(std::vector&lt;glm::vec3&gt; points, bool isClosed = false, float weight = GOWeight::Default);\n\n        virtual ~GOPolyline() = default;\n\n        static std::shared_ptr&lt;GOPolyline&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOPolyline&gt;&gt; GetAll();\n\n        inline const std::vector&lt;GOPoint&gt; &amp;GetPoints() const { return m_Points; }\n        inline void SetPoints(std::vector&lt;glm::vec3&gt; points) {\n            m_Points.clear();\n            for (auto&amp; point : points) {\n                m_Points.push_back(GOPoint(point));\n            }\n            InitGLObject();\n        }\n        inline void SetPoints(std::vector&lt;GOPoint&gt; points) { m_Points = points; InitGLObject(); }\n\n        inline void SetClosed(bool isClosed) { m_IsClosed = isClosed; InitGLObject(); }\n        inline bool IsClosed() const { return m_IsClosed; }\n\n        inline void SetWeight(float weight) { m_Weight = weight; InitGLObject(); }\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            for (auto&amp; point : m_Points) {\n                point.Transform(transformMat);\n            }\n            InitGLObject();\n        }\n\n        GOPrimitive operator* (const glm::mat4x4&amp; transformMat)\n        {\n            GOPolyline polyline = *this;\n            polyline.Transform(transformMat);\n            return polyline;\n        }\n        void InitGLObject();\n\n    private:\n        std::vector&lt;GOPoint&gt; m_Points;\n        bool m_IsClosed = true;\n        float m_Weight = GOWeight::Default;\n\n    friend class GOPoint;\n    };\n\n    class GOTriangle : public GOPrimitive\n    {\n    private:\n        GOTriangle(GOPoint p1, GOPoint p2, GOPoint p3);\n\n    public:\n        static std::shared_ptr&lt;GOTriangle&gt; Add(GOPoint p1, GOPoint p2, GOPoint p3);\n\n        virtual ~GOTriangle() = default;\n\n        static std::shared_ptr&lt;GOTriangle&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOTriangle&gt;&gt; GetAll();\n\n        const std::vector&lt;glm::vec3&gt; GetVertices() const {\n            return std::vector&lt;glm::vec3&gt;{m_P1.GetPosition(), m_P2.GetPosition(), m_P3.GetPosition()};\n        }\n\n        inline void SetWeight(float weight) { m_Weight = weight; InitGLObject(); }\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            m_P1.Transform(transformMat);\n            m_P2.Transform(transformMat);\n            m_P3.Transform(transformMat);\n            InitGLObject();\n        }\n\n        GOPrimitive operator* (const glm::mat4x4&amp; transformMat)\n        {\n            GOTriangle triangle = *this;\n            triangle.Transform(transformMat);\n            return triangle;\n        }\n\n        void InitGLObject();\n\n    private:\n        GOPoint m_P1;\n        GOPoint m_P2;\n        GOPoint m_P3;\n        float m_Weight = GOWeight::Default;\n\n    friend class GOPoint;\n    };\n\n    class GOMesh : public GOPrimitive\n    {\n    private:\n        GOMesh();\n        GOMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;uint32_t&gt; indices,\n               std::vector&lt;glm::vec3&gt; normals = std::vector&lt;glm::vec3&gt;(),\n               std::vector&lt;glm::vec4&gt; colors = std::vector&lt;glm::vec4&gt;());\n\n    public:\n        static std::shared_ptr&lt;GOMesh&gt; Add();\n\n        static std::shared_ptr&lt;GOMesh&gt; Add(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;uint32_t&gt; indices);\n\n        static std::shared_ptr&lt;GOMesh&gt; LoadPly(std::string);\n\n        virtual ~GOMesh() = default;\n\n        static std::shared_ptr&lt;GOMesh&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOMesh&gt;&gt; GetAll();\n\n        const std::vector&lt;glm::vec3&gt; GetVertices() const { return m_Vertices; }\n        const std::vector&lt;uint32_t&gt; GetIndices() const { return m_Indices; }\n        const std::vector&lt;glm::vec3&gt; GetNormals() const { return m_Normals; }\n        const std::vector&lt;glm::vec4&gt; GetColors() const { return m_Colors; }\n\n        void SetColors(std::vector&lt;glm::vec4&gt; colors) {\n            m_IsUsingUniformColor = false;\n            m_Colors = colors;\n            InitGLObject();\n        }\n        void SetColor(glm::vec4 color) {\n            m_IsUsingUniformColor = true;\n            m_UniformColor = color;\n            m_Colors = std::vector&lt;glm::vec4&gt;(m_Vertices.size(), m_UniformColor);\n            InitGLObject();\n        }\n        void SetVertices(std::vector&lt;glm::vec3&gt; vertices) {\n            if(m_IsUsingUniformColor &amp;&amp; m_Vertices.size() != vertices.size()){\n                SetColor(m_UniformColor);\n            }\n            m_Vertices = vertices;\n            if(m_IsUsingUniformColor){\n                SetColor(m_UniformColor);\n            }\n            InitGLObject();\n        }\n        void SetIndices(std::vector&lt;uint32_t&gt; indices) { m_Indices = indices; InitGLObject(); }\n        void SetNormals(std::vector&lt;glm::vec3&gt; normals) { m_Normals = normals; InitGLObject(); }\n\n\n        void InitGLObject();\n\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ {\n            // vertices\n            for (auto&amp; vertex : m_Vertices) {\n                vertex = glm::vec3(transformMat * glm::vec4(vertex, 1.0f));\n            }\n            // normals\n            for (auto&amp; normal : m_Normals) {\n                normal = glm::normalize(glm::vec3(transformMat * glm::vec4(normal, 0.0f)));\n            }\n            InitGLObject();\n        }\n\n        GOPrimitive operator* (const glm::mat4x4&amp; transformMat)\n        {\n            GOMesh mesh = *this;\n            mesh.Transform(transformMat);\n            return mesh;\n        }\n\n\n    private:\n        std::vector&lt;glm::vec3&gt; m_Vertices;\n        std::vector&lt;uint32_t&gt; m_Indices;\n        std::vector&lt;glm::vec3&gt; m_Normals;\n        std::vector&lt;glm::vec4&gt; m_Colors;\n        glm::vec4 m_UniformColor = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);\n\n        bool m_IsUsingUniformColor = true;\n\n    friend class GOPoint;\n    };\n\n    class GOText : public GOPrimitive\n    {\n    private:\n        GOText();\n        GOText(std::string text, GOPoint anchor, double size);\n\n    public:\n        static std::shared_ptr&lt;GOText&gt; Add();\n        static std::shared_ptr&lt;GOText&gt; Add(std::string text, GOPoint anchor, double size = GOTextSize::Default);\n        virtual ~GOText() = default;\n\n        static std::shared_ptr&lt;GOText&gt; Get(const uint32_t&amp; id);\n        static std::vector&lt;std::shared_ptr&lt;GOText&gt;&gt; GetAll();\n\n        inline const std::string GetText() const { return m_Text; }\n        inline const GOPoint GetAnchor() const { return m_Anchor; }\n        inline const double GetTextSize() const { return m_Size; }\n\n        inline void SetText(const std::string text) { m_Text = text; InitGLObject(); }\n        inline void SetAnchor(const GOPoint anchor) { m_Anchor = anchor; InitGLObject(); }\n        inline void SetAnchor(const glm::vec3 anchor) { m_Anchor.SetPosition(anchor); InitGLObject(); }\n        inline void SetTextSize(const double size) { m_Size = size; InitGLObject(); }\n\n        inline void Transform(const glm::mat4x4&amp; transformMat) /* override */ { m_Anchor.Transform(transformMat); }\n\n        inline void SetValueFrom(const std::shared_ptr&lt;GOPrimitive&gt;&amp; ptrGO) /* override */ {\n            auto ptrPoint = std::dynamic_pointer_cast&lt;GOText&gt;(ptrGO);\n            if (ptrPoint != nullptr)\n            {\n                SetText(ptrPoint-&gt;GetText());\n                SetAnchor(ptrPoint-&gt;GetAnchor());\n                SetTextSize(ptrPoint-&gt;GetTextSize());\n                InitGLObject();\n                return;\n            }\n            AIAC_ERROR(\"Cannot set value from different type of primitive; The type is {}\", ptrGO-&gt;GetType());\n        }\n\n        GOPrimitive operator* (const glm::mat4x4&amp; transformMat)\n        {\n            GOText text = *this;\n            text.Transform(transformMat);\n            return text;\n        }\n\n    private:\n        GOPoint m_Anchor;\n        std::string m_Text;\n        double m_Size;\n\n    friend class GOPoint;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/GORegistry_8h/","title":"File GORegistry.h","text":"<p>FileList &gt; AIAC &gt; GOSys &gt; GORegistry.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> </ul>"},{"location":"acdoxygen/GORegistry_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/GORegistry_8h/#classes","title":"Classes","text":"Type Name class GORegistry <p>The documentation for this class was generated from the following file <code>src/AIAC/GOSys/GORegistry.h</code></p>"},{"location":"acdoxygen/GORegistry_8h_source/","title":"File GORegistry.h","text":"<p>File List &gt; AIAC &gt; GOSys &gt; GORegistry.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/Log.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n\n\nnamespace AIAC\n{\n    class GORegistry\n    {\n    public:\n        GORegistry() = default;\n        ~GORegistry() = default;\n\n        void Init()\n        {\n            Clear();\n        }\n\n        template&lt;typename T&gt;\n        void Register(std::shared_ptr&lt;T&gt; go)\n        {\n            static_assert(std::is_base_of&lt;AIAC::GOPrimitive, T&gt;::value, \"Pushed type is not subclass of GOPrimitive!\");\n            m_GOMap.emplace(go-&gt;GetId(), go);\n        }\n\n        template&lt;typename T&gt;\n        void Register(const uint32_t&amp; id, std::shared_ptr&lt;T&gt; go)\n        {\n            static_assert(std::is_base_of&lt;AIAC::GOPrimitive, T&gt;::value, \"Pushed type is not subclass of GOPrimitive!\");\n            m_GOMap.emplace(id, go);\n        }\n\n        inline void Unregister(const uint32_t&amp; id)\n        {\n            m_GOMap.erase(id);\n        }\n\n        template&lt;typename T&gt;\n        std::shared_ptr&lt;T&gt; GetGO(const uint32_t&amp; id)\n        {\n            static_assert(std::is_base_of&lt;AIAC::GOPrimitive, T&gt;::value, \"Type to get is not subclass of GOPrimitive!\");\n            auto it = m_GOMap[id];\n            // check if the static pointer cast succeed\n            if (it != nullptr)\n            {\n                try\n                {\n                    return std::dynamic_pointer_cast&lt;T&gt;(it);\n                }\n                catch (const std::bad_cast&amp; e)\n                {\n                    AIAC_ERROR(\"Bad cast exception: {}\", e.what());\n                    return nullptr;\n                }\n            }\n            else { AIAC_ERROR(\"Could not get GO with id: {}\", id); return nullptr; }\n        }\n\n        void GetAllGOs(std::vector&lt;std::shared_ptr&lt;GOPoint&gt;&gt;&amp; points,\n                        std::vector&lt;std::shared_ptr&lt;GOLine&gt;&gt;&amp; lines,\n                        std::vector&lt;std::shared_ptr&lt;GOCircle&gt;&gt;&amp; circles,\n                        std::vector&lt;std::shared_ptr&lt;GOCylinder&gt;&gt;&amp; cylinders,\n                        std::vector&lt;std::shared_ptr&lt;GOPolyline&gt;&gt;&amp; polylines,\n                        std::vector&lt;std::shared_ptr&lt;GOTriangle&gt;&gt;&amp; triangles,\n                        std::vector&lt;std::shared_ptr&lt;GOMesh&gt;&gt;&amp; meshes,\n                        std::vector&lt;std::shared_ptr&lt;GOText&gt;&gt;&amp; texts)\n        {\n            try\n            {\n                for (auto&amp; go : m_GOMap)\n                {\n                    if (go.second-&gt;GetType() == GOTypeFlags::_GOPoint)\n                    {\n                        points.push_back(std::dynamic_pointer_cast&lt;GOPoint&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOLine)\n                    {\n                        lines.push_back(std::dynamic_pointer_cast&lt;GOLine&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOCircle)\n                    {\n                        circles.push_back(std::dynamic_pointer_cast&lt;GOCircle&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOCylinder)\n                    {\n                        cylinders.push_back(std::dynamic_pointer_cast&lt;GOCylinder&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOPolyline)\n                    {\n                        polylines.push_back(std::dynamic_pointer_cast&lt;GOPolyline&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOTriangle)\n                    {\n                        triangles.push_back(std::dynamic_pointer_cast&lt;GOTriangle&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOMesh)\n                    {\n                        meshes.push_back(std::dynamic_pointer_cast&lt;GOMesh&gt;(go.second));\n                    }\n                    else if (go.second-&gt;GetType() == GOTypeFlags::_GOText)\n                    {\n                        texts.push_back(std::dynamic_pointer_cast&lt;GOText&gt;(go.second));\n                    }\n                }\n            }\n            catch (const std::bad_cast&amp; e) { AIAC_ERROR(\"Bad cast exception: {}\", e.what()); }\n        }\n\n        template&lt;typename T&gt;\n        std::vector&lt;std::shared_ptr&lt;T&gt;&gt; GetAllGOs()\n        {\n            static_assert(std::is_base_of&lt;AIAC::GOPrimitive, T&gt;::value, \"Type to get is not subclass of GOPrimitive!\");\n            std::vector&lt;std::shared_ptr&lt;T&gt;&gt; goVector;\n            for (auto&amp; go : m_GOMap)\n            {\n                if (go.second-&gt;GetType() == GOTypeFlags::_GOPoint)\n                {\n                    goVector.push_back(std::dynamic_pointer_cast&lt;T&gt;(go.second));\n                }\n            }\n            return goVector;\n        }\n\n        void GetAllGOs(std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt;&amp; goVector)\n        {\n            try\n            {\n                for (auto&amp; go : m_GOMap)\n                {\n                    goVector.push_back(go.second);\n                }\n            }\n            catch (const std::bad_cast&amp; e) { AIAC_ERROR(\"Bad cast exception: {}\", e.what()); }\n        }\n\n        inline void Clear() { m_GOMap.clear(); }\n\n        inline uint32_t CheckIfKeyExists(uint32_t key) { return m_GOMap.count(key); }\n\n        inline uint32_t Count() const { return m_GOMap.size(); }\n\n    private:\n        inline static std::map&lt;uint32_t, std::shared_ptr&lt;GOPrimitive&gt;&gt; m_GOMap;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/dir_4231f99b70cbd7a69a19f070b3954fcb/","title":"Dir src/AIAC/Render","text":"<p>FileList &gt; AIAC &gt; Render</p>"},{"location":"acdoxygen/dir_4231f99b70cbd7a69a19f070b3954fcb/#files","title":"Files","text":"Type Name file GLObject.cpp file GLObject.h file GlUtils.cpp file GlUtils.h file RenderAPI.cpp file RenderAPI.h file Renderer.cpp file Renderer.h file Shader.cpp file Shader.hpp file TextRenderer.cpp file TextRenderer.h file Viewport.cpp file Viewport.h <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/</code></p>"},{"location":"acdoxygen/GLObject_8cpp/","title":"File GLObject.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; GLObject.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GLObject.h\"</code></li> </ul>"},{"location":"acdoxygen/GLObject_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/GLObject_8cpp/#classes","title":"Classes","text":"Type Name struct CylinderPole <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.cpp</code></p>"},{"location":"acdoxygen/GLObject_8cpp_source/","title":"File GLObject.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; GLObject.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"GLObject.h\"\nnamespace AIAC\n{\n    static const float WEIGHT_TO_CYLINDER_RADIUS_RATE = 1.0f / 64.0f;\n    // GLObject\n    void GLObject::BindVBOs(){\n#ifndef HEADLESS_TEST\n        glBindBuffer(GL_ARRAY_BUFFER, vertexBuf);\n        glEnableVertexAttribArray(0);\n        glVertexAttribPointer(\n                0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.\n                3,                  // size\n                GL_FLOAT,           // type\n                GL_FALSE,           // normalized?\n                0,                  // stride\n                (GLvoid *) 0        // array buffer offset\n        );\n\n        glBindBuffer(GL_ARRAY_BUFFER, colorBuf);\n        glEnableVertexAttribArray(1);\n        glVertexAttribPointer(\n                1,                  // attribute 1. No particular reason for 0, but must match the layout in the shader.\n                4,                  // size\n                GL_FLOAT,           // type\n                GL_FALSE,           // normalized?\n                0,                  // stride\n                (GLvoid *) 0        // array buffer offset\n        );\n#endif\n    }\n\n    void GLObject::BufferData(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors) {\n#ifndef HEADLESS_TEST\n        glGenBuffers(1, &amp;this-&gt;vertexBuf);\n        glBindBuffer(GL_ARRAY_BUFFER, this-&gt;vertexBuf);\n        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices) * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);\n\n        glGenBuffers(1, &amp;this-&gt;colorBuf);\n        glBindBuffer(GL_ARRAY_BUFFER, this-&gt;colorBuf);\n        glBufferData(GL_ARRAY_BUFFER, sizeof(colors) * sizeof(glm::vec4), &amp;colors[0], GL_STATIC_DRAW);\n#endif\n    }\n\n    void GLObject::DeleteVBOs() {\n#ifndef HEADLESS_TEST\n        glDeleteBuffers(1, &amp;vertexBuf);\n        glDeleteBuffers(1, &amp;colorBuf);\n#endif\n    }\n\n    // ----------------- //\n    //   GLPointObject   //\n    // ----------------- //\n    GLPointObject::GLPointObject(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize) {\n        this-&gt;type = GLObjectType::POINTS;\n        this-&gt;size = int(vertices.size());\n        this-&gt;pointSize = pointSize;\n\n        GLObject::BufferData(vertices, colors);\n    }\n\n    void GLPointObject::Draw()\n    {\n        BindVBOs();\n        GLfloat prevPointSize;\n        glGetFloatv(GL_POINT_SIZE, &amp;prevPointSize);\n        glPointSize(this-&gt;pointSize);\n        glDrawArrays(GL_POINTS, 0, this-&gt;size);\n        glPointSize(prevPointSize);\n    }\n\n    // ----------------- //\n    //   GLLineObject   //\n    // ----------------- //\n    GLLineObject::GLLineObject(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat lineWidth) {\n        this-&gt;type = GLObjectType::LINES;\n        this-&gt;size = vertices.size();\n        this-&gt;lineWidth = lineWidth;\n\n        GLObject::BufferData(vertices, colors);\n    }\n\n    void GLLineObject::Draw()\n    {\n        BindVBOs();\n        GLfloat prevLineWidth;\n        glGetFloatv(GL_LINE_WIDTH, &amp;prevLineWidth);\n        glLineWidth(lineWidth);\n        glDrawArrays(GL_LINES, 0, size);\n        glLineWidth(prevLineWidth);\n    }\n\n    // -------------------- //\n    //     GLMeshObject     //\n    // -------------------- //\n    GLMeshObject::GLMeshObject(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, const std::vector&lt;uint32_t&gt; &amp;indices) {\n        this-&gt;type = GLObjectType::TRIANGLES;\n        this-&gt;size = indices.size();\n\n        this-&gt;m_Indices = indices;\n        this-&gt;m_Vertices = vertices;\n        this-&gt;m_Colors = colors;\n\n#ifndef HEADLESS_TEST\n        glGenBuffers(1, &amp;this-&gt;indexBuf);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this-&gt;indexBuf);\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(uint32_t), &amp;indices[0], GL_STATIC_DRAW);\n        GLObject::BufferData(vertices, colors);\n#endif\n    }\n\n    void GLMeshObject::Draw()\n    {\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this-&gt;indexBuf);\n\n        BindVBOs();\n        glDrawElements(GL_TRIANGLES, this-&gt;m_Indices.size(), GL_UNSIGNED_INT, nullptr);\n    }\n\n    // ---------------------- //\n    //   Auxilary functions   //\n    // ---------------------- //\n    struct CylinderPole {\n        GLfloat x, z;\n    };\n\n    int GetSectorNum(float radius)\n    {\n        // TODO: there is a bug if sector number &gt; 8, now we just set it to 8\n        // if(radius &lt;= 3){\n        //     return 8;\n        // }\n        // if(radius &lt;= 12){\n        //     return 16;\n        // }\n        // if(radius &lt;= 24){\n        //     return 24;\n        // }\n        return 8;\n    }\n\n    glm::vec3 GetTransformed(glm::mat4 transformMat, float x, float y, float z)\n    {\n        glm::vec4 point(x, y, z, 1);\n        point = transformMat * point;\n        return {point.x, point.y, point.z};\n    }\n\n    std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt; CreateCylinder(const glm::vec3 &amp;baseCenter, const glm::vec3 &amp;topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum){\n        // if(sectorNum == -1){\n        sectorNum = GetSectorNum(radius);\n        // }\n        std::vector&lt;CylinderPole&gt; cylinderPoles; // vector of structs\n\n        glm::vec3 x1 = baseCenter, x2 = topCenter;\n        glm::vec3 norm = glm::normalize(x2 - x1);\n        GLfloat h = glm::length(x2 - x1);\n\n        glm::vec3 newX = glm::normalize(glm::cross(norm, glm::vec3(0, 1, 0)));\n        glm::vec3 newZ = glm::normalize(glm::cross(newX, norm));\n\n        glm::mat4 transformMat;\n\n        transformMat[0] = glm::vec4(newX, 0);\n        transformMat[1] = glm::vec4(norm, 0);\n        transformMat[2] = glm::vec4(newZ, 0);\n        transformMat[3] = glm::vec4(x1, 1);\n\n        for (int i = 0; i &lt; sectorNum; ++i){\n            GLfloat u = (GLfloat)i / (GLfloat)sectorNum;\n            CylinderPole cp{\n                    .x = static_cast&lt;GLfloat&gt;(radius * cos(2 * M_PI * u)),\n                    .z = static_cast&lt;GLfloat&gt;(radius * sin(2 * M_PI * u)),\n            };\n            cylinderPoles.push_back(cp);\n        }\n\n        std::vector&lt;uint32_t&gt; flattenedIndices;\n        std::vector&lt;glm::vec3&gt; indices;\n        std::vector&lt;glm::vec3&gt; vertices;\n        std::vector&lt;glm::vec3&gt; capContourTop, capContourBase;\n\n        vertices.emplace_back(x1); // 0\n        vertices.emplace_back(x2); // 1\n\n        vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, 0, cylinderPoles[0].z)); // 2\n        vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, h, cylinderPoles[0].z)); // 3\n\n        capContourBase.push_back(GetTransformed(transformMat, cylinderPoles[0].x, 0, cylinderPoles[0].z));\n        capContourTop.push_back(GetTransformed(transformMat, cylinderPoles[0].x, h, cylinderPoles[0].z));\n\n        int baseCenterIdx = 0;\n        int topCenterIdx = 1;\n        int prevBaseVertexIdx = 2;\n        int prevTopVertexIdx = 3;\n        int curBaseVertexIdx = 4;\n        int curTopVertexIdx = 5;\n\n        for(int i = 1; i &lt; sectorNum; i++){\n            capContourBase.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, 0, cylinderPoles[i].z));\n            capContourBase.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, 0, cylinderPoles[i].z));\n            capContourTop.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, h, cylinderPoles[i].z));\n            capContourTop.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, h, cylinderPoles[i].z));\n\n            vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, 0, cylinderPoles[i].z));\n            vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, h, cylinderPoles[i].z));\n\n            indices.emplace_back(curBaseVertexIdx ,baseCenterIdx   , prevBaseVertexIdx);\n            indices.emplace_back(prevTopVertexIdx ,topCenterIdx    , curTopVertexIdx  );\n            indices.emplace_back(curBaseVertexIdx ,curTopVertexIdx , prevTopVertexIdx );\n            indices.emplace_back(prevBaseVertexIdx,curBaseVertexIdx, prevTopVertexIdx );\n\n            prevBaseVertexIdx = curBaseVertexIdx;\n            prevTopVertexIdx = curTopVertexIdx;\n            curBaseVertexIdx += 2;\n            curTopVertexIdx += 2;\n        }\n\n        // Last one\n        curBaseVertexIdx = 2;\n        curTopVertexIdx = 3;\n        indices.emplace_back(curBaseVertexIdx ,baseCenterIdx   , prevBaseVertexIdx);\n        indices.emplace_back(prevTopVertexIdx ,topCenterIdx    , curTopVertexIdx  );\n        indices.emplace_back(curBaseVertexIdx ,curTopVertexIdx , prevTopVertexIdx );\n        indices.emplace_back(prevBaseVertexIdx,curBaseVertexIdx, prevTopVertexIdx );\n\n        capContourBase.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, 0, cylinderPoles[0].z));\n        capContourTop.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, h, cylinderPoles[0].z));\n\n\n        int counter = 0;\n        for(auto vid: indices){\n            flattenedIndices.push_back((uint)vid.x);\n            flattenedIndices.push_back((uint)vid.y);\n            flattenedIndices.push_back((uint)vid.z);\n        }\n\n        std::vector&lt;glm::vec4&gt; cylinderColorVec(vertices.size(), color);\n        std::vector&lt;glm::vec4&gt; edgeColorVec(vertices.size(), edgeColor);\n\n        std::vector&lt;std::shared_ptr&lt;GLObject&gt;&gt; glObjs;\n\n        glObjs.push_back(std::make_shared&lt;GLMeshObject&gt;(vertices, cylinderColorVec, flattenedIndices));\n        glObjs.push_back(std::make_shared&lt;GLLineObject&gt;(capContourBase, edgeColorVec, 1.0f));\n        glObjs.push_back(std::make_shared&lt;GLLineObject&gt;(capContourTop, edgeColorVec, 1.0f));\n\n        return glObjs;\n    }\n\n    std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt; CreateCircle(glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum){\n        if(sectorNum == -1){\n            sectorNum = GetSectorNum(radius);\n        }\n\n        std::vector&lt;glm::vec3&gt; vertices; // vertices.reserve(sectorNum);\n        std::vector&lt;glm::vec3&gt; edges; // edges.reserve(2 * sectorNum);\n        std::vector&lt;uint32_t&gt; indices; // indices.reserve(3 * sectorNum);\n        vertices.emplace_back(center);\n\n        // Rodrigues' rotation formula ?\n        glm::vec3 newX = glm::normalize(glm::cross(normal, glm::vec3(0, 1, 0)));\n        glm::vec3 newZ = glm::normalize(glm::cross(newX, normal));\n\n        glm::mat4 transformMat;\n\n        transformMat[0] = glm::vec4(newX, 0);\n        transformMat[1] = glm::vec4(normal, 0);\n        transformMat[2] = glm::vec4(newZ, 0);\n        transformMat[3] = glm::vec4(center, 1);\n\n        for (int i = 0; i &lt; sectorNum; ++i){\n            GLfloat u = (GLfloat)i / (GLfloat)sectorNum;\n            glm::vec3 vertex = transformMat * glm::vec4(\n                    static_cast&lt;GLfloat&gt;(radius * cos(2 * M_PI * u)),\n                    0,\n                    static_cast&lt;GLfloat&gt;(radius * sin(2 * M_PI * u)),\n                    1\n            );\n            vertices.emplace_back(vertex);\n        }\n\n        for (int i = 1; i &lt; sectorNum; ++i){\n            indices.emplace_back(0);\n            indices.emplace_back(i);\n            indices.emplace_back(i + 1);\n        }\n        indices.emplace_back(0);\n        indices.emplace_back(sectorNum);\n        indices.emplace_back(1);\n\n\n        for (int i = 1; i &lt; sectorNum; ++i){\n            edges.emplace_back(vertices[i]);\n            edges.emplace_back(vertices[i + 1]);\n        }\n        edges.emplace_back(vertices[sectorNum]);\n        edges.emplace_back(vertices[1]);\n\n        std::vector&lt;glm::vec4&gt; faceColorVec(vertices.size(), color);\n        std::vector&lt;glm::vec4&gt; edgeColorVec(vertices.size(), edgeColor);\n\n        // auto faceObj = std::make_shared&lt;GLMeshObject&gt;(vertices, faceColorVec, indices);\n        auto edgeObj = std::make_shared&lt;GLLineObject&gt;(edges, edgeColorVec, edgeWeight);\n\n        std::vector&lt; std::shared_ptr&lt;GLObject&gt;&gt; glObjs;\n\n        glObjs.push_back(edgeObj);\n\n        return glObjs;\n    }\n\n    std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt; CreatePolyline(std::vector&lt;glm::vec3&gt; vertices, bool isClosed, glm::vec4 color, float lineWidth){\n        // TODO: dealing with lineWidth &gt; 1.0\n        auto glObjs = std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt;();\n        if(vertices.size() &lt; 2){\n            return glObjs;\n        }\n\n        if(lineWidth &lt;= 1.0f){\n            std::vector&lt;glm::vec3&gt; lineObjVertices; lineObjVertices.reserve(vertices.size() * 2);\n            lineObjVertices.emplace_back(vertices[0]);\n            for (int i = 1; i &lt; vertices.size() - 1; i++) {\n                lineObjVertices.emplace_back(vertices[i]);\n                lineObjVertices.emplace_back(vertices[i]);\n            }\n            lineObjVertices.emplace_back(vertices[vertices.size() - 1]);\n            if(isClosed){\n                lineObjVertices.emplace_back(vertices[vertices.size() - 1]);\n                lineObjVertices.emplace_back(vertices[0]);\n            }\n            std::vector&lt;glm::vec4&gt; colors(lineObjVertices.size(), color);\n            glObjs.emplace_back(std::make_shared&lt;GLLineObject&gt;(lineObjVertices, colors, lineWidth));\n        } else {\n            auto radius = WEIGHT_TO_CYLINDER_RADIUS_RATE * lineWidth;\n            for(int i = 1; i &lt; vertices.size(); i++){\n                auto cylinderLine = CreateCylinder(vertices[i - 1], vertices[i], radius, color, color);\n                glObjs.insert(glObjs.end(), cylinderLine.begin(), cylinderLine.end());\n            }\n            if(isClosed){\n                auto cylinderLine = CreateCylinder(vertices[vertices.size() - 1], vertices[0], radius, color, color);\n                glObjs.insert(glObjs.end(), cylinderLine.begin(), cylinderLine.end());\n            }\n        }\n        return glObjs;\n    }\n\n} // namespace AIAC\n</code></pre>"},{"location":"acdoxygen/GLObject_8h/","title":"File GLObject.h","text":"<p>FileList &gt; AIAC &gt; Render &gt; GLObject.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"AIAC/GlHeader.h\"</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> </ul>"},{"location":"acdoxygen/GLObject_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/GLObject_8h/#classes","title":"Classes","text":"Type Name class GLLineObject class GLMeshObject class GLObject class GLPointObject <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GLObject.h</code></p>"},{"location":"acdoxygen/GLObject_8h_source/","title":"File GLObject.h","text":"<p>File List &gt; AIAC &gt; Render &gt; GLObject.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include \"AIAC/GlHeader.h\"\n#include \"glm/glm.hpp\"\n\nnamespace AIAC {\n    enum class GLObjectType {\n        POINTS,\n        LINES,\n        TRIANGLES\n    };\n\n    class GLObject {\n    public:\n        GLObjectType type;\n        GLuint vertexBuf;\n        GLuint colorBuf;\n        GLsizei size; // how many objects to Draw (for glDrawArrays)\n\n        GLObject() = default;\n        ~GLObject() {};\n\n        // copy constructor\n        GLObject(const GLObject &amp;other) {\n            type = other.type;\n            vertexBuf = other.vertexBuf;\n            colorBuf = other.colorBuf;\n            size = other.size;\n        }\n\n        GLObject&amp; operator=(const GLObject &amp;other) {\n            type = other.type;\n            vertexBuf = other.vertexBuf;\n            colorBuf = other.colorBuf;\n            size = other.size;\n            return *this;\n        }\n\n        virtual void Draw() = 0;\n\n        // must be called if data is already buffered\n        // I didn't do this inside deconstructor because there might be multiple &lt;GLObject&gt; instances holding the same VBOs\n        // For example, when operator= or copy operator is called, it shouldn't do this delete\n        void DeleteVBOs();\n\n    protected:\n        void BindVBOs();\n        void BufferData(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors);\n    };\n\n    // ----------------- //\n    //   GLPointObject   //\n    // ----------------- //\n    class GLPointObject : public GLObject {\n    public:\n        GLPointObject() { type = GLObjectType::POINTS; }\n\n        GLPointObject(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize = 1.0f);\n\n        // copy constructor\n        GLPointObject(const GLPointObject &amp;other) : GLObject(other) {\n            pointSize = other.pointSize;\n        }\n\n        GLPointObject&amp; operator=(const GLPointObject &amp;other) {\n            GLObject::operator=(other);\n            pointSize = other.pointSize;\n            return *this;\n        }\n\n        virtual void Draw();\n\n    public:\n        GLfloat pointSize;\n    };\n\n    // ----------------- //\n    //   GLLineObject   //\n    // ----------------- //\n    class GLLineObject : public GLObject {\n    public:\n        GLLineObject() { type = GLObjectType::LINES; }\n\n        GLLineObject(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat lineWidth = 1.0f);\n\n        // copy constructor\n        GLLineObject(const GLLineObject &amp;other) : GLObject(other) {\n            lineWidth = other.lineWidth;\n        }\n\n        GLLineObject&amp; operator=(const GLLineObject &amp;other) {\n            GLObject::operator=(other);\n            lineWidth = other.lineWidth;\n            return *this;\n        }\n\n        virtual void Draw();\n\n    public:\n        GLfloat lineWidth;\n    };\n\n    // -------------------- //\n    //   GLMeshObject   //\n    // -------------------- //\n    class GLMeshObject : public GLObject {\n    public:\n        GLMeshObject() { type = GLObjectType::TRIANGLES; }\n\n        GLMeshObject(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, const std::vector&lt;uint32_t&gt; &amp;indices);\n\n        // copy constructor\n        GLMeshObject(const GLMeshObject &amp;other) : GLObject(other) {\n            indexBuf = other.indexBuf;\n            m_Vertices = other.m_Vertices;\n            m_Colors = other.m_Colors;\n            m_Indices = other.m_Indices;\n        }\n\n        GLMeshObject&amp; operator=(const GLMeshObject &amp;other) {\n            GLObject::operator=(other);\n            indexBuf = other.indexBuf;\n            m_Vertices = other.m_Vertices;\n            m_Colors = other.m_Colors;\n            m_Indices = other.m_Indices;\n            return *this;\n        }\n\n        virtual void Draw();\n\n    public:\n        GLuint indexBuf;\n        std::vector&lt;glm::vec3&gt; m_Vertices;\n        std::vector&lt;glm::vec4&gt; m_Colors;\n        std::vector&lt;uint32_t&gt; m_Indices;\n    };\n\n    // --------------------- //\n    //   Auxilary function   //\n    // --------------------- //\n    glm::vec3 GetTransformed(glm::mat4 transformMat, float x, float y, float z);\n\n    std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt; CreateCylinder(const glm::vec3 &amp;baseCenter, const glm::vec3 &amp;topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum=-1);\n    std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt; CreateCircle(glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum = -1);\n    std::vector&lt; std::shared_ptr&lt;GLObject&gt; &gt; CreatePolyline(std::vector&lt;glm::vec3&gt; vertices, bool isClosed, glm::vec4 color, float lineWidth);\n}\n</code></pre>"},{"location":"acdoxygen/GlUtils_8cpp/","title":"File GlUtils.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; GlUtils.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"GlUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/GlUtils_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GlUtils.cpp</code></p>"},{"location":"acdoxygen/GlUtils_8cpp_source/","title":"File GlUtils.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; GlUtils.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"aiacpch.h\"\n#include \"GlUtils.h\"\n\nnamespace AIAC {\n    void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize) {\n        // GLuint vbo;\n        // glGenBuffers(1, &amp;vbo);\n        // glBindBuffer(GL_ARRAY_BUFFER, vbo);\n        // glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_DYNAMIC_DRAW);\n        // glEnableVertexAttribArray(0);\n        // glVertexAttribPointer(\n        //         0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.\n        //         3,                  // size\n        //         GL_FLOAT,           // type\n        //         GL_FALSE,           // normalized?\n        //         0,                  // stride\n        //         (void *) nullptr     // array buffer offset\n        // );\n\n        // GLuint colorBuffer;\n        // glGenBuffers(1, &amp;colorBuffer);\n        // glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n        // glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(glm::vec4), &amp;colors[0], GL_DYNAMIC_DRAW);\n        // glEnableVertexAttribArray(1);\n        // glVertexAttribPointer(\n        //         1,                  // attribute 1. No particular reason for 0, but must match the layout in the shader.\n        //         4,                  // size\n        //         GL_FLOAT,           // type\n        //         GL_FALSE,           // normalized?\n        //         0,                  // stride\n        //         (void *) nullptr     // array buffer offset\n        // );\n\n        // GLfloat prevPointSize;\n        // glGetFloatv(GL_POINT_SIZE, &amp;prevPointSize);\n        // glPointSize(pointSize);\n\n        // glDrawArrays(GL_POINTS, 0, (GLsizei) vertices.size());\n\n        // glPointSize(prevPointSize);\n        // // glDisableVertexAttribArray(0);\n        // // glDisableVertexAttribArray(1);\n        // // glDeleteBuffers(1, &amp;vbo);\n        // // glDeleteBuffers(1, &amp;colorBuffer);\n    }\n\n    void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const glm::vec4 &amp;color, GLfloat pointSize) {\n        std::vector&lt;glm::vec4&gt; colors(vertices.size(), color);\n        glDrawPoints3d(vertices, std::move(colors), pointSize);\n    }\n\n    void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const std::vector&lt;glm::vec4&gt; &amp;colors) {\n        GLuint vbo;\n        glGenBuffers(1, &amp;vbo);\n\n        // show current vao\n        // GLint vao;\n        // glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &amp;vao);\n        // cout &lt;&lt; \"vbo: \" &lt;&lt; vbo &lt;&lt; \" vao: \" &lt;&lt; vao &lt;&lt; endl;\n        glBindBuffer(GL_ARRAY_BUFFER, vbo);\n        glBufferData(GL_ARRAY_BUFFER, edges.size() * sizeof(glm::vec3), &amp;edges[0], GL_DYNAMIC_DRAW);\n        glEnableVertexAttribArray(0);\n        glVertexAttribPointer(\n                0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.\n                3,                  // size\n                GL_FLOAT,           // type\n                GL_FALSE,           // normalized?\n                0,                  // stride\n                (void *) nullptr     // array buffer offset\n        );\n\n        GLuint colorBuffer;\n        glGenBuffers(1, &amp;colorBuffer);\n        glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n        glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(glm::vec4), &amp;colors[0], GL_DYNAMIC_DRAW);\n        glEnableVertexAttribArray(1);\n        glVertexAttribPointer(\n                1,                  // attribute 1. No particular reason for 0, but must match the layout in the shader.\n                4,                  // size\n                GL_FLOAT,           // type\n                GL_FALSE,           // normalized?\n                0,                  // stride\n                (void *) nullptr     // array buffer offset\n        );\n\n        glDrawArrays(GL_LINES, 0, (GLsizei) edges.size());\n\n        glDisableVertexAttribArray(0);\n        glDisableVertexAttribArray(1);\n        glDeleteBuffers(1, &amp;vbo);\n        glDeleteBuffers(1, &amp;colorBuffer);\n    }\n\n    void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const glm::vec4 &amp;color) {\n        std::vector&lt;glm::vec4&gt; colors(edges.size(), color);\n        glDrawLines3d(edges, colors);\n    }\n\n    void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const std::vector&lt;glm::vec4&gt; &amp;colors){\n        GLuint elementBuffer;\n        glGenBuffers(1, &amp;elementBuffer);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(uint32_t), &amp;indices[0], GL_DYNAMIC_DRAW);\n\n        // Index buffer\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);\n        int size;  glGetBufferParameteriv(GL_ELEMENT_ARRAY_BUFFER, GL_BUFFER_SIZE, &amp;size);\n\n        GLuint vbo;\n        glGenBuffers(1, &amp;vbo);\n        glBindBuffer(GL_ARRAY_BUFFER, vbo);\n        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_DYNAMIC_DRAW);\n        glEnableVertexAttribArray(0);\n        glVertexAttribPointer(\n                0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.\n                3,                  // size\n                GL_FLOAT,           // type\n                GL_FALSE,           // normalized?\n                0,                  // stride\n                (void *) nullptr     // array buffer offset\n        );\n\n        GLuint colorBuffer;\n        glGenBuffers(1, &amp;colorBuffer);\n        glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);\n        glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(glm::vec4), &amp;colors[0], GL_DYNAMIC_DRAW);\n        glEnableVertexAttribArray(1);\n        glVertexAttribPointer(\n                1,                  // attribute 1. No particular reason for 0, but must match the layout in the shader.\n                4,                  // size\n                GL_FLOAT,           // type\n                GL_FALSE,           // normalized?\n                0,                  // stride\n                (void *) nullptr     // array buffer offset\n        );\n\n        glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, nullptr);\n\n        // // glDisableVertexAttribArray(0);\n        // // glDisableVertexAttribArray(1);\n        // // glDeleteBuffers(1, &amp;elementBuffer);\n        // // glDeleteBuffers(1, &amp;vbo);\n        // // glDeleteBuffers(1, &amp;colorBuffer);\n\n    }\n    void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const glm::vec4 &amp;color){\n        std::vector&lt;glm::vec4&gt; colors(vertices.size(), color);\n        glDrawTriangles3d(vertices, indices, colors);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/GlUtils_8h/","title":"File GlUtils.h","text":"<p>FileList &gt; AIAC &gt; Render &gt; GlUtils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GlHeader.h\"</code></li> <li><code>#include \"tslam.h\"</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> </ul>"},{"location":"acdoxygen/GlUtils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/GlUtils.h</code></p>"},{"location":"acdoxygen/GlUtils_8h_source/","title":"File GlUtils.h","text":"<p>File List &gt; AIAC &gt; Render &gt; GlUtils.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"AIAC/GlHeader.h\"\n\n#include \"tslam.h\"\n\n#include \"glm/glm.hpp\"\n\nnamespace AIAC {\n    const static glm::vec4 OGL_BLACK   = glm::vec4(0, 0, 0, 1);\n    const static glm::vec4 OGL_RED     = glm::vec4(1, 0, 0, 1);\n    const static glm::vec4 OGL_GREEN   = glm::vec4(0, 1, 0, 1);\n    const static glm::vec4 OGL_BLUE    = glm::vec4(0, 0, 1, 1);\n    const static glm::vec4 OGL_YELLOW  = glm::vec4(1, 1, 0, 1);\n    const static glm::vec4 OGL_MAGENTA = glm::vec4(1, 0, 1, 1);\n    const static glm::vec4 OGL_CYAN    = glm::vec4(0, 1, 1, 1);\n    const static glm::vec4 OGL_WHITE   = glm::vec4(1, 1, 1, 1);\n\n\n    extern void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;glm::vec4&gt; &amp;colors, GLfloat pointSize=1.0f);\n    extern void glDrawPoints3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const glm::vec4 &amp;color, GLfloat pointSize=1.0f);\n\n    extern void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const std::vector&lt;glm::vec4&gt; &amp;colors);\n    extern void glDrawLines3d(const std::vector&lt;glm::vec3&gt; &amp;edges, const glm::vec4 &amp;color);\n\n    extern void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const std::vector&lt;glm::vec4&gt; &amp;colors);\n    extern void glDrawTriangles3d(const std::vector&lt;glm::vec3&gt; &amp;vertices, const std::vector&lt;uint32_t&gt; &amp;indices, const glm::vec4 &amp;colors);\n\n    extern void DrawSlamMap(const std::shared_ptr&lt;tslam::Map&gt; &amp;map, const glm::vec4 &amp;color, float pointSize=1);\n}\n</code></pre>"},{"location":"acdoxygen/RenderAPI_8cpp/","title":"File RenderAPI.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; RenderAPI.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;ft2build.h&gt;</code></li> <li><code>#include \"GlUtils.h\"</code></li> <li><code>#include \"RenderAPI.h\"</code></li> <li><code>#include \"TextRenderer.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> </ul>"},{"location":"acdoxygen/RenderAPI_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/RenderAPI.cpp</code></p>"},{"location":"acdoxygen/RenderAPI_8cpp_source/","title":"File RenderAPI.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; RenderAPI.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include &lt;ft2build.h&gt;\n#include FT_FREETYPE_H\n\n#include \"GlUtils.h\"\n#include \"RenderAPI.h\"\n#include \"TextRenderer.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Application.h\"\n\nnamespace AIAC\n{\n    void DrawAllGOs(glm::mat4 projection, float textScale)\n    {\n        std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; gos;\n        AIAC_GOREG-&gt;GetAllGOs(gos);\n\n        std::vector&lt;std::shared_ptr&lt;GOPrimitive&gt;&gt; goTexts;\n        for(auto&amp; go: gos){\n            if(!go-&gt;IsVisible()){\n                continue;\n            }\n            if(go-&gt;GetType() == _GOText){\n                if (textScale &gt; 0) goTexts.emplace_back(go);\n            } else{\n                DrawGO(go);\n            }\n        }\n\n        if (textScale &gt; 0) {\n            TextRenderer::SetProjection(projection);\n            for(auto&amp; goText: goTexts){\n                DrawText(*std::dynamic_pointer_cast&lt;GOText&gt;(goText), textScale);\n            }\n        }\n    }\n\n    void DrawGO(const shared_ptr&lt;GOPrimitive&gt;&amp; goPrimitive)\n    {\n        switch (goPrimitive-&gt;GetType()){\n            case _GOPoint:\n            case _GOLine:\n            case _GOCylinder:\n            case _GOCircle:\n            case _GOPolyline:\n            case _GOTriangle:\n            case _GOMesh:\n                goPrimitive-&gt;Draw(); break;\n            case _GOText:\n                DrawText(*std::dynamic_pointer_cast&lt;GOText&gt;(goPrimitive)); break;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    void DrawText(const GOText&amp; goText, float scale, const glm::mat4&amp; projection) {\n        if(projection != glm::mat4(1.0f)){\n            TextRenderer::SetProjection(projection);\n        }\n        TextRenderer::RenderTextIn3DSpace(\n                goText.GetText(),\n                goText.GetAnchor(),\n                goText.GetColor(),\n                goText.GetTextSize() * scale);\n\n    }\n\n    void DrawTexts(const std::vector&lt;std::shared_ptr&lt;GOText&gt;&gt; &amp;goTexts, float scale, const glm::mat4&amp; projection) {\n        if(projection != glm::mat4(1.0f)){\n            TextRenderer::SetProjection(projection);\n        }\n        for (auto &amp;goText: goTexts) {\n            if(!goText-&gt;IsVisible()){\n                continue;\n            }\n            DrawText(*goText, scale, projection);\n        }\n    }\n\n    void DrawSlamMap(const shared_ptr&lt;tslam::Map&gt; &amp;map, const glm::vec4 &amp;color, float pointSize)\n    {\n        std::vector&lt;glm::vec3&gt; markerEdges; markerEdges.reserve(map-&gt;map_markers.size() * 4 * 2);\n        std::vector&lt;glm::vec4&gt; markerEdgeColors; markerEdgeColors.reserve(map-&gt;map_markers.size() * 4 * 2);\n        for(const auto&amp; mapMarker: map-&gt;map_markers){\n            auto points = mapMarker.second.get3DPoints();\n            markerEdges.emplace_back(points[0].x, points[0].y, points[0].z);\n            for(int i = 1 ; i &lt; 4; i++){\n                markerEdges.emplace_back(points[i].x, points[i].y, points[i].z);\n                markerEdges.emplace_back(points[i].x, points[i].y, points[i].z);\n            }\n            markerEdges.emplace_back(points[0].x, points[0].y, points[0].z);\n\n            markerEdgeColors.emplace_back(OGL_RED);\n            markerEdgeColors.emplace_back(OGL_RED);\n            markerEdgeColors.emplace_back(OGL_RED);\n            markerEdgeColors.emplace_back(OGL_RED);\n            markerEdgeColors.emplace_back(OGL_BLUE);\n            markerEdgeColors.emplace_back(OGL_BLUE);\n            markerEdgeColors.emplace_back(OGL_BLUE);\n            markerEdgeColors.emplace_back(OGL_BLUE);\n        }\n        glDrawLines3d(markerEdges, markerEdgeColors);\n    }\n\n    // int getSectorNum(float radius){\n    //     return 8;\n    // }\n\n    // void DrawLine(const glm::vec3 &amp;p1, const glm::vec3 &amp;p2, float weight, const glm::vec4 &amp;color)\n    // {\n    //     if(weight &lt;= 0){\n    //         return;\n    //     }\n    //     if(weight == 1.0f){\n    //         vector&lt;glm::vec3&gt; line;\n    //         line.emplace_back(p1);\n    //         line.emplace_back(p2);\n    //         glDrawLines3d(line, color);\n    //         return;\n    //     }\n    //     float radius = weight * WEIGHT_TO_CYLINDER_RADIUS_RATE;\n    //     DrawCylinder(p1, p2, radius,\n    //                  color, glm::vec4(0,0,0,0), getSectorNum(radius));\n    // }\n\n    // void DrawLines(const vector&lt;glm::vec3&gt; &amp;vertices, float weight, const glm::vec4 &amp;color)\n    // {\n    //     if(weight &lt;= 0){\n    //         return;\n    //     }\n    //     if(weight == 1.0f){\n    //         glDrawLines3d(vertices, color);\n    //         return;\n    //     }\n    //     float radius = weight * WEIGHT_TO_CYLINDER_RADIUS_RATE;\n    //     DrawCylinder(vertices[0], vertices[1], radius,\n    //                  color, glm::vec4(0,0,0,0), getSectorNum(radius));\n    // }\n\n    // void DrawCircle(glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum)\n    // {\n    //     std::vector&lt;glm::vec3&gt; vertices; vertices.reserve(sectorNum + 1);\n    //     std::vector&lt;glm::vec3&gt; edges; edges.reserve(2 * sectorNum);\n    //     std::vector&lt;uint32_t&gt; indices; indices.reserve(3 * sectorNum);\n    //     vertices.emplace_back(center);\n\n    //     glm::vec3 newX = glm::cross(normal, glm::vec3(0, 1, 0));\n    //     glm::vec3 newZ = glm::cross(newX, normal);\n\n    //     glm::mat4 transformMat;\n\n    //     transformMat[0] = glm::vec4(newX, 0);\n    //     transformMat[1] = glm::vec4(normal, 0);\n    //     transformMat[2] = glm::vec4(newZ, 0);\n    //     transformMat[3] = glm::vec4(center, 1);\n\n    //     for (int i = 0; i &lt; sectorNum; ++i){\n    //         GLfloat u = (GLfloat)i / (GLfloat)sectorNum;\n    //         glm::vec3 vertex = transformMat * glm::vec4(\n    //                 static_cast&lt;GLfloat&gt;(radius * cos(2 * M_PI * u)),\n    //                 0,\n    //                 static_cast&lt;GLfloat&gt;(radius * sin(2 * M_PI * u)),\n    //                 1\n    //         );\n    //         vertices.emplace_back(vertex);\n    //     }\n\n    //     for (int i = 1; i &lt; sectorNum; ++i){\n    //         indices.emplace_back(0);\n    //         indices.emplace_back(i);\n    //         indices.emplace_back(i + 1);\n    //     }\n    //     indices.emplace_back(0);\n    //     indices.emplace_back(sectorNum);\n    //     indices.emplace_back(1);\n\n    //     glDrawTriangles3d(vertices, indices, color);\n\n    //     for (int i = 1; i &lt; sectorNum; ++i){\n    //         edges.emplace_back(vertices[i]);\n    //         edges.emplace_back(vertices[i + 1]);\n    //     }\n    //     edges.emplace_back(vertices[sectorNum]);\n    //     edges.emplace_back(vertices[1]);\n\n    //     DrawLines(edges, edgeWeight, edgeColor);\n    // }\n\n\n    // void DrawCylinder(const glm::vec3 &amp;baseCenter, const glm::vec3 &amp;topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum){\n    //     std::vector&lt;CylinderPole&gt; cylinderPoles; // vector of structs\n\n    //     glm::vec3 x1 = baseCenter, x2 = topCenter;\n    //     glm::vec3 norm = glm::normalize(x2 - x1);\n    //     GLfloat h = glm::length(x2 - x1);\n\n    //     glm::vec3 newX = glm::cross(norm, glm::vec3(0, 1, 0));\n    //     glm::vec3 newZ = glm::cross(newX, norm);\n\n    //     glm::mat4 transformMat;\n\n    //     transformMat[0] = glm::vec4(newX, 0);\n    //     transformMat[1] = glm::vec4(norm, 0);\n    //     transformMat[2] = glm::vec4(newZ, 0);\n    //     transformMat[3] = glm::vec4(x1, 1);\n\n    //     for (int i = 0; i &lt; sectorNum; ++i){\n    //         GLfloat u = (GLfloat)i / (GLfloat)sectorNum;\n    //         CylinderPole cp{\n    //                 .x = static_cast&lt;GLfloat&gt;(radius * cos(2 * M_PI * u)),\n    //                 .z = static_cast&lt;GLfloat&gt;(radius * sin(2 * M_PI * u)),\n    //         };\n    //         cylinderPoles.push_back(cp);\n    //     }\n\n    //     vector&lt;uint32_t&gt; flattenedIndices;\n    //     vector&lt;glm::vec3&gt; indices;\n    //     vector&lt;glm::vec3&gt; vertices;\n    //     vector&lt;glm::vec3&gt; capContourTop, capContourBase;\n\n    //     vertices.emplace_back(x1); // 0\n    //     vertices.emplace_back(x2); // 1\n\n    //     vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, 0, cylinderPoles[0].z)); // 2\n    //     vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, h, cylinderPoles[0].z)); // 3\n\n    //     capContourBase.push_back(GetTransformed(transformMat, cylinderPoles[0].x, 0, cylinderPoles[0].z));\n    //     capContourTop.push_back(GetTransformed(transformMat, cylinderPoles[0].x, h, cylinderPoles[0].z));\n\n    //     int baseCenterIdx = 0;\n    //     int topCenterIdx = 1;\n    //     int prevBaseVertexIdx = 2;\n    //     int prevTopVertexIdx = 3;\n    //     int curBaseVertexIdx = 4;\n    //     int curTopVertexIdx = 5;\n\n    //     for(int i = 1; i &lt; sectorNum; i++){\n    //         capContourBase.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, 0, cylinderPoles[i].z));\n    //         capContourBase.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, 0, cylinderPoles[i].z));\n    //         capContourTop.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, h, cylinderPoles[i].z));\n    //         capContourTop.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, h, cylinderPoles[i].z));\n\n    //         vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, 0, cylinderPoles[i].z));\n    //         vertices.emplace_back(GetTransformed(transformMat, cylinderPoles[i].x, h, cylinderPoles[i].z));\n\n    //         indices.emplace_back(curBaseVertexIdx ,baseCenterIdx   , prevBaseVertexIdx);\n    //         indices.emplace_back(prevTopVertexIdx ,topCenterIdx    , curTopVertexIdx  );\n    //         indices.emplace_back(curBaseVertexIdx ,curTopVertexIdx , prevTopVertexIdx );\n    //         indices.emplace_back(prevBaseVertexIdx,curBaseVertexIdx, prevTopVertexIdx );\n\n    //         prevBaseVertexIdx = curBaseVertexIdx;\n    //         prevTopVertexIdx = curTopVertexIdx;\n    //         curBaseVertexIdx += 2;\n    //         curTopVertexIdx += 2;\n    //     }\n\n    //     // Last one\n    //     curBaseVertexIdx = 2;\n    //     curTopVertexIdx = 3;\n    //     indices.emplace_back(curBaseVertexIdx ,baseCenterIdx   , prevBaseVertexIdx);\n    //     indices.emplace_back(prevTopVertexIdx ,topCenterIdx    , curTopVertexIdx  );\n    //     indices.emplace_back(curBaseVertexIdx ,curTopVertexIdx , prevTopVertexIdx );\n    //     indices.emplace_back(prevBaseVertexIdx,curBaseVertexIdx, prevTopVertexIdx );\n\n    //     capContourBase.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, 0, cylinderPoles[0].z));\n    //     capContourTop.emplace_back(GetTransformed(transformMat, cylinderPoles[0].x, h, cylinderPoles[0].z));\n\n    //     for(auto vid: indices){\n    //         flattenedIndices.push_back((uint)vid.x);\n    //         flattenedIndices.push_back((uint)vid.y);\n    //         flattenedIndices.push_back((uint)vid.z);\n    //     }\n\n    //     glDrawTriangles3d(vertices, flattenedIndices, color);\n    //     glDrawLines3d(capContourBase, edgeColor);\n    //     glDrawLines3d(capContourTop, edgeColor);\n    // }\n}\n</code></pre>"},{"location":"acdoxygen/RenderAPI_8h/","title":"File RenderAPI.h","text":"<p>FileList &gt; AIAC &gt; Render &gt; RenderAPI.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"map.h\"</code></li> <li><code>#include \"TextRenderer.h\"</code></li> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> </ul>"},{"location":"acdoxygen/RenderAPI_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/RenderAPI_8h/#classes","title":"Classes","text":"Type Name struct CylinderPole <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/RenderAPI.h</code></p>"},{"location":"acdoxygen/RenderAPI_8h_source/","title":"File RenderAPI.h","text":"<p>File List &gt; AIAC &gt; Render &gt; RenderAPI.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#include \"map.h\" // TSLAM map\n\n#include \"TextRenderer.h\"\n#include \"AIAC/GOSys/GOPrimitive.h\"\n\nnamespace AIAC\n{\n    struct CylinderPole {\n        GLfloat x, z;\n    };\n\n    glm::vec3 GetTransformed(glm::mat4 transformMat, float x, float y, float z);\n\n    void DrawSlamMap(const shared_ptr&lt;tslam::Map&gt; &amp;map, const glm::vec4 &amp;color, float pointSize);\n\n    void DrawAllGOs(glm::mat4 projection = glm::mat4(1.0f), float textScale = 1.0f);\n\n    void DrawGO(const shared_ptr&lt;GOPrimitive&gt;&amp; goPrimitive);\n\n    void DrawPoint(const GOPoint&amp; goPoint);\n    void DrawPoints(const std::vector&lt;std::shared_ptr&lt;GOPoint&gt;&gt;&amp; goPoints);\n\n    void DrawLine(const glm::vec3 &amp;p1, const glm::vec3 &amp;p2, float weight = GOWeight::Default, const glm::vec4 &amp;color = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f));\n    void DrawLines(const vector&lt;glm::vec3&gt; &amp;vertices, float weight, const glm::vec4 &amp;color);\n    void DrawLine(const GOLine&amp; goLine);\n    void DrawLines(const std::vector&lt;std::shared_ptr&lt;GOLine&gt;&gt;&amp; goLines);\n\n    void DrawCircle(glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum = 24);\n    void DrawCircle(const GOCircle&amp; goCircle);\n    void DrawCircles(const std::vector&lt;std::shared_ptr&lt;GOCircle&gt;&gt;&amp; goCircles);\n\n    void DrawCylinder(const glm::vec3 &amp;baseCenter, const glm::vec3 &amp;topCenter,\n                      GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum = 24);\n    void DrawCylinder(const GOCylinder&amp; goCylinder);\n    void DrawCylinders(const std::vector&lt;std::shared_ptr&lt;GOCylinder&gt;&gt;&amp; goCylinders);\n\n    void DrawPolyline(const GOPolyline&amp; goPolyline);\n    void DrawPolylines(const std::vector&lt;std::shared_ptr&lt;GOPolyline&gt;&gt;&amp; goPolylines);\n\n    void DrawTriangle(const GOTriangle&amp; goTriangle);\n    void DrawTriangles(const std::vector&lt;std::shared_ptr&lt;GOTriangle&gt;&gt;&amp; goTriangles);\n\n    void DrawMesh(const GOMesh&amp; goMesh);\n    void DrawMeshes(const std::vector&lt;std::shared_ptr&lt;GOMesh&gt;&gt; &amp;goMeshes);\n\n    void DrawText(const GOText&amp; goText, float scale = 1.0f, const glm::mat4&amp; projection = glm::mat4(1.0f));\n    void DrawTexts(std::vector&lt;GOText&gt; goTexts, float scale = 1.0f, const glm::mat4&amp; projection = glm::mat4(1.0f));\n}\n</code></pre>"},{"location":"acdoxygen/Renderer_8cpp/","title":"File Renderer.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; Renderer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"AIAC/Render/Renderer.h\"</code></li> <li><code>#include \"TextRenderer.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"AIAC/Render/RenderAPI.h\"</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include \"glm/gtx/string_cast.hpp\"</code></li> <li><code>#include \"glm/gtc/matrix_transform.hpp\"</code></li> <li><code>#include \"Shader.hpp\"</code></li> <li><code>#include \"utils/utils.h\"</code></li> <li><code>#include \"AIAC/LayerCameraCalib.h\"</code></li> </ul>"},{"location":"acdoxygen/Renderer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Renderer_8cpp/#macros","title":"Macros","text":"Type Name define GLM_ENABLE_EXPERIMENTAL"},{"location":"acdoxygen/Renderer_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Renderer_8cpp/#define-glm_enable_experimental","title":"define GLM_ENABLE_EXPERIMENTAL","text":"<pre><code>#define GLM_ENABLE_EXPERIMENTAL \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Renderer.cpp</code></p>"},{"location":"acdoxygen/Renderer_8cpp_source/","title":"File Renderer.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; Renderer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"aiacpch.h\"\n\n#include \"AIAC/Render/Renderer.h\"\n#include \"TextRenderer.h\"\n\n#include \"AIAC/Application.h\"\n#include \"AIAC/Log.h\"\n#include \"AIAC/Config.h\"\n\n#include \"AIAC/Render/RenderAPI.h\"\n#include \"glm/glm.hpp\"\n#include \"glm/gtx/string_cast.hpp\"\n#define GLM_ENABLE_EXPERIMENTAL\n#include \"glm/gtc/matrix_transform.hpp\"\n#include \"Shader.hpp\"\n\n#include \"utils/utils.h\"\n#include \"AIAC/LayerCameraCalib.h\"\n\nnamespace AIAC\n{\n    void Renderer::Init()\n    {\n        // Create and compile our GLSL program from the shaders\n        char* vertexFilePath = (char*)\"assets/opengl/SimpleTransform.vs\";\n        char* fragmentFilePath = (char*)\"assets/opengl/SingleColor.fs\";\n\n        m_BasicShaderProgram = LoadShaders(vertexFilePath, fragmentFilePath);\n\n        glGenVertexArrays(1, &amp;m_VAO);\n        glBindVertexArray(m_VAO);\n\n        // Get a handle for our \"MVP\" uniform\n        m_MatrixId = glGetUniformLocation(m_BasicShaderProgram, \"MVP\");\n\n        // init the projection matrix based on the camera parameters\n        InitProjMatrix();\n\n        // Initialize the static interface of TextRenderer\n        TextRenderer::Init();\n\n        // Initialize sub views\n        InitMappingView();\n        InitGlobalView();\n        InitCamCalibView();\n\n        m_MappingView.SetSize(600, 442);\n    }\n\n    void Renderer::InitProjMatrix(){\n        // Calculate Perspective Projection Matrix based on camera intrinsic parameters\n        // Reference: https://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/\n        cv::Mat cameraMatrix = AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.GetCameraMatrix();\n        float camW = AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.GetWidth();\n        float camH = AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.GetHeight();\n        float x0 = 0, y0 = 0,zF = 100.0f, zN =0.01f;\n        float fovX = cameraMatrix.at&lt;float&gt;(0,0);\n        float fovY = cameraMatrix.at&lt;float&gt;(1,1);\n        float cX = cameraMatrix.at&lt;float&gt;(0,2);\n        float cY = cameraMatrix.at&lt;float&gt;(1,2);\n        float perspectiveProjMatrixData[16] = {\n                2 * fovX / camW,    0, ( camW - 2 * cX + 2 * x0) / camW,                         0,\n                0,    2 * fovY / camH, (-camH + 2 * cY + 2 * y0) / camH,                         0,\n                0,                  0,             (-zF - zN)/(zF - zN),  -2 * zF * zN / (zF - zN),\n                0,                  0,                               -1,                         0\n        };\n        glm::mat4 perspectiveProjMatrix = glm::transpose(glm::make_mat4(perspectiveProjMatrixData));\n\n        // opencv and opengl has different direction on y and z axis\n        glm::mat4 scalarMatrix(1.0f);\n        scalarMatrix[1][1] = -1;\n        scalarMatrix[2][2] = -1;\n\n        m_ProjMatrix = perspectiveProjMatrix * scalarMatrix;\n\n        // Save variable for later use\n        m_CamW = AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.GetWidth();\n        m_CamH = AIAC_APP.GetLayer&lt;LayerCamera&gt;()-&gt;MainCamera.GetHeight();\n    }\n\n\n    void Renderer::InitGlobalView()\n    {\n        m_GlobalView.Init(400, 300);\n\n        // build camera visualization object, which is a pyramid\n        const float CAMERA_SIZE_W = 1.6, CAMERA_SIZE_H = 1.2;\n        float bW = CAMERA_SIZE_W / 2, bH = CAMERA_SIZE_H / 2, h = 0.5f;\n        m_CamVisualizationEdges.emplace_back( bW,  bH, 0);\n        m_CamVisualizationEdges.emplace_back( bW, -bH, 0);\n        m_CamVisualizationEdges.emplace_back( bW, -bH, 0);\n        m_CamVisualizationEdges.emplace_back(-bW, -bH, 0);\n        m_CamVisualizationEdges.emplace_back(-bW, -bH, 0);\n        m_CamVisualizationEdges.emplace_back(-bW,  bH, 0);\n        m_CamVisualizationEdges.emplace_back(-bW,  bH, 0);\n        m_CamVisualizationEdges.emplace_back( bW,  bH, 0);\n        m_CamVisualizationEdges.emplace_back(  0,   0,-h);\n        m_CamVisualizationEdges.emplace_back( bW,  bH, 0);\n        m_CamVisualizationEdges.emplace_back(  0,   0,-h);\n        m_CamVisualizationEdges.emplace_back(-bW,  bH, 0);\n        m_CamVisualizationEdges.emplace_back(  0,   0,-h);\n        m_CamVisualizationEdges.emplace_back(-bW, -bH, 0);\n        m_CamVisualizationEdges.emplace_back(  0,   0,-h);\n        m_CamVisualizationEdges.emplace_back( bW, -bH, 0);\n\n        m_GlobalProjMatrix = glm::ortho(-m_GlobalProjOrthoSize, m_GlobalProjOrthoSize, -m_GlobalProjOrthoSize, m_GlobalProjOrthoSize, 0.0f, 1000.0f);\n\n        m_GlobalCamMatrix = glm::lookAt(\n                glm::vec3(20, 20, 20),   // the position of your camera, in world space\n                glm::vec3(0, 0, 0),      // where you want to look at, in world space\n                glm::vec3(0, 1, 0)       // probably glm::vec3(0,1,0), but (0,-1,0) would make you looking upside-down, which can be great too\n        );\n    }\n\n    void Renderer::OnRender()\n    {\n        // During mapping, an overlay panel is opened, so we only render things on it\n        // and stop updating the main scene.\n        // TODO: mapping has some problem when calib file is switched (with slam map)\n        if(AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;IsMapping()) {\n            // RenderGlobalView();\n            RenderMappingView();\n            return;\n        }\n\n        if(AIAC_APP.GetLayer&lt;LayerCameraCalib&gt;()-&gt;IsCalibrating()) {\n            RenderCamCalibView();\n            return;\n        }\n\n        // Default, render the main scene\n        RenderMainView();\n        RenderGlobalView();\n    }\n\n    void Renderer::SetGlobalViewSize(float w, float h) {\n        m_GlobalView.SetSize(w, h);\n    }\n\n    void Renderer::UpdateGlobalViewCameraRotation(double diffX, double diffY){\n        auto t1 = glm::translate(glm::mat4(1),-m_GlobalCamLookAtCenter);\n        auto rx = glm::rotate(glm::mat4(1), float(-diffX / 100), glm::vec3(0,1,0));\n        auto ry = glm::rotate(glm::mat4(1), float(-diffY / 100), glm::vec3(1,0,0));\n        auto t2 = glm::translate(glm::mat4(1), m_GlobalCamLookAtCenter);\n        m_GlobalCamMatrix = m_GlobalCamMatrix * t2 * rx * ry * t1;\n    }\n\n    void Renderer::UpdateGlobalViewCameraTranslation(double diffX, double diffY){\n        m_GlobalCamMatrix[3][0] += float(diffX) / 10;\n        m_GlobalCamMatrix[3][1] -= float(diffY) / 10;\n    }\n\n    void Renderer::UpdateGlobalViewCameraScale(double diff) {\n        // m_GlobalCamMatrix[3][2] += float(diff) / 10; // this is for perspective projection\n        m_GlobalProjOrthoSize -= diff / 30;\n        if (m_GlobalProjOrthoSize &lt; .1f) {\n            m_GlobalProjOrthoSize = .1f;\n        }\n        m_GlobalProjMatrix = glm::ortho(-m_GlobalProjOrthoSize, m_GlobalProjOrthoSize, -m_GlobalProjOrthoSize, m_GlobalProjOrthoSize, 0.0f, 1000.0f);\n    }\n\n    void Renderer::SetGlobalViewToActivatedComponent(StandardView standardView){\n        auto activatedComponent = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponent();\n        if (activatedComponent == nullptr) {\n            return;\n        }\n\n        m_GlobalCamLookAtCenter = activatedComponent-&gt;GetCenter();\n\n        glm::vec3 camPosition;\n        const double camDistance = 15.0;\n        const double sqrt2 = sqrt(2);\n\n        switch (standardView) {\n            case StandardView::TOP:\n                camPosition = glm::vec3(0, 0, 1);\n                break;\n            case StandardView::BOTTOM:\n                camPosition = glm::vec3(0, 0, -1);\n                break;\n            case StandardView::NW:\n                camPosition = glm::vec3(-sqrt2, sqrt2, 1);\n                break;\n            case StandardView::NE:\n                camPosition = glm::vec3(sqrt2, sqrt2, 1);\n                break;\n            case StandardView::SW:\n                camPosition = glm::vec3(-sqrt2, -sqrt2, 1);\n                break;\n            case StandardView::SE:\n                camPosition = glm::vec3(sqrt2, -sqrt2, 1);\n                break;\n        }\n\n        camPosition *= camDistance;\n        camPosition += m_GlobalCamLookAtCenter;\n\n        m_GlobalCamMatrix = glm::lookAt(\n                camPosition,\n                m_GlobalCamLookAtCenter,\n                glm::vec3(0, 1, 0)\n        );\n    }\n\n    void Renderer::RenderGlobalView() {\n\n        glBindVertexArray(m_VAO);\n        glUseProgram(m_BasicShaderProgram);\n\n        m_GlobalView.Activate();\n\n        glDisable(GL_DEPTH_TEST);\n\n        // visualize map\n        glm::mat4 finalPoseMatrix = m_GlobalProjMatrix * m_GlobalCamMatrix;\n        glUniformMatrix4fv(m_MatrixId, 1, GL_FALSE, &amp;finalPoseMatrix[0][0]);\n\n        // Draw All objects\n        DrawAllGOs(finalPoseMatrix, 0.05f);\n\n        // Bind back to the main framebuffer\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n    }\n\n    void Renderer::RenderMappingView() {\n        glBindVertexArray(m_VAO);\n        glUseProgram(m_BasicShaderProgram);\n\n        // Draw the small panel 3D view\n        m_GlobalView.Activate();\n        glm::mat4 finalPoseMatrix = m_ProjMatrix * AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;GetCamPoseGlm();\n        glUniformMatrix4fv(m_MatrixId, 1, GL_FALSE, &amp;finalPoseMatrix[0][0]);\n\n        DrawSlamMap(AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.getMap(), glm::vec4(1, 0, 0, 1), 1.5);\n\n        // Draw the camera view\n        m_MappingView.Activate();\n        RenderCameraFrame(600, 442, Renderer::CameraFrameType::SLAM_PROCESSED);\n\n        // Bind back to the main framebuffer\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n    }\n\n    void Renderer::RenderCamCalibView() {\n        m_CamCalibView.Activate();\n\n        RenderCameraFrame(600, 442, Renderer::CameraFrameType::RAW);\n\n        // Bind back to the main framebuffer\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n    }\n\n    void Renderer::RenderMainView() {\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n        glBindVertexArray(m_VAO);\n        glUseProgram(m_BasicShaderProgram);\n\n        glDisable(GL_DEPTH_TEST);        \n\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f );\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        RenderCameraFrame(AIAC_APP.GetWindow()-&gt;GetDisplayW(), AIAC_APP.GetWindow()-&gt;GetDisplayH());\n\n        // finalPoseMatrix is the perspective projected pose of the current camera detected by SLAM\n        glm::mat4 finalPoseMatrix = m_ProjMatrix * AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;GetCamPoseGlm();\n        glUniformMatrix4fv(m_MatrixId, 1, GL_FALSE, &amp;finalPoseMatrix[0][0]);\n\n        // Draw the essential objects: map, point cloud map and digital model !\n        // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n        glm::vec4 edgeColor;\n        if (AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;GetNumLostFrame() &lt;= 3){\n            DrawAllGOs(finalPoseMatrix);\n        }\n    }\n\n    void Renderer::RenderCameraFrame(int w, int h, Renderer::CameraFrameType frameType) {\n        if ( w &lt;= 0 || h &lt;= 0 ){\n            stringstream ss;\n            ss &lt;&lt; \"Renderer::RenderCameraFrame: invalid size: (\" &lt;&lt; w &lt;&lt; \",\" &lt;&lt; h &lt;&lt; \")\";\n            throw std::runtime_error(ss.str());\n        }\n\n        GLuint frameGlTextureObj;\n        cv::Size frameSize;\n        if(frameType == Renderer::CameraFrameType::RAW) {\n            frameGlTextureObj = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetRawCurrentFrame().GetGlTextureObj();\n            frameSize.height = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetRawHeight();\n            frameSize.width = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetRawWidth();\n        } else if (frameType == Renderer::CameraFrameType::UNDISTORTED) {\n            frameGlTextureObj = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetCurrentFrame().GetGlTextureObj();\n            frameSize.height = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetHeight();\n            frameSize.width = AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetWidth();\n        } else if (frameType == Renderer::CameraFrameType::SLAM_PROCESSED) {\n            frameGlTextureObj = AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;GetProcessedFrame().GetGlTextureObj();\n            frameSize =  AIAC_APP.GetLayer&lt;LayerSlam&gt;()-&gt;Slam.imageParams.CamSize;\n        }\n\n        GLuint readFboIdFrame = 0;\n        glGenFramebuffers(1, &amp;readFboIdFrame);\n        glBindFramebuffer(GL_READ_FRAMEBUFFER, readFboIdFrame);\n        glFramebufferTexture2D(GL_READ_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n                               GL_TEXTURE_2D, frameGlTextureObj, 0);\n\n        glBlitFramebuffer(0, 0, frameSize.width, frameSize.height,\n                          0, 0, w, h,\n                          GL_COLOR_BUFFER_BIT, GL_LINEAR);\n        glDeleteFramebuffers(1, &amp;readFboIdFrame);\n\n        glViewport(0,0,w,h); // Renderer on the whole framebuffer, complete from the lower left corner to the upper right\n    }\n}\n</code></pre>"},{"location":"acdoxygen/Renderer_8h/","title":"File Renderer.h","text":"<p>FileList &gt; AIAC &gt; Render &gt; Renderer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include \"AIAC/GlHeader.h\"</code></li> <li><code>#include \"AIAC/Layer.h\"</code></li> <li><code>#include \"AIAC/Render/Viewport.h\"</code></li> <li><code>#include \"AIAC/Render/GLObject.h\"</code></li> </ul>"},{"location":"acdoxygen/Renderer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Renderer_8h/#classes","title":"Classes","text":"Type Name class Renderer <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Renderer.h</code></p>"},{"location":"acdoxygen/Renderer_8h_source/","title":"File Renderer.h","text":"<p>File List &gt; AIAC &gt; Render &gt; Renderer.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;vector&gt;\n\n#include \"glm/glm.hpp\"\n\n#include \"AIAC/GlHeader.h\"\n#include \"AIAC/Layer.h\"\n\n#include \"AIAC/Render/Viewport.h\"\n\n#include \"AIAC/Render/GLObject.h\"\n\nnamespace AIAC\n{\n    class Renderer\n    {\n    public:\n        // For navigating the global view\n        enum class StandardView\n        {\n            TOP,\n            BOTTOM,\n            NW,\n            NE,\n            SW,\n            SE\n        };\n\n    public:\n        Renderer() = default;\n        virtual ~Renderer() = default;\n\n        void Init();\n        void InitProjMatrix();\n        void OnRender();\n\n        GLuint GetGlobalView() const { return m_GlobalView.GetTexture(); };\n        void SetGlobalViewSize(float w, float h);\n        void SetGlobalViewToActivatedComponent(StandardView standardView);\n        void UpdateGlobalViewCameraTranslation(double diffX, double diffY);\n        void UpdateGlobalViewCameraRotation(double diffX, double diffY);\n        void UpdateGlobalViewCameraScale(double diff);\n\n        // Mapping View\n        GLuint GetMappingView() const { return m_MappingView.GetTexture(); };\n        void SetMappingViewSize(float w, float h);\n\n        // CamCalib view\n        GLuint GetCamCalibView() const { return m_CamCalibView.GetTexture(); };\n        void SetCamCalibViewSize(float w, float h);\n\n        // Camera Frame rendering type\n        enum class CameraFrameType\n        {\n            RAW,\n            UNDISTORTED,\n            SLAM_PROCESSED\n        };\n\n    private:\n        void RenderMainView();\n\n        void InitGlobalView();\n        void InitMappingView() { m_MappingView.Init(600, 442); }\n        void InitCamCalibView() { m_CamCalibView.Init(600, 442); }\n\n        void RenderGlobalView();\n        void RenderMappingView();\n        void RenderCamCalibView();\n\n        void RenderCameraFrame(int w, int h, CameraFrameType frameType=CameraFrameType::UNDISTORTED);\n\n\n    private:\n        std::shared_ptr&lt;GLObject&gt; m_TestGLObject;\n\n        float m_CamW, m_CamH;\n\n        GLuint m_BasicShaderProgram;\n        GLuint m_MatrixId;\n        GLuint m_VAO;\n\n        glm::mat4 m_ProjMatrix;\n\n        // Global view\n        Viewport m_GlobalView;\n        glm::vec3 m_GlobalCamLookAtCenter = glm::vec3(0, 0, 0);\n        glm::mat4 m_GlobalCamMatrix;\n        glm::mat4 m_GlobalProjMatrix;\n        float m_GlobalProjOrthoSize = 15.f;\n\n        // Mapping view\n        Viewport m_MappingView;\n\n        // Camera calib view\n        Viewport m_CamCalibView;\n\n        std::vector&lt;glm::vec3&gt; m_CamVisualizationEdges;\n\n        glm::vec4 m_DefaultEdgeColor = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);\n        glm::vec4 m_PointCloudMapColor = glm::vec4(0.9, 0.9, 0.9, 0.2);\n        glm::vec4 m_DigitalModelBoundingBoxColor = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f);\n        glm::vec4 m_DigitalModelFaceColor = glm::vec4(0.6, 0.35, 0.2, 0.3);\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Shader_8cpp/","title":"File Shader.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; Shader.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include \"Shader.hpp\"</code></li> <li><code>#include \"utils/utils.h\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> </ul>"},{"location":"acdoxygen/Shader_8cpp/#public-functions","title":"Public Functions","text":"Type Name GLuint LoadShaders (const char * vertex_file_path, const char * fragment_file_path)"},{"location":"acdoxygen/Shader_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/Shader_8cpp/#function-loadshaders","title":"function LoadShaders","text":"<pre><code>GLuint LoadShaders (\n    const char * vertex_file_path,\n    const char * fragment_file_path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Shader.cpp</code></p>"},{"location":"acdoxygen/Shader_8cpp_source/","title":"File Shader.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; Shader.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;sstream&gt;\n\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;GL/glew.h&gt;\n\n#include \"Shader.hpp\"\n#include \"utils/utils.h\"\n#include \"AIAC/Log.h\"\n\nGLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path){\n\n    assert(IsFileExist(vertex_file_path));\n    assert(IsFileExist(fragment_file_path));\n\n    // Create the shaders\n    GLuint VertexShaderID = glCreateShader(GL_VERTEX_SHADER);\n    GLuint FragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);\n\n    // Read the Vertex Shader code from the file\n    std::string VertexShaderCode;\n    std::ifstream VertexShaderStream(vertex_file_path, std::ios::in);\n    if(VertexShaderStream.is_open()){\n        std::stringstream sstr;\n        sstr &lt;&lt; VertexShaderStream.rdbuf();\n        VertexShaderCode = sstr.str();\n        VertexShaderStream.close();\n    }else{\n        AIAC_ERROR(\"Impossible to open {0}. Are you in the right directory ? Don't forget to read the FAQ !\\n\", vertex_file_path);\n        getchar();\n        return 0;\n    }\n\n    // Read the Fragment Shader code from the file\n    std::string FragmentShaderCode;\n    std::ifstream FragmentShaderStream(fragment_file_path, std::ios::in);\n    if(FragmentShaderStream.is_open()){\n        std::stringstream sstr;\n        sstr &lt;&lt; FragmentShaderStream.rdbuf();\n        FragmentShaderCode = sstr.str();\n        FragmentShaderStream.close();\n    }\n\n    GLint Result = GL_FALSE;\n    int InfoLogLength;\n\n\n    // Compile Vertex Shader\n    char const * VertexSourcePointer = VertexShaderCode.c_str();\n    glShaderSource(VertexShaderID, 1, &amp;VertexSourcePointer , NULL);\n    glCompileShader(VertexShaderID);\n\n    // Check Vertex Shader\n    glGetShaderiv(VertexShaderID, GL_COMPILE_STATUS, &amp;Result);\n    glGetShaderiv(VertexShaderID, GL_INFO_LOG_LENGTH, &amp;InfoLogLength);\n    if ( InfoLogLength &gt; 0 ){\n        std::vector&lt;char&gt; VertexShaderErrorMessage(InfoLogLength+1);\n        glGetShaderInfoLog(VertexShaderID, InfoLogLength, NULL, &amp;VertexShaderErrorMessage[0]);\n    }\n\n\n\n    // Compile Fragment Shader\n    char const * FragmentSourcePointer = FragmentShaderCode.c_str();\n    glShaderSource(FragmentShaderID, 1, &amp;FragmentSourcePointer , NULL);\n    glCompileShader(FragmentShaderID);\n\n    // Check Fragment Shader\n    glGetShaderiv(FragmentShaderID, GL_COMPILE_STATUS, &amp;Result);\n    glGetShaderiv(FragmentShaderID, GL_INFO_LOG_LENGTH, &amp;InfoLogLength);\n    if ( InfoLogLength &gt; 0 ){\n        std::vector&lt;char&gt; FragmentShaderErrorMessage(InfoLogLength+1);\n        glGetShaderInfoLog(FragmentShaderID, InfoLogLength, NULL, &amp;FragmentShaderErrorMessage[0]);\n        printf(\"%s\\n\", &amp;FragmentShaderErrorMessage[0]);\n    }\n\n    // Link the program\n    GLuint ProgramID = glCreateProgram();\n    glAttachShader(ProgramID, VertexShaderID);\n    glAttachShader(ProgramID, FragmentShaderID);\n    glLinkProgram(ProgramID);\n\n    // Check the program\n    glGetProgramiv(ProgramID, GL_LINK_STATUS, &amp;Result);\n    glGetProgramiv(ProgramID, GL_INFO_LOG_LENGTH, &amp;InfoLogLength);\n    if ( InfoLogLength &gt; 0 ){\n        std::vector&lt;char&gt; ProgramErrorMessage(InfoLogLength+1);\n        glGetProgramInfoLog(ProgramID, InfoLogLength, NULL, &amp;ProgramErrorMessage[0]);\n    }\n\n\n    glDetachShader(ProgramID, VertexShaderID);\n    glDetachShader(ProgramID, FragmentShaderID);\n\n    glDeleteShader(VertexShaderID);\n    glDeleteShader(FragmentShaderID);\n\n    return ProgramID;\n}\n</code></pre>"},{"location":"acdoxygen/Shader_8hpp/","title":"File Shader.hpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; Shader.hpp</p> <p>Go to the source code of this file</p>"},{"location":"acdoxygen/Shader_8hpp/#public-functions","title":"Public Functions","text":"Type Name GLuint LoadShaders (const char * vertex_file_path, const char * fragment_file_path)"},{"location":"acdoxygen/Shader_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/Shader_8hpp/#function-loadshaders","title":"function LoadShaders","text":"<pre><code>GLuint LoadShaders (\n    const char * vertex_file_path,\n    const char * fragment_file_path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Shader.hpp</code></p>"},{"location":"acdoxygen/Shader_8hpp_source/","title":"File Shader.hpp","text":"<p>File List &gt; AIAC &gt; Render &gt; Shader.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SHADER_HPP\n#define SHADER_HPP\n\nGLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path);\n\n#endif\n</code></pre>"},{"location":"acdoxygen/TextRenderer_8cpp/","title":"File TextRenderer.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; TextRenderer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"TextRenderer.h\"</code></li> <li><code>#include \"glm/gtc/type_ptr.hpp\"</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> </ul>"},{"location":"acdoxygen/TextRenderer_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/TextRenderer.cpp</code></p>"},{"location":"acdoxygen/TextRenderer_8cpp_source/","title":"File TextRenderer.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; TextRenderer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n\n#include &lt;map&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n#include \"TextRenderer.h\"\n#include \"glm/gtc/type_ptr.hpp\"\n#include \"AIAC/Log.h\"\n\nnamespace AIAC{\n\n    TextRenderer* TextRenderer::s_instance = nullptr;\n    bool TextRenderer::s_Initialized;\n    GLuint TextRenderer::s_ShaderProgram;\n    GLuint TextRenderer::s_VBO;\n    std::map&lt;char, Character&gt; TextRenderer::Characters;\n    glm::mat4 TextRenderer::s_Projection = glm::mat4(1.0f);\n\n    void TextRenderer::Init() {\n        s_instance = new TextRenderer();\n\n        // glGenVertexArrays(1, &amp;s_VAO);\n\n        // Load FreeType\n        // --------\n        // All functions return a value different from 0 whenever an error occurred\n        FT_Library ft;\n        if (FT_Init_FreeType(&amp;ft)) {\n            std::cerr &lt;&lt; \"ERROR::FREETYPE: Could not init FreeType Library\" &lt;&lt; std::endl;\n            throw(std::runtime_error(\"ERROR::FREETYPE: Could not init FreeType Library\"));\n        }\n\n        // find path to font\n        std::string font_name = \"assets/fonts/UbuntuMono-R.ttf\";\n        if (font_name.empty()) {\n            std::cerr &lt;&lt; \"ERROR::FREETYPE: Failed to load font_name\" &lt;&lt; std::endl;\n            throw(std::runtime_error(\"ERROR::FREETYPE: Failed to load font_name\"));\n        }\n\n        // load font as face\n        FT_Face face;\n        if (FT_New_Face(ft, font_name.c_str(), 0, &amp;face)) {\n            std::cerr &lt;&lt; \"ERROR::FREETYPE: Failed to load font\" &lt;&lt; std::endl;\n            throw(std::runtime_error(\"ERROR::FREETYPE: Failed to load font\"));\n        }\n\n        // set size to load glyphs as\n        FT_Set_Pixel_Sizes(face, 0, 48);\n        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n        // load first 128 characters of ASCII set\n        for (unsigned char c = 0; c &lt; 128; c++) {\n            // Load character glyph\n            if (FT_Load_Char(face, c, FT_LOAD_RENDER)) {\n                std::cerr &lt;&lt; \"ERROR::FREETYPE: Failed to load Glyph\" &lt;&lt; std::endl;\n                continue;\n            }\n            // generate texture\n            unsigned int texture;\n            glGenTextures(1, &amp;texture);\n            glBindTexture(GL_TEXTURE_2D, texture);\n            glTexImage2D(\n                    GL_TEXTURE_2D,\n                    0,\n                    GL_RED,\n                    face-&gt;glyph-&gt;bitmap.width,\n                    face-&gt;glyph-&gt;bitmap.rows,\n                    0,\n                    GL_RED,\n                    GL_UNSIGNED_BYTE,\n                    face-&gt;glyph-&gt;bitmap.buffer\n            );\n            // set texture options\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n            // now store character for later use\n            Character character = {\n                    texture,\n                    glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows),\n                    glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top),\n                    static_cast&lt;unsigned int&gt;(face-&gt;glyph-&gt;advance.x)\n            };\n            s_instance-&gt;Characters.insert(std::pair&lt;char, Character&gt;(c, character));\n        }\n\n        // disable byte-alignment restriction\n        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n        // destroy FreeType once we're finished\n        FT_Done_Face(face);\n        FT_Done_FreeType(ft);\n\n        glEnable(GL_BLEND);\n        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n        s_instance-&gt;s_ShaderProgram = LoadShaders(\n                \"assets/opengl/TextShader.vs\",\n                \"assets/opengl/TextShader.fs\");\n\n        glGenBuffers(1, &amp;(s_instance-&gt;s_VBO));\n        s_instance-&gt;s_Initialized = true;\n\n    }\n\n    void TextRenderer::RenderTextIn3DSpace(std::string text, glm::vec3 position, glm::vec4 color, float scale)\n    {\n        if(!s_Initialized){\n            throw std::runtime_error(\"Try to render text before init.\");\n        }\n\n        if(s_Projection == glm::mat4(1.0f)){\n            AIAC_WARN(\"Projection matrix is not set.\");\n        }\n\n        GLint viewport[4];\n        glGetIntegerv( GL_VIEWPORT, viewport);\n        int w = viewport[2];\n        int h = viewport[3];\n\n        auto coordProj = s_Projection * glm::vec4(position, 1.0f);\n        if (coordProj.w != 0){\n            coordProj.w = 1.0 / coordProj.w;\n            coordProj.x *= coordProj.w;\n            coordProj.y *= coordProj.w;\n            coordProj.z *= coordProj.w;\n        }\n        if(scale * coordProj.w * 10 &gt; 0) {\n            RenderText(text,\n                       (coordProj.x / 2 + 0.5) * w, (coordProj.y / 2 + 0.5) * h,\n                       color,\n                       scale * coordProj.w * 10);\n        }\n    }\n\n    void TextRenderer::RenderText(std::string text, float x, float y, glm::vec4 color, float scale)\n    {\n        if(!s_Initialized){\n            throw std::runtime_error(\"Try to render text before init.\");\n        }\n\n        GLint viewport[4];\n        glGetIntegerv( GL_VIEWPORT, viewport);\n\n        GLint prevProgram;\n        glGetIntegerv(GL_PROGRAM, &amp;prevProgram);\n        glUseProgram(s_ShaderProgram);\n        glUniform4f(glGetUniformLocation(s_ShaderProgram, \"textColor\"), color.r, color.g, color.b, color.a);\n        glm::mat4 orthoProjection = glm::ortho(0.0f, float(viewport[2]), 0.0f, float(viewport[3]));\n        glUniformMatrix4fv(glGetUniformLocation(s_ShaderProgram, \"projection\"), 1, GL_FALSE, &amp;orthoProjection[0][0]);\n\n        glActiveTexture(GL_TEXTURE0);\n\n        // glBindVertexArray(s_VAO);\n        glBindBuffer(GL_ARRAY_BUFFER, s_VBO);\n        glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 6 * 4, nullptr, GL_DYNAMIC_DRAW);\n        glEnableVertexAttribArray(0);\n        glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n        glEnable(GL_BLEND);\n        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n        // iterate through all characters\n        std::string::const_iterator c;\n\n        for (c = text.begin(); c != text.end(); c++)\n        {\n            Character ch = Characters[*c];\n\n            float xpos = x + ch.Bearing.x * scale;\n            float ypos = y - (ch.Size.y - ch.Bearing.y) * scale;\n\n            float w = ch.Size.x * scale;\n            float h = ch.Size.y * scale;\n            // update VBO for each character\n            float vertices[6][4] = {\n                    { xpos,     ypos + h,   0.0f, 0.0f },\n                    { xpos,     ypos,       0.0f, 1.0f },\n                    { xpos + w, ypos,       1.0f, 1.0f },\n                    { xpos,     ypos + h,   0.0f, 0.0f },\n                    { xpos + w, ypos,       1.0f, 1.0f },\n                    { xpos + w, ypos + h,   1.0f, 0.0f }\n            };\n            // render glyph texture over quad\n            glBindTexture(GL_TEXTURE_2D, ch.TextureID);\n            // update content of VBO memory\n            glBindBuffer(GL_ARRAY_BUFFER, s_VBO);\n            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);\n            glBindBuffer(GL_ARRAY_BUFFER, 0);\n            // render quad\n            glDrawArrays(GL_TRIANGLES, 0, 6);\n            // now advance cursors for next glyph (note that advance is number of 1/64 pixels)\n            x += (ch.Advance &gt;&gt; 6) * scale; // bitshift by 6 to get value in pixels (2^6 = 64)\n        }\n\n        // restore previous state\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glUseProgram(prevProgram);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/TextRenderer_8h/","title":"File TextRenderer.h","text":"<p>FileList &gt; AIAC &gt; Render &gt; TextRenderer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GlHeader.h\"</code></li> <li><code>#include \"Shader.hpp\"</code></li> <li><code>#include &lt;ft2build.h&gt;</code></li> </ul>"},{"location":"acdoxygen/TextRenderer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/TextRenderer_8h/#classes","title":"Classes","text":"Type Name struct Character class TextRenderer <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/TextRenderer.h</code></p>"},{"location":"acdoxygen/TextRenderer_8h_source/","title":"File TextRenderer.h","text":"<p>File List &gt; AIAC &gt; Render &gt; TextRenderer.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n#include \"AIAC/GlHeader.h\"\n\n#include \"Shader.hpp\"\n\n#include &lt;ft2build.h&gt;\n#include FT_FREETYPE_H\n\nnamespace AIAC\n{\n    // Character stores a character's texture and property\n    struct Character {\n        unsigned int TextureID;  // ID handle of the glyph texture\n        glm::ivec2   Size;       // Size of glyph\n        glm::ivec2   Bearing;    // Offset from baseline to left/top of glyph\n        unsigned int Advance;    // Offset to advance to next glyph\n    };\n\n    // Since a TextRenderer has to hold the information of the font (i.e. a list of \"struct Character\"),\n    // it is wrapped into a class that exporting a static global instance.\n    // The initialization `Init(G)` has to be called before any rendering happening (now it's in `Renderer.Init()`).\n    // When you want to render a text through the TextRenderer directly, use something like:\n    // `TextRenderer::GetInstance().RenderTextOnScreen()` to get the static instance and render the text.\n    class TextRenderer {\n\n    public:\n        TextRenderer() = default;\n        ~TextRenderer() = default;\n\n        static void Init();\n\n        static inline void SetProjection(glm::mat4 projection) { s_Projection = projection; }\n\n        static void RenderTextIn3DSpace(std::string text, glm::vec3 position, glm::vec4 color, float scale=1.0f);\n\n    private:\n        static void RenderText(std::string text, float x, float y, glm::vec4 color, float scale=1.0f);\n\n    public:\n        static std::map&lt;char, Character&gt; Characters;\n\n    private:\n        static bool s_Initialized;\n        static GLuint s_ShaderProgram;\n        static GLuint s_VBO;\n        static TextRenderer* s_instance;\n        static glm::mat4 s_Projection;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Viewport_8cpp/","title":"File Viewport.cpp","text":"<p>FileList &gt; AIAC &gt; Render &gt; Viewport.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Viewport.h\"</code></li> </ul>"},{"location":"acdoxygen/Viewport_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Viewport.cpp</code></p>"},{"location":"acdoxygen/Viewport_8cpp_source/","title":"File Viewport.cpp","text":"<p>File List &gt; AIAC &gt; Render &gt; Viewport.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n\n#include \"Viewport.h\"\n\nnamespace AIAC {\n    void Viewport::Init(int w, int h) {\n        m_W = w;\n        m_H = h;\n\n        glGenFramebuffers(1, &amp;m_FrameBuffer);\n        glBindFramebuffer(GL_FRAMEBUFFER, m_FrameBuffer);\n\n        // The texture we're going to render to\n        glGenTextures(1, &amp;m_Texture);\n\n        // \"Bind\" the newly created texture : all future texture functions will modify this texture\n        glBindTexture(GL_TEXTURE_2D, m_Texture);\n\n        // Give an empty image to OpenGL ( the last \"0\" )\n        glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, m_W, m_H, 0,GL_RGB, GL_UNSIGNED_BYTE, 0);\n\n        // Poor filtering. Needed !\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\n        // The depth buffer\n        glGenRenderbuffers(1, &amp;m_DepthBuffer);\n        glBindRenderbuffer(GL_RENDERBUFFER, m_DepthBuffer);\n        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, m_W, m_H);\n        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_DepthBuffer);\n\n        // Set \"renderedTexture\" as our colour attachement #0\n        glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, m_Texture, 0);\n\n        // Set the list of draw buffers.\n        GLenum DrawBuffers[1] = {GL_COLOR_ATTACHMENT0};\n        glDrawBuffers(1, DrawBuffers); // \"1\" is the size of DrawBuffers\n    }\n\n    void Viewport::Activate() {\n        glBindFramebuffer(GL_FRAMEBUFFER, m_FrameBuffer);\n        glViewport(0, 0, m_W, m_H);\n\n        // \"Bind\" the newly created texture : all future texture functions will modify this texture\n        glBindTexture(GL_TEXTURE_2D, m_Texture);\n\n        // Give an empty image to OpenGL ( the last \"0\" )\n        glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, m_W, m_H, 0,GL_RGB, GL_UNSIGNED_BYTE, 0);\n\n        // Poor filtering. Needed !\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\n        // The depth buffer\n        glBindRenderbuffer(GL_RENDERBUFFER, m_DepthBuffer);\n        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, m_W, m_H);\n        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_DepthBuffer);\n\n        // Set \"renderedTexture\" as our colour attachment #0\n        glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, m_Texture, 0);\n\n        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n        glEnable( GL_BLEND );\n        glClearColor(1.0, 1.0, 1.0, 0.0);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    }\n}\n</code></pre>"},{"location":"acdoxygen/Viewport_8h/","title":"File Viewport.h","text":"<p>FileList &gt; AIAC &gt; Render &gt; Viewport.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"glm/glm.hpp\"</code></li> <li><code>#include \"AIAC/GlHeader.h\"</code></li> </ul>"},{"location":"acdoxygen/Viewport_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC"},{"location":"acdoxygen/Viewport_8h/#classes","title":"Classes","text":"Type Name class Viewport <p>The documentation for this class was generated from the following file <code>src/AIAC/Render/Viewport.h</code></p>"},{"location":"acdoxygen/Viewport_8h_source/","title":"File Viewport.h","text":"<p>File List &gt; AIAC &gt; Render &gt; Viewport.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"glm/glm.hpp\"\n#include \"AIAC/GlHeader.h\"\n\nnamespace AIAC{\n    class Viewport {\n    public:\n        Viewport() = default;\n        ~Viewport() = default;\n\n        void Init(int w, int h);\n        void Activate();\n        GLuint GetTexture() const { return m_Texture; };\n        void SetSize(int w, int h) { m_W = w; m_H = h; };\n\n        GLuint GetW() const { return m_W; };\n        GLuint GetH() const { return m_H; };\n\n    protected:\n        GLuint m_FrameBuffer;\n        GLuint m_Texture;\n        GLuint m_DepthBuffer;\n        GLuint m_W;\n        GLuint m_H;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/dir_1ecaf06ce723c740944fb523b6bd2c55/","title":"Dir src/AIAC/UI","text":"<p>FileList &gt; AIAC &gt; UI</p>"},{"location":"acdoxygen/dir_1ecaf06ce723c740944fb523b6bd2c55/#files","title":"Files","text":"Type Name file ClrPalette.h file CustomLogos.h file ImGuiFileDialog.cpp file ImGuiFileDialog.h file ImGuiFileDialogConfig.h <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/</code></p>"},{"location":"acdoxygen/ClrPalette_8h/","title":"File ClrPalette.h","text":"<p>FileList &gt; AIAC &gt; UI &gt; ClrPalette.h</p> <p>Go to the source code of this file</p>"},{"location":"acdoxygen/ClrPalette_8h/#macros","title":"Macros","text":"Type Name define AIAC_UI_APRICOT_ORANGE <code>ImVec4(0.98f, 0.81f, 0.69f, 1.0f)</code> define AIAC_UI_BLACK <code>ImVec4(0.0f, 0.0f, 0.0f, 1.0f)</code> define AIAC_UI_BLUE <code>ImVec4(0.0f, 0.0f, 1.0f, 1.0f)</code> define AIAC_UI_BRONZE_ORANGE <code>ImVec4(0.8f, 0.5f, 0.2f, 1.0f)</code> define AIAC_UI_CARMINE_RED <code>ImVec4(0.59f, 0.0f, 0.09f, 1.0f)</code> define AIAC_UI_CINNAMON_RED <code>ImVec4(0.82f, 0.41f, 0.12f, 1.0f)</code> define AIAC_UI_CYAN <code>ImVec4(0.0f, 1.0f, 1.0f, 1.0f)</code> define AIAC_UI_DARK_GREEN <code>ImVec4(0.0f, 0.5f, 0.0f, 1.0f)</code> define AIAC_UI_DARK_GREY <code>ImVec4(0.2f, 0.2f, 0.2f, 1.0f)</code> define AIAC_UI_EGYPTIAN_BLUE <code>ImVec4(0.06f, 0.2f, 0.65f, 1.0f)</code> define AIAC_UI_GRAPE_PURPLE <code>ImVec4(0.56f, 0.35f, 0.62f, 1.0f)</code> define AIAC_UI_GREEN <code>ImVec4(0.0f, 1.0f, 0.0f, 1.0f)</code> define AIAC_UI_GREY <code>ImVec4(0.5f, 0.5f, 0.5f, 1.0f)</code> define AIAC_UI_HIBISCUS_RED <code>ImVec4(0.79f, 0.0f, 0.09f, 1.0f)</code> define AIAC_UI_LIGHT_BLACK <code>ImVec4(0.4f, 0.4f, 0.4f, 1.0f)</code> define AIAC_UI_LIGHT_BLUE <code>ImVec4(0.4f, 0.4f, 1.0f, 1.0f)</code> define AIAC_UI_LIGHT_CYAN <code>ImVec4(0.4f, 1.0f, 1.0f, 1.0f)</code> define AIAC_UI_LIGHT_GREEN <code>ImVec4(0.4f, 1.0f, 0.4f, 1.0f)</code> define AIAC_UI_LIGHT_GREY <code>ImVec4(0.5f, 0.5f, 0.5f, 1.0f)</code> define AIAC_UI_LIGHT_MAGENTA <code>ImVec4(1.0f, 0.4f, 1.0f, 1.0f)</code> define AIAC_UI_LIGHT_RED <code>ImVec4(1.0f, 0.4f, 0.4f, 1.0f)</code> define AIAC_UI_LIGHT_WHITE <code>ImVec4(1.0f, 1.0f, 1.0f, 1.0f)</code> define AIAC_UI_LIGHT_YELLOW <code>ImVec4(1.0f, 1.0f, 0.4f, 1.0f)</code> define AIAC_UI_LOLLIPOP_PURPLE <code>ImVec4(0.6f, 0.0f, 0.6f, 1.0f)</code> define AIAC_UI_MAGENTA <code>ImVec4(1.0f, 0.0f, 1.0f, 1.0f)</code> define AIAC_UI_PLUM_PURPLE <code>ImVec4(0.56f, 0.27f, 0.52f, 1.0f)</code> define AIAC_UI_PRUSSIAN_BLUE <code>ImVec4(0.0f, 0.19f, 0.33f, 1.0f)</code> define AIAC_UI_PURPLE <code>ImVec4(0.5f, 0.0f, 0.5f, 1.0f)</code> define AIAC_UI_RED <code>ImVec4(1.0f, 0.0f, 0.0f, 1.0f)</code> define AIAC_UI_ROYAL_PURPLE <code>ImVec4(0.4f, 0.0f, 0.6f, 1.0f)</code> define AIAC_UI_SAPPHIRE_BLUE <code>ImVec4(0.06f, 0.32f, 0.73f, 1.0f)</code> define AIAC_UI_SEA_GREEN <code>ImVec4(0.18f, 0.545f, 0.341f, 1.0f)</code> define AIAC_UI_SPARK_ORANGE <code>ImVec4(1.0f, 0.2f, 0.0f, 1.0f)</code> define AIAC_UI_WHITE <code>ImVec4(1.0f, 1.0f, 1.0f, 1.0f)</code> define AIAC_UI_YALE_BLUE <code>ImVec4(0.06f, 0.3f, 0.57f, 1.0f)</code> define AIAC_UI_YELLOW <code>ImVec4(1.0f, 1.0f, 0.0f, 1.0f)</code>"},{"location":"acdoxygen/ClrPalette_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_apricot_orange","title":"define AIAC_UI_APRICOT_ORANGE","text":"<pre><code>#define AIAC_UI_APRICOT_ORANGE `ImVec4(0.98f, 0.81f, 0.69f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_black","title":"define AIAC_UI_BLACK","text":"<pre><code>#define AIAC_UI_BLACK `ImVec4(0.0f, 0.0f, 0.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_blue","title":"define AIAC_UI_BLUE","text":"<pre><code>#define AIAC_UI_BLUE `ImVec4(0.0f, 0.0f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_bronze_orange","title":"define AIAC_UI_BRONZE_ORANGE","text":"<pre><code>#define AIAC_UI_BRONZE_ORANGE `ImVec4(0.8f, 0.5f, 0.2f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_carmine_red","title":"define AIAC_UI_CARMINE_RED","text":"<pre><code>#define AIAC_UI_CARMINE_RED `ImVec4(0.59f, 0.0f, 0.09f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_cinnamon_red","title":"define AIAC_UI_CINNAMON_RED","text":"<pre><code>#define AIAC_UI_CINNAMON_RED `ImVec4(0.82f, 0.41f, 0.12f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_cyan","title":"define AIAC_UI_CYAN","text":"<pre><code>#define AIAC_UI_CYAN `ImVec4(0.0f, 1.0f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_dark_green","title":"define AIAC_UI_DARK_GREEN","text":"<pre><code>#define AIAC_UI_DARK_GREEN `ImVec4(0.0f, 0.5f, 0.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_dark_grey","title":"define AIAC_UI_DARK_GREY","text":"<pre><code>#define AIAC_UI_DARK_GREY `ImVec4(0.2f, 0.2f, 0.2f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_egyptian_blue","title":"define AIAC_UI_EGYPTIAN_BLUE","text":"<pre><code>#define AIAC_UI_EGYPTIAN_BLUE `ImVec4(0.06f, 0.2f, 0.65f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_grape_purple","title":"define AIAC_UI_GRAPE_PURPLE","text":"<pre><code>#define AIAC_UI_GRAPE_PURPLE `ImVec4(0.56f, 0.35f, 0.62f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_green","title":"define AIAC_UI_GREEN","text":"<pre><code>#define AIAC_UI_GREEN `ImVec4(0.0f, 1.0f, 0.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_grey","title":"define AIAC_UI_GREY","text":"<pre><code>#define AIAC_UI_GREY `ImVec4(0.5f, 0.5f, 0.5f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_hibiscus_red","title":"define AIAC_UI_HIBISCUS_RED","text":"<pre><code>#define AIAC_UI_HIBISCUS_RED `ImVec4(0.79f, 0.0f, 0.09f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_black","title":"define AIAC_UI_LIGHT_BLACK","text":"<pre><code>#define AIAC_UI_LIGHT_BLACK `ImVec4(0.4f, 0.4f, 0.4f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_blue","title":"define AIAC_UI_LIGHT_BLUE","text":"<pre><code>#define AIAC_UI_LIGHT_BLUE `ImVec4(0.4f, 0.4f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_cyan","title":"define AIAC_UI_LIGHT_CYAN","text":"<pre><code>#define AIAC_UI_LIGHT_CYAN `ImVec4(0.4f, 1.0f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_green","title":"define AIAC_UI_LIGHT_GREEN","text":"<pre><code>#define AIAC_UI_LIGHT_GREEN `ImVec4(0.4f, 1.0f, 0.4f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_grey","title":"define AIAC_UI_LIGHT_GREY","text":"<pre><code>#define AIAC_UI_LIGHT_GREY `ImVec4(0.5f, 0.5f, 0.5f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_magenta","title":"define AIAC_UI_LIGHT_MAGENTA","text":"<pre><code>#define AIAC_UI_LIGHT_MAGENTA `ImVec4(1.0f, 0.4f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_red","title":"define AIAC_UI_LIGHT_RED","text":"<pre><code>#define AIAC_UI_LIGHT_RED `ImVec4(1.0f, 0.4f, 0.4f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_white","title":"define AIAC_UI_LIGHT_WHITE","text":"<pre><code>#define AIAC_UI_LIGHT_WHITE `ImVec4(1.0f, 1.0f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_light_yellow","title":"define AIAC_UI_LIGHT_YELLOW","text":"<pre><code>#define AIAC_UI_LIGHT_YELLOW `ImVec4(1.0f, 1.0f, 0.4f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_lollipop_purple","title":"define AIAC_UI_LOLLIPOP_PURPLE","text":"<pre><code>#define AIAC_UI_LOLLIPOP_PURPLE `ImVec4(0.6f, 0.0f, 0.6f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_magenta","title":"define AIAC_UI_MAGENTA","text":"<pre><code>#define AIAC_UI_MAGENTA `ImVec4(1.0f, 0.0f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_plum_purple","title":"define AIAC_UI_PLUM_PURPLE","text":"<pre><code>#define AIAC_UI_PLUM_PURPLE `ImVec4(0.56f, 0.27f, 0.52f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_prussian_blue","title":"define AIAC_UI_PRUSSIAN_BLUE","text":"<pre><code>#define AIAC_UI_PRUSSIAN_BLUE `ImVec4(0.0f, 0.19f, 0.33f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_purple","title":"define AIAC_UI_PURPLE","text":"<pre><code>#define AIAC_UI_PURPLE `ImVec4(0.5f, 0.0f, 0.5f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_red","title":"define AIAC_UI_RED","text":"<pre><code>#define AIAC_UI_RED `ImVec4(1.0f, 0.0f, 0.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_royal_purple","title":"define AIAC_UI_ROYAL_PURPLE","text":"<pre><code>#define AIAC_UI_ROYAL_PURPLE `ImVec4(0.4f, 0.0f, 0.6f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_sapphire_blue","title":"define AIAC_UI_SAPPHIRE_BLUE","text":"<pre><code>#define AIAC_UI_SAPPHIRE_BLUE `ImVec4(0.06f, 0.32f, 0.73f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_sea_green","title":"define AIAC_UI_SEA_GREEN","text":"<pre><code>#define AIAC_UI_SEA_GREEN `ImVec4(0.18f, 0.545f, 0.341f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_spark_orange","title":"define AIAC_UI_SPARK_ORANGE","text":"<pre><code>#define AIAC_UI_SPARK_ORANGE `ImVec4(1.0f, 0.2f, 0.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_white","title":"define AIAC_UI_WHITE","text":"<pre><code>#define AIAC_UI_WHITE `ImVec4(1.0f, 1.0f, 1.0f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_yale_blue","title":"define AIAC_UI_YALE_BLUE","text":"<pre><code>#define AIAC_UI_YALE_BLUE `ImVec4(0.06f, 0.3f, 0.57f, 1.0f)`\n</code></pre>"},{"location":"acdoxygen/ClrPalette_8h/#define-aiac_ui_yellow","title":"define AIAC_UI_YELLOW","text":"<pre><code>#define AIAC_UI_YELLOW `ImVec4(1.0f, 1.0f, 0.0f, 1.0f)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/ClrPalette.h</code></p>"},{"location":"acdoxygen/ClrPalette_8h_source/","title":"File ClrPalette.h","text":"<p>File List &gt; AIAC &gt; UI &gt; ClrPalette.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n// define macros for colors\n#define AIAC_UI_RED ImVec4(1.0f, 0.0f, 0.0f, 1.0f)\n#define AIAC_UI_GREEN ImVec4(0.0f, 1.0f, 0.0f, 1.0f)\n#define AIAC_UI_DARK_GREEN ImVec4(0.0f, 0.5f, 0.0f, 1.0f)\n#define AIAC_UI_BLUE ImVec4(0.0f, 0.0f, 1.0f, 1.0f)\n#define AIAC_UI_YELLOW ImVec4(1.0f, 1.0f, 0.0f, 1.0f)\n#define AIAC_UI_CYAN ImVec4(0.0f, 1.0f, 1.0f, 1.0f)\n#define AIAC_UI_MAGENTA ImVec4(1.0f, 0.0f, 1.0f, 1.0f)\n#define AIAC_UI_WHITE ImVec4(1.0f, 1.0f, 1.0f, 1.0f)\n#define AIAC_UI_BLACK ImVec4(0.0f, 0.0f, 0.0f, 1.0f)\n#define AIAC_UI_GREY ImVec4(0.5f, 0.5f, 0.5f, 1.0f)\n#define AIAC_UI_PURPLE ImVec4(0.5f, 0.0f, 0.5f, 1.0f)\n#define AIAC_UI_LIGHT_GREY ImVec4(0.5f, 0.5f, 0.5f, 1.0f)\n#define AIAC_UI_DARK_GREY ImVec4(0.2f, 0.2f, 0.2f, 1.0f)\n#define AIAC_UI_LIGHT_RED ImVec4(1.0f, 0.4f, 0.4f, 1.0f)\n#define AIAC_UI_LIGHT_GREEN ImVec4(0.4f, 1.0f, 0.4f, 1.0f)\n#define AIAC_UI_LIGHT_BLUE ImVec4(0.4f, 0.4f, 1.0f, 1.0f)\n#define AIAC_UI_LIGHT_YELLOW ImVec4(1.0f, 1.0f, 0.4f, 1.0f)\n#define AIAC_UI_LIGHT_CYAN ImVec4(0.4f, 1.0f, 1.0f, 1.0f)\n#define AIAC_UI_LIGHT_MAGENTA ImVec4(1.0f, 0.4f, 1.0f, 1.0f)\n#define AIAC_UI_LIGHT_WHITE ImVec4(1.0f, 1.0f, 1.0f, 1.0f)\n#define AIAC_UI_LIGHT_BLACK ImVec4(0.4f, 0.4f, 0.4f, 1.0f)\n#define AIAC_UI_SPARK_ORANGE ImVec4(1.0f, 0.2f, 0.0f, 1.0f)\n#define AIAC_UI_SEA_GREEN ImVec4(0.18f, 0.545f, 0.341f, 1.0f)\n#define AIAC_UI_GRAPE_PURPLE ImVec4(0.56f, 0.35f, 0.62f, 1.0f)\n#define AIAC_UI_CARMINE_RED ImVec4(0.59f, 0.0f, 0.09f, 1.0f)\n#define AIAC_UI_YALE_BLUE ImVec4(0.06f, 0.3f, 0.57f, 1.0f)\n#define AIAC_UI_HIBISCUS_RED ImVec4(0.79f, 0.0f, 0.09f, 1.0f)\n#define AIAC_UI_ROYAL_PURPLE ImVec4(0.4f, 0.0f, 0.6f, 1.0f)\n#define AIAC_UI_LOLLIPOP_PURPLE ImVec4(0.6f, 0.0f, 0.6f, 1.0f)\n#define AIAC_UI_PLUM_PURPLE ImVec4(0.56f, 0.27f, 0.52f, 1.0f)\n#define AIAC_UI_EGYPTIAN_BLUE ImVec4(0.06f, 0.2f, 0.65f, 1.0f)\n#define AIAC_UI_SAPPHIRE_BLUE ImVec4(0.06f, 0.32f, 0.73f, 1.0f)\n#define AIAC_UI_PRUSSIAN_BLUE ImVec4(0.0f, 0.19f, 0.33f, 1.0f)\n#define AIAC_UI_CINNAMON_RED ImVec4(0.82f, 0.41f, 0.12f, 1.0f)\n#define AIAC_UI_APRICOT_ORANGE ImVec4(0.98f, 0.81f, 0.69f, 1.0f)\n#define AIAC_UI_BRONZE_ORANGE ImVec4(0.8f, 0.5f, 0.2f, 1.0f)\n</code></pre>"},{"location":"acdoxygen/CustomLogos_8h/","title":"File CustomLogos.h","text":"<p>FileList &gt; AIAC &gt; UI &gt; CustomLogos.h</p> <p>Go to the source code of this file</p>"},{"location":"acdoxygen/CustomLogos_8h/#macros","title":"Macros","text":"Type Name define AIAC_LOGO_BLACK <code>\"assets/images/logos/logo\\_linux\\_black.png\"</code> define AIAC_LOGO_COLOR <code>\"logo.png\"</code> define AIAC_LOGO_LIGHT_GRAY <code>\"assets/images/logos/logo\\_linux\\_gray\\_light.png\"</code>"},{"location":"acdoxygen/CustomLogos_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/CustomLogos_8h/#define-aiac_logo_black","title":"define AIAC_LOGO_BLACK","text":"<pre><code>#define AIAC_LOGO_BLACK `\"assets/images/logos/logo_linux_black.png\"`\n</code></pre>"},{"location":"acdoxygen/CustomLogos_8h/#define-aiac_logo_color","title":"define AIAC_LOGO_COLOR","text":"<pre><code>#define AIAC_LOGO_COLOR `\"logo.png\"`\n</code></pre>"},{"location":"acdoxygen/CustomLogos_8h/#define-aiac_logo_light_gray","title":"define AIAC_LOGO_LIGHT_GRAY","text":"<pre><code>#define AIAC_LOGO_LIGHT_GRAY `\"assets/images/logos/logo_linux_gray_light.png\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/CustomLogos.h</code></p>"},{"location":"acdoxygen/CustomLogos_8h_source/","title":"File CustomLogos.h","text":"<p>File List &gt; AIAC &gt; UI &gt; CustomLogos.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n// TODO: replace to .ini\n#define AIAC_LOGO_LIGHT_GRAY \"assets/images/logos/logo_linux_gray_light.png\"\n#define AIAC_LOGO_BLACK \"assets/images/logos/logo_linux_black.png\"\n#define AIAC_LOGO_COLOR \"logo.png\"\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/","title":"File ImGuiFileDialog.cpp","text":"<p>FileList &gt; AIAC &gt; UI &gt; ImGuiFileDialog.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"aiacpch.h\"</code></li> <li><code>#include \"ImGuiFileDialog.h\"</code></li> </ul>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#public-functions","title":"Public Functions","text":"Type Name IMGUIFILEDIALOG_API void IGFD_ClearFilesStyle (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void IGFD_CloseDialog (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API ImGuiFileDialog * IGFD_Create (void)  IMGUIFILEDIALOG_API void IGFD_Destroy (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_DisplayDialog (ImGuiFileDialog * vContext, const char * vKey, ImGuiWindowFlags vFlags, ImVec2 vMinSize, ImVec2 vMaxSize)  IMGUIFILEDIALOG_API char * IGFD_GetCurrentFileName (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API char * IGFD_GetCurrentFilter (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API char * IGFD_GetCurrentPath (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API char * IGFD_GetFilePathName (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_GetFileStyle (ImGuiFileDialog * vContext, IGFD_FileStyleFlags vFlags, const char * vCriteria, ImVec4 * vOutColor, char ** vOutIconText, ImFont ** vOutFont)  IMGUIFILEDIALOG_API IGFD_Selection IGFD_GetSelection (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void * IGFD_GetUserDatas (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_IsKeyOpened (ImGuiFileDialog * vContext, const char * vCurrentOpenedKey)  IMGUIFILEDIALOG_API bool IGFD_IsOk (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_IsOpened (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void IGFD_OpenDialog (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vPath, const char * vFileName, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags flags)  IMGUIFILEDIALOG_API void IGFD_OpenDialog2 (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vFilePathName, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags flags)  IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vPath, const char * vFileName, IGFD_PaneFun vSidePane, const float vSidePaneWidth, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags flags)  IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog2 (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vFilePathName, IGFD_PaneFun vSidePane, const float vSidePaneWidth, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags flags)  IMGUIFILEDIALOG_API void IGFD_Selection_DestroyContent (IGFD_Selection * vSelection)  IMGUIFILEDIALOG_API IGFD_Selection IGFD_Selection_Get (void)  IMGUIFILEDIALOG_API void IGFD_Selection_Pair_DestroyContent (IGFD_Selection_Pair * vSelection_Pair)  IMGUIFILEDIALOG_API IGFD_Selection_Pair IGFD_Selection_Pair_Get (void)  IMGUIFILEDIALOG_API void IGFD_SetFileStyle (ImGuiFileDialog * vContext, IGFD_FileStyleFlags vFlags, const char * vCriteria, ImVec4 vColor, const char * vIcon, ImFont * vFont)  IMGUIFILEDIALOG_API void IGFD_SetFileStyle2 (ImGuiFileDialog * vContext, IGFD_FileStyleFlags vFlags, const char * vCriteria, float vR, float vG, float vB, float vA, const char * vIcon, ImFont * vFont)  IMGUIFILEDIALOG_API bool IGFD_WasKeyOpenedThisFrame (ImGuiFileDialog * vContext, const char * vKey)  IMGUIFILEDIALOG_API bool IGFD_WasOpenedThisFrame (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void SetLocales (ImGuiFileDialog * vContext, const int vCategory, const char * vBeginLocale, const char * vEndLocale)"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#macros","title":"Macros","text":"Type Name define IMGUI_DEFINE_MATH_OPERATORS"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_clearfilesstyle","title":"function IGFD_ClearFilesStyle","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_ClearFilesStyle (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_closedialog","title":"function IGFD_CloseDialog","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_CloseDialog (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_create","title":"function IGFD_Create","text":"<pre><code>IMGUIFILEDIALOG_API ImGuiFileDialog * IGFD_Create (\n    void\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_destroy","title":"function IGFD_Destroy","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_Destroy (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_displaydialog","title":"function IGFD_DisplayDialog","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_DisplayDialog (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    ImGuiWindowFlags vFlags,\n    ImVec2 vMinSize,\n    ImVec2 vMaxSize\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getcurrentfilename","title":"function IGFD_GetCurrentFileName","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetCurrentFileName (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getcurrentfilter","title":"function IGFD_GetCurrentFilter","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetCurrentFilter (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getcurrentpath","title":"function IGFD_GetCurrentPath","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetCurrentPath (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getfilepathname","title":"function IGFD_GetFilePathName","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetFilePathName (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getfilestyle","title":"function IGFD_GetFileStyle","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_GetFileStyle (\n    ImGuiFileDialog * vContext,\n    IGFD_FileStyleFlags vFlags,\n    const char * vCriteria,\n    ImVec4 * vOutColor,\n    char ** vOutIconText,\n    ImFont ** vOutFont\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getselection","title":"function IGFD_GetSelection","text":"<pre><code>IMGUIFILEDIALOG_API IGFD_Selection IGFD_GetSelection (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_getuserdatas","title":"function IGFD_GetUserDatas","text":"<pre><code>IMGUIFILEDIALOG_API void * IGFD_GetUserDatas (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_iskeyopened","title":"function IGFD_IsKeyOpened","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_IsKeyOpened (\n    ImGuiFileDialog * vContext,\n    const char * vCurrentOpenedKey\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_isok","title":"function IGFD_IsOk","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_IsOk (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_isopened","title":"function IGFD_IsOpened","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_IsOpened (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_opendialog","title":"function IGFD_OpenDialog","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenDialog (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vPath,\n    const char * vFileName,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags flags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_opendialog2","title":"function IGFD_OpenDialog2","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenDialog2 (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vFilePathName,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags flags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_openpanedialog","title":"function IGFD_OpenPaneDialog","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vPath,\n    const char * vFileName,\n    IGFD_PaneFun vSidePane,\n    const float vSidePaneWidth,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags flags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_openpanedialog2","title":"function IGFD_OpenPaneDialog2","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog2 (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vFilePathName,\n    IGFD_PaneFun vSidePane,\n    const float vSidePaneWidth,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags flags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_selection_destroycontent","title":"function IGFD_Selection_DestroyContent","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_Selection_DestroyContent (\n    IGFD_Selection * vSelection\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_selection_get","title":"function IGFD_Selection_Get","text":"<pre><code>IMGUIFILEDIALOG_API IGFD_Selection IGFD_Selection_Get (\n    void\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_selection_pair_destroycontent","title":"function IGFD_Selection_Pair_DestroyContent","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_Selection_Pair_DestroyContent (\n    IGFD_Selection_Pair * vSelection_Pair\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_selection_pair_get","title":"function IGFD_Selection_Pair_Get","text":"<pre><code>IMGUIFILEDIALOG_API IGFD_Selection_Pair IGFD_Selection_Pair_Get (\n    void\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_setfilestyle","title":"function IGFD_SetFileStyle","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_SetFileStyle (\n    ImGuiFileDialog * vContext,\n    IGFD_FileStyleFlags vFlags,\n    const char * vCriteria,\n    ImVec4 vColor,\n    const char * vIcon,\n    ImFont * vFont\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_setfilestyle2","title":"function IGFD_SetFileStyle2","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_SetFileStyle2 (\n    ImGuiFileDialog * vContext,\n    IGFD_FileStyleFlags vFlags,\n    const char * vCriteria,\n    float vR,\n    float vG,\n    float vB,\n    float vA,\n    const char * vIcon,\n    ImFont * vFont\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_waskeyopenedthisframe","title":"function IGFD_WasKeyOpenedThisFrame","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_WasKeyOpenedThisFrame (\n    ImGuiFileDialog * vContext,\n    const char * vKey\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-igfd_wasopenedthisframe","title":"function IGFD_WasOpenedThisFrame","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_WasOpenedThisFrame (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#function-setlocales","title":"function SetLocales","text":"<pre><code>IMGUIFILEDIALOG_API void SetLocales (\n    ImGuiFileDialog * vContext,\n    const int vCategory,\n    const char * vBeginLocale,\n    const char * vEndLocale\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/ImGuiFileDialog_8cpp/#define-imgui_define_math_operators","title":"define IMGUI_DEFINE_MATH_OPERATORS","text":"<pre><code>#define IMGUI_DEFINE_MATH_OPERATORS \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/ImGuiFileDialog.cpp</code></p>"},{"location":"acdoxygen/ImGuiFileDialog_8cpp_source/","title":"File ImGuiFileDialog.cpp","text":"<p>File List &gt; AIAC &gt; UI &gt; ImGuiFileDialog.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// This is an independent project of an individual developer. Dear PVS-Studio, please check it.\n// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\nMIT License\n\nCopyright (c) 2019-2020 Stephane Cuillerdier (aka aiekick)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n#include \"aiacpch.h\"\n\n#define IMGUI_DEFINE_MATH_OPERATORS\n#include \"ImGuiFileDialog.h\"\n\n#ifdef __cplusplus\n\n#include &lt;cfloat&gt;\n#include &lt;cstring&gt; // stricmp / strcasecmp\n#include &lt;cstdarg&gt; // variadic\n#include &lt;sstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;ctime&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;cerrno&gt;\n\n// this option need c++17\n#ifdef USE_STD_FILESYSTEM\n    #include &lt;filesystem&gt;\n    #include &lt;exception&gt;\n#endif // USE_STD_FILESYSTEM\n\n#ifdef __EMSCRIPTEN__\n    #include &lt;emscripten.h&gt;\n#endif // __EMSCRIPTEN__\n\n#if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || \\\n    defined(__WIN64__) || defined(WIN64) || defined(_WIN64) || defined(_MSC_VER)\n    #define _IGFD_WIN_\n    #define stat _stat\n    #define stricmp _stricmp\n    #include &lt;cctype&gt;\n    // this option need c++17\n    #ifdef USE_STD_FILESYSTEM\n        #include &lt;Windows.h&gt;\n    #else\n        #include \"dirent/dirent.h\" // directly open the dirent file attached to this lib\n    #endif // USE_STD_FILESYSTEM\n    #define PATH_SEP '\\\\'\n    #ifndef PATH_MAX\n        #define PATH_MAX 260\n    #endif // PATH_MAX\n#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || \\\n    defined(__NetBSD__) || defined(__APPLE__) || defined (__EMSCRIPTEN__)\n    #define _IGFD_UNIX_\n    #define stricmp strcasecmp\n    #include &lt;sys/types.h&gt;\n    // this option need c++17\n    #ifndef USE_STD_FILESYSTEM\n        #include &lt;dirent.h&gt; \n    #endif // USE_STD_FILESYSTEM\n    #define PATH_SEP '/'\n#endif // _IGFD_UNIX_\n\n#include \"imgui.h\"\n#include \"imgui_internal.h\"\n\n#include &lt;cstdlib&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\n#ifdef USE_THUMBNAILS\n#ifndef DONT_DEFINE_AGAIN__STB_IMAGE_IMPLEMENTATION\n#ifndef STB_IMAGE_IMPLEMENTATION\n#define STB_IMAGE_IMPLEMENTATION\n#endif // STB_IMAGE_IMPLEMENTATION\n#endif // DONT_DEFINE_AGAIN__STB_IMAGE_IMPLEMENTATION\n#include \"stb/stb_image.h\"\n#ifndef DONT_DEFINE_AGAIN__STB_IMAGE_RESIZE_IMPLEMENTATION\n#ifndef STB_IMAGE_RESIZE_IMPLEMENTATION\n#define STB_IMAGE_RESIZE_IMPLEMENTATION\n#endif // STB_IMAGE_RESIZE_IMPLEMENTATION\n#endif // DONT_DEFINE_AGAIN__STB_IMAGE_RESIZE_IMPLEMENTATION\n#include \"stb/stb_image_resize.h\"\n#endif // USE_THUMBNAILS\n\nnamespace IGFD\n{\n// float comparisons\n#ifndef IS_FLOAT_DIFFERENT\n#define IS_FLOAT_DIFFERENT(a,b) (fabs((a) - (b)) &gt; FLT_EPSILON)\n#endif // IS_FLOAT_DIFFERENT\n#ifndef IS_FLOAT_EQUAL\n#define IS_FLOAT_EQUAL(a,b) (fabs((a) - (b)) &lt; FLT_EPSILON)\n#endif // IS_FLOAT_EQUAL\n// width of filter combobox\n#ifndef FILTER_COMBO_WIDTH\n#define FILTER_COMBO_WIDTH 150.0f\n#endif // FILTER_COMBO_WIDTH\n// for lets you define your button widget\n// if you have like me a special bi-color button\n#ifndef IMGUI_PATH_BUTTON\n#define IMGUI_PATH_BUTTON ImGui::Button\n#endif // IMGUI_PATH_BUTTON\n#ifndef IMGUI_BUTTON\n#define IMGUI_BUTTON ImGui::Button\n#endif // IMGUI_BUTTON\n// locales\n#ifndef createDirButtonString\n#define createDirButtonString \"+\"\n#endif // createDirButtonString\n#ifndef okButtonString\n#define okButtonString \"OK\"\n#endif // okButtonString\n#ifndef okButtonWidth\n#define okButtonWidth 0.0f\n#endif // okButtonWidth\n#ifndef cancelButtonString\n#define cancelButtonString \"Cancel\"\n#endif // cancelButtonString\n#ifndef cancelButtonWidth\n#define cancelButtonWidth 0.0f\n#endif // cancelButtonWidth\n#ifndef okCancelButtonAlignement\n#define okCancelButtonAlignement 0.0f\n#endif // okCancelButtonAlignement\n#ifndef invertOkAndCancelButtons\n// 0 =&gt; disabled, 1 =&gt; enabled\n#define invertOkAndCancelButtons 0\n#endif // invertOkAndCancelButtons\n#ifndef resetButtonString\n#define resetButtonString \"R\"\n#endif // resetButtonString\n#ifndef drivesButtonString\n#define drivesButtonString \"Drives\"\n#endif // drivesButtonString\n#ifndef editPathButtonString\n#define editPathButtonString \"E\"\n#endif // editPathButtonString\n#ifndef searchString\n#define searchString \"Search :\"\n#endif // searchString\n#ifndef dirEntryString\n#define dirEntryString \"[Dir]\"\n#endif // dirEntryString\n#ifndef linkEntryString\n#define linkEntryString \"[Link]\"\n#endif // linkEntryString\n#ifndef fileEntryString\n#define fileEntryString \"[File]\"\n#endif // fileEntryString\n#ifndef fileNameString\n#define fileNameString \"File Name :\"\n#endif // fileNameString\n#ifndef dirNameString\n#define dirNameString \"Directory Path :\"\n#endif // dirNameString\n#ifndef buttonResetSearchString\n#define buttonResetSearchString \"Reset search\"\n#endif // buttonResetSearchString\n#ifndef buttonDriveString\n#define buttonDriveString \"Drives\"\n#endif // buttonDriveString\n#ifndef buttonEditPathString\n#define buttonEditPathString \"Edit path\\nYou can also right click on path buttons\"\n#endif // buttonEditPathString\n#ifndef buttonResetPathString\n#define buttonResetPathString \"Reset to current directory\"\n#endif // buttonResetPathString\n#ifndef buttonCreateDirString\n#define buttonCreateDirString \"Create Directory\"\n#endif // buttonCreateDirString\n#ifndef tableHeaderAscendingIcon\n#define tableHeaderAscendingIcon \"A|\"\n#endif // tableHeaderAscendingIcon\n#ifndef tableHeaderDescendingIcon\n#define tableHeaderDescendingIcon \"D|\"\n#endif // tableHeaderDescendingIcon\n#ifndef tableHeaderFileNameString\n#define tableHeaderFileNameString \"File name\"\n#endif // tableHeaderFileNameString\n#ifndef tableHeaderFileTypeString\n#define tableHeaderFileTypeString \"Type\"\n#endif // tableHeaderFileTypeString\n#ifndef tableHeaderFileSizeString\n#define tableHeaderFileSizeString \"Size\"\n#endif // tableHeaderFileSizeString\n#ifndef tableHeaderFileDateString\n#define tableHeaderFileDateString \"Date\"\n#endif // tableHeaderFileDateString\n#ifndef fileSizeBytes\n#define fileSizeBytes \"o\"\n#endif // fileSizeBytes\n#ifndef fileSizeKiloBytes\n#define fileSizeKiloBytes \"Ko\"\n#endif // fileSizeKiloBytes\n#ifndef fileSizeMegaBytes\n#define fileSizeMegaBytes \"Mo\"\n#endif // fileSizeMegaBytes\n#ifndef fileSizeGigaBytes\n#define fileSizeGigaBytes \"Go\"\n#endif // fileSizeGigaBytes\n#ifndef OverWriteDialogTitleString\n#define OverWriteDialogTitleString \"The file Already Exist !\"\n#endif // OverWriteDialogTitleString\n#ifndef OverWriteDialogMessageString\n#define OverWriteDialogMessageString \"Would you like to OverWrite it ?\"\n#endif // OverWriteDialogMessageString\n#ifndef OverWriteDialogConfirmButtonString\n#define OverWriteDialogConfirmButtonString \"Confirm\"\n#endif // OverWriteDialogConfirmButtonString\n#ifndef OverWriteDialogCancelButtonString\n#define OverWriteDialogCancelButtonString \"Cancel\"\n#endif // OverWriteDialogCancelButtonString\n// see strftime functionin &lt;ctime&gt; for customize\n#ifndef DateTimeFormat\n#define DateTimeFormat \"%Y/%m/%d %H:%M\"\n#endif // DateTimeFormat\n#ifdef USE_THUMBNAILS\n#ifndef tableHeaderFileThumbnailsString\n#define tableHeaderFileThumbnailsString \"Thumbnails\"\n#endif // tableHeaderFileThumbnailsString\n#ifndef DisplayMode_FilesList_ButtonString\n#define DisplayMode_FilesList_ButtonString \"FL\"\n#endif // DisplayMode_FilesList_ButtonString\n#ifndef DisplayMode_FilesList_ButtonHelp\n#define DisplayMode_FilesList_ButtonHelp \"File List\"\n#endif // DisplayMode_FilesList_ButtonHelp\n#ifndef DisplayMode_ThumbailsList_ButtonString\n#define DisplayMode_ThumbailsList_ButtonString \"TL\"\n#endif // DisplayMode_ThumbailsList_ButtonString\n#ifndef DisplayMode_ThumbailsList_ButtonHelp\n#define DisplayMode_ThumbailsList_ButtonHelp \"Thumbnails List\"\n#endif // DisplayMode_ThumbailsList_ButtonHelp\n#ifndef DisplayMode_ThumbailsGrid_ButtonString\n#define DisplayMode_ThumbailsGrid_ButtonString \"TG\"\n#endif // DisplayMode_ThumbailsGrid_ButtonString\n#ifndef DisplayMode_ThumbailsGrid_ButtonHelp\n#define DisplayMode_ThumbailsGrid_ButtonHelp \"Thumbnails Grid\"\n#endif // DisplayMode_ThumbailsGrid_ButtonHelp\n#ifndef DisplayMode_ThumbailsList_ImageHeight \n#define DisplayMode_ThumbailsList_ImageHeight 32.0f\n#endif // DisplayMode_ThumbailsList_ImageHeight\n#ifndef IMGUI_RADIO_BUTTON\n    inline bool inRadioButton(const char* vLabel, bool vToggled)\n    {\n        bool pressed = false;\n\n        if (vToggled)\n        {\n            ImVec4 bua = ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);\n            ImVec4 te = ImGui::GetStyleColorVec4(ImGuiCol_Text);\n            ImGui::PushStyleColor(ImGuiCol_Button, te);\n            ImGui::PushStyleColor(ImGuiCol_ButtonActive, te);\n            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, te);\n            ImGui::PushStyleColor(ImGuiCol_Text, bua);\n        }\n\n        pressed = IMGUI_BUTTON(vLabel);\n\n        if (vToggled)\n        {\n            ImGui::PopStyleColor(4); //-V112\n        }\n\n        return pressed;\n    }\n#define IMGUI_RADIO_BUTTON inRadioButton\n#endif // IMGUI_RADIO_BUTTON\n#endif  // USE_THUMBNAILS\n#ifdef USE_BOOKMARK\n#ifndef defaultBookmarkPaneWith\n#define defaultBookmarkPaneWith 150.0f\n#endif // defaultBookmarkPaneWith\n#ifndef bookmarksButtonString\n#define bookmarksButtonString \"Bookmark\"\n#endif // bookmarksButtonString\n#ifndef bookmarksButtonHelpString\n#define bookmarksButtonHelpString \"Bookmark\"\n#endif // bookmarksButtonHelpString\n#ifndef addBookmarkButtonString\n#define addBookmarkButtonString \"+\"\n#endif // addBookmarkButtonString\n#ifndef removeBookmarkButtonString\n#define removeBookmarkButtonString \"-\"\n#endif // removeBookmarkButtonString\n#ifndef IMGUI_TOGGLE_BUTTON\n    inline bool inToggleButton(const char* vLabel, bool* vToggled)\n    {\n        bool pressed = false;\n\n        if (vToggled &amp;&amp; *vToggled)\n        {\n            ImVec4 bua = ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);\n            //ImVec4 buh = ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered);\n            //ImVec4 bu = ImGui::GetStyleColorVec4(ImGuiCol_Button);\n            ImVec4 te = ImGui::GetStyleColorVec4(ImGuiCol_Text);\n            ImGui::PushStyleColor(ImGuiCol_Button, te);\n            ImGui::PushStyleColor(ImGuiCol_ButtonActive, te);\n            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, te);\n            ImGui::PushStyleColor(ImGuiCol_Text, bua);\n        }\n\n        pressed = IMGUI_BUTTON(vLabel);\n\n        if (vToggled &amp;&amp; *vToggled)\n        {\n            ImGui::PopStyleColor(4); //-V112\n        }\n\n        if (vToggled &amp;&amp; pressed)\n            *vToggled = !*vToggled;\n\n        return pressed;\n    }\n#define IMGUI_TOGGLE_BUTTON inToggleButton\n#endif // IMGUI_TOGGLE_BUTTON\n#endif // USE_BOOKMARK\n\n\n#ifndef USE_STD_FILESYSTEM\n    inline int inAlphaSort(const struct dirent** a, const struct dirent** b)\n    {\n        return strcoll((*a)-&gt;d_name, (*b)-&gt;d_name);\n    }\n#endif\n\n\n    IGFD::FileStyle::FileStyle() \n        : color(0, 0, 0, 0)\n    { \n\n    }\n\n    IGFD::FileStyle::FileStyle(const FileStyle&amp; vStyle)\n    {\n        color = vStyle.color;\n        icon = vStyle.icon;\n        font = vStyle.font;\n        flags = vStyle.flags;\n    }\n\n    IGFD::FileStyle::FileStyle(const ImVec4&amp; vColor, const std::string&amp; vIcon, ImFont* vFont) \n        : color(vColor), icon(vIcon), font(vFont)\n    { \n\n    }\n\n\n    // https://github.com/ocornut/imgui/issues/1720\n    bool IGFD::Utils::Splitter(bool split_vertically, float thickness, float* size1, float* size2, float min_size1, float min_size2, float splitter_long_axis_size)\n    {\n        using namespace ImGui;\n        ImGuiContext&amp; g = *GImGui;\n        ImGuiWindow* window = g.CurrentWindow;\n        ImGuiID id = window-&gt;GetID(\"##Splitter\");\n        ImRect bb;\n        bb.Min = window-&gt;DC.CursorPos + (split_vertically ? ImVec2(*size1, 0.0f) : ImVec2(0.0f, *size1));\n        bb.Max = bb.Min + CalcItemSize(split_vertically ? ImVec2(thickness, splitter_long_axis_size) : ImVec2(splitter_long_axis_size, thickness), 0.0f, 0.0f);\n        return SplitterBehavior(bb, id, split_vertically ? ImGuiAxis_X : ImGuiAxis_Y, size1, size2, min_size1, min_size2, 1.0f);\n    }\n\n    bool IGFD::Utils::WReplaceString(std::wstring&amp; str, const std::wstring&amp; oldStr, const std::wstring&amp; newStr)\n    {\n        bool found = false;\n#ifdef _IGFD_WIN_\n        size_t pos = 0;\n        while ((pos = str.find(oldStr, pos)) != std::wstring::npos)\n        {\n            found = true;\n            str.replace(pos, oldStr.length(), newStr);\n            pos += newStr.length();\n        }\n#endif // _IGFD_WIN_\n        return found;\n    }\n\n    std::vector&lt;std::wstring&gt; IGFD::Utils::WSplitStringToVector(const std::wstring&amp; text, char delimiter, bool pushEmpty)\n    {\n        std::vector&lt;std::wstring&gt; arr;\n#ifdef _IGFD_WIN_\n        if (!text.empty())\n        {\n            std::wstring::size_type start = 0;\n            std::wstring::size_type end = text.find(delimiter, start);\n            while (end != std::wstring::npos)\n            {\n                std::wstring token = text.substr(start, end - start);\n                if (!token.empty() || (token.empty() &amp;&amp; pushEmpty)) //-V728\n                    arr.push_back(token);\n                start = end + 1;\n                end = text.find(delimiter, start);\n            }\n            std::wstring token = text.substr(start);\n            if (!token.empty() || (token.empty() &amp;&amp; pushEmpty)) //-V728\n                arr.push_back(token);\n        }\n#endif // _IGFD_WIN_\n        return arr;\n    }\n\n    // Convert a wide Unicode string to an UTF8 string\n    std::string IGFD::Utils::utf8_encode(const std::wstring &amp;wstr)\n    {\n        std::string res;\n#ifdef _IGFD_WIN_\n        if(!wstr.empty())\n        {\n            int size_needed = WideCharToMultiByte(CP_UTF8, 0, &amp;wstr[0],\n            (int)wstr.size(), NULL, 0, NULL, NULL);\n            if (size_needed)\n            {\n                res = std::string(size_needed, 0);\n                WideCharToMultiByte (CP_UTF8, 0, &amp;wstr[0],\n                    (int)wstr.size(), &amp;res[0], size_needed, NULL, NULL);\n            }\n        }\n#endif // _IGFD_WIN_\n        return res;\n    }\n\n    // Convert an UTF8 string to a wide Unicode String\n    std::wstring IGFD::Utils::utf8_decode(const std::string &amp;str)\n    {\n        std::wstring res;\n#ifdef _IGFD_WIN_\n        if( !str.empty())\n        {\n            int size_needed = MultiByteToWideChar(CP_UTF8, 0, &amp;str[0],\n                (int)str.size(), NULL, 0);\n            if (size_needed)\n            {\n                res = std::wstring(size_needed, 0);\n                MultiByteToWideChar(CP_UTF8, 0, &amp;str[0],\n                    (int)str.size(), &amp;res[0], size_needed);\n            }\n        }\n#endif // _IGFD_WIN_\n        return res;\n    }\n\n    bool IGFD::Utils::ReplaceString(std::string&amp; str, const std::string&amp; oldStr, const std::string&amp; newStr)\n    {\n        bool found = false;\n        size_t pos = 0;\n        while ((pos = str.find(oldStr, pos)) != std::string::npos)\n        {\n            found = true;\n            str.replace(pos, oldStr.length(), newStr);\n            pos += newStr.length();\n        }\n        return found;\n    }\n\n    std::vector&lt;std::string&gt; IGFD::Utils::SplitStringToVector(const std::string&amp; text, char delimiter, bool pushEmpty)\n    {\n        std::vector&lt;std::string&gt; arr;\n        if (!text.empty())\n        {\n            size_t start = 0;\n            size_t end = text.find(delimiter, start);\n            while (end != std::string::npos)\n            {\n                auto token = text.substr(start, end - start);\n                if (!token.empty() || (token.empty() &amp;&amp; pushEmpty)) //-V728\n                    arr.push_back(token);\n                start = end + 1;\n                end = text.find(delimiter, start);\n            }\n            auto token = text.substr(start);\n            if (!token.empty() || (token.empty() &amp;&amp; pushEmpty)) //-V728\n                arr.push_back(token);\n        }\n        return arr;\n    }\n\n    std::vector&lt;std::string&gt; IGFD::Utils::GetDrivesList()\n    {\n        std::vector&lt;std::string&gt; res;\n\n#ifdef _IGFD_WIN_\n        const DWORD mydrives = 2048;\n        char lpBuffer[2048];\n#define mini(a,b) (((a) &lt; (b)) ? (a) : (b))\n        const DWORD countChars = mini(GetLogicalDriveStringsA(mydrives, lpBuffer), 2047);\n#undef mini\n        if (countChars &gt; 0U &amp;&amp; countChars &lt; 2049U)\n        {\n            std::string var = std::string(lpBuffer, (size_t)countChars);\n            IGFD::Utils::ReplaceString(var, \"\\\\\", \"\");\n            res = IGFD::Utils::SplitStringToVector(var, '\\0', false);\n        }\n#endif // _IGFD_WIN_\n\n        return res;\n    }\n\n    bool IGFD::Utils::IsDirectoryCanBeOpened(const std::string&amp; name)\n    {\n        bool bExists = false;\n\n        if (!name.empty())\n        {\n#ifdef USE_STD_FILESYSTEM\n            namespace fs = std::filesystem;\n#ifdef _IGFD_WIN_\n            std::wstring wname = IGFD::Utils::utf8_decode(name.c_str());\n            fs::path pathName = fs::path(wname);\n#else // _IGFD_WIN_\n            fs::path pathName = fs::path(name);\n#endif // _IGFD_WIN_\n            try\n            {\n                // interesting, in the case of a protected dir or for any reason the dir cant be opened\n                // this func will work but will say nothing more . not like the dirent version\n                bExists = fs::is_directory(pathName);\n                // test if can be opened, this function can thrown an exception if there is an issue with this dir\n                // here, the dir_iter is need else not exception is thrown.. \n                const auto dir_iter = std::filesystem::directory_iterator(pathName);\n                (void)dir_iter; // for avoid unused warnings\n            }\n            catch (std::exception /*ex*/)\n            {\n                // fail so this dir cant be opened\n                bExists = false;\n            }\n#else\n            DIR* pDir = nullptr;\n            // interesting, in the case of a protected dir or for any reason the dir cant be opened\n            // this func will fail\n            pDir = opendir(name.c_str());\n            if (pDir != nullptr)\n            {\n                bExists = true;\n                (void)closedir(pDir);\n            }\n#endif // USE_STD_FILESYSTEM\n        }\n\n        return bExists;    // this is not a directory!\n    }\n\n    bool IGFD::Utils::IsDirectoryExist(const std::string&amp; name)\n    {\n        bool bExists = false;\n\n        if (!name.empty())\n        {\n#ifdef USE_STD_FILESYSTEM\n            namespace fs = std::filesystem;\n#ifdef _IGFD_WIN_\n            std::wstring wname = IGFD::Utils::utf8_decode(name.c_str());\n            fs::path pathName = fs::path(wname);\n#else // _IGFD_WIN_\n            fs::path pathName = fs::path(name);\n#endif // _IGFD_WIN_\n            bExists = fs::is_directory(pathName);\n#else\n            DIR* pDir = nullptr;\n            pDir = opendir(name.c_str());\n            if (pDir)\n            {\n                bExists = true; \n                closedir(pDir);\n            }\n            else if (ENOENT == errno) \n            {\n                /* Directory does not exist. */\n                //bExists = false;\n            }\n            else \n            {\n                /* opendir() failed for some other reason. \n                   like if a dir is protected, or not accessable with user right\n                */\n                bExists = true;\n            }\n#endif // USE_STD_FILESYSTEM\n        }\n\n        return bExists;    // this is not a directory!\n    }\n\n    bool IGFD::Utils::CreateDirectoryIfNotExist(const std::string&amp; name)\n    {\n        bool res = false;\n\n        if (!name.empty())\n        {\n            if (!IsDirectoryExist(name))\n            {\n#ifdef _IGFD_WIN_\n    #ifdef USE_STD_FILESYSTEM\n                    namespace fs = std::filesystem;\n                    std::wstring wname = IGFD::Utils::utf8_decode(name.c_str());\n                    fs::path pathName = fs::path(wname);\n                    res = fs::create_directory(pathName);\n    #else // USE_STD_FILESYSTEM\n                    std::wstring wname = IGFD::Utils::utf8_decode(name);\n                    if (CreateDirectoryW(wname.c_str(), nullptr))\n                    {\n                        res = true;\n                    }\n    #endif // USE_STD_FILESYSTEM\n#elif defined(__EMSCRIPTEN__) // _IGFD_WIN_\n                std::string str = std::string(\"FS.mkdir('\") + name + \"');\";\n                emscripten_run_script(str.c_str());\n                res = true;\n#elif defined(_IGFD_UNIX_)\n                char buffer[PATH_MAX] = {};\n                snprintf(buffer, PATH_MAX, \"mkdir -p \\\"%s\\\"\", name.c_str()); \n                const int dir_err = std::system(buffer);\n                if (dir_err != -1)\n                {\n                    res = true;\n                }\n#endif // _IGFD_WIN_\n                if (!res) {\n                    std::cout &lt;&lt; \"Error creating directory \" &lt;&lt; name &lt;&lt; std::endl;\n                }\n            }\n        }\n\n        return res;\n    }\n\n#ifdef USE_STD_FILESYSTEM\n    // https://github.com/aiekick/ImGuiFileDialog/issues/54\n    IGFD::Utils::PathStruct IGFD::Utils::ParsePathFileName(const std::string&amp; vPathFileName)\n    {\n        namespace fs = std::filesystem;\n        PathStruct res;\n        if (vPathFileName.empty())\n            return res;\n\n        auto fsPath = fs::path(vPathFileName);\n\n        if (fs::is_directory(fsPath)) {\n            res.name = \"\";\n            res.path = fsPath.string();\n            res.isOk = true;\n\n        } else if (fs::is_regular_file(fsPath)) {\n            res.name = fsPath.filename().string();\n            res.path = fsPath.parent_path().string();\n            res.isOk = true;\n        }\n\n        return res;\n    }\n#else\n    IGFD::Utils::PathStruct IGFD::Utils::ParsePathFileName(const std::string&amp; vPathFileName)\n    {\n        PathStruct res;\n\n        if (!vPathFileName.empty())\n        {\n            std::string pfn = vPathFileName;\n            std::string separator(1u, PATH_SEP);\n            IGFD::Utils::ReplaceString(pfn, \"\\\\\", separator);\n            IGFD::Utils::ReplaceString(pfn, \"/\", separator);\n\n            size_t lastSlash = pfn.find_last_of(separator);\n            if (lastSlash != std::string::npos)\n            {\n                res.name = pfn.substr(lastSlash + 1);\n                res.path = pfn.substr(0, lastSlash);\n                res.isOk = true;\n            }\n\n            size_t lastPoint = pfn.find_last_of('.');\n            if (lastPoint != std::string::npos)\n            {\n                if (!res.isOk)\n                {\n                    res.name = pfn;\n                    res.isOk = true;\n                }\n                res.ext = pfn.substr(lastPoint + 1);\n                IGFD::Utils::ReplaceString(res.name, \".\" + res.ext, \"\");\n            }\n\n            if (!res.isOk)\n            {\n                res.name = std::move(pfn);\n                res.isOk = true;\n            }\n        }\n\n        return res;\n    }\n#endif // USE_STD_FILESYSTEM\n\n    void IGFD::Utils::AppendToBuffer(char* vBuffer, size_t vBufferLen, const std::string&amp; vStr)\n    {\n        std::string st = vStr;\n        size_t len = vBufferLen - 1u;\n        size_t slen = strlen(vBuffer);\n\n        if (!st.empty() &amp;&amp; st != \"\\n\")\n        {\n            IGFD::Utils::ReplaceString(st, \"\\n\", \"\");\n            IGFD::Utils::ReplaceString(st, \"\\r\", \"\");\n        }\n        vBuffer[slen] = '\\0';\n        std::string str = std::string(vBuffer);\n        //if (!str.empty()) str += \"\\n\";\n        str += vStr;\n        if (len &gt; str.size()) len = str.size();\n#ifdef _MSC_VER\n        strncpy_s(vBuffer, vBufferLen, str.c_str(), len);\n#else // _MSC_VER\n        strncpy(vBuffer, str.c_str(), len);\n#endif // _MSC_VER\n        vBuffer[len] = '\\0';\n    }\n\n    void IGFD::Utils::ResetBuffer(char* vBuffer)\n    {\n        vBuffer[0] = '\\0';\n    }\n\n    void IGFD::Utils::SetBuffer(char* vBuffer, size_t vBufferLen, const std::string&amp; vStr)\n    {\n        ResetBuffer(vBuffer);\n        AppendToBuffer(vBuffer, vBufferLen, vStr);\n    }\n\n    std::string IGFD::Utils::LowerCaseString(const std::string&amp; vString)\n    {\n        auto str = vString;\n\n        // convert to lower case\n        for (char&amp; c : str)\n            c = (char)std::tolower(c);\n\n        return str;\n    }\n\n\n    bool IGFD::FileInfos::IsTagFound(const std::string&amp; vTag) const\n    {\n        if (!vTag.empty())\n        {\n            if (fileNameExt_optimized == \"..\") return true;\n\n            return\n                fileNameExt_optimized.find(vTag) != std::string::npos ||    // first try wihtout case and accents\n                fileNameExt.find(vTag) != std::string::npos;                // second if searched with case and accents\n        }\n\n        // if tag is empty =&gt; its a special case but all is found\n        return true;\n    }\n\n\n    void IGFD::SearchManager::Clear()\n    {\n        puSearchTag.clear();\n        IGFD::Utils::ResetBuffer(puSearchBuffer);\n    }\n\n    void IGFD::SearchManager::DrawSearchBar(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        // search field\n        if (IMGUI_BUTTON(resetButtonString \"##BtnImGuiFileDialogSearchField\"))\n        {\n            Clear();\n            vFileDialogInternal.puFileManager.ApplyFilteringOnFileList(vFileDialogInternal);\n        }\n        if (ImGui::IsItemHovered())\n            ImGui::SetTooltip(buttonResetSearchString);\n        ImGui::SameLine();\n        ImGui::Text(searchString);\n        ImGui::SameLine();\n        ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x);\n        bool edited = ImGui::InputText(\"##InputImGuiFileDialogSearchField\", puSearchBuffer, MAX_FILE_DIALOG_NAME_BUFFER);\n        if (ImGui::GetItemID() == ImGui::GetActiveID())\n            /* ADD HERE TOUCH */\n            std::cout &lt;&lt; \"Search bar selected\" &lt;&lt; std::endl;  // DEBUG\n            puSearchInputIsActive = true;\n        ImGui::PopItemWidth();\n        if (edited)\n        {\n            puSearchTag = puSearchBuffer;\n            vFileDialogInternal.puFileManager.ApplyFilteringOnFileList(vFileDialogInternal);\n        }\n    }\n\n\n    void IGFD::FilterManager::FilterInfos::clear()\n    {\n        filter.clear();\n        filter_regex = std::regex();\n        collectionfilters.clear();\n        filter_optimized.clear();\n        collectionfilters_optimized.clear();\n        collectionfilters_regex.clear();\n    }\n\n    bool IGFD::FilterManager::FilterInfos::empty() const\n    {\n        return filter.empty() &amp;&amp; collectionfilters.empty();\n    }\n\n    bool IGFD::FilterManager::FilterInfos::exist(const std::string&amp; vFilter, bool vIsCaseInsensitive) const\n    {\n        if (vIsCaseInsensitive)\n        {\n            auto _filter = Utils::LowerCaseString(vFilter);\n            return\n                filter_optimized == _filter ||\n                (collectionfilters_optimized.find(_filter) != collectionfilters_optimized.end());\n        }\n        return \n            filter == vFilter || \n            (collectionfilters.find(vFilter) != collectionfilters.end());\n    }\n\n    bool IGFD::FilterManager::FilterInfos::regex_exist(const std::string&amp; vFilter) const\n    {\n        if (std::regex_search(vFilter, filter_regex))\n        {\n            return true;\n        }\n        else\n        {\n            for (auto regex : collectionfilters_regex)\n            {\n                if (std::regex_search(vFilter, regex))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n\n    void IGFD::FilterManager::ParseFilters(const char* vFilters)\n    {\n        prParsedFilters.clear();\n\n        if (vFilters)\n            puDLGFilters = vFilters;            // file mode\n        else\n            puDLGFilters.clear();               // directory mode\n\n        if (!puDLGFilters.empty())\n        {\n            // \".*,.cpp,.h,.hpp\" =&gt; simple filters\n            // \"Source files{.cpp,.h,.hpp},Image files{.png,.gif,.jpg,.jpeg},.md\" =&gt; collection filters\n            // \"([.][0-9]{3}),.cpp,.h,.hpp\" =&gt; simple filters with regex\n            // \"frames files{([.][0-9]{3}),.frames}\" =&gt; collection filters with regex\n\n            bool currentFilterFound = false;\n\n            size_t nan = std::string::npos;\n            size_t p = 0, lp = 0;\n            while ((p = puDLGFilters.find_first_of(\"{,\", p)) != nan)\n            {\n                FilterInfos infos;\n\n                if (puDLGFilters[p] == '{') // {\n                {\n                    infos.filter = puDLGFilters.substr(lp, p - lp);\n                    infos.filter_optimized = Utils::LowerCaseString(infos.filter);\n                    p++;\n                    lp = puDLGFilters.find('}', p);\n                    if (lp != nan)\n                    {\n                        std::string fs = puDLGFilters.substr(p, lp - p);\n                        auto arr = IGFD::Utils::SplitStringToVector(fs, ',', false);\n                        for (auto a : arr)\n                        {\n                            infos.collectionfilters.emplace(a);\n                            infos.collectionfilters_optimized.emplace(Utils::LowerCaseString(a));\n\n                            // a regex\n                            if (a.find('(') != std::string::npos) {\n                                if (a.find(')') != std::string::npos) {\n                                    infos.collectionfilters_regex.push_back(std::regex(a));\n                                }\n                            }\n                        }\n                    }\n                    p = lp + 1;\n                }\n                else // ,\n                {\n                    infos.filter = puDLGFilters.substr(lp, p - lp);\n                    infos.filter_optimized = Utils::LowerCaseString(infos.filter);\n\n                    // a regex\n                    if (infos.filter.find('(') != std::string::npos) {\n                        if (infos.filter.find(')') != std::string::npos) {\n                            infos.filter_regex = std::regex(infos.filter);\n                        }\n                    }\n\n                    p++;\n                }\n\n                if (!currentFilterFound &amp;&amp; prSelectedFilter.filter == infos.filter)\n                {\n                    currentFilterFound = true;\n                    prSelectedFilter = infos;\n                }\n\n                lp = p;\n                if (!infos.empty())\n                    prParsedFilters.emplace_back(infos);\n            }\n\n            std::string token = puDLGFilters.substr(lp);\n            if (!token.empty())\n            {\n                FilterInfos infos;\n                infos.filter = std::move(token);\n                prParsedFilters.emplace_back(infos);\n            }\n\n            if (!currentFilterFound)\n                if (!prParsedFilters.empty())\n                    prSelectedFilter = *prParsedFilters.begin();\n        }\n    }\n\n    void IGFD::FilterManager::SetSelectedFilterWithExt(const std::string&amp; vFilter)\n    {\n        if (!prParsedFilters.empty())\n        {\n            if (!vFilter.empty())\n            {\n                // std::map&lt;std::string, FilterInfos&gt;\n                for (const auto&amp; infos : prParsedFilters)\n                {\n                    if (vFilter == infos.filter)\n                    {\n                        prSelectedFilter = infos;\n                    }\n                    else\n                    {\n                        // maybe this ext is in an extention so we will \n                        // explore the collections is they are existing\n                        for (const auto&amp; filter : infos.collectionfilters)\n                        {\n                            if (vFilter == filter)\n                            {\n                                prSelectedFilter = infos;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (prSelectedFilter.empty())\n                prSelectedFilter = *prParsedFilters.begin();\n        }\n    }\n\n    void IGFD::FilterManager::SetFileStyle(const IGFD_FileStyleFlags&amp; vFlags, const char* vCriteria, const FileStyle&amp; vInfos)\n    {\n        std::string _criteria;\n        if (vCriteria)\n            _criteria = std::string(vCriteria);\n        prFilesStyle[vFlags][_criteria] = std::make_shared&lt;FileStyle&gt;(vInfos);\n        prFilesStyle[vFlags][_criteria]-&gt;flags = vFlags;\n    }\n\n    // will be called internally \n    // will not been exposed to IGFD API\n    bool IGFD::FilterManager::prFillFileStyle(std::shared_ptr&lt;FileInfos&gt; vFileInfos) const\n    {\n        // todo : better system to found regarding what style to priorize regarding other\n        // maybe with a lambda fucntion for let the user use his style\n        // according to his use case\n        if (vFileInfos.use_count() &amp;&amp; !prFilesStyle.empty())\n        {\n            for (const auto&amp; _flag : prFilesStyle)\n            {\n                for (const auto&amp; _file : _flag.second)\n                {\n                    if ((_flag.first &amp; IGFD_FileStyleByTypeDir &amp;&amp; _flag.first &amp; IGFD_FileStyleByTypeLink &amp;&amp; vFileInfos-&gt;fileType.isDir() &amp;&amp; vFileInfos-&gt;fileType.isSymLink()) ||\n                        (_flag.first &amp; IGFD_FileStyleByTypeFile &amp;&amp; _flag.first &amp; IGFD_FileStyleByTypeLink &amp;&amp; vFileInfos-&gt;fileType.isFile() &amp;&amp; vFileInfos-&gt;fileType.isSymLink()) ||\n                        (_flag.first &amp; IGFD_FileStyleByTypeLink &amp;&amp; vFileInfos-&gt;fileType.isSymLink()) ||\n                        (_flag.first &amp; IGFD_FileStyleByTypeDir &amp;&amp; vFileInfos-&gt;fileType.isDir()) ||\n                        (_flag.first &amp; IGFD_FileStyleByTypeFile &amp;&amp; vFileInfos-&gt;fileType.isFile()))\n                    {\n                        if (_file.first.empty()) // for all links\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                        else if (_file.first.find('(') != std::string::npos &amp;&amp;\n                            std::regex_search(vFileInfos-&gt;fileNameExt, std::regex(_file.first)))  // for links who are equal to style criteria\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                        else if (_file.first == vFileInfos-&gt;fileNameExt)  // for links who are equal to style criteria\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                    }           \n\n                    if (_flag.first &amp; IGFD_FileStyleByExtention)\n                    {\n                        if (_file.first.find('(') != std::string::npos &amp;&amp;\n                            std::regex_search(vFileInfos-&gt;fileExt, std::regex(_file.first)))\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                        else if (_file.first == vFileInfos-&gt;fileExt)\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                    }\n\n                    if (_flag.first &amp; IGFD_FileStyleByFullName)\n                    {\n                        if (_file.first.find('(') != std::string::npos &amp;&amp;\n                            std::regex_search(vFileInfos-&gt;fileNameExt, std::regex(_file.first)))\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                        else if (_file.first == vFileInfos-&gt;fileNameExt)\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                    }\n\n                    if (_flag.first &amp; IGFD_FileStyleByContainedInFullName)\n                    {\n                        if (_file.first.find('(') != std::string::npos &amp;&amp;\n                            std::regex_search(vFileInfos-&gt;fileNameExt, std::regex(_file.first)))\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                        else if (vFileInfos-&gt;fileNameExt.find(_file.first) != std::string::npos)\n                        {\n                            vFileInfos-&gt;fileStyle = _file.second;\n                        }\n                    }\n\n                    if (vFileInfos-&gt;fileStyle.use_count())\n                        return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    void IGFD::FilterManager::SetFileStyle(const IGFD_FileStyleFlags&amp; vFlags, const char* vCriteria, const ImVec4&amp; vColor, const std::string&amp; vIcon, ImFont* vFont)\n    {\n        std::string _criteria;\n        if (vCriteria)\n            _criteria = std::string(vCriteria);\n        prFilesStyle[vFlags][_criteria] = std::make_shared&lt;FileStyle&gt;(vColor, vIcon, vFont);\n        prFilesStyle[vFlags][_criteria]-&gt;flags = vFlags;\n    }\n\n    // todo : to refactor this fucking function\n    bool IGFD::FilterManager::GetFileStyle(const IGFD_FileStyleFlags&amp; vFlags, const std::string&amp; vCriteria, ImVec4* vOutColor, std::string* vOutIcon, ImFont **vOutFont)\n    {\n        if (vOutColor)\n        {\n            if (!prFilesStyle.empty())\n            {\n                if (prFilesStyle.find(vFlags) != prFilesStyle.end()) // found\n                {\n                    if (vFlags &amp; IGFD_FileStyleByContainedInFullName)\n                    {\n                        // search for vCriteria who are containing the criteria\n                        for (const auto&amp; _file : prFilesStyle.at(vFlags))\n                        {\n                            if (vCriteria.find(_file.first) != std::string::npos)\n                            {\n                                if (_file.second.use_count())\n                                {\n                                    *vOutColor = _file.second-&gt;color;\n                                    if (vOutIcon)\n                                        *vOutIcon = _file.second-&gt;icon;\n                                    if (vOutFont)\n                                        *vOutFont = _file.second-&gt;font;\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if (prFilesStyle.at(vFlags).find(vCriteria) != prFilesStyle.at(vFlags).end()) // found\n                        {\n                            *vOutColor = prFilesStyle[vFlags][vCriteria]-&gt;color;\n                            if (vOutIcon)\n                                *vOutIcon = prFilesStyle[vFlags][vCriteria]-&gt;icon;\n                            if (vOutFont)\n                                *vOutFont = prFilesStyle[vFlags][vCriteria]-&gt;font;\n                            return true;\n                        }\n                    }\n                }\n                else\n                {\n                    // search for flag composition\n                    for (const auto&amp; _flag : prFilesStyle)\n                    {\n                        if (_flag.first &amp; vFlags)\n                        {\n                            if (_flag.first &amp; IGFD_FileStyleByContainedInFullName)\n                            {\n                                // search for vCriteria who are containing the criteria\n                                for (const auto&amp; _file : prFilesStyle.at(_flag.first))\n                                {\n                                    if (vCriteria.find(_file.first) != std::string::npos)\n                                    {\n                                        if (_file.second.use_count())\n                                        {\n                                            *vOutColor = _file.second-&gt;color;\n                                            if (vOutIcon)\n                                                *vOutIcon = _file.second-&gt;icon;\n                                            if (vOutFont)\n                                                *vOutFont = _file.second-&gt;font;\n                                            return true;\n                                        }\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                if (prFilesStyle.at(_flag.first).find(vCriteria) != prFilesStyle.at(_flag.first).end()) // found\n                                {\n                                    *vOutColor = prFilesStyle[_flag.first][vCriteria]-&gt;color;\n                                    if (vOutIcon)\n                                        *vOutIcon = prFilesStyle[_flag.first][vCriteria]-&gt;icon;\n                                    if (vOutFont)\n                                        *vOutFont = prFilesStyle[_flag.first][vCriteria]-&gt;font;\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    void IGFD::FilterManager::ClearFilesStyle()\n    {\n        prFilesStyle.clear();\n    }\n\n    bool IGFD::FilterManager::IsCoveredByFilters(const std::string&amp; vNameExt, const std::string&amp; vExt, bool vIsCaseInsensitive) const\n    {\n        if (!puDLGFilters.empty() &amp;&amp; !prSelectedFilter.empty())\n        {\n            // check if current file extention is covered by current filter\n            // we do that here, for avoid doing that during filelist display\n            // for better fps\n            return (\n                prSelectedFilter.exist(vExt, vIsCaseInsensitive) ||\n                prSelectedFilter.exist(\".*\", vIsCaseInsensitive) ||\n                prSelectedFilter.exist(\"*.*\", vIsCaseInsensitive) ||\n                prSelectedFilter.filter == \".*\" ||\n                prSelectedFilter.regex_exist(vNameExt));\n        }\n\n        return false;\n    }\n\n    bool IGFD::FilterManager::DrawFilterComboBox(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        // combobox of filters\n        if (!puDLGFilters.empty())\n        {\n            ImGui::SameLine();\n\n            bool needToApllyNewFilter = false;\n\n            ImGui::PushItemWidth(FILTER_COMBO_WIDTH);\n            if (ImGui::BeginCombo(\"##Filters\", prSelectedFilter.filter.c_str(), ImGuiComboFlags_None))\n            {\n                intptr_t i = 0;\n                for (const auto&amp; filter : prParsedFilters)\n                {\n                    const bool item_selected = (filter.filter == prSelectedFilter.filter);\n                    ImGui::PushID((void*)(intptr_t)i++);\n                    if (ImGui::Selectable(filter.filter.c_str(), item_selected))\n                    {\n                        prSelectedFilter = filter;\n                        needToApllyNewFilter = true;\n                    }\n                    ImGui::PopID();\n                }\n\n                ImGui::EndCombo();\n            }\n            ImGui::PopItemWidth();\n\n            if (needToApllyNewFilter)\n            {\n                vFileDialogInternal.puFileManager.OpenCurrentPath(vFileDialogInternal);\n            }\n\n            return needToApllyNewFilter;\n        }\n\n        return false;\n    }\n\n    IGFD::FilterManager::FilterInfos IGFD::FilterManager::GetSelectedFilter()\n    {\n        return prSelectedFilter;\n    }\n\n    std::string IGFD::FilterManager::ReplaceExtentionWithCurrentFilter(const std::string&amp; vFile) const\n    {\n        auto result = vFile;\n\n        if (!result.empty())\n        {\n            // if not a collection we can replace the filter by the extention we want\n            if (prSelectedFilter.collectionfilters.empty() &amp;&amp; \n                prSelectedFilter.filter != \".*\" &amp;&amp;\n                prSelectedFilter.filter != \"*.*\")\n            {\n                size_t lastPoint = vFile.find_last_of('.');\n                if (lastPoint != std::string::npos)\n                {\n                    result = result.substr(0, lastPoint);\n                }\n\n                result += prSelectedFilter.filter;\n            }\n        }\n\n        return result;\n    }\n\n    void IGFD::FilterManager::SetDefaultFilterIfNotDefined()\n    {\n        if (prSelectedFilter.empty() &amp;&amp; // no filter selected\n            !prParsedFilters.empty()) // filter exist\n            prSelectedFilter = *prParsedFilters.begin(); // we take the first filter\n    }\n\n\n    IGFD::FileManager::FileManager()\n    {\n        puFsRoot = std::string(1u, PATH_SEP);\n    }\n\n    void IGFD::FileManager::OpenCurrentPath(const FileDialogInternal&amp; vFileDialogInternal)\n    {\n        puShowDrives = false;\n        ClearComposer();\n        ClearFileLists();\n        if (puDLGDirectoryMode) // directory mode\n            SetDefaultFileName(\".\");\n        else\n            SetDefaultFileName(puDLGDefaultFileName);\n        ScanDir(vFileDialogInternal, GetCurrentPath());\n    }\n\n    void IGFD::FileManager::SortFields(const FileDialogInternal&amp; vFileDialogInternal)\n    {\n        SortFields(vFileDialogInternal, prFileList, prFilteredFileList);\n    }\n\n    void IGFD::FileManager::SortFields(const FileDialogInternal&amp; vFileDialogInternal, \n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosList,\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosFilteredList)\n    {\n        if (puSortingField != SortingFieldEnum::FIELD_NONE)\n        {\n            puHeaderFileName = tableHeaderFileNameString;\n            puHeaderFileType = tableHeaderFileTypeString;\n            puHeaderFileSize = tableHeaderFileSizeString;\n            puHeaderFileDate = tableHeaderFileDateString;\n#ifdef USE_THUMBNAILS\n            puHeaderFileThumbnails = tableHeaderFileThumbnailsString;\n#endif // #ifdef USE_THUMBNAILS\n        }\n\n        if (puSortingField == SortingFieldEnum::FIELD_FILENAME)\n        {\n            if (puSortingDirection[0])\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileName = tableHeaderAscendingIcon + puHeaderFileName;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        // this code fail in c:\\\\Users with the link \"All users\". got a invalid comparator\n                        /*\n                        // use code from https://github.com/jackm97/ImGuiFileDialog/commit/bf40515f5a1de3043e60562dc1a494ee7ecd3571\n                        // strict ordering for file/directory types beginning in '.'\n                        // common on _IGFD_WIN_ platforms\n                        if (a-&gt;fileNameExt[0] == '.' &amp;&amp; b-&gt;fileNameExt[0] != '.')\n                            return false;\n                        if (a-&gt;fileNameExt[0] != '.' &amp;&amp; b-&gt;fileNameExt[0] == '.')\n                            return true;\n                        if (a-&gt;fileNameExt[0] == '.' &amp;&amp; b-&gt;fileNameExt[0] == '.')\n                        {\n                            return (stricmp(a-&gt;fileNameExt.c_str(), b-&gt;fileNameExt.c_str()) &lt; 0); // sort in insensitive case\n                        }\n                        */\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &lt; b-&gt;fileType); // directories first\n                        return (stricmp(a-&gt;fileNameExt.c_str(), b-&gt;fileNameExt.c_str()) &lt; 0); // sort in insensitive case\n                    });\n            }\n            else\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileName = tableHeaderDescendingIcon + puHeaderFileName;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        // this code fail in c:\\\\Users with the link \"All users\". got a invalid comparator\n                        /*\n                        // use code from https://github.com/jackm97/ImGuiFileDialog/commit/bf40515f5a1de3043e60562dc1a494ee7ecd3571\n                        // strict ordering for file/directory types beginning in '.'\n                        // common on _IGFD_WIN_ platforms\n                        if (a-&gt;fileNameExt[0] == '.' &amp;&amp; b-&gt;fileNameExt[0] != '.')\n                            return false;\n                        if (a-&gt;fileNameExt[0] != '.' &amp;&amp; b-&gt;fileNameExt[0] == '.')\n                            return true;\n                        if (a-&gt;fileNameExt[0] == '.' &amp;&amp; b-&gt;fileNameExt[0] == '.')\n                        {\n                            return (stricmp(a-&gt;fileNameExt.c_str(), b-&gt;fileNameExt.c_str()) &gt; 0); // sort in insensitive case\n                        }\n                        */\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &gt; b-&gt;fileType); // directories last\n                        return (stricmp(a-&gt;fileNameExt.c_str(), b-&gt;fileNameExt.c_str()) &gt; 0); // sort in insensitive case\n                    });\n            }\n        }\n        else if (puSortingField == SortingFieldEnum::FIELD_TYPE)\n        {\n            if (puSortingDirection[1])\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileType = tableHeaderAscendingIcon + puHeaderFileType;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &lt; b-&gt;fileType); // directory in first\n                        return (a-&gt;fileExt &lt; b-&gt;fileExt); // else\n                    });\n            }\n            else\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileType = tableHeaderDescendingIcon + puHeaderFileType;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &gt; b-&gt;fileType); // directory in last\n                        return (a-&gt;fileExt &gt; b-&gt;fileExt); // else\n                    });\n            }\n        }\n        else if (puSortingField == SortingFieldEnum::FIELD_SIZE)\n        {\n            if (puSortingDirection[2])\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileSize = tableHeaderAscendingIcon + puHeaderFileSize;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &lt; b-&gt;fileType); // directory in first\n                        return (a-&gt;fileSize &lt; b-&gt;fileSize); // else\n                    });\n            }\n            else\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileSize = tableHeaderDescendingIcon + puHeaderFileSize;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &gt; b-&gt;fileType); // directory in last\n                        return (a-&gt;fileSize &gt; b-&gt;fileSize); // else\n                    });\n            }\n        }\n        else if (puSortingField == SortingFieldEnum::FIELD_DATE)\n        {\n            if (puSortingDirection[3])\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileDate = tableHeaderAscendingIcon + puHeaderFileDate;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &lt; b-&gt;fileType); // directory in first\n                        return (a-&gt;fileModifDate &lt; b-&gt;fileModifDate); // else\n                    });\n            }\n            else\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileDate = tableHeaderDescendingIcon + puHeaderFileDate;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType &gt; b-&gt;fileType); // directory in last\n                        return (a-&gt;fileModifDate &gt; b-&gt;fileModifDate); // else\n                    });\n            }\n        }\n#ifdef USE_THUMBNAILS\n        else if (puSortingField == SortingFieldEnum::FIELD_THUMBNAILS)\n        {\n            // we will compare thumbnails by :\n            // 1) width \n            // 2) height\n\n            if (puSortingDirection[4])\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileThumbnails = tableHeaderAscendingIcon + puHeaderFileThumbnails;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (a-&gt;fileType.isDir()); // directory in first\n                        if (a-&gt;thumbnailInfo.textureWidth == b-&gt;thumbnailInfo.textureWidth)\n                            return (a-&gt;thumbnailInfo.textureHeight &lt; b-&gt;thumbnailInfo.textureHeight);\n                        return (a-&gt;thumbnailInfo.textureWidth &lt; b-&gt;thumbnailInfo.textureWidth);\n                    });\n            }\n\n            else\n            {\n#ifdef USE_CUSTOM_SORTING_ICON\n                puHeaderFileThumbnails = tableHeaderDescendingIcon + puHeaderFileThumbnails;\n#endif // USE_CUSTOM_SORTING_ICON\n                std::sort(vFileInfosList.begin(), vFileInfosList.end(),\n                    [](const std::shared_ptr&lt;FileInfos&gt;&amp; a, const std::shared_ptr&lt;FileInfos&gt;&amp; b) -&gt; bool\n                    {\n                        if (!a.use_count() || !b.use_count())\n                            return false;\n\n                        if (a-&gt;fileType != b-&gt;fileType) return (!a-&gt;fileType.isDir()); // directory in last\n                        if (a-&gt;thumbnailInfo.textureWidth == b-&gt;thumbnailInfo.textureWidth)\n                            return (a-&gt;thumbnailInfo.textureHeight &gt; b-&gt;thumbnailInfo.textureHeight);\n                        return (a-&gt;thumbnailInfo.textureWidth &gt; b-&gt;thumbnailInfo.textureWidth);\n                    });\n            }\n        }\n#endif // USE_THUMBNAILS\n\n        ApplyFilteringOnFileList(vFileDialogInternal, vFileInfosList, vFileInfosFilteredList);\n    }\n\n    void IGFD::FileManager::ClearFileLists()\n    {\n        prFilteredFileList.clear();\n        prFileList.clear();\n    }\n\n    void IGFD::FileManager::ClearPathLists()\n    {\n        prFilteredPathList.clear();\n        prPathList.clear();\n    }\n\n    void IGFD::FileManager::AddFile(const FileDialogInternal&amp; vFileDialogInternal, const std::string&amp; vPath, const std::string&amp; vFileName, const FileType&amp; vFileType)\n    {\n        auto infos = std::make_shared&lt;FileInfos&gt;();\n\n        infos-&gt;filePath = vPath;\n        infos-&gt;fileNameExt = vFileName;\n        infos-&gt;fileNameExt_optimized = Utils::LowerCaseString(infos-&gt;fileNameExt);\n        infos-&gt;fileType = vFileType;\n\n        if (infos-&gt;fileNameExt.empty() || (infos-&gt;fileNameExt == \".\" &amp;&amp; !vFileDialogInternal.puFilterManager.puDLGFilters.empty())) return; // filename empty or filename is the current dir '.' //-V807\n        if (infos-&gt;fileNameExt != \"..\" &amp;&amp; (vFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DontShowHiddenFiles) &amp;&amp; infos-&gt;fileNameExt[0] == '.') // dont show hidden files\n            if (!vFileDialogInternal.puFilterManager.puDLGFilters.empty() || (vFileDialogInternal.puFilterManager.puDLGFilters.empty() &amp;&amp; infos-&gt;fileNameExt != \".\")) // except \".\" if in directory mode //-V728\n                return;\n\n        if (infos-&gt;fileType.isFile()\n            || infos-&gt;fileType.isLinkToUnknown()) // link can have the same extention of a file\n        {\n            size_t lpt = infos-&gt;fileNameExt.find_last_of('.');\n            if (lpt != std::string::npos)\n            {\n                infos-&gt;fileExt = infos-&gt;fileNameExt.substr(lpt);\n            }\n\n            if (!vFileDialogInternal.puFilterManager.IsCoveredByFilters(infos-&gt;fileNameExt, infos-&gt;fileExt,\n                (vFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_CaseInsensitiveExtention) != 0))\n            {\n                return;\n            }\n        }\n\n        vFileDialogInternal.puFilterManager.prFillFileStyle(infos);\n\n        prCompleteFileInfos(infos);\n        prFileList.push_back(infos);\n    }\n\n    void IGFD::FileManager::AddPath(const FileDialogInternal&amp; vFileDialogInternal, const std::string&amp; vPath, const std::string&amp; vFileName, const FileType&amp; vFileType)\n    {\n        if (!vFileType.isDir())\n            return;\n\n        auto infos = std::make_shared&lt;FileInfos&gt;();\n\n        infos-&gt;filePath = vPath;\n        infos-&gt;fileNameExt = vFileName;\n        infos-&gt;fileNameExt_optimized = Utils::LowerCaseString(infos-&gt;fileNameExt);\n        infos-&gt;fileType = vFileType;\n\n        if (infos-&gt;fileNameExt.empty() || (infos-&gt;fileNameExt == \".\" &amp;&amp; !vFileDialogInternal.puFilterManager.puDLGFilters.empty())) return; // filename empty or filename is the current dir '.' //-V807\n        if (infos-&gt;fileNameExt != \"..\" &amp;&amp; (vFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DontShowHiddenFiles) &amp;&amp; infos-&gt;fileNameExt[0] == '.') // dont show hidden files\n            if (!vFileDialogInternal.puFilterManager.puDLGFilters.empty() || (vFileDialogInternal.puFilterManager.puDLGFilters.empty() &amp;&amp; infos-&gt;fileNameExt != \".\")) // except \".\" if in directory mode //-V728\n                return;\n\n        if (infos-&gt;fileType.isFile() \n            || infos-&gt;fileType.isLinkToUnknown()) // link can have the same extention of a file\n        {\n            size_t lpt = infos-&gt;fileNameExt.find_last_of('.');\n            if (lpt != std::string::npos)\n            {\n                infos-&gt;fileExt = infos-&gt;fileNameExt.substr(lpt);\n            }\n\n            if (!vFileDialogInternal.puFilterManager.IsCoveredByFilters(infos-&gt;fileNameExt, infos-&gt;fileExt,\n                (vFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_CaseInsensitiveExtention) != 0))\n            {\n                return;\n            }\n        }\n\n        vFileDialogInternal.puFilterManager.prFillFileStyle(infos);\n\n        prCompleteFileInfos(infos);\n        prPathList.push_back(infos);\n    }\n\n    void IGFD::FileManager::ScanDir(const FileDialogInternal&amp; vFileDialogInternal, const std::string&amp; vPath)\n    {\n        std::string path = vPath;\n\n        if (prCurrentPathDecomposition.empty())\n        {\n            SetCurrentDir(path);\n        }\n\n        if (!prCurrentPathDecomposition.empty())\n        {\n#ifdef _IGFD_WIN_\n            if (path == puFsRoot)\n                path += std::string(1u, PATH_SEP);\n#endif // _IGFD_WIN_\n\n            ClearFileLists();\n\n#ifdef USE_STD_FILESYSTEM\n            const std::filesystem::path fspath(path);\n            const auto dir_iter = std::filesystem::directory_iterator(fspath);\n            FileType fstype = FileType(FileType::ContentType::Directory, std::filesystem::is_symlink(std::filesystem::status(fspath)));\n            AddFile(vFileDialogInternal, path, \"..\", fstype);\n            for (const auto&amp; file : dir_iter)\n            {\n                FileType fileType;\n                if (file.is_symlink())\n                {\n                    fileType.SetSymLink(file.is_symlink());\n                    fileType.SetContent(FileType::ContentType::LinkToUnknown);\n                }\n\n                if (file.is_directory()) { fileType.SetContent(FileType::ContentType::Directory); } // directory or symlink to directory\n                else if (file.is_regular_file()) { fileType.SetContent(FileType::ContentType::File); }\n\n                if (fileType.isValid())\n                {\n                    auto fileNameExt = file.path().filename().string();\n                    AddFile(vFileDialogInternal, path, fileNameExt, fileType);\n                }\n            }\n#else // dirent\n            struct dirent** files = nullptr;\n            size_t n = scandir(path.c_str(), &amp;files, nullptr, inAlphaSort);\n            if (n &amp;&amp; files)\n            {\n                size_t i;\n\n                for (i = 0; i &lt; n; i++)\n                {\n                    struct dirent* ent = files[i];\n\n                    FileType fileType;\n                    switch (ent-&gt;d_type)\n                    {\n                    case DT_DIR:\n                        fileType.SetContent(FileType::ContentType::Directory); break;\n                    case DT_REG:\n                        fileType.SetContent(FileType::ContentType::File); break;\n                    case DT_LNK:\n                    {\n                        fileType.SetSymLink(true);\n                        fileType.SetContent(FileType::ContentType::LinkToUnknown); // by default if we can't figure out the target type.\n                        struct stat statInfos = {};\n                        int result = stat((path + PATH_SEP + ent-&gt;d_name).c_str(), &amp;statInfos);\n                        if (result == 0)\n                        {\n                            if (statInfos.st_mode &amp; S_IFREG)\n                            {\n                                fileType.SetContent(FileType::ContentType::File);\n                            }\n                            else if (statInfos.st_mode &amp; S_IFDIR)\n                            {\n                                fileType.SetContent(FileType::ContentType::Directory);\n                            }\n                        }\n                        break;\n                    }\n                    default:\n                        break; // leave it invalid (devices, etc.)\n                    }\n\n                    if (fileType.isValid())\n                    {\n                        auto fileNameExt = ent-&gt;d_name;\n                        AddFile(vFileDialogInternal, path, fileNameExt, fileType);\n                    }\n                }\n\n                for (i = 0; i &lt; n; i++)\n                {\n                    free(files[i]);\n                }\n\n                free(files);\n            }\n#endif // USE_STD_FILESYSTEM\n\n            SortFields(vFileDialogInternal, prFileList, prFilteredFileList);\n        }\n    }\n\n#if defined(USE_QUICK_PATH_SELECT)\n    void IGFD::FileManager::ScanDirForPathSelection(const FileDialogInternal&amp; vFileDialogInternal, const std::string&amp; vPath)\n    {\n        std::string path = vPath;\n\n        /*if (prCurrentPathDecomposition.empty())\n        {\n            SetCurrentDir(path);\n        }*/\n\n        if (!path.empty())\n        {\n#ifdef _IGFD_WIN_\n            if (path == puFsRoot)\n                path += std::string(1u, PATH_SEP);\n#endif // _IGFD_WIN_\n\n            ClearPathLists();\n\n#ifdef USE_STD_FILESYSTEM\n            const std::filesystem::path fspath(path);\n            const auto dir_iter = std::filesystem::directory_iterator(fspath);\n            FileType fstype = FileType(FileType::ContentType::Directory, std::filesystem::is_symlink(std::filesystem::status(fspath)));\n            AddPath(vFileDialogInternal, path, \"..\", fstype);\n            for (const auto&amp; file : dir_iter)\n            {\n                FileType fileType; \n                if (file.is_symlink())\n                {\n                    fileType.SetSymLink(file.is_symlink());\n                    fileType.SetContent(FileType::ContentType::LinkToUnknown);\n                }\n                if (file.is_directory())\n                {\n                    fileType.SetContent(FileType::ContentType::Directory);\n                    auto fileNameExt = file.path().filename().string();\n                    AddPath(vFileDialogInternal, path, fileNameExt, fileType);\n                }\n            }\n#else // dirent\n            struct dirent** files = nullptr;\n            size_t n = scandir(path.c_str(), &amp;files, nullptr, inAlphaSort);\n            if (n)\n            {\n                size_t i;\n\n                for (i = 0; i &lt; n; i++)\n                {\n                    struct dirent* ent = files[i];\n\n                    if (ent-&gt;d_type == DT_DIR)\n                    {\n                        auto fileNameExt = ent-&gt;d_name;\n                        AddPath(vFileDialogInternal, path, fileNameExt, FileType(FileType::ContentType::Directory, false));\n                    }\n                }\n\n                for (i = 0; i &lt; n; i++)\n                {\n                    free(files[i]);\n                }\n\n                free(files);\n            }\n#endif // USE_STD_FILESYSTEM\n\n            SortFields(vFileDialogInternal, prPathList, prFilteredPathList);\n        }\n    }\n#endif // USE_QUICK_PATH_SELECT\n\n#if defined(USE_QUICK_PATH_SELECT)\n    void IGFD::FileManager::OpenPathPopup(const FileDialogInternal&amp; vFileDialogInternal, std::vector&lt;std::string&gt;::iterator vPathIter)\n    {\n        const auto path = ComposeNewPath(vPathIter);\n        ScanDirForPathSelection(vFileDialogInternal, path);\n        prPopupComposedPath = vPathIter;\n        ImGui::OpenPopup(\"IGFD_Path_Popup\");\n    }\n#endif // USE_QUICK_PATH_SELECT\n\n    bool IGFD::FileManager::GetDrives()\n    {\n        auto drives = IGFD::Utils::GetDrivesList();\n        if (!drives.empty())\n        {\n            prCurrentPath.clear();\n            prCurrentPathDecomposition.clear();\n            ClearFileLists();\n            for (auto&amp; drive : drives)\n            {\n                auto info = std::make_shared&lt;FileInfos&gt;();\n                info-&gt;fileNameExt = drive;\n                info-&gt;fileNameExt_optimized = Utils::LowerCaseString(drive);\n                info-&gt;fileType.SetContent(FileType::ContentType::Directory);\n\n                if (!info-&gt;fileNameExt.empty())\n                {\n                    prFileList.push_back(info);\n                }\n            }\n            puShowDrives = true;\n            return true;\n        }\n        return false;\n    }\n\n    bool IGFD::FileManager::IsComposerEmpty()\n    {\n        return prCurrentPathDecomposition.empty();\n    }\n\n    size_t IGFD::FileManager::GetComposerSize()\n    {\n        return prCurrentPathDecomposition.size();\n    }\n\n    bool IGFD::FileManager::IsFileListEmpty()\n    {\n        return prFileList.empty();\n    }\n\n    bool IGFD::FileManager::IsPathListEmpty()\n    {\n        return prPathList.empty();\n    }\n\n    size_t IGFD::FileManager::GetFullFileListSize()\n    {\n        return prFileList.size();\n    }\n\n    std::shared_ptr&lt;FileInfos&gt; IGFD::FileManager::GetFullFileAt(size_t vIdx)\n    {\n        if (vIdx &lt; prFileList.size())\n            return prFileList[vIdx];\n        return nullptr;\n    }\n\n    bool IGFD::FileManager::IsFilteredListEmpty()\n    {\n        return prFilteredFileList.empty();\n    }\n\n    bool IGFD::FileManager::IsPathFilteredListEmpty()\n    {\n        return prFilteredPathList.empty();\n    }\n\n    size_t IGFD::FileManager::GetFilteredListSize()\n    {\n        return prFilteredFileList.size();\n    }\n\n    size_t IGFD::FileManager::GetPathFilteredListSize()\n    {\n        return prFilteredPathList.size();\n    }\n\n    std::shared_ptr&lt;FileInfos&gt; IGFD::FileManager::GetFilteredFileAt(size_t vIdx)\n    {\n        if (vIdx &lt; prFilteredFileList.size())\n            return prFilteredFileList[vIdx];\n        return nullptr;\n    }\n\n    std::shared_ptr&lt;FileInfos&gt; IGFD::FileManager::GetFilteredPathAt(size_t vIdx)\n    {\n        if (vIdx &lt; prFilteredPathList.size())\n            return prFilteredPathList[vIdx];\n        return nullptr;\n    }\n\n    std::vector&lt;std::string&gt;::iterator IGFD::FileManager::GetCurrentPopupComposedPath()\n    {\n        return prPopupComposedPath;\n    }\n\n    bool IGFD::FileManager::IsFileNameSelected(const std::string&amp; vFileName)\n    {\n        return prSelectedFileNames.find(vFileName) != prSelectedFileNames.end();\n    }\n\n    std::string IGFD::FileManager::GetBack()\n    {\n        return prCurrentPathDecomposition.back();\n    }\n\n    void IGFD::FileManager::ClearComposer()\n    {\n        prCurrentPathDecomposition.clear();\n    }\n\n    void IGFD::FileManager::ClearAll()\n    {\n        ClearComposer();\n        ClearFileLists();\n        ClearPathLists();\n    }\n    void IGFD::FileManager::ApplyFilteringOnFileList(const FileDialogInternal&amp; vFileDialogInternal)\n    {\n        ApplyFilteringOnFileList(vFileDialogInternal, prFileList, prFilteredFileList);\n    }\n\n    void IGFD::FileManager::ApplyFilteringOnFileList(\n        const FileDialogInternal&amp; vFileDialogInternal,\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosList,\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosFilteredList)\n    {\n        vFileInfosFilteredList.clear();\n        for (const auto&amp; file : vFileInfosList)\n        {\n            if (!file.use_count())\n                continue;\n            bool show = true;\n            if (!file-&gt;IsTagFound(vFileDialogInternal.puSearchManager.puSearchTag))  // if search tag\n                show = false;\n            if (puDLGDirectoryMode &amp;&amp; !file-&gt;fileType.isDir())\n                show = false;\n            if (show)\n                vFileInfosFilteredList.push_back(file);\n        }\n    }\n\n    std::string IGFD::FileManager::prRoundNumber(double vvalue, int n)\n    {\n        std::stringstream tmp;\n        tmp &lt;&lt; std::setprecision(n) &lt;&lt; std::fixed &lt;&lt; vvalue;\n        return tmp.str();\n    }\n\n    std::string IGFD::FileManager::prFormatFileSize(size_t vByteSize)\n    {\n        if (vByteSize != 0)\n        {\n            static double lo = 1024.0;\n            static double ko = 1024.0 * 1024.0;\n            static double mo = 1024.0 * 1024.0 * 1024.0;\n\n            auto v = (double)vByteSize;\n\n            if (v &lt; lo)\n                return prRoundNumber(v, 0) + \" \" + fileSizeBytes; // octet\n            else if (v &lt; ko)\n                return prRoundNumber(v / lo, 2) + \" \" + fileSizeKiloBytes; // ko\n            else  if (v &lt; mo)\n                return prRoundNumber(v / ko, 2) + \" \" + fileSizeMegaBytes; // Mo\n            else\n                return prRoundNumber(v / mo, 2) + \" \" + fileSizeGigaBytes; // Go\n        }\n\n        return \"\";\n    }\n\n    void IGFD::FileManager::prCompleteFileInfos(const std::shared_ptr&lt;FileInfos&gt;&amp; vInfos)\n    {\n        if (!vInfos.use_count())\n            return;\n\n        if (vInfos-&gt;fileNameExt != \".\" &amp;&amp;\n            vInfos-&gt;fileNameExt != \"..\")\n        {\n            // _stat struct :\n            //dev_t     st_dev;     /* ID of device containing file */\n            //ino_t     st_ino;     /* inode number */\n            //mode_t    st_mode;    /* protection */\n            //nlink_t   st_nlink;   /* number of hard links */\n            //uid_t     st_uid;     /* user ID of owner */\n            //gid_t     st_gid;     /* group ID of owner */\n            //dev_t     st_rdev;    /* device ID (if special file) */\n            //off_t     st_size;    /* total size, in bytes */\n            //blksize_t st_blksize; /* blocksize for file system I/O */\n            //blkcnt_t  st_blocks;  /* number of 512B blocks allocated */\n            //time_t    st_atime;   /* time of last access - not sure out of ntfs */\n            //time_t    st_mtime;   /* time of last modification - not sure out of ntfs */\n            //time_t    st_ctime;   /* time of last status change - not sure out of ntfs */\n\n            std::string fpn;\n\n            // FIXME: so the condition is always true?\n            if (vInfos-&gt;fileType.isFile() || vInfos-&gt;fileType.isLinkToUnknown() || vInfos-&gt;fileType.isDir())\n                fpn = vInfos-&gt;filePath + std::string(1u, PATH_SEP) + vInfos-&gt;fileNameExt;\n\n            struct stat statInfos = {};\n            char timebuf[100];\n            int result = stat(fpn.c_str(), &amp;statInfos);\n            if (!result)\n            {\n                if (!vInfos-&gt;fileType.isDir())\n                {\n                    vInfos-&gt;fileSize = (size_t)statInfos.st_size;\n                    vInfos-&gt;formatedFileSize = prFormatFileSize(vInfos-&gt;fileSize);\n                }\n\n                size_t len = 0;\n#ifdef _MSC_VER\n                struct tm _tm;\n                errno_t err = localtime_s(&amp;_tm, &amp;statInfos.st_mtime);\n                if (!err) len = strftime(timebuf, 99, DateTimeFormat, &amp;_tm);\n#else // _MSC_VER\n                struct tm* _tm = localtime(&amp;statInfos.st_mtime);\n                if (_tm) len = strftime(timebuf, 99, DateTimeFormat, _tm);\n#endif // _MSC_VER\n                if (len)\n                {\n                    vInfos-&gt;fileModifDate = std::string(timebuf, len);\n                }\n            }\n        }\n    }\n\n    void IGFD::FileManager::prRemoveFileNameInSelection(const std::string&amp; vFileName)\n    {\n        prSelectedFileNames.erase(vFileName);\n\n        if (prSelectedFileNames.size() == 1)\n        {\n            snprintf(puFileNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER, \"%s\", vFileName.c_str());\n        }\n        else\n        {\n            snprintf(puFileNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER, \"%zu files Selected\", prSelectedFileNames.size());\n        }\n    }\n\n    void IGFD::FileManager::prAddFileNameInSelection(const std::string&amp; vFileName, bool vSetLastSelectionFileName)\n    {\n        prSelectedFileNames.emplace(vFileName);\n\n        if (prSelectedFileNames.size() == 1)\n        {\n            snprintf(puFileNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER, \"%s\", vFileName.c_str());\n        }\n        else\n        {\n            snprintf(puFileNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER, \"%zu files Selected\", prSelectedFileNames.size());\n        }\n\n        if (vSetLastSelectionFileName)\n            prLastSelectedFileName = vFileName;\n    }\n\n    void IGFD::FileManager::SetCurrentDir(const std::string&amp; vPath)\n    {\n        std::string path = vPath;\n#ifdef _IGFD_WIN_\n        if (puFsRoot == path)\n            path += std::string(1u, PATH_SEP);\n#endif // _IGFD_WIN_\n\n#ifdef USE_STD_FILESYSTEM\n        namespace fs = std::filesystem;\n        bool dir_opened = fs::is_directory(vPath);\n        if (!dir_opened)\n        {\n            path = \".\";\n            dir_opened = fs::is_directory(vPath);\n        }\n        if (dir_opened)\n#else\n        DIR* dir = opendir(path.c_str());\n        if (dir == nullptr)\n        {\n            path = \".\";\n            dir = opendir(path.c_str());\n        }\n\n        if (dir != nullptr)\n#endif // USE_STD_FILESYSTEM\n        {\n#ifdef _IGFD_WIN_\n            DWORD numchar = 0;\n            std::wstring wpath = IGFD::Utils::utf8_decode(path);\n            numchar = GetFullPathNameW(wpath.c_str(), 0, nullptr, nullptr);\n            std::wstring fpath(numchar, 0);\n            GetFullPathNameW(wpath.c_str(), numchar, (wchar_t*)fpath.data(), nullptr);\n            std::string real_path = IGFD::Utils::utf8_encode(fpath);\n            if (real_path.back() == '\\0') // for fix issue we can have with std::string concatenation.. if there is a \\0 at end\n                real_path = real_path.substr(0, real_path.size() - 1U);\n            if (!real_path.empty())\n#elif defined(_IGFD_UNIX_) // _IGFD_UNIX_ is _IGFD_WIN_ or APPLE\n            char real_path[PATH_MAX]; \n            char* numchar = realpath(path.c_str(), real_path);\n            if (numchar != nullptr)\n#endif // _IGFD_WIN_\n            {\n                prCurrentPath = std::move(real_path);\n                if (prCurrentPath[prCurrentPath.size() - 1] == PATH_SEP)\n                {\n                    prCurrentPath = prCurrentPath.substr(0, prCurrentPath.size() - 1);\n                }\n                IGFD::Utils::SetBuffer(puInputPathBuffer, MAX_PATH_BUFFER_SIZE, prCurrentPath);\n                prCurrentPathDecomposition = IGFD::Utils::SplitStringToVector(prCurrentPath, PATH_SEP, false);\n#ifdef _IGFD_UNIX_ // _IGFD_UNIX_ is _IGFD_WIN_ or APPLE\n                prCurrentPathDecomposition.insert(prCurrentPathDecomposition.begin(), std::string(1u, PATH_SEP));\n#endif // _IGFD_UNIX_\n                if (!prCurrentPathDecomposition.empty())\n                {\n#ifdef _IGFD_WIN_\n                    puFsRoot = prCurrentPathDecomposition[0];\n#endif // _IGFD_WIN_\n                }\n            }\n#ifndef USE_STD_FILESYSTEM\n            closedir(dir);\n#endif\n        }\n    }\n\n    bool IGFD::FileManager::CreateDir(const std::string&amp; vPath)\n    {\n        bool res = false;\n\n        if (!vPath.empty())\n        {\n            std::string path = prCurrentPath + std::string(1u, PATH_SEP) + vPath;\n\n            res = IGFD::Utils::CreateDirectoryIfNotExist(path);\n        }\n\n        return res;\n    }\n\n    std::string IGFD::FileManager::ComposeNewPath(std::vector&lt;std::string&gt;::iterator vIter)\n    {\n        std::string res;\n\n        while (true)\n        {\n            if (!res.empty())\n            {\n#ifdef _IGFD_WIN_\n                res = *vIter + std::string(1u, PATH_SEP) + res;\n#elif defined(_IGFD_UNIX_) // _IGFD_UNIX_ is _IGFD_WIN_ or APPLE\n                if (*vIter == puFsRoot)\n                    res = *vIter + res;\n                else\n                    res = *vIter + PATH_SEP + res;\n#endif // _IGFD_WIN_\n            }\n            else\n                res = *vIter;\n\n            if (vIter == prCurrentPathDecomposition.begin())\n            {\n#ifdef _IGFD_UNIX_ // _IGFD_UNIX_ is _IGFD_WIN_ or APPLE\n                if (res[0] != PATH_SEP)\n                    res = PATH_SEP + res;\n#endif // defined(_IGFD_UNIX_)\n                break;\n            }\n\n            --vIter;\n        }\n\n         return res;\n    }\n\n    bool IGFD::FileManager::SetPathOnParentDirectoryIfAny()\n    {\n        if (prCurrentPathDecomposition.size() &gt; 1)\n        {\n            prCurrentPath = ComposeNewPath(prCurrentPathDecomposition.end() - 2);\n            return true;\n        }\n        return false;\n    }\n\n    std::string IGFD::FileManager::GetCurrentPath()\n    {\n        if (prCurrentPath.empty())\n            prCurrentPath = \".\";\n        return prCurrentPath;\n    }\n\n    void IGFD::FileManager::SetCurrentPath(const std::string&amp; vCurrentPath)\n    {\n        if (vCurrentPath.empty())\n            prCurrentPath = \".\";\n        else\n            prCurrentPath = vCurrentPath;\n    }\n\n    bool IGFD::FileManager::IsFileExist(const std::string&amp; vFile)\n    {\n        std::ifstream docFile(vFile, std::ios::in);\n        if (docFile.is_open())\n        {\n            docFile.close();\n            return true;\n        }\n        return false;\n    }\n\n    void IGFD::FileManager::SetDefaultFileName(const std::string&amp; vFileName)\n    {\n        puDLGDefaultFileName = vFileName;\n        IGFD::Utils::SetBuffer(puFileNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER, vFileName);\n    }\n\n    bool IGFD::FileManager::SelectDirectory(const std::shared_ptr&lt;FileInfos&gt;&amp; vInfos)\n    {\n        if (!vInfos.use_count())\n            return false;\n\n        bool pathClick = false;\n\n        if (vInfos-&gt;fileNameExt == \"..\")\n        {\n            pathClick = SetPathOnParentDirectoryIfAny();\n        }\n        else\n        {\n            std::string newPath;\n\n            if (puShowDrives)\n            {\n                newPath = vInfos-&gt;fileNameExt + std::string(1u, PATH_SEP);\n            }\n            else\n            {\n#ifdef __linux__\n                if (puFsRoot == prCurrentPath)\n                    newPath = prCurrentPath + vInfos-&gt;fileNameExt;\n                else\n#endif // __linux__\n                    newPath = prCurrentPath + std::string(1u, PATH_SEP) + vInfos-&gt;fileNameExt;\n            }\n\n            if (IGFD::Utils::IsDirectoryCanBeOpened(newPath))\n            {\n\n                if (puShowDrives)\n                {\n                    prCurrentPath = vInfos-&gt;fileNameExt;\n                    puFsRoot = prCurrentPath;\n                }\n                else\n                {\n                    prCurrentPath = newPath; //-V820\n                }\n                pathClick = true;\n            }\n        }\n\n        return pathClick;\n    }\n\n    void IGFD::FileManager::SelectFileName(const FileDialogInternal&amp; vFileDialogInternal, const std::shared_ptr&lt;FileInfos&gt;&amp; vInfos)\n    {\n        if (!vInfos.use_count())\n            return;\n\n        if (ImGui::GetIO().KeyCtrl)\n        {\n            if (puDLGcountSelectionMax == 0) // infinite selection\n            {\n                if (prSelectedFileNames.find(vInfos-&gt;fileNameExt) == prSelectedFileNames.end()) // not found +&gt; add\n                {\n                    prAddFileNameInSelection(vInfos-&gt;fileNameExt, true);\n                }\n                else // found +&gt; remove\n                {\n                    prRemoveFileNameInSelection(vInfos-&gt;fileNameExt);\n                }\n            }\n            else // selection limited by size\n            {\n                if (prSelectedFileNames.size() &lt; puDLGcountSelectionMax)\n                {\n                    if (prSelectedFileNames.find(vInfos-&gt;fileNameExt) == prSelectedFileNames.end()) // not found +&gt; add\n                    {\n                        prAddFileNameInSelection(vInfos-&gt;fileNameExt, true);\n                    }\n                    else // found +&gt; remove\n                    {\n                        prRemoveFileNameInSelection(vInfos-&gt;fileNameExt);\n                    }\n                }\n            }\n        }\n        else if (ImGui::GetIO().KeyShift)\n        {\n            if (puDLGcountSelectionMax != 1)\n            {\n                prSelectedFileNames.clear();\n                // we will iterate filelist and get the last selection after the start selection\n                bool startMultiSelection = false;\n                std::string fileNameToSelect = vInfos-&gt;fileNameExt;\n                std::string savedLastSelectedFileName; // for invert selection mode\n                for (const auto&amp; file : prFileList)\n                {\n                    if (!file.use_count())\n                        continue;\n\n                    bool canTake = true;\n                    if (!file-&gt;IsTagFound(vFileDialogInternal.puSearchManager.puSearchTag)) canTake = false;\n                    if (canTake) // if not filtered, we will take files who are filtered by the dialog\n                    {\n                        if (file-&gt;fileNameExt == prLastSelectedFileName)\n                        {\n                            startMultiSelection = true;\n                            prAddFileNameInSelection(prLastSelectedFileName, false);\n                        }\n                        else if (startMultiSelection)\n                        {\n                            if (puDLGcountSelectionMax == 0) // infinite selection\n                            {\n                                prAddFileNameInSelection(file-&gt;fileNameExt, false);\n                            }\n                            else // selection limited by size\n                            {\n                                if (prSelectedFileNames.size() &lt; puDLGcountSelectionMax)\n                                {\n                                    prAddFileNameInSelection(file-&gt;fileNameExt, false);\n                                }\n                                else\n                                {\n                                    startMultiSelection = false;\n                                    if (!savedLastSelectedFileName.empty())\n                                        prLastSelectedFileName = savedLastSelectedFileName;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (file-&gt;fileNameExt == fileNameToSelect)\n                        {\n                            if (!startMultiSelection) // we are before the last Selected FileName, so we must inverse\n                            {\n                                savedLastSelectedFileName = prLastSelectedFileName;\n                                prLastSelectedFileName = fileNameToSelect;\n                                fileNameToSelect = savedLastSelectedFileName;\n                                startMultiSelection = true;\n                                prAddFileNameInSelection(prLastSelectedFileName, false);\n                            }\n                            else\n                            {\n                                startMultiSelection = false;\n                                if (!savedLastSelectedFileName.empty())\n                                    prLastSelectedFileName = savedLastSelectedFileName;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            prSelectedFileNames.clear();\n            IGFD::Utils::ResetBuffer(puFileNameBuffer);\n            prAddFileNameInSelection(vInfos-&gt;fileNameExt, true);\n        }\n    }\n\n    void IGFD::FileManager::DrawDirectoryCreation(const FileDialogInternal&amp; vFileDialogInternal)\n    {\n        if (vFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableCreateDirectoryButton)\n            return;\n\n        if (IMGUI_BUTTON(createDirButtonString))\n        {\n            if (!prCreateDirectoryMode)\n            {\n                prCreateDirectoryMode = true;\n                IGFD::Utils::ResetBuffer(puDirectoryNameBuffer);\n            }\n        }\n        if (ImGui::IsItemHovered())\n            ImGui::SetTooltip(buttonCreateDirString);\n\n        if (prCreateDirectoryMode)\n        {\n            ImGui::SameLine();\n\n            ImGui::PushItemWidth(100.0f);\n            ImGui::InputText(\"##DirectoryFileName\", puDirectoryNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER);\n            ImGui::PopItemWidth();\n\n            ImGui::SameLine();\n\n            if (IMGUI_BUTTON(okButtonString))\n            {\n                std::string newDir = std::string(puDirectoryNameBuffer);\n                if (CreateDir(newDir))\n                {\n                    SetCurrentPath(prCurrentPath + std::string(1u, PATH_SEP) + newDir);\n                    OpenCurrentPath(vFileDialogInternal);\n                }\n\n                prCreateDirectoryMode = false;\n            }\n\n            ImGui::SameLine();\n\n            if (IMGUI_BUTTON(cancelButtonString))\n            {\n                prCreateDirectoryMode = false;\n            }\n        }\n\n        ImGui::SameLine();\n    }\n\n    void IGFD::FileManager::DrawPathComposer(const FileDialogInternal&amp; vFileDialogInternal)\n    {\n        if (IMGUI_BUTTON(resetButtonString))\n        {\n            SetCurrentPath(\".\");\n            OpenCurrentPath(vFileDialogInternal);\n        }\n        if (ImGui::IsItemHovered())\n            ImGui::SetTooltip(buttonResetPathString);\n\n#ifdef _IGFD_WIN_\n        ImGui::SameLine();\n\n        if (IMGUI_BUTTON(drivesButtonString))\n        {\n            puDrivesClicked = true;\n        }\n        if (ImGui::IsItemHovered())\n            ImGui::SetTooltip(buttonDriveString);\n#endif // _IGFD_WIN_\n\n        ImGui::SameLine();\n\n        if (IMGUI_BUTTON(editPathButtonString))\n        {\n            puInputPathActivated = !puInputPathActivated;\n            if (puInputPathActivated)\n            {\n                auto endIt = prCurrentPathDecomposition.end();\n                prCurrentPath = ComposeNewPath(--endIt);\n                IGFD::Utils::SetBuffer(puInputPathBuffer, MAX_PATH_BUFFER_SIZE, prCurrentPath);\n            }\n        }\n        if (ImGui::IsItemHovered())\n            ImGui::SetTooltip(buttonEditPathString);\n\n        ImGui::SameLine();\n\n        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);\n\n        // show current path\n        if (!prCurrentPathDecomposition.empty())\n        {\n            ImGui::SameLine();\n\n            if (puInputPathActivated)\n            {\n                ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x);\n                ImGui::InputText(\"##pathedition\", puInputPathBuffer, MAX_PATH_BUFFER_SIZE);\n                ImGui::PopItemWidth();\n            }\n            else\n            {\n                int _id = 0;\n                for (auto itPathDecomp = prCurrentPathDecomposition.begin();\n                    itPathDecomp != prCurrentPathDecomposition.end(); ++itPathDecomp)\n                {\n                    if (itPathDecomp != prCurrentPathDecomposition.begin())\n                    {\n#if defined(CUSTOM_PATH_SPACING)\n                        ImGui::SameLine(0, CUSTOM_PATH_SPACING);\n#else\n                        ImGui::SameLine();\n#endif // USE_CUSTOM_PATH_SPACING\n#if defined(USE_QUICK_PATH_SELECT)\n\n#if defined(_IGFD_WIN_)\n                        const char* sep = \"\\\\\";\n#elif defined(_IGFD_UNIX_)\n                        const char* sep = \"/\";\n                        if (itPathDecomp != prCurrentPathDecomposition.begin() + 1)\n#endif\n                        {\n                            ImGui::PushID(_id++);\n                            bool click = IMGUI_PATH_BUTTON(sep);\n                            ImGui::PopID();\n\n#if defined(CUSTOM_PATH_SPACING)\n                            ImGui::SameLine(0, CUSTOM_PATH_SPACING);\n#else\n                            ImGui::SameLine();\n#endif // USE_CUSTOM_PATH_SPACING\n\n                            if (click)\n                            {\n                                OpenPathPopup(vFileDialogInternal, itPathDecomp-1);\n                            }\n                            else if (ImGui::IsItemClicked(ImGuiMouseButton_Right))\n                            {\n                                SetCurrentPath(itPathDecomp-1);\n                                break;\n                            }\n                        }\n#endif // USE_QUICK_PATH_SELECT\n                    }\n\n                    ImGui::PushID(_id++);\n                    bool click = IMGUI_PATH_BUTTON((*itPathDecomp).c_str());\n                    ImGui::PopID();\n                    if (click)\n                    {\n                        prCurrentPath = ComposeNewPath(itPathDecomp);\n                        puPathClicked = true;\n                        break;\n                    }\n                    else if (ImGui::IsItemClicked(ImGuiMouseButton_Right)) // activate input for path\n                    {\n                        SetCurrentPath(itPathDecomp);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    void IGFD::FileManager::SetCurrentPath(std::vector&lt;std::string&gt;::iterator vPathIter)\n    {\n        prCurrentPath = ComposeNewPath(vPathIter);\n        IGFD::Utils::SetBuffer(puInputPathBuffer, MAX_PATH_BUFFER_SIZE, prCurrentPath);\n        puInputPathActivated = true;\n    }\n\n    std::string IGFD::FileManager::GetResultingPath()\n    {\n        std::string path = prCurrentPath;\n\n        if (puDLGDirectoryMode) // if directory mode\n        {\n            std::string selectedDirectory = puFileNameBuffer;\n            if (!selectedDirectory.empty() &amp;&amp;\n                selectedDirectory != \".\")\n                path += std::string(1u, PATH_SEP) + selectedDirectory;\n        }\n\n        return path;\n    }\n\n    std::string IGFD::FileManager::GetResultingFileName(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        if (!puDLGDirectoryMode) // if not directory mode\n        {\n            return vFileDialogInternal.puFilterManager.ReplaceExtentionWithCurrentFilter(std::string(puFileNameBuffer));\n        }\n\n        return \"\"; // directory mode\n    }\n\n    std::string IGFD::FileManager::GetResultingFilePathName(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        std::string result = GetResultingPath();\n\n        std::string filename = GetResultingFileName(vFileDialogInternal);\n        if (!filename.empty())\n        {\n#ifdef _IGFD_UNIX_\n            if (puFsRoot != result)\n#endif // _IGFD_UNIX_\n                result += std::string(1u, PATH_SEP);\n\n            result += filename;\n        }\n\n        return result;\n    }\n\n    std::map&lt;std::string, std::string&gt; IGFD::FileManager::GetResultingSelection()\n    {\n        std::map&lt;std::string, std::string&gt; res;\n\n        for (auto&amp; selectedFileName : prSelectedFileNames)\n        {\n            std::string result = GetResultingPath();\n\n#ifdef _IGFD_UNIX_\n            if (puFsRoot != result)\n#endif // _IGFD_UNIX_\n                result += std::string(1u, PATH_SEP);\n\n            result += selectedFileName;\n\n            res[selectedFileName] = result;\n        }\n\n        return res;\n    }\n\n\n    void IGFD::FileDialogInternal::NewFrame()\n    {\n        puCanWeContinue = true; // reset flag for possibily validate the dialog\n        puIsOk = false;             // reset dialog result\n        puFileManager.puDrivesClicked = false;\n        puFileManager.puPathClicked = false;\n\n        puNeedToExitDialog = false;\n\n#ifdef USE_DIALOG_EXIT_WITH_KEY\n        if (ImGui::IsKeyPressed(IGFD_EXIT_KEY))\n        {\n            // we do that here with the data's defined at the last frame\n            // because escape key can quit input activation and at the end of the frame all flag will be false\n            // so we will detect nothing\n            if (!(puFileManager.puInputPathActivated ||\n                puSearchManager.puSearchInputIsActive ||\n                puFileInputIsActive ||\n                puFileListViewIsActive))\n            {\n                puNeedToExitDialog = true; // need to quit dialog\n            }\n        }\n        else\n#endif\n        {\n            puSearchManager.puSearchInputIsActive = false;\n            puFileInputIsActive = false;\n            puFileListViewIsActive = false;\n        }\n    }\n\n    void IGFD::FileDialogInternal::EndFrame()\n    {\n        // directory change\n        if (puFileManager.puPathClicked)\n        {\n            puFileManager.OpenCurrentPath(*this);\n        }\n\n        if (puFileManager.puDrivesClicked)\n        {\n            if (puFileManager.GetDrives())\n            {\n                puFileManager.ApplyFilteringOnFileList(*this);\n            }\n        }\n\n        if (puFileManager.puInputPathActivated)\n        {\n            auto gio = ImGui::GetIO();\n            if (ImGui::IsKeyReleased(ImGuiKey_Enter))\n            {\n                puFileManager.SetCurrentPath(std::string(puFileManager.puInputPathBuffer));\n                puFileManager.OpenCurrentPath(*this);\n                puFileManager.puInputPathActivated = false;\n            }\n            if (ImGui::IsKeyReleased(ImGuiKey_Escape))\n            {\n                puFileManager.puInputPathActivated = false;\n            }\n        }\n    }\n\n    void IGFD::FileDialogInternal::ResetForNewDialog()\n    {\n\n    }\n\n\n    IGFD::ThumbnailFeature::ThumbnailFeature()\n    {\n#ifdef USE_THUMBNAILS\n        prDisplayMode = DisplayModeEnum::FILE_LIST;\n#endif\n    }\n\n    IGFD::ThumbnailFeature::~ThumbnailFeature() = default;\n\n    void IGFD::ThumbnailFeature::NewThumbnailFrame(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        (void)vFileDialogInternal;\n\n#ifdef USE_THUMBNAILS\n        prStartThumbnailFileDatasExtraction();\n#endif\n    }\n\n    void IGFD::ThumbnailFeature::EndThumbnailFrame(FileDialogInternal&amp; vFileDialogInternal)\n    {\n#ifdef USE_THUMBNAILS\n        prClearThumbnails(vFileDialogInternal);\n#endif\n    }\n\n    void IGFD::ThumbnailFeature::QuitThumbnailFrame(FileDialogInternal&amp; vFileDialogInternal)\n    {\n#ifdef USE_THUMBNAILS\n        prStopThumbnailFileDatasExtraction();\n        prClearThumbnails(vFileDialogInternal);\n#endif\n    }\n\n#ifdef USE_THUMBNAILS\n    void IGFD::ThumbnailFeature::prStartThumbnailFileDatasExtraction()\n    {\n        const bool res = prThumbnailGenerationThread.use_count() &amp;&amp; prThumbnailGenerationThread-&gt;joinable();\n        if (!res)\n        {\n            prIsWorking = true;\n            prCountFiles = 0U;\n            prThumbnailGenerationThread = std::shared_ptr&lt;std::thread&gt;(\n                new std::thread(&amp;IGFD::ThumbnailFeature::prThreadThumbnailFileDatasExtractionFunc, this),\n                [this](std::thread* obj)\n                {\n                    prIsWorking = false;\n                    if (obj)\n                        obj-&gt;join();\n                });\n        }\n    }\n\n    bool IGFD::ThumbnailFeature::prStopThumbnailFileDatasExtraction()\n    {\n        const bool res = prThumbnailGenerationThread.use_count() &amp;&amp; prThumbnailGenerationThread-&gt;joinable();\n        if (res)\n        {\n            prThumbnailGenerationThread.reset();\n        }\n\n        return res;\n    }\n\n    void IGFD::ThumbnailFeature::prThreadThumbnailFileDatasExtractionFunc()\n    {\n        prCountFiles = 0U;\n        prIsWorking = true;\n\n        // infinite loop while is thread working\n        while(prIsWorking)\n        {\n            if (!prThumbnailFileDatasToGet.empty())\n            {\n                std::shared_ptr&lt;FileInfos&gt; file = nullptr;\n                prThumbnailFileDatasToGetMutex.lock();\n                //get the first file in the list\n                file = (*prThumbnailFileDatasToGet.begin());\n                prThumbnailFileDatasToGetMutex.unlock();\n\n                // retrieve datas of the texture file if its an image file\n                if (file.use_count())\n                {\n                    if (file-&gt;fileType.isFile()) //-V522\n                    {\n                        if (file-&gt;fileExt == \".png\"\n                            || file-&gt;fileExt == \".bmp\"\n                            || file-&gt;fileExt == \".tga\"\n                            || file-&gt;fileExt == \".jpg\" || file-&gt;fileExt == \".jpeg\"\n                            || file-&gt;fileExt == \".gif\"\n                            || file-&gt;fileExt == \".psd\"\n                            || file-&gt;fileExt == \".pic\"\n                            || file-&gt;fileExt == \".ppm\" || file-&gt;fileExt == \".pgm\"\n                            //|| file-&gt;fileExt == \".hdr\" =&gt; format float so in few times\n                            )\n                        {\n                            auto fpn = file-&gt;filePath + std::string(1u, PATH_SEP) + file-&gt;fileNameExt;\n\n                            int w = 0;\n                            int h = 0;\n                            int chans = 0;\n                            uint8_t *datas = stbi_load(fpn.c_str(), &amp;w, &amp;h, &amp;chans, STBI_rgb_alpha);\n                            if (datas)\n                            {\n                                if (w &amp;&amp; h)\n                                {\n                                    // resize with respect to glyph ratio\n                                    const float ratioX = (float)w / (float)h;\n                                    const float newX = DisplayMode_ThumbailsList_ImageHeight * ratioX;\n                                    float newY = w / ratioX;\n                                    if (newX &lt; w) \n                                        newY = DisplayMode_ThumbailsList_ImageHeight;\n\n                                    const auto newWidth = (int)newX;\n                                    const auto newHeight = (int)newY;\n                                    const auto newBufSize = (size_t)(newWidth * newHeight * 4U); //-V112 //-V1028\n                                    auto resizedData = new uint8_t[newBufSize];\n\n                                    const int resizeSucceeded = stbir_resize_uint8(\n                                        datas, w, h, 0,\n                                        resizedData, newWidth, newHeight, 0,\n                                        4); //-V112\n\n                                    if (resizeSucceeded)\n                                    {\n                                        auto th = &amp;file-&gt;thumbnailInfo;\n\n                                        th-&gt;textureFileDatas = resizedData;\n                                        th-&gt;textureWidth = newWidth;\n                                        th-&gt;textureHeight = newHeight;\n                                        th-&gt;textureChannels = 4; //-V112\n\n                                        // we set that at least, because will launch the gpu creation of the texture in the main thread\n                                        th-&gt;isReadyToUpload = true;\n\n                                        // need gpu loading\n                                        prAddThumbnailToCreate(file);\n                                    }\n                                }\n                                else\n                                {\n                                    printf(\"image loading fail : w:%i h:%i c:%i\\n\", w, h, 4); //-V112\n                                }\n\n                                stbi_image_free(datas);\n                            }\n                        }\n                    }\n\n                    // peu importe le resultat on vire le fichicer\n                    // remove form this list\n                    // write =&gt; thread concurency issues\n                    prThumbnailFileDatasToGetMutex.lock();\n                    prThumbnailFileDatasToGet.pop_front();\n                    prThumbnailFileDatasToGetMutex.unlock();\n                }\n            }\n            else\n            {\n                std::this_thread::sleep_for(std::chrono::milliseconds(500));\n            }\n        }\n    }\n\n    inline void inVariadicProgressBar(float fraction, const ImVec2&amp; size_arg, const char* fmt, ...)\n    {\n        va_list args;\n        va_start(args, fmt);\n        char TempBuffer[512];\n        const int w = vsnprintf(TempBuffer, 511, fmt, args);\n        va_end(args);\n        if (w)\n        {\n            ImGui::ProgressBar(fraction, size_arg, TempBuffer);\n        }\n    }\n\n    void IGFD::ThumbnailFeature::prDrawThumbnailGenerationProgress()\n    {\n        if (prThumbnailGenerationThread.use_count() &amp;&amp; prThumbnailGenerationThread-&gt;joinable())\n        {\n            if (!prThumbnailFileDatasToGet.empty())\n            {\n                const auto p = (float)((double)prCountFiles / (double)prThumbnailFileDatasToGet.size()); // read =&gt; no thread concurency issues\n                inVariadicProgressBar(p, ImVec2(50, 0), \"%u/%u\", prCountFiles, (uint32_t)prThumbnailFileDatasToGet.size()); // read =&gt; no thread concurency issues\n                ImGui::SameLine();\n            }\n        }\n    }\n\n    void IGFD::ThumbnailFeature::prAddThumbnailToLoad(const std::shared_ptr&lt;FileInfos&gt;&amp; vFileInfos)\n    {\n        if (vFileInfos.use_count())\n        {\n            if (vFileInfos-&gt;fileType.isFile())\n            {\n                if (vFileInfos-&gt;fileExt == \".png\"\n                    || vFileInfos-&gt;fileExt == \".bmp\"\n                    || vFileInfos-&gt;fileExt == \".tga\"\n                    || vFileInfos-&gt;fileExt == \".jpg\" || vFileInfos-&gt;fileExt == \".jpeg\"\n                    || vFileInfos-&gt;fileExt == \".gif\"\n                    || vFileInfos-&gt;fileExt == \".psd\"\n                    || vFileInfos-&gt;fileExt == \".pic\"\n                    || vFileInfos-&gt;fileExt == \".ppm\" || vFileInfos-&gt;fileExt == \".pgm\"\n                    //|| file-&gt;fileExt == \".hdr\" =&gt; format float so in few times\n                    )\n                {\n                    // write =&gt; thread concurency issues\n                    prThumbnailFileDatasToGetMutex.lock();\n                    prThumbnailFileDatasToGet.push_back(vFileInfos);\n                    vFileInfos-&gt;thumbnailInfo.isLoadingOrLoaded = true;\n                    prThumbnailFileDatasToGetMutex.unlock();\n                }\n            }\n        }\n    }\n\n    void IGFD::ThumbnailFeature::prAddThumbnailToCreate(const std::shared_ptr&lt;FileInfos&gt;&amp; vFileInfos)\n    {\n        if (vFileInfos.use_count())\n        {\n            // write =&gt; thread concurency issues\n            prThumbnailToCreateMutex.lock();\n            prThumbnailToCreate.push_back(vFileInfos);\n            prThumbnailToCreateMutex.unlock();\n        }\n    }\n\n    void IGFD::ThumbnailFeature::prAddThumbnailToDestroy(const IGFD_Thumbnail_Info&amp; vIGFD_Thumbnail_Info)\n    {\n        // write =&gt; thread concurency issues\n        prThumbnailToDestroyMutex.lock();\n        prThumbnailToDestroy.push_back(vIGFD_Thumbnail_Info);\n        prThumbnailToDestroyMutex.unlock();\n    }\n\n    void IGFD::ThumbnailFeature::prDrawDisplayModeToolBar()\n    {\n        if (IMGUI_RADIO_BUTTON(DisplayMode_FilesList_ButtonString,\n            prDisplayMode == DisplayModeEnum::FILE_LIST))\n            prDisplayMode = DisplayModeEnum::FILE_LIST;\n        if (ImGui::IsItemHovered()) ImGui::SetTooltip(DisplayMode_FilesList_ButtonHelp);\n        ImGui::SameLine();\n        if (IMGUI_RADIO_BUTTON(DisplayMode_ThumbailsList_ButtonString,\n            prDisplayMode == DisplayModeEnum::THUMBNAILS_LIST))\n            prDisplayMode = DisplayModeEnum::THUMBNAILS_LIST;\n        if (ImGui::IsItemHovered()) ImGui::SetTooltip(DisplayMode_ThumbailsList_ButtonHelp);\n        ImGui::SameLine();\n        /* todo\n        if (IMGUI_RADIO_BUTTON(DisplayMode_ThumbailsGrid_ButtonString,\n            prDisplayMode == DisplayModeEnum::THUMBNAILS_GRID))\n            prDisplayMode = DisplayModeEnum::THUMBNAILS_GRID;\n        if (ImGui::IsItemHovered()) ImGui::SetTooltip(DisplayMode_ThumbailsGrid_ButtonHelp);\n        ImGui::SameLine();\n        */\n        prDrawThumbnailGenerationProgress();\n    }\n\n    void IGFD::ThumbnailFeature::prClearThumbnails(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        // directory wil be changed so the file list will be erased\n        if (vFileDialogInternal.puFileManager.puPathClicked)\n        {\n            size_t count = vFileDialogInternal.puFileManager.GetFullFileListSize();\n            for (size_t idx = 0U; idx &lt; count; idx++)\n            {\n                auto file = vFileDialogInternal.puFileManager.GetFullFileAt(idx);\n                if (file.use_count())\n                {\n                    if (file-&gt;thumbnailInfo.isReadyToDisplay) //-V522\n                    {\n                        prAddThumbnailToDestroy(file-&gt;thumbnailInfo);\n                    }\n                }\n            }\n        }\n    }\n\n    void IGFD::ThumbnailFeature::SetCreateThumbnailCallback(const CreateThumbnailFun&amp; vCreateThumbnailFun)\n    {\n        prCreateThumbnailFun = vCreateThumbnailFun;\n    }\n\n    void IGFD::ThumbnailFeature::SetDestroyThumbnailCallback(const DestroyThumbnailFun&amp; vCreateThumbnailFun)\n    {\n        prDestroyThumbnailFun = vCreateThumbnailFun;\n    }\n\n    void IGFD::ThumbnailFeature::ManageGPUThumbnails()\n    {\n        if (prCreateThumbnailFun)\n        {\n            if (!prThumbnailToCreate.empty())\n            {\n                for (const auto&amp; file : prThumbnailToCreate)\n                {\n                    if (file.use_count())\n                    {\n                        prCreateThumbnailFun(&amp;file-&gt;thumbnailInfo);\n                    }\n                }\n                prThumbnailToCreateMutex.lock();\n                prThumbnailToCreate.clear();\n                prThumbnailToCreateMutex.unlock();\n            }\n        }\n        else\n        {\n            printf(\"No Callback found for create texture\\nYou need to define the callback with a call to SetCreateThumbnailCallback\\n\");\n        }\n\n        if (prDestroyThumbnailFun)\n        {\n            if (!prThumbnailToDestroy.empty())\n            {\n                for (auto thumbnail : prThumbnailToDestroy)\n                {\n                    prDestroyThumbnailFun(&amp;thumbnail);\n                }\n                prThumbnailToDestroyMutex.lock();\n                prThumbnailToDestroy.clear();\n                prThumbnailToDestroyMutex.unlock();\n            }\n        }\n        else\n        {\n        printf(\"No Callback found for destroy texture\\nYou need to define the callback with a call to SetCreateThumbnailCallback\\n\");\n        }\n    }\n\n#endif // USE_THUMBNAILS\n\n\n    IGFD::BookMarkFeature::BookMarkFeature()\n    {\n#ifdef USE_BOOKMARK\n        prBookmarkWidth = defaultBookmarkPaneWith;\n#endif // USE_BOOKMARK\n    }\n\n#ifdef USE_BOOKMARK\n    void IGFD::BookMarkFeature::prDrawBookmarkButton()\n    {\n        IMGUI_TOGGLE_BUTTON(bookmarksButtonString, &amp;prBookmarkPaneShown);\n\n        if (ImGui::IsItemHovered())\n            ImGui::SetTooltip(bookmarksButtonHelpString);\n    }\n\n    bool IGFD::BookMarkFeature::prDrawBookmarkPane(FileDialogInternal&amp; vFileDialogInternal, const ImVec2&amp; vSize)\n    {\n        bool res = false;\n\n        ImGui::BeginChild(\"##bookmarkpane\", vSize);\n\n        static int selectedBookmarkForEdition = -1;\n\n        if (IMGUI_BUTTON(addBookmarkButtonString \"##ImGuiFileDialogAddBookmark\"))\n        {\n            if (!vFileDialogInternal.puFileManager.IsComposerEmpty())\n            {\n                BookmarkStruct bookmark;\n                bookmark.name = vFileDialogInternal.puFileManager.GetBack();\n                bookmark.path = vFileDialogInternal.puFileManager.GetCurrentPath();\n                prBookmarks.push_back(bookmark);\n            }\n        }\n        if (selectedBookmarkForEdition &gt;= 0 &amp;&amp;\n            selectedBookmarkForEdition &lt; (int)prBookmarks.size())\n        {\n            ImGui::SameLine();\n            if (IMGUI_BUTTON(removeBookmarkButtonString \"##ImGuiFileDialogAddBookmark\"))\n            {\n                prBookmarks.erase(prBookmarks.begin() + selectedBookmarkForEdition);\n                if (selectedBookmarkForEdition == (int)prBookmarks.size())\n                    selectedBookmarkForEdition--;\n            }\n\n            if (selectedBookmarkForEdition &gt;= 0 &amp;&amp;\n                selectedBookmarkForEdition &lt; (int)prBookmarks.size())\n            {\n                ImGui::SameLine();\n\n                ImGui::PushItemWidth(vSize.x - ImGui::GetCursorPosX());\n                if (ImGui::InputText(\"##ImGuiFileDialogBookmarkEdit\", prBookmarkEditBuffer, MAX_FILE_DIALOG_NAME_BUFFER))\n                {\n                    prBookmarks[(size_t)selectedBookmarkForEdition].name = std::string(prBookmarkEditBuffer);\n                }\n                ImGui::PopItemWidth();\n            }\n        }\n\n        ImGui::Separator();\n\n        if (!prBookmarks.empty())\n        {\n            prBookmarkClipper.Begin((int)prBookmarks.size(), ImGui::GetTextLineHeightWithSpacing());\n            while (prBookmarkClipper.Step())\n            {\n                for (int i = prBookmarkClipper.DisplayStart; i &lt; prBookmarkClipper.DisplayEnd; i++)\n                {\n                    if (i &lt; 0) continue;\n                    const BookmarkStruct&amp; bookmark = prBookmarks[(size_t)i];\n                    ImGui::PushID(i);\n                    if (ImGui::Selectable(bookmark.name.c_str(), selectedBookmarkForEdition == i,ImGuiSelectableFlags_AllowDoubleClick) ||\n                        (selectedBookmarkForEdition == -1 &amp;&amp; bookmark.path == vFileDialogInternal.puFileManager.GetCurrentPath())) // select if path is current\n                    {\n                        selectedBookmarkForEdition = i;\n                        IGFD::Utils::ResetBuffer(prBookmarkEditBuffer);\n                        IGFD::Utils::AppendToBuffer(prBookmarkEditBuffer, MAX_FILE_DIALOG_NAME_BUFFER, bookmark.name);\n\n                        if (ImGui::IsMouseDoubleClicked(0)) // apply path\n                        {\n                            vFileDialogInternal.puFileManager.SetCurrentPath(bookmark.path);\n                            vFileDialogInternal.puFileManager.OpenCurrentPath(vFileDialogInternal);\n                            res = true;\n                        }\n                    }\n                    ImGui::PopID();\n                    if (ImGui::IsItemHovered())\n                        ImGui::SetTooltip(\"%s\", bookmark.path.c_str()); //-V111\n                }\n            }\n            prBookmarkClipper.End();\n        }\n\n        ImGui::EndChild();\n\n        return res;\n    }\n\n    std::string IGFD::BookMarkFeature::SerializeBookmarks(const bool&amp; vDontSerializeCodeBasedBookmarks)\n    {\n        std::string res;\n\n        size_t idx = 0;\n        for (auto&amp; it : prBookmarks)\n        {\n            if (vDontSerializeCodeBasedBookmarks &amp;&amp; it.defined_by_code)\n                continue;\n\n            if (idx++ != 0)\n                res += \"##\"; // ## because reserved by imgui, so an input text cant have ##\n\n            res += it.name + \"##\" + it.path;\n        }\n\n        return res;\n    }\n\n    void IGFD::BookMarkFeature::DeserializeBookmarks(const std::string&amp; vBookmarks)\n    {\n        if (!vBookmarks.empty())\n        {\n            prBookmarks.clear();\n            auto arr = IGFD::Utils::SplitStringToVector(vBookmarks, '#', false);\n            for (size_t i = 0; i &lt; arr.size(); i += 2)\n            {\n                if (i + 1 &lt; arr.size()) // for avoid crash if arr size is impair due to user mistake after edition\n                {\n                    BookmarkStruct bookmark;\n                    bookmark.name = arr[i];\n                    // if bad format we jump this bookmark\n                    bookmark.path = arr[i + 1];\n                    prBookmarks.push_back(bookmark);\n                }\n            }\n        }\n    }\n\n    void IGFD::BookMarkFeature::AddBookmark(const std::string&amp; vBookMarkName, const std::string&amp; vBookMarkPath)\n    {\n        if (vBookMarkName.empty() || vBookMarkPath.empty())\n            return;\n\n        BookmarkStruct bookmark;\n        bookmark.name = vBookMarkName;\n        bookmark.path = vBookMarkPath;\n        bookmark.defined_by_code = true;\n        prBookmarks.push_back(bookmark);\n    }\n\n    bool IGFD::BookMarkFeature::RemoveBookmark(const std::string&amp; vBookMarkName)\n    {\n        if (vBookMarkName.empty())\n            return false;\n\n        for (auto bookmark_it = prBookmarks.begin(); bookmark_it != prBookmarks.end(); ++bookmark_it)\n        {\n            if ((*bookmark_it).name == vBookMarkName)\n            {\n                prBookmarks.erase(bookmark_it);\n                return true;\n            }\n        }\n\n        return false;\n    }\n#endif // USE_BOOKMARK\n\n\n    KeyExplorerFeature::KeyExplorerFeature() = default;\n\n#ifdef USE_EXPLORATION_BY_KEYS\n    bool IGFD::KeyExplorerFeature::prLocateItem_Loop(FileDialogInternal&amp; vFileDialogInternal, ImWchar vC)\n    {\n        bool found = false;\n\n        auto&amp; fdi = vFileDialogInternal.puFileManager;\n        if (!fdi.IsFilteredListEmpty())\n        {\n            auto countFiles = fdi.GetFilteredListSize();\n            for (size_t i = prLocateFileByInputChar_lastFileIdx; i &lt; countFiles; i++)\n            {\n                auto nfo = fdi.GetFilteredFileAt(i);\n                if (nfo.use_count())\n                {\n                    if (nfo-&gt;fileNameExt_optimized[0] == vC || // lower case search //-V522\n                        nfo-&gt;fileNameExt[0] == vC) // maybe upper case search\n                    {\n                        //float p = ((float)i) * ImGui::GetTextLineHeightWithSpacing();\n                        float p = (float)((double)i / (double)countFiles) * ImGui::GetScrollMaxY();\n                        ImGui::SetScrollY(p);\n                        prLocateFileByInputChar_lastFound = true;\n                        prLocateFileByInputChar_lastFileIdx = i;\n                        prStartFlashItem(prLocateFileByInputChar_lastFileIdx);\n\n                        auto infos = fdi.GetFilteredFileAt(prLocateFileByInputChar_lastFileIdx);\n                        if (infos.use_count())\n                        {\n                            if (infos-&gt;fileType.isDir()) //-V522\n                            {\n                                if (fdi.puDLGDirectoryMode) // directory chooser\n                                {\n                                    fdi.SelectFileName(vFileDialogInternal, infos);\n                                }\n                            }\n                            else\n                            {\n                                fdi.SelectFileName(vFileDialogInternal, infos);\n                            }\n\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return found;\n    }\n\n    void IGFD::KeyExplorerFeature::prLocateByInputKey(FileDialogInternal&amp; vFileDialogInternal)\n    {\n        ImGuiContext&amp; g = *GImGui;\n        auto&amp; fdi = vFileDialogInternal.puFileManager;\n        if (!g.ActiveId &amp;&amp; !fdi.IsFilteredListEmpty())\n        {\n            auto&amp; queueChar = ImGui::GetIO().InputQueueCharacters;\n            auto countFiles = fdi.GetFilteredListSize();\n\n            // point by char\n            if (!queueChar.empty())\n            {\n                ImWchar c = queueChar.back();\n                if (prLocateFileByInputChar_InputQueueCharactersSize != queueChar.size())\n                {\n                    if (c == prLocateFileByInputChar_lastChar) // next file starting with same char until\n                    {\n                        if (prLocateFileByInputChar_lastFileIdx &lt; countFiles - 1U)\n                            prLocateFileByInputChar_lastFileIdx++;\n                        else\n                            prLocateFileByInputChar_lastFileIdx = 0;\n                    }\n\n                    if (!prLocateItem_Loop(vFileDialogInternal, c))\n                    {\n                        // not found, loop again from 0 this time\n                        prLocateFileByInputChar_lastFileIdx = 0;\n                        prLocateItem_Loop(vFileDialogInternal, c);\n                    }\n\n                    prLocateFileByInputChar_lastChar = c;\n                }\n            }\n\n            prLocateFileByInputChar_InputQueueCharactersSize = queueChar.size();\n        }\n    }\n\n    void IGFD::KeyExplorerFeature::prExploreWithkeys(FileDialogInternal&amp; vFileDialogInternal, ImGuiID vListViewID)\n    {\n        auto&amp; fdi = vFileDialogInternal.puFileManager;\n        if (!fdi.IsFilteredListEmpty())\n        {\n            bool canWeExplore = false;\n            bool hasNav = (ImGui::GetIO().ConfigFlags &amp; ImGuiConfigFlags_NavEnableKeyboard);\n\n            ImGuiContext&amp; g = *GImGui;\n            if (!hasNav &amp;&amp; !g.ActiveId) // no nav and no activated inputs\n                canWeExplore = true;\n\n            if (g.NavId &amp;&amp; g.NavId == vListViewID)\n            {\n                if (ImGui::IsKeyPressed(ImGuiKey_Enter) ||\n                    ImGui::IsKeyPressed(ImGuiKey_KeypadEnter) ||\n                    ImGui::IsKeyPressed(ImGuiKey_Space))\n                {\n                    ImGui::ActivateItem(vListViewID);\n                    ImGui::SetActiveID(vListViewID, g.CurrentWindow);\n                }\n            }\n\n            if (vListViewID == g.LastActiveId-1) // if listview id is the last acticated nav id (ImGui::ActivateItem(vListViewID);)\n                canWeExplore = true;\n\n            if (canWeExplore &amp;&amp; ImGui::IsWindowFocused())\n            {\n                if (ImGui::IsKeyPressed(ImGuiKey_Escape))\n                {\n                    ImGui::ClearActiveID();\n                    g.LastActiveId = 0;\n                }\n\n                auto countFiles = fdi.GetFilteredListSize();\n\n                // explore\n                bool exploreByKey = false;\n                bool enterInDirectory = false;\n                bool exitDirectory = false;\n\n                if ((hasNav &amp;&amp; ImGui::IsKeyPressed(ImGuiKey_UpArrow)) || (!hasNav &amp;&amp; ImGui::IsKeyPressed(IGFD_KEY_UP)))\n                {\n                    exploreByKey = true;\n                    if (prLocateFileByInputChar_lastFileIdx &gt; 0)\n                        prLocateFileByInputChar_lastFileIdx--;\n                    else\n                        prLocateFileByInputChar_lastFileIdx = countFiles - 1U;\n                }\n                else if ((hasNav &amp;&amp; ImGui::IsKeyPressed(ImGuiKey_DownArrow)) || (!hasNav &amp;&amp; ImGui::IsKeyPressed(IGFD_KEY_DOWN)))\n                {\n                    exploreByKey = true;\n                    if (prLocateFileByInputChar_lastFileIdx &lt; countFiles - 1U)\n                        prLocateFileByInputChar_lastFileIdx++;\n                    else\n                        prLocateFileByInputChar_lastFileIdx = 0U;\n                }\n                else if (ImGui::IsKeyReleased(IGFD_KEY_ENTER))\n                {\n                    exploreByKey = true;\n                    enterInDirectory = true;\n                }\n                else if (ImGui::IsKeyReleased(IGFD_KEY_BACKSPACE))\n                {\n                    exploreByKey = true;\n                    exitDirectory = true;\n                }\n\n                if (exploreByKey)\n                {\n                    //float totalHeight = prFilteredFileList.size() * ImGui::GetTextLineHeightWithSpacing();\n                    float p = (float)((double)prLocateFileByInputChar_lastFileIdx / (double)(countFiles - 1U)) * ImGui::GetScrollMaxY();// seems not udpated in tables version outside tables\n                    //float p = ((float)locateFileByInputChar_lastFileIdx) * ImGui::GetTextLineHeightWithSpacing();\n                    ImGui::SetScrollY(p);\n                    prStartFlashItem(prLocateFileByInputChar_lastFileIdx);\n\n                    auto infos = fdi.GetFilteredFileAt(prLocateFileByInputChar_lastFileIdx);\n                    if (infos.use_count())\n                    {\n                        if (infos-&gt;fileType.isDir()) //-V522\n                        {\n                            if (!fdi.puDLGDirectoryMode || enterInDirectory)\n                            {\n                                if (enterInDirectory)\n                                {\n                                    if (fdi.SelectDirectory(infos))\n                                    {\n                                        // changement de repertoire\n                                        vFileDialogInternal.puFileManager.OpenCurrentPath(vFileDialogInternal);\n                                        if (prLocateFileByInputChar_lastFileIdx &gt; countFiles - 1U)\n                                        {\n                                            prLocateFileByInputChar_lastFileIdx = 0;\n                                        }\n                                    }\n                                }\n                            }\n                            else // directory chooser\n                            {\n                                fdi.SelectFileName(vFileDialogInternal, infos);\n                            }\n                        }\n                        else\n                        {\n                            fdi.SelectFileName(vFileDialogInternal, infos);\n\n                            if (enterInDirectory)\n                            {\n                                vFileDialogInternal.puIsOk = true;\n                            }\n                        }\n\n                        if (exitDirectory)\n                        {\n                            auto nfo = std::make_shared&lt;FileInfos&gt;();\n                            nfo-&gt;fileNameExt = \"..\";\n\n                            if (fdi.SelectDirectory(nfo))\n                            {\n                                // changement de repertoire\n                                vFileDialogInternal.puFileManager.OpenCurrentPath(vFileDialogInternal);\n                                if (prLocateFileByInputChar_lastFileIdx &gt; countFiles - 1U)\n                                {\n                                    prLocateFileByInputChar_lastFileIdx = 0;\n                                }\n                            }\n#ifdef _IGFD_WIN_\n                            else\n                            {\n                                if (fdi.GetComposerSize() == 1U)\n                                {\n                                    if (fdi.GetDrives())\n                                    {\n                                        fdi.ApplyFilteringOnFileList(vFileDialogInternal);\n                                    }\n                                }\n                            }\n#endif // _IGFD_WIN_\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    bool IGFD::KeyExplorerFeature::prFlashableSelectable(const char* label, bool selected,\n        ImGuiSelectableFlags flags, bool vFlashing, const ImVec2&amp; size_arg)\n    {\n        using namespace ImGui;\n\n        ImGuiWindow* window = GetCurrentWindow();\n        if (window-&gt;SkipItems)\n            return false;\n\n        ImGuiContext&amp; g = *GImGui;\n        const ImGuiStyle&amp; style = g.Style;\n\n        // Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.\n        ImGuiID id = window-&gt;GetID(label);\n        ImVec2 label_size = CalcTextSize(label, nullptr, true);\n        ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y); //-V550\n        ImVec2 pos = window-&gt;DC.CursorPos;\n        pos.y += window-&gt;DC.CurrLineTextBaseOffset;\n        ItemSize(size, 0.0f);\n\n        // Fill horizontal space\n        // We don't support (size &lt; 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.\n        const bool span_all_columns = (flags &amp; ImGuiSelectableFlags_SpanAllColumns) != 0;\n        const float min_x = span_all_columns ? window-&gt;ParentWorkRect.Min.x : pos.x;\n        const float max_x = span_all_columns ? window-&gt;ParentWorkRect.Max.x : window-&gt;WorkRect.Max.x;\n        if (fabs(size_arg.x) &lt; FLT_EPSILON || (flags &amp; ImGuiSelectableFlags_SpanAvailWidth))\n            size.x = ImMax(label_size.x, max_x - min_x);\n\n        // Text stays at the submission position, but bounding box may be extended on both sides\n        const ImVec2 text_min = pos;\n        const ImVec2 text_max(min_x + size.x, pos.y + size.y);\n\n        // Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.\n        ImRect bb(min_x, pos.y, text_max.x, text_max.y);\n        if ((flags &amp; ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)\n        {\n            const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;\n            const float spacing_y = style.ItemSpacing.y;\n            const float spacing_L = IM_FLOOR(spacing_x * 0.50f);\n            const float spacing_U = IM_FLOOR(spacing_y * 0.50f);\n            bb.Min.x -= spacing_L;\n            bb.Min.y -= spacing_U;\n            bb.Max.x += (spacing_x - spacing_L);\n            bb.Max.y += (spacing_y - spacing_U);\n        }\n        //if (g.IO.KeyCtrl) { GetForegroundDrawList()-&gt;AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }\n\n        // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackground for every Selectable..\n        const float backup_clip_rect_min_x = window-&gt;ClipRect.Min.x;\n        const float backup_clip_rect_max_x = window-&gt;ClipRect.Max.x;\n        if (span_all_columns)\n        {\n            window-&gt;ClipRect.Min.x = window-&gt;ParentWorkRect.Min.x;\n            window-&gt;ClipRect.Max.x = window-&gt;ParentWorkRect.Max.x;\n        }\n\n        bool item_add;\n        const bool disabled_item = (flags &amp; ImGuiSelectableFlags_Disabled) != 0;\n        if (disabled_item)\n        {\n            ImGuiItemFlags backup_item_flags = g.CurrentItemFlags;\n            g.CurrentItemFlags |= ImGuiItemFlags_Disabled;\n            item_add = ItemAdd(bb, id);\n            g.CurrentItemFlags = backup_item_flags;\n        }\n        else\n        {\n            item_add = ItemAdd(bb, id);\n        }\n\n        if (span_all_columns)\n        {\n            window-&gt;ClipRect.Min.x = backup_clip_rect_min_x;\n            window-&gt;ClipRect.Max.x = backup_clip_rect_max_x;\n        }\n\n        if (!item_add)\n            return false;\n\n        const bool disabled_global = (g.CurrentItemFlags &amp; ImGuiItemFlags_Disabled) != 0;\n        if (disabled_item &amp;&amp; !disabled_global) // Only testing this as an optimization\n            BeginDisabled(true);\n\n        // FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,\n        // which would be advantageous since most selectable are not selected.\n        if (span_all_columns &amp;&amp; window-&gt;DC.CurrentColumns)\n            PushColumnsBackground();\n        else if (span_all_columns &amp;&amp; g.CurrentTable)\n            TablePushBackgroundChannel();\n\n        // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries\n        ImGuiButtonFlags button_flags = 0;\n        if (flags &amp; ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }\n        if (flags &amp; ImGuiSelectableFlags_SelectOnClick) { button_flags |= ImGuiButtonFlags_PressedOnClick; }\n        if (flags &amp; ImGuiSelectableFlags_SelectOnRelease) { button_flags |= ImGuiButtonFlags_PressedOnRelease; }\n        if (flags &amp; ImGuiSelectableFlags_AllowDoubleClick) { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }\n        if (flags &amp; ImGuiSelectableFlags_AllowItemOverlap) { button_flags |= ImGuiButtonFlags_AllowItemOverlap; }\n\n        const bool was_selected = selected;\n        bool hovered, held;\n        bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, button_flags);\n\n        // Auto-select when moved into\n        // - This will be more fully fleshed in the range-select branch\n        // - This is not exposed as it won't nicely work with some user side handling of shift/control\n        // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons\n        //   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())\n        //   - (2) usage will fail with clipped items\n        //   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.\n        if ((flags &amp; ImGuiSelectableFlags_SelectOnNav) &amp;&amp; g.NavJustMovedToId != 0 &amp;&amp; g.NavJustMovedToFocusScopeId == window-&gt;DC.NavFocusScopeIdCurrent)\n            if (g.NavJustMovedToId == id)\n                selected = pressed = true;\n\n        // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard\n        if (pressed || (hovered &amp;&amp; (flags &amp; ImGuiSelectableFlags_SetNavIdOnHover)))\n        {\n            if (!g.NavDisableMouseHover &amp;&amp; g.NavWindow == window &amp;&amp; g.NavLayer == window-&gt;DC.NavLayerCurrent)\n            {\n                SetNavID(id, window-&gt;DC.NavLayerCurrent, window-&gt;DC.NavFocusScopeIdCurrent, ImRect(bb.Min - window-&gt;Pos, bb.Max - window-&gt;Pos));\n                g.NavDisableHighlight = true;\n            }\n        }\n        if (pressed)\n            MarkItemEdited(id);\n\n        if (flags &amp; ImGuiSelectableFlags_AllowItemOverlap)\n            SetItemAllowOverlap();\n\n        // In this branch, Selectable() cannot toggle the selection so this will never trigger.\n        if (selected != was_selected) //-V547\n            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;\n\n        // Render\n        if ((held &amp;&amp; (flags &amp; ImGuiSelectableFlags_DrawHoveredWhenHeld)) || vFlashing)\n            hovered = true;\n        if (hovered || selected)\n        {\n            const ImU32 col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\n            RenderFrame(bb.Min, bb.Max, col, false, 0.0f);\n        }\n        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);\n\n        if (span_all_columns &amp;&amp; window-&gt;DC.CurrentColumns)\n            PopColumnsBackground();\n        else if (span_all_columns &amp;&amp; g.CurrentTable)\n            TablePopBackgroundChannel();\n\n        RenderTextClipped(text_min, text_max, label, nullptr, &amp;label_size, style.SelectableTextAlign, &amp;bb);\n\n        // Automatically close popups\n        if (pressed &amp;&amp; (window-&gt;Flags &amp; ImGuiWindowFlags_Popup) &amp;&amp; !(flags &amp; ImGuiSelectableFlags_DontClosePopups) &amp;&amp; !(g.LastItemData.InFlags &amp; ImGuiItemFlags_SelectableDontClosePopup))\n            CloseCurrentPopup();\n\n        if (disabled_item &amp;&amp; !disabled_global)\n            EndDisabled();\n\n        IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);\n        return pressed; //-V1020\n    }\n\n    void IGFD::KeyExplorerFeature::prStartFlashItem(size_t vIdx)\n    {\n        prFlashAlpha = 1.0f;\n        prFlashedItem = vIdx;\n    }\n\n    bool IGFD::KeyExplorerFeature::prBeginFlashItem(size_t vIdx)\n    {\n        bool res = false;\n\n        if (prFlashedItem == vIdx &amp;&amp;\n            std::abs(prFlashAlpha - 0.0f) &gt; 0.00001f)\n        {\n            prFlashAlpha -= prFlashAlphaAttenInSecs * ImGui::GetIO().DeltaTime;\n            if (prFlashAlpha &lt; 0.0f) prFlashAlpha = 0.0f;\n\n            ImVec4 hov = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);\n            hov.w = prFlashAlpha;\n            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, hov);\n            res = true;\n        }\n\n        return res;\n    }\n\n    void IGFD::KeyExplorerFeature::prEndFlashItem()\n    {\n        ImGui::PopStyleColor();\n    }\n\n    void IGFD::KeyExplorerFeature::SetFlashingAttenuationInSeconds(float vAttenValue)\n    {\n        prFlashAlphaAttenInSecs = 1.0f / ImMax(vAttenValue, 0.01f);\n    }\n#endif // USE_EXPLORATION_BY_KEYS\n\n\n    IGFD::FileDialog::FileDialog() : BookMarkFeature(), KeyExplorerFeature(), ThumbnailFeature() {}\n    IGFD::FileDialog::~FileDialog() = default;\n\n\n    // path and fileNameExt can be specified\n    void IGFD::FileDialog::OpenDialog(\n        const std::string&amp; vKey,\n        const std::string&amp; vTitle,\n        const char* vFilters,\n        const std::string&amp; vPath,\n        const std::string&amp; vFileName,\n        const int&amp; vCountSelectionMax,\n        UserDatas vUserDatas,\n        ImGuiFileDialogFlags vFlags)\n    {\n        if (prFileDialogInternal.puShowDialog) // if already opened, quit\n            return;\n\n        prFileDialogInternal.ResetForNewDialog();\n\n        prFileDialogInternal.puDLGkey = vKey;\n        prFileDialogInternal.puDLGtitle = vTitle;\n        prFileDialogInternal.puDLGuserDatas = vUserDatas;\n        prFileDialogInternal.puDLGflags = vFlags;\n        prFileDialogInternal.puDLGoptionsPane = nullptr;\n        prFileDialogInternal.puDLGoptionsPaneWidth = 0.0f;\n\n        prFileDialogInternal.puFilterManager.puDLGdefaultExt.clear();\n        prFileDialogInternal.puFilterManager.ParseFilters(vFilters);\n\n        prFileDialogInternal.puFileManager.puDLGDirectoryMode = (vFilters == nullptr);\n        if (vPath.empty())\n            prFileDialogInternal.puFileManager.puDLGpath = prFileDialogInternal.puFileManager.GetCurrentPath();\n        else\n            prFileDialogInternal.puFileManager.puDLGpath = vPath;\n        prFileDialogInternal.puFileManager.SetCurrentPath(vPath);\n        prFileDialogInternal.puFileManager.puDLGcountSelectionMax = (size_t)vCountSelectionMax;\n        prFileDialogInternal.puFileManager.SetDefaultFileName(vFileName);\n\n        prFileDialogInternal.puFileManager.ClearAll();\n\n        prFileDialogInternal.puShowDialog = true;                   // open dialog\n    }\n\n    // path and filename are obtained from filePathName\n    void IGFD::FileDialog::OpenDialog(\n        const std::string&amp; vKey,\n        const std::string&amp; vTitle,\n        const char* vFilters,\n        const std::string&amp; vFilePathName,\n        const int&amp; vCountSelectionMax,\n        UserDatas vUserDatas,\n        ImGuiFileDialogFlags vFlags)\n    {\n        if (prFileDialogInternal.puShowDialog) // if already opened, quit\n            return;\n\n        prFileDialogInternal.ResetForNewDialog();\n\n        prFileDialogInternal.puDLGkey = vKey;\n        prFileDialogInternal.puDLGtitle = vTitle;\n        prFileDialogInternal.puDLGoptionsPane = nullptr;\n        prFileDialogInternal.puDLGoptionsPaneWidth = 0.0f;\n        prFileDialogInternal.puDLGuserDatas = vUserDatas;\n        prFileDialogInternal.puDLGflags = vFlags;\n\n        auto ps = IGFD::Utils::ParsePathFileName(vFilePathName);\n        if (ps.isOk)\n        {\n            prFileDialogInternal.puFileManager.puDLGpath = ps.path;\n            prFileDialogInternal.puFileManager.SetDefaultFileName(ps.name);\n            prFileDialogInternal.puFilterManager.puDLGdefaultExt = \".\" + ps.ext;\n        }\n        else\n        {\n            prFileDialogInternal.puFileManager.puDLGpath = prFileDialogInternal.puFileManager.GetCurrentPath();\n            prFileDialogInternal.puFileManager.SetDefaultFileName(\"\");\n            prFileDialogInternal.puFilterManager.puDLGdefaultExt.clear();\n        }\n\n        prFileDialogInternal.puFilterManager.ParseFilters(vFilters);\n        prFileDialogInternal.puFilterManager.SetSelectedFilterWithExt(\n            prFileDialogInternal.puFilterManager.puDLGdefaultExt);\n\n        prFileDialogInternal.puFileManager.SetCurrentPath(prFileDialogInternal.puFileManager.puDLGpath);\n\n        prFileDialogInternal.puFileManager.puDLGDirectoryMode = (vFilters == nullptr);\n        prFileDialogInternal.puFileManager.puDLGcountSelectionMax = vCountSelectionMax; //-V101\n\n        prFileDialogInternal.puFileManager.ClearAll();\n\n        prFileDialogInternal.puShowDialog = true;\n    }\n\n    // with pane\n    // path and fileNameExt can be specified\n    void IGFD::FileDialog::OpenDialog(\n        const std::string&amp; vKey,\n        const std::string&amp; vTitle,\n        const char* vFilters,\n        const std::string&amp; vPath,\n        const std::string&amp; vFileName,\n        const PaneFun&amp; vSidePane,\n        const float&amp; vSidePaneWidth,\n        const int&amp; vCountSelectionMax,\n        UserDatas vUserDatas,\n        ImGuiFileDialogFlags vFlags)\n    {\n        if (prFileDialogInternal.puShowDialog) // if already opened, quit\n            return;\n\n        prFileDialogInternal.ResetForNewDialog();\n\n        prFileDialogInternal.puDLGkey = vKey;\n        prFileDialogInternal.puDLGtitle = vTitle;\n        prFileDialogInternal.puDLGuserDatas = vUserDatas;\n        prFileDialogInternal.puDLGflags = vFlags;\n        prFileDialogInternal.puDLGoptionsPane = vSidePane;\n        prFileDialogInternal.puDLGoptionsPaneWidth = vSidePaneWidth;\n\n        prFileDialogInternal.puFilterManager.puDLGdefaultExt.clear();\n        prFileDialogInternal.puFilterManager.ParseFilters(vFilters);\n\n        prFileDialogInternal.puFileManager.puDLGcountSelectionMax = (size_t)vCountSelectionMax;\n        prFileDialogInternal.puFileManager.puDLGDirectoryMode = (vFilters == nullptr);\n        if (vPath.empty())\n            prFileDialogInternal.puFileManager.puDLGpath = prFileDialogInternal.puFileManager.GetCurrentPath();\n        else\n            prFileDialogInternal.puFileManager.puDLGpath = vPath;\n\n        prFileDialogInternal.puFileManager.SetCurrentPath(prFileDialogInternal.puFileManager.puDLGpath);\n\n        prFileDialogInternal.puFileManager.SetDefaultFileName(vFileName);\n\n        prFileDialogInternal.puFileManager.ClearAll();\n\n        prFileDialogInternal.puShowDialog = true;                   // open dialog\n    }\n\n    // with pane\n    // path and filename are obtained from filePathName\n    void IGFD::FileDialog::OpenDialog(\n        const std::string&amp; vKey,\n        const std::string&amp; vTitle,\n        const char* vFilters,\n        const std::string&amp; vFilePathName,\n        const PaneFun&amp; vSidePane,\n        const float&amp; vSidePaneWidth,\n        const int&amp; vCountSelectionMax,\n        UserDatas vUserDatas,\n        ImGuiFileDialogFlags vFlags)\n    {\n        if (prFileDialogInternal.puShowDialog) // if already opened, quit\n            return;\n\n        prFileDialogInternal.ResetForNewDialog();\n\n        prFileDialogInternal.puDLGkey = vKey;\n        prFileDialogInternal.puDLGtitle = vTitle;\n        prFileDialogInternal.puDLGoptionsPane = vSidePane;\n        prFileDialogInternal.puDLGoptionsPaneWidth = vSidePaneWidth;\n        prFileDialogInternal.puDLGuserDatas = vUserDatas;\n        prFileDialogInternal.puDLGflags = vFlags;\n\n        auto ps = IGFD::Utils::ParsePathFileName(vFilePathName);\n        if (ps.isOk)\n        {\n            prFileDialogInternal.puFileManager.puDLGpath = ps.path;\n            prFileDialogInternal.puFileManager.SetDefaultFileName(vFilePathName);\n            prFileDialogInternal.puFilterManager.puDLGdefaultExt = \".\" + ps.ext;\n        }\n        else\n        {\n            prFileDialogInternal.puFileManager.puDLGpath = prFileDialogInternal.puFileManager.GetCurrentPath();\n            prFileDialogInternal.puFileManager.SetDefaultFileName(\"\");\n            prFileDialogInternal.puFilterManager.puDLGdefaultExt.clear();\n        }\n\n        prFileDialogInternal.puFileManager.SetCurrentPath(prFileDialogInternal.puFileManager.puDLGpath);\n\n        prFileDialogInternal.puFileManager.puDLGcountSelectionMax = vCountSelectionMax; //-V101\n        prFileDialogInternal.puFileManager.puDLGDirectoryMode = (vFilters == nullptr);\n        prFileDialogInternal.puFilterManager.ParseFilters(vFilters);\n        prFileDialogInternal.puFilterManager.SetSelectedFilterWithExt(\n            prFileDialogInternal.puFilterManager.puDLGdefaultExt);\n\n        prFileDialogInternal.puFileManager.ClearAll();\n\n        prFileDialogInternal.puShowDialog = true;\n    }\n\n\n    bool IGFD::FileDialog::Display(const std::string&amp; vKey, ImGuiWindowFlags vFlags, ImVec2 vMinSize, ImVec2 vMaxSize)\n    {\n        bool res = false;\n\n        if (prFileDialogInternal.puShowDialog &amp;&amp; prFileDialogInternal.puDLGkey == vKey)\n        {\n            if (prFileDialogInternal.puUseCustomLocale)\n                setlocale(prFileDialogInternal.puLocaleCategory, prFileDialogInternal.puLocaleBegin.c_str());\n\n            auto&amp; fdFile = prFileDialogInternal.puFileManager;\n            auto&amp; fdFilter = prFileDialogInternal.puFilterManager;\n\n            static ImGuiWindowFlags flags; // todo: not a good solution for multi instance, to fix\n\n            // to be sure than only one dialog is displayed per frame\n            ImGuiContext&amp; g = *GImGui;\n            if (g.FrameCount == prFileDialogInternal.puLastImGuiFrameCount) // one instance was displayed this frame before for this key +&gt; quit\n                return res;\n            prFileDialogInternal.puLastImGuiFrameCount = g.FrameCount; // mark this instance as used this frame\n\n            std::string name = prFileDialogInternal.puDLGtitle + \"##\" + prFileDialogInternal.puDLGkey;\n            if (prFileDialogInternal.puName != name)\n            {\n                fdFile.ClearComposer();\n                fdFile.ClearFileLists();\n                flags = vFlags;\n            }\n\n            NewFrame();\n\n#ifdef IMGUI_HAS_VIEWPORT\n            if (!ImGui::GetIO().ConfigViewportsNoDecoration)\n            {\n                // https://github.com/ocornut/imgui/issues/4534\n                ImGuiWindowClass window_class;\n                window_class.ViewportFlagsOverrideClear = ImGuiViewportFlags_NoDecoration;\n                ImGui::SetNextWindowClass(&amp;window_class);\n            }\n#endif // IMGUI_HAS_VIEWPORT\n\n            bool beg = false;\n            if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_NoDialog) // disable our own dialog system (standard or modal)\n            {\n                beg = true;\n            }\n            else\n            {\n                ImGui::SetNextWindowSizeConstraints(vMinSize, vMaxSize);\n\n                if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_Modal &amp;&amp;\n                    !prFileDialogInternal.puOkResultToConfirm) // disable modal because the confirm dialog for overwrite is a new modal\n                {\n                    ImGui::OpenPopup(name.c_str());\n                    beg = ImGui::BeginPopupModal(name.c_str(), (bool*)nullptr,\n                        flags | ImGuiWindowFlags_NoScrollbar);\n                }\n                else\n                {\n                    beg = ImGui::Begin(name.c_str(), (bool*)nullptr, flags | ImGuiWindowFlags_NoScrollbar);\n                }\n            }\n            if (beg)\n            {\n#ifdef IMGUI_HAS_VIEWPORT\n                // if decoration is enabled we disable the resizing feature of imgui for avoid crash with SDL2 and GLFW3\n                if (ImGui::GetIO().ConfigViewportsNoDecoration)\n                {\n                    flags = vFlags;\n                }\n                else\n                {\n                    auto win = ImGui::GetCurrentWindowRead();\n                    if (win-&gt;Viewport-&gt;Idx != 0)\n                        flags |= ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar;\n                    else\n                        flags = vFlags;\n                }\n#endif // IMGUI_HAS_VIEWPORT\n\n                ImGuiID _frameId = ImGui::GetID(name.c_str());\n                ImVec2 frameSize = ImVec2(0, 0);\n                if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_NoDialog)\n                    frameSize = vMaxSize;\n                if (ImGui::BeginChild(_frameId, frameSize,\n                    false, flags | ImGuiWindowFlags_NoScrollbar))\n                {\n                    prFileDialogInternal.puName = name; //-V820\n                    puAnyWindowsHovered |= ImGui::IsWindowHovered();\n\n                    if (fdFile.puDLGpath.empty())\n                        fdFile.puDLGpath = \".\"; // defaut path is '.'\n\n                    fdFilter.SetDefaultFilterIfNotDefined();\n\n                    // init list of files\n                    if (fdFile.IsFileListEmpty() &amp;&amp; !fdFile.puShowDrives)\n                    {\n                        IGFD::Utils::ReplaceString(fdFile.puDLGDefaultFileName, fdFile.puDLGpath, \"\"); // local path\n                        if (!fdFile.puDLGDefaultFileName.empty())\n                        {\n                            fdFile.SetDefaultFileName(fdFile.puDLGDefaultFileName);\n                            fdFilter.SetSelectedFilterWithExt(fdFilter.puDLGdefaultExt);\n                        }\n                        else if (fdFile.puDLGDirectoryMode) // directory mode\n                            fdFile.SetDefaultFileName(\".\");\n                        fdFile.ScanDir(prFileDialogInternal, fdFile.puDLGpath);\n                    }\n\n                    // draw dialog parts\n                    prDrawHeader(); // bookmark, directory, path\n                    prDrawContent(); // bookmark, files view, side pane \n                    res = prDrawFooter(); // file field, filter combobox, ok/cancel buttons\n\n                    EndFrame();\n\n\n                }\n                ImGui::EndChild();\n\n                // for display in dialog center, the confirm to overwrite dlg\n                prFileDialogInternal.puDialogCenterPos = ImGui::GetCurrentWindowRead()-&gt;ContentRegionRect.GetCenter();\n\n                // when the confirm to overwrite dialog will appear we need to \n                // disable the modal mode of the main file dialog\n                // see prOkResultToConfirm under\n                if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_Modal &amp;&amp;\n                    !prFileDialogInternal.puOkResultToConfirm)\n                    ImGui::EndPopup();\n            }\n\n            if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_NoDialog) // disable our own dialog system (standard or modal)\n            {\n\n            }\n            else\n            {\n                // same things here regarding prOkResultToConfirm\n                if (!(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_Modal) ||\n                    prFileDialogInternal.puOkResultToConfirm)\n                    ImGui::End();\n            }\n            // confirm the result and show the confirm to overwrite dialog if needed\n            res = prConfirm_Or_OpenOverWriteFileDialog_IfNeeded(res, vFlags);\n\n            if (prFileDialogInternal.puUseCustomLocale)\n                setlocale(prFileDialogInternal.puLocaleCategory, prFileDialogInternal.puLocaleEnd.c_str());\n        }\n\n        return res;\n    }\n\n    void IGFD::FileDialog::NewFrame()\n    {\n        prFileDialogInternal.NewFrame();\n        NewThumbnailFrame(prFileDialogInternal);\n    }\n\n    void IGFD::FileDialog::EndFrame()\n    {\n        EndThumbnailFrame(prFileDialogInternal);\n        prFileDialogInternal.EndFrame();\n\n    }\n    void IGFD::FileDialog::QuitFrame()\n    {\n        QuitThumbnailFrame(prFileDialogInternal);\n    }\n\n    void IGFD::FileDialog::prDrawHeader()\n    {\n#ifdef USE_BOOKMARK\n        if (!(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableBookmarkMode))\n        {\n            prDrawBookmarkButton();\n            ImGui::SameLine();\n        }\n\n#endif // USE_BOOKMARK\n\n        prFileDialogInternal.puFileManager.DrawDirectoryCreation(prFileDialogInternal);\n\n        if (\n#ifdef USE_BOOKMARK\n            !(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableBookmarkMode) ||\n#endif // USE_BOOKMARK\n            !(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableCreateDirectoryButton))\n        {\n            ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);\n            ImGui::SameLine();\n        }\n        prFileDialogInternal.puFileManager.DrawPathComposer(prFileDialogInternal);\n\n#ifdef USE_THUMBNAILS\n        if (!(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableThumbnailMode))\n        {\n            prDrawDisplayModeToolBar();\n            ImGui::SameLine();\n            ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);\n            ImGui::SameLine();\n        }\n#endif // USE_THUMBNAILS\n\n        // prFileDialogInternal.puSearchManager.DrawSearchBar(prFileDialogInternal);  //TODO: AIAC: implement virtual touch keybord\n    }\n\n    void IGFD::FileDialog::prDrawContent()\n    {\n        ImVec2 size = ImGui::GetContentRegionAvail() - ImVec2(0.0f, prFileDialogInternal.puFooterHeight);\n\n#ifdef USE_BOOKMARK\n        if (!(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableBookmarkMode))\n        {\n            if (prBookmarkPaneShown)\n            {\n                //size.x -= prBookmarkWidth;\n                float otherWidth = size.x - prBookmarkWidth;\n                ImGui::PushID(\"##splitterbookmark\");\n                IGFD::Utils::Splitter(true, 4.0f,\n                    &amp;prBookmarkWidth, &amp;otherWidth, 10.0f,\n                    10.0f + prFileDialogInternal.puDLGoptionsPaneWidth, size.y);\n                ImGui::PopID();\n                size.x -= otherWidth;\n                prDrawBookmarkPane(prFileDialogInternal, size);\n                ImGui::SameLine();\n            }\n        }\n#endif // USE_BOOKMARK\n\n        size.x = ImGui::GetContentRegionAvail().x - prFileDialogInternal.puDLGoptionsPaneWidth;\n\n        if (prFileDialogInternal.puDLGoptionsPane)\n        {\n            ImGui::PushID(\"##splittersidepane\");\n            IGFD::Utils::Splitter(true, 4.0f, &amp;size.x, &amp;prFileDialogInternal.puDLGoptionsPaneWidth, 10.0f, 10.0f, size.y);\n            ImGui::PopID();\n        }\n\n#ifdef USE_THUMBNAILS\n        if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableThumbnailMode)\n        {\n            prDrawFileListView(size);\n        }\n        else\n        {\n            switch (prDisplayMode)\n            {\n            case DisplayModeEnum::FILE_LIST:\n                prDrawFileListView(size);\n                break;\n            case DisplayModeEnum::THUMBNAILS_LIST:\n                prDrawThumbnailsListView(size);\n                break;\n            case DisplayModeEnum::THUMBNAILS_GRID:\n                prDrawThumbnailsGridView(size);\n            }\n        }\n#else   // USE_THUMBNAILS\n        prDrawFileListView(size);\n#endif  // USE_THUMBNAILS\n\n        if (prFileDialogInternal.puDLGoptionsPane)\n        {\n            prDrawSidePane(size.y);\n        }\n\n#if defined(USE_QUICK_PATH_SELECT)\n        DisplayPathPopup(size);\n#endif // USE_QUICK_PATH_SELECT\n    }\n\n#if defined(USE_QUICK_PATH_SELECT)\n    void IGFD::FileDialog::DisplayPathPopup(ImVec2 vSize)\n    {\n        ImVec2 size = ImVec2(vSize.x * 0.5f, vSize.y * 0.5f);\n        if (ImGui::BeginPopup(\"IGFD_Path_Popup\"))\n        {\n            auto&amp; fdi = prFileDialogInternal.puFileManager;\n\n            ImGui::PushID(this);\n\n            static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg |\n                ImGuiTableFlags_Hideable | ImGuiTableFlags_ScrollY | ImGuiTableFlags_NoHostExtendY;\n            auto listViewID = ImGui::GetID(\"##FileDialog_pathTable\");\n            if (ImGui::BeginTableEx(\"##FileDialog_pathTable\", listViewID, 1, flags, size, 0.0f)) //-V112\n            {\n                ImGui::TableSetupScrollFreeze(0, 1); // Make header always visible\n                ImGui::TableSetupColumn(tableHeaderFileNameString, ImGuiTableColumnFlags_WidthStretch |\n                    (defaultSortOrderFilename ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending), -1, 0);\n\n                ImGui::TableHeadersRow();\n\n                if (!fdi.IsPathFilteredListEmpty())\n                {\n                    std::string _str;\n                    ImFont* _font = nullptr;\n                    bool _showColor = false;\n\n                    prPathListClipper.Begin((int)fdi.GetPathFilteredListSize(), ImGui::GetTextLineHeightWithSpacing());\n                    while (prPathListClipper.Step())\n                    {\n                        for (int i = prPathListClipper.DisplayStart; i &lt; prPathListClipper.DisplayEnd; i++)\n                        {\n                            if (i &lt; 0) continue;\n\n                            auto infos = fdi.GetFilteredPathAt((size_t)i);\n                            if (!infos.use_count())\n                                continue;\n\n                            prBeginFileColorIconStyle(infos, _showColor, _str, &amp;_font);\n\n                            bool selected = fdi.IsFileNameSelected(infos-&gt;fileNameExt); // found\n\n                            ImGui::TableNextRow();\n\n                            if (ImGui::TableNextColumn()) // file name\n                            {\n                                if (ImGui::Selectable(infos-&gt;fileNameExt.c_str(), &amp;selected,\n                                    ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_SpanAvailWidth))\n                                {\n                                    fdi.SetCurrentPath(fdi.ComposeNewPath(fdi.GetCurrentPopupComposedPath()));\n                                    fdi.puPathClicked = fdi.SelectDirectory(infos);\n                                    ImGui::CloseCurrentPopup();\n                                }\n                            }\n\n                            prEndFileColorIconStyle(_showColor, _font);\n                        }\n                    }\n                    prPathListClipper.End();\n                }\n\n                ImGui::EndTable();\n            }\n\n            ImGui::PopID();\n\n            ImGui::EndPopup();\n        }\n    }\n#endif\n\n    bool IGFD::FileDialog::prDrawOkButton()\n    {\n        auto&amp; fdFile = prFileDialogInternal.puFileManager;\n        if (prFileDialogInternal.puCanWeContinue &amp;&amp; strlen(fdFile.puFileNameBuffer))\n        {\n            if (IMGUI_BUTTON(okButtonString \"##validationdialog\", ImVec2(okButtonWidth, 0.0f)) || prFileDialogInternal.puIsOk)\n            {\n                prFileDialogInternal.puIsOk = true;\n                return true;\n            }\n\n#if !invertOkAndCancelButtons\n            ImGui::SameLine();\n#endif\n\n        }\n\n        return false;\n    }\n\n    bool IGFD::FileDialog::prDrawCancelButton()\n    {\n        if (IMGUI_BUTTON(cancelButtonString \"##validationdialog\", ImVec2(cancelButtonWidth, 0.0f)) ||\n            prFileDialogInternal.puNeedToExitDialog) // dialog exit asked\n        {\n            prFileDialogInternal.puIsOk = false;\n            return true;\n        }\n\n#if invertOkAndCancelButtons\n        ImGui::SameLine();\n#endif\n\n        return false;\n    }\n\n    bool IGFD::FileDialog::prDrawValidationButtons()\n    {\n        bool res = false;\n\n        ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (ImGui::GetContentRegionAvail().x - prOkCancelButtonWidth) * okCancelButtonAlignement);\n\n        ImGui::BeginGroup();\n\n        if (invertOkAndCancelButtons)\n        {\n            res |= prDrawCancelButton();\n            res |= prDrawOkButton();\n        }\n        else\n        {\n            res |= prDrawOkButton();\n            res |= prDrawCancelButton();\n        }\n\n        ImGui::EndGroup();\n\n        prOkCancelButtonWidth = ImGui::GetItemRectSize().x;\n\n        return res;\n    }\n\n    bool IGFD::FileDialog::prDrawFooter()\n    {\n        auto&amp; fdFile = prFileDialogInternal.puFileManager;\n\n        float posY = ImGui::GetCursorPos().y; // height of last bar calc\n\n        ImGui::AlignTextToFramePadding();\n\n        if (!fdFile.puDLGDirectoryMode)\n            ImGui::Text(fileNameString);\n        else // directory chooser\n            ImGui::Text(dirNameString);\n\n        ImGui::SameLine();\n\n        // Input file fields\n        float width = ImGui::GetContentRegionAvail().x;\n        if (!fdFile.puDLGDirectoryMode)\n        {\n            ImGuiContext&amp; g = *GImGui;\n            width -= FILTER_COMBO_WIDTH + g.Style.ItemSpacing.x;\n        }\n\n        ImGui::PushItemWidth(width);\n\n        ImGuiInputTextFlags flags = ImGuiInputTextFlags_EnterReturnsTrue;\n\n        if (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_ReadOnlyFileNameField)\n        {\n            flags |= ImGuiInputTextFlags_ReadOnly;\n        }\n\n        if (ImGui::InputText(\"##FileName\", fdFile.puFileNameBuffer, MAX_FILE_DIALOG_NAME_BUFFER, flags))\n        {\n            prFileDialogInternal.puIsOk = true;\n        }\n\n        if (ImGui::GetItemID() == ImGui::GetActiveID())\n            prFileDialogInternal.puFileInputIsActive = true;\n        ImGui::PopItemWidth();\n\n        // combobox of filters\n        prFileDialogInternal.puFilterManager.DrawFilterComboBox(prFileDialogInternal);\n\n        bool res = false;\n\n        res = prDrawValidationButtons();\n\n        prFileDialogInternal.puFooterHeight = ImGui::GetCursorPosY() - posY;\n\n        return res;\n    }\n\n    void IGFD::FileDialog::prSelectableItem(int vidx, std::shared_ptr&lt;FileInfos&gt; vInfos, bool vSelected, const char* vFmt, ...)\n    {\n        if (!vInfos.use_count())\n            return;\n\n        auto&amp; fdi = prFileDialogInternal.puFileManager;\n\n        static ImGuiSelectableFlags selectableFlags = ImGuiSelectableFlags_AllowDoubleClick |\n            ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_SpanAvailWidth;\n\n        va_list args;\n        va_start(args, vFmt);\n        vsnprintf(fdi.puVariadicBuffer, MAX_FILE_DIALOG_NAME_BUFFER, vFmt, args);\n        va_end(args);\n\n        float h = 0.0f;\n#ifdef USE_THUMBNAILS\n        if (prDisplayMode == DisplayModeEnum::THUMBNAILS_LIST &amp;&amp;\n            !(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_DisableThumbnailMode))\n        {\n            h = DisplayMode_ThumbailsList_ImageHeight;\n        }\n#endif // USE_THUMBNAILS\n#ifdef USE_EXPLORATION_BY_KEYS\n        bool flashed = prBeginFlashItem((size_t)vidx);\n        bool res = prFlashableSelectable(fdi.puVariadicBuffer, vSelected, selectableFlags,\n            flashed, ImVec2(-1.0f, h));\n        if (flashed)\n            prEndFlashItem();\n#else // USE_EXPLORATION_BY_KEYS\n        (void)vidx; // remove a warnings ofr unused var\n\n        bool res = ImGui::Selectable(fdi.puVariadicBuffer, vSelected, selectableFlags, ImVec2(-1.0f, h));\n#endif // USE_EXPLORATION_BY_KEYS\n        if (res)\n        {\n            if (vInfos-&gt;fileType.isDir())\n            {\n                // nav system, selectable cause open directory or select directory\n                if (ImGui::GetIO().ConfigFlags &amp; ImGuiConfigFlags_NavEnableKeyboard)\n                {\n                    // little fix for get back the mouse behavior in nav system\n                    if (ImGui::IsMouseDoubleClicked(0)) // 0 -&gt; left mouse button double click\n                    {\n                        fdi.puPathClicked = fdi.SelectDirectory(vInfos);\n                    }\n                    else if (fdi.puDLGDirectoryMode) // directory chooser\n                    {\n                        fdi.SelectFileName(prFileDialogInternal, vInfos);\n                    }\n                    else\n                    {\n                        fdi.puPathClicked = fdi.SelectDirectory(vInfos);\n                    }\n                }\n                else // no nav system =&gt; classic behavior\n                {\n                    if (ImGui::IsMouseDoubleClicked(0)) // 0 -&gt; left mouse button double click\n                    {\n                        fdi.puPathClicked = fdi.SelectDirectory(vInfos);\n                    }\n                    else if (fdi.puDLGDirectoryMode) // directory chooser\n                    {\n                        fdi.SelectFileName(prFileDialogInternal, vInfos);\n                    }\n                }\n            }\n            else\n            {\n                fdi.SelectFileName(prFileDialogInternal, vInfos);\n\n                if (ImGui::IsMouseDoubleClicked(0))\n                {\n                    prFileDialogInternal.puIsOk = true;\n                }\n            }\n        }\n    }\n\n    void IGFD::FileDialog::prBeginFileColorIconStyle(std::shared_ptr&lt;FileInfos&gt; vFileInfos, bool&amp; vOutShowColor, std::string&amp; vOutStr, ImFont** vOutFont)\n    {\n        vOutStr.clear();\n        vOutShowColor = false;\n\n        if (vFileInfos-&gt;fileStyle.use_count()) //-V807 //-V522\n        {\n            vOutShowColor = true;\n\n            *vOutFont = vFileInfos-&gt;fileStyle-&gt;font;\n        }\n\n        if (vOutShowColor &amp;&amp; !vFileInfos-&gt;fileStyle-&gt;icon.empty()) vOutStr = vFileInfos-&gt;fileStyle-&gt;icon;\n        else if (vFileInfos-&gt;fileType.isDir()) vOutStr = dirEntryString;\n        else if (vFileInfos-&gt;fileType.isLinkToUnknown()) vOutStr = linkEntryString;\n        else if (vFileInfos-&gt;fileType.isFile()) vOutStr = fileEntryString;\n\n        vOutStr += \" \" + vFileInfos-&gt;fileNameExt;\n\n        if (vOutShowColor)\n            ImGui::PushStyleColor(ImGuiCol_Text, vFileInfos-&gt;fileStyle-&gt;color);\n        if (*vOutFont)\n            ImGui::PushFont(*vOutFont);\n    }\n\n    void IGFD::FileDialog::prEndFileColorIconStyle(const bool&amp; vShowColor, ImFont* vFont)\n    {\n        if (vFont)\n            ImGui::PopFont();\n        if (vShowColor)\n            ImGui::PopStyleColor();\n    }\n\n    void IGFD::FileDialog::prDrawFileListView(ImVec2 vSize)\n    {\n        auto&amp; fdi = prFileDialogInternal.puFileManager;\n\n        ImGui::PushID(this);\n\n        static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg |\n            ImGuiTableFlags_Hideable | ImGuiTableFlags_ScrollY |\n            ImGuiTableFlags_NoHostExtendY\n#ifndef USE_CUSTOM_SORTING_ICON\n            | ImGuiTableFlags_Sortable\n#endif // USE_CUSTOM_SORTING_ICON\n            ;\n        auto listViewID = ImGui::GetID(\"##FileDialog_fileTable\");\n        if (ImGui::BeginTableEx(\"##FileDialog_fileTable\", listViewID, 4, flags, vSize, 0.0f)) //-V112\n        {\n            ImGui::TableSetupScrollFreeze(0, 1); // Make header always visible\n            ImGui::TableSetupColumn(fdi.puHeaderFileName.c_str(), ImGuiTableColumnFlags_WidthStretch |\n                (defaultSortOrderFilename ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending), -1, 0);\n            ImGui::TableSetupColumn(fdi.puHeaderFileType.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderType ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending) |\n                ((prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_HideColumnType) ? ImGuiTableColumnFlags_DefaultHide : 0), -1, 1);\n            ImGui::TableSetupColumn(fdi.puHeaderFileSize.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderSize ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending) |\n                ((prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_HideColumnSize) ? ImGuiTableColumnFlags_DefaultHide : 0), -1, 2);\n            ImGui::TableSetupColumn(fdi.puHeaderFileDate.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderDate ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending) |\n                ((prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_HideColumnDate) ? ImGuiTableColumnFlags_DefaultHide : 0), -1, 3);\n\n#ifndef USE_CUSTOM_SORTING_ICON\n            // Sort our data if sort specs have been changed!\n            if (ImGuiTableSortSpecs* sorts_specs = ImGui::TableGetSortSpecs())\n            {\n                if (sorts_specs-&gt;SpecsDirty &amp;&amp; !fdi.IsFileListEmpty())\n                {\n                    bool direction = sorts_specs-&gt;Specs-&gt;SortDirection == ImGuiSortDirection_Ascending;\n\n                    if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 0)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_FILENAME;\n                        fdi.puSortingDirection[0] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 1)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_TYPE;\n                        fdi.puSortingDirection[1] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 2)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_SIZE;\n                        fdi.puSortingDirection[2] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else //if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 3) =&gt; alwayd true for the moment, to uncomment if we add a fourth column\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_DATE;\n                        fdi.puSortingDirection[3] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n\n                    sorts_specs-&gt;SpecsDirty = false;\n                }\n            }\n\n            ImGui::TableHeadersRow();\n#else // USE_CUSTOM_SORTING_ICON\n            ImGui::TableNextRow(ImGuiTableRowFlags_Headers);\n            for (int column = 0; column &lt; 4; column++) //-V112\n            {\n                ImGui::TableSetColumnIndex(column);\n                const char* column_name = ImGui::TableGetColumnName(column); // Retrieve name passed to TableSetupColumn()\n                ImGui::PushID(column);\n                ImGui::TableHeader(column_name);\n                ImGui::PopID();\n                if (ImGui::IsItemClicked())\n                {\n                    if (column == 0)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_FILENAME)\n                            fdi.puSortingDirection[0] = !fdi.puSortingDirection[0];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_FILENAME;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (column == 1)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_TYPE)\n                            fdi.puSortingDirection[1] = !fdi.puSortingDirection[1];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_TYPE;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (column == 2)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_SIZE)\n                            fdi.puSortingDirection[2] = !fdi.puSortingDirection[2];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_SIZE;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else //if (column == 3) =&gt; alwayd true for the moment, to uncomment if we add a fourth column\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_DATE)\n                            fdi.puSortingDirection[3] = !fdi.puSortingDirection[3];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_DATE;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                }\n            }\n#endif // USE_CUSTOM_SORTING_ICON\n            if (!fdi.IsFilteredListEmpty())\n            {\n                std::string _str;\n                ImFont* _font = nullptr;\n                bool _showColor = false;\n\n                prFileListClipper.Begin((int)fdi.GetFilteredListSize(), ImGui::GetTextLineHeightWithSpacing());\n                while (prFileListClipper.Step())\n                {\n                    for (int i = prFileListClipper.DisplayStart; i &lt; prFileListClipper.DisplayEnd; i++)\n                    {\n                        if (i &lt; 0) continue;\n\n                        auto infos = fdi.GetFilteredFileAt((size_t)i);\n                        if (!infos.use_count())\n                            continue;\n\n                        prBeginFileColorIconStyle(infos, _showColor, _str, &amp;_font);\n\n                        bool selected = fdi.IsFileNameSelected(infos-&gt;fileNameExt); // found\n\n                        ImGui::TableNextRow();\n\n                        if (ImGui::TableNextColumn()) // file name\n                        {\n                            prSelectableItem(i, infos, selected, _str.c_str());\n                        }\n                        if (ImGui::TableNextColumn()) // file type\n                        {\n                            ImGui::Text(\"%s\", infos-&gt;fileExt.c_str());\n                        }\n                        if (ImGui::TableNextColumn()) // file size\n                        {\n                            if (!infos-&gt;fileType.isDir())\n                            {\n                                ImGui::Text(\"%s \", infos-&gt;formatedFileSize.c_str());\n                            }\n                            else\n                            {\n                                ImGui::TextUnformatted(\"\");\n                            }\n                        }\n                        if (ImGui::TableNextColumn()) // file date + time\n                        {\n                            ImGui::Text(\"%s\", infos-&gt;fileModifDate.c_str());\n                        }\n\n                        prEndFileColorIconStyle(_showColor, _font);\n                    }\n                }\n                prFileListClipper.End();\n            }\n\n#ifdef USE_EXPLORATION_BY_KEYS\n            if (!fdi.puInputPathActivated)\n            {\n                prLocateByInputKey(prFileDialogInternal);\n                prExploreWithkeys(prFileDialogInternal, listViewID);\n            }\n#endif // USE_EXPLORATION_BY_KEYS\n\n            ImGuiContext&amp; g = *GImGui;\n            if (g.LastActiveId - 1 == listViewID || g.LastActiveId == listViewID)\n            {\n                prFileDialogInternal.puFileListViewIsActive = true;\n            }\n\n            ImGui::EndTable();\n        }\n\n        ImGui::PopID();\n    }\n\n#ifdef USE_THUMBNAILS\n    void IGFD::FileDialog::prDrawThumbnailsListView(ImVec2 vSize)\n    {\n        auto&amp; fdi = prFileDialogInternal.puFileManager;\n\n        ImGui::PushID(this);\n\n        static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg |\n            ImGuiTableFlags_Hideable | ImGuiTableFlags_ScrollY |\n            ImGuiTableFlags_NoHostExtendY\n#ifndef USE_CUSTOM_SORTING_ICON\n            | ImGuiTableFlags_Sortable\n#endif // USE_CUSTOM_SORTING_ICON\n            ;\n        auto listViewID = ImGui::GetID(\"##FileDialog_fileTable\");\n        if (ImGui::BeginTableEx(\"##FileDialog_fileTable\", listViewID, 5, flags, vSize, 0.0f))\n        {\n            ImGui::TableSetupScrollFreeze(0, 1); // Make header always visible\n            ImGui::TableSetupColumn(fdi.puHeaderFileName.c_str(), ImGuiTableColumnFlags_WidthStretch |\n                (defaultSortOrderFilename ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending), -1, 0);\n            ImGui::TableSetupColumn(fdi.puHeaderFileType.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderType ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending) |\n                ((prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_HideColumnType) ? ImGuiTableColumnFlags_DefaultHide : 0), -1, 1);\n            ImGui::TableSetupColumn(fdi.puHeaderFileSize.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderSize ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending) |\n                ((prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_HideColumnSize) ? ImGuiTableColumnFlags_DefaultHide : 0), -1, 2);\n            ImGui::TableSetupColumn(fdi.puHeaderFileDate.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderDate ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending) |\n                ((prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_HideColumnDate) ? ImGuiTableColumnFlags_DefaultHide : 0), -1, 3);\n            // not needed to have an option for hide the thumbnails since this is why this view is used\n            ImGui::TableSetupColumn(fdi.puHeaderFileThumbnails.c_str(), ImGuiTableColumnFlags_WidthFixed |\n                (defaultSortOrderThumbnails ? ImGuiTableColumnFlags_PreferSortAscending : ImGuiTableColumnFlags_PreferSortDescending), -1, 4); //-V112\n\n#ifndef USE_CUSTOM_SORTING_ICON\n            // Sort our data if sort specs have been changed!\n            if (ImGuiTableSortSpecs* sorts_specs = ImGui::TableGetSortSpecs())\n            {\n                if (sorts_specs-&gt;SpecsDirty &amp;&amp; !fdi.IsFileListEmpty())\n                {\n                    bool direction = sorts_specs-&gt;Specs-&gt;SortDirection == ImGuiSortDirection_Ascending;\n\n                    if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 0)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_FILENAME;\n                        fdi.puSortingDirection[0] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 1)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_TYPE;\n                        fdi.puSortingDirection[1] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 2)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_SIZE;\n                        fdi.puSortingDirection[2] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 3)\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_DATE;\n                        fdi.puSortingDirection[3] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else // if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 4) = &gt; always true for the moment, to uncomment if we add another column\n                    {\n                        fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_THUMBNAILS;\n                        fdi.puSortingDirection[4] = direction;\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n\n                    sorts_specs-&gt;SpecsDirty = false;\n                }\n            }\n\n            ImGui::TableHeadersRow();\n#else // USE_CUSTOM_SORTING_ICON\n            ImGui::TableNextRow(ImGuiTableRowFlags_Headers);\n            for (int column = 0; column &lt; 5; column++)\n            {\n                ImGui::TableSetColumnIndex(column);\n                const char* column_name = ImGui::TableGetColumnName(column); // Retrieve name passed to TableSetupColumn()\n                ImGui::PushID(column);\n                ImGui::TableHeader(column_name);\n                ImGui::PopID();\n                if (ImGui::IsItemClicked())\n                {\n                    if (column == 0)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_FILENAME)\n                            fdi.puSortingDirection[0] = !fdi.puSortingDirection[0];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_FILENAME;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (column == 1)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_TYPE)\n                            fdi.puSortingDirection[1] = !fdi.puSortingDirection[1];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_TYPE;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (column == 2)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_SIZE)\n                            fdi.puSortingDirection[2] = !fdi.puSortingDirection[2];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_SIZE;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else if (column == 3)\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_DATE)\n                            fdi.puSortingDirection[3] = !fdi.puSortingDirection[3];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_DATE;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                    else // if (sorts_specs-&gt;Specs-&gt;ColumnUserID == 4) = &gt; always true for the moment, to uncomment if we add another column\n                    {\n                        if (fdi.puSortingField == IGFD::FileManager::SortingFieldEnum::FIELD_THUMBNAILS)\n                            fdi.puSortingDirection[4] = !fdi.puSortingDirection[4];\n                        else\n                            fdi.puSortingField = IGFD::FileManager::SortingFieldEnum::FIELD_THUMBNAILS;\n\n                        fdi.SortFields(prFileDialogInternal);\n                    }\n                }\n            }\n#endif // USE_CUSTOM_SORTING_ICON\n            if (!fdi.IsFilteredListEmpty())\n            {\n                std::string _str;\n                ImFont* _font = nullptr;\n                bool _showColor = false;\n\n                ImGuiContext&amp; g = *GImGui;\n                const float itemHeight = ImMax(g.FontSize, DisplayMode_ThumbailsList_ImageHeight) + g.Style.ItemSpacing.y;\n\n                prFileListClipper.Begin((int)fdi.GetFilteredListSize(), itemHeight);\n                while (prFileListClipper.Step())\n                {\n                    for (int i = prFileListClipper.DisplayStart; i &lt; prFileListClipper.DisplayEnd; i++)\n                    {\n                        if (i &lt; 0) continue;\n\n                        auto infos = fdi.GetFilteredFileAt((size_t)i);\n                        if (!infos.use_count())\n                            continue;\n\n                        prBeginFileColorIconStyle(infos, _showColor, _str, &amp;_font);\n\n                        bool selected = fdi.IsFileNameSelected(infos-&gt;fileNameExt); // found\n\n                        ImGui::TableNextRow();\n\n                        if (ImGui::TableNextColumn()) // file name\n                        {\n                            prSelectableItem(i, infos, selected, _str.c_str());\n                        }\n                        if (ImGui::TableNextColumn()) // file type\n                        {\n                            ImGui::Text(\"%s\", infos-&gt;fileExt.c_str());\n                        }\n                        if (ImGui::TableNextColumn()) // file size\n                        {\n                            if (!infos-&gt;fileType.isDir())\n                            {\n                                ImGui::Text(\"%s \", infos-&gt;formatedFileSize.c_str());\n                            }\n                            else\n                            {\n                                ImGui::TextUnformatted(\"\");\n                            }\n                        }\n                        if (ImGui::TableNextColumn()) // file date + time\n                        {\n                            ImGui::Text(\"%s\", infos-&gt;fileModifDate.c_str());\n                        }\n                        if (ImGui::TableNextColumn()) // file thumbnails\n                        {\n                            auto th = &amp;infos-&gt;thumbnailInfo;\n\n                            if (!th-&gt;isLoadingOrLoaded)\n                            {\n                                prAddThumbnailToLoad(infos);\n                            }\n                            if (th-&gt;isReadyToDisplay &amp;&amp;\n                                th-&gt;textureID)\n                            {\n                                ImGui::Image((ImTextureID)th-&gt;textureID,\n                                    ImVec2((float)th-&gt;textureWidth,\n                                        (float)th-&gt;textureHeight));\n                            }\n                        }\n\n                        prEndFileColorIconStyle(_showColor, _font);\n                    }\n                }\n                prFileListClipper.End();\n            }\n\n#ifdef USE_EXPLORATION_BY_KEYS\n            if (!fdi.puInputPathActivated)\n            {\n                prLocateByInputKey(prFileDialogInternal);\n                prExploreWithkeys(prFileDialogInternal, listViewID);\n            }\n#endif // USE_EXPLORATION_BY_KEYS\n\n            ImGuiContext&amp; g = *GImGui;\n            if (g.LastActiveId - 1 == listViewID || g.LastActiveId == listViewID)\n            {\n                prFileDialogInternal.puFileListViewIsActive = true;\n            }\n\n            ImGui::EndTable();\n        }\n\n        ImGui::PopID();\n    }\n\n    void IGFD::FileDialog::prDrawThumbnailsGridView(ImVec2 vSize)\n    {\n        if (ImGui::BeginChild(\"##thumbnailsGridsFiles\", vSize))\n        {\n            // todo\n        }\n\n        ImGui::EndChild();\n    }\n\n#endif\n\n    void IGFD::FileDialog::prDrawSidePane(float vHeight)\n    {\n        ImGui::SameLine();\n\n        ImGui::BeginChild(\"##FileTypes\", ImVec2(0, vHeight));\n\n        prFileDialogInternal.puDLGoptionsPane(\n            prFileDialogInternal.puFilterManager.GetSelectedFilter().filter.c_str(), \n            prFileDialogInternal.puDLGuserDatas, &amp;prFileDialogInternal.puCanWeContinue);\n\n        ImGui::EndChild();\n    }\n\n    void IGFD::FileDialog::Close()\n    {\n        prFileDialogInternal.puDLGkey.clear();\n        prFileDialogInternal.puShowDialog = false;\n    }\n\n    bool IGFD::FileDialog::WasOpenedThisFrame(const std::string&amp; vKey) const\n    {\n        bool res = prFileDialogInternal.puShowDialog &amp;&amp; prFileDialogInternal.puDLGkey == vKey;\n        if (res)\n        {\n            ImGuiContext&amp; g = *GImGui;\n            res &amp;= prFileDialogInternal.puLastImGuiFrameCount == g.FrameCount; // return true if a dialog was displayed in this frame\n        }\n        return res;\n    }\n\n    bool IGFD::FileDialog::WasOpenedThisFrame() const\n    {\n        bool res = prFileDialogInternal.puShowDialog;\n        if (res)\n        {\n            ImGuiContext&amp; g = *GImGui;\n            res &amp;= prFileDialogInternal.puLastImGuiFrameCount == g.FrameCount; // return true if a dialog was displayed in this frame\n        }\n        return res;\n    }\n\n    bool IGFD::FileDialog::IsOpened(const std::string&amp; vKey) const\n    {\n        return (prFileDialogInternal.puShowDialog &amp;&amp; prFileDialogInternal.puDLGkey == vKey);\n    }\n\n    bool IGFD::FileDialog::IsOpened() const\n    {\n        return prFileDialogInternal.puShowDialog;\n    }\n\n    std::string IGFD::FileDialog::GetOpenedKey() const\n    {\n        if (prFileDialogInternal.puShowDialog)\n            return prFileDialogInternal.puDLGkey;\n        return \"\";\n    }\n\n    std::string IGFD::FileDialog::GetFilePathName()\n    {\n        return prFileDialogInternal.puFileManager.GetResultingFilePathName(prFileDialogInternal);\n    }\n\n    std::string IGFD::FileDialog::GetCurrentPath()\n    {\n        return prFileDialogInternal.puFileManager.GetResultingPath();\n    }\n\n    std::string IGFD::FileDialog::GetCurrentFileName()\n    {\n        return prFileDialogInternal.puFileManager.GetResultingFileName(prFileDialogInternal);\n    }\n\n    std::string IGFD::FileDialog::GetCurrentFilter()\n    {\n        return prFileDialogInternal.puFilterManager.GetSelectedFilter().filter;\n    }\n\n    std::map&lt;std::string, std::string&gt; IGFD::FileDialog::GetSelection()\n    {\n        return prFileDialogInternal.puFileManager.GetResultingSelection();\n    }\n\n    UserDatas IGFD::FileDialog::GetUserDatas() const\n    {\n        return prFileDialogInternal.puDLGuserDatas;\n    }\n\n    bool IGFD::FileDialog::IsOk() const\n    {\n        return prFileDialogInternal.puIsOk;\n    }\n\n    void IGFD::FileDialog::SetFileStyle(const IGFD_FileStyleFlags&amp; vFlags, const char* vCriteria, const FileStyle&amp; vInfos)\n    {\n        prFileDialogInternal.puFilterManager.SetFileStyle(vFlags, vCriteria, vInfos);\n    }\n\n    void IGFD::FileDialog::SetFileStyle(const IGFD_FileStyleFlags&amp; vFlags, const char* vCriteria, const ImVec4&amp; vColor, const std::string&amp; vIcon, ImFont* vFont)\n    {\n        prFileDialogInternal.puFilterManager.SetFileStyle(vFlags, vCriteria, vColor, vIcon, vFont);\n    }\n\n    bool IGFD::FileDialog::GetFileStyle(const IGFD_FileStyleFlags&amp; vFlags, const std::string&amp; vCriteria, ImVec4* vOutColor, std::string* vOutIcon, ImFont **vOutFont)\n    {\n        return prFileDialogInternal.puFilterManager.GetFileStyle(vFlags, vCriteria, vOutColor, vOutIcon, vOutFont);\n    }\n\n    void IGFD::FileDialog::ClearFilesStyle()\n    {\n        prFileDialogInternal.puFilterManager.ClearFilesStyle();\n    }\n\n    void IGFD::FileDialog::SetLocales(const int&amp; /*vLocaleCategory*/, const std::string&amp; vLocaleBegin, const std::string&amp; vLocaleEnd)\n    {\n        prFileDialogInternal.puUseCustomLocale = true;\n        prFileDialogInternal.puLocaleBegin = vLocaleBegin;\n        prFileDialogInternal.puLocaleEnd = vLocaleEnd;\n    }\n\n\n    bool IGFD::FileDialog::prConfirm_Or_OpenOverWriteFileDialog_IfNeeded(bool vLastAction, ImGuiWindowFlags vFlags)\n    {\n        // if confirmation =&gt; return true for confirm the overwrite et quit the dialog\n        // if cancel =&gt; return false &amp;&amp; set IsOk to false for keep inside the dialog\n\n        // if IsOk == false =&gt; return false for quit the dialog\n        if (!prFileDialogInternal.puIsOk &amp;&amp; vLastAction)\n        {\n            QuitFrame();\n            return true;\n        }\n\n        // if IsOk == true &amp;&amp; no check of overwrite =&gt; return true for confirm the dialog\n        if (prFileDialogInternal.puIsOk &amp;&amp; vLastAction &amp;&amp; !(prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_ConfirmOverwrite))\n        {\n            QuitFrame();\n            return true;\n        }\n\n        // if IsOk == true &amp;&amp; check of overwrite =&gt; return false and show confirm to overwrite dialog\n        if ((prFileDialogInternal.puOkResultToConfirm || (prFileDialogInternal.puIsOk &amp;&amp; vLastAction)) &amp;&amp; \n            (prFileDialogInternal.puDLGflags &amp; ImGuiFileDialogFlags_ConfirmOverwrite))\n        {\n            if (prFileDialogInternal.puIsOk) // catched only one time\n            {\n                if (!prFileDialogInternal.puFileManager.IsFileExist(GetFilePathName())) // not existing =&gt; quit dialog\n                {\n                    QuitFrame();\n                    return true;\n                }\n                else // existing =&gt; confirm dialog to open\n                {\n                    prFileDialogInternal.puIsOk = false;\n                    prFileDialogInternal.puOkResultToConfirm = true;\n                }\n            }\n\n            std::string name = OverWriteDialogTitleString \"##\" + prFileDialogInternal.puDLGtitle + prFileDialogInternal.puDLGkey + \"OverWriteDialog\";\n\n            bool res = false;\n\n            ImGui::OpenPopup(name.c_str());\n            if (ImGui::BeginPopupModal(name.c_str(), (bool*)0,\n                vFlags | ImGuiWindowFlags_AlwaysAutoResize |\n                ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove))\n            {\n                ImGui::SetWindowPos(prFileDialogInternal.puDialogCenterPos - ImGui::GetWindowSize() * 0.5f); // next frame needed for GetWindowSize to work\n\n                ImGui::Text(\"%s\", OverWriteDialogMessageString);\n\n                if (IMGUI_BUTTON(OverWriteDialogConfirmButtonString))\n                {\n                    prFileDialogInternal.puOkResultToConfirm = false;\n                    prFileDialogInternal.puIsOk = true;\n                    res = true;\n                    ImGui::CloseCurrentPopup();\n                }\n\n                ImGui::SameLine();\n\n                if (IMGUI_BUTTON(OverWriteDialogCancelButtonString))\n                {\n                    prFileDialogInternal.puOkResultToConfirm = false;\n                    prFileDialogInternal.puIsOk = false;\n                    res = false;\n                    ImGui::CloseCurrentPopup();\n                }\n\n                ImGui::EndPopup();\n            }\n\n            if (res)\n            {\n                QuitFrame();\n            }\n            return res;\n        }\n\n        return false;\n    }\n}\n\n#endif // __cplusplus\n\n\n// Return an initialized IGFD_Selection_Pair\nIMGUIFILEDIALOG_API IGFD_Selection_Pair IGFD_Selection_Pair_Get(void)\n{\n    IGFD_Selection_Pair res = {};\n    res.fileName = nullptr;\n    res.filePathName = nullptr;\n    return res;\n}\n\n// destroy only the content of vSelection_Pair\nIMGUIFILEDIALOG_API void IGFD_Selection_Pair_DestroyContent(IGFD_Selection_Pair* vSelection_Pair)\n{\n    if (vSelection_Pair)\n    {\n        delete[] vSelection_Pair-&gt;fileName;\n        delete[] vSelection_Pair-&gt;filePathName;\n    }\n}\n\n// Return an initialized IGFD_Selection\nIMGUIFILEDIALOG_API IGFD_Selection IGFD_Selection_Get(void)\n{\n    return { nullptr, 0U };\n}\n\n// destroy only the content of vSelection\nIMGUIFILEDIALOG_API void IGFD_Selection_DestroyContent(IGFD_Selection* vSelection)\n{\n    if (vSelection)\n    {\n        if (vSelection-&gt;table)\n        {\n            for (size_t i = 0U; i &lt; vSelection-&gt;count; i++)\n            {\n                IGFD_Selection_Pair_DestroyContent(&amp;vSelection-&gt;table[i]);\n            }\n            delete[] vSelection-&gt;table;\n        }\n        vSelection-&gt;count = 0U;\n    }\n}\n\n// create an instance of ImGuiFileDialog\nIMGUIFILEDIALOG_API ImGuiFileDialog* IGFD_Create(void)\n{\n    return new ImGuiFileDialog();\n}\n\n// destroy the instance of ImGuiFileDialog\nIMGUIFILEDIALOG_API void IGFD_Destroy(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        delete vContext;\n        vContext = nullptr;\n    }\n}\n\n// standard dialog\nIMGUIFILEDIALOG_API void IGFD_OpenDialog(\n    ImGuiFileDialog* vContext,\n    const char* vKey,\n    const char* vTitle,\n    const char* vFilters,\n    const char* vPath,\n    const char* vFileName,\n    const int vCountSelectionMax,\n    void* vUserDatas,\n    ImGuiFileDialogFlags flags)\n{\n    if (vContext)\n    {\n        vContext-&gt;OpenDialog(\n            vKey, vTitle, vFilters, vPath, vFileName,\n            vCountSelectionMax, vUserDatas, flags);\n    }\n}\n\nIMGUIFILEDIALOG_API void IGFD_OpenDialog2(\n    ImGuiFileDialog* vContext,\n    const char* vKey,\n    const char* vTitle,\n    const char* vFilters,\n    const char* vFilePathName,\n    const int vCountSelectionMax,\n    void* vUserDatas,\n    ImGuiFileDialogFlags flags)\n{\n    if (vContext)\n    {\n        vContext-&gt;OpenDialog(\n            vKey, vTitle, vFilters, vFilePathName,\n            vCountSelectionMax, vUserDatas, flags);\n    }\n}\n\nIMGUIFILEDIALOG_API void IGFD_OpenPaneDialog(\n    ImGuiFileDialog* vContext,\n    const char* vKey,\n    const char* vTitle,\n    const char* vFilters,\n    const char* vPath,\n    const char* vFileName,\n    IGFD_PaneFun vSidePane,\n    const float vSidePaneWidth,\n    const int vCountSelectionMax,\n    void* vUserDatas,\n    ImGuiFileDialogFlags flags)\n{\n    if (vContext)\n    {\n        vContext-&gt;OpenDialog(\n            vKey, vTitle, vFilters,\n            vPath, vFileName,\n            vSidePane, vSidePaneWidth,\n            vCountSelectionMax, vUserDatas, flags);\n    }\n}\n\nIMGUIFILEDIALOG_API void IGFD_OpenPaneDialog2(\n    ImGuiFileDialog* vContext,\n    const char* vKey,\n    const char* vTitle,\n    const char* vFilters,\n    const char* vFilePathName,\n    IGFD_PaneFun vSidePane,\n    const float vSidePaneWidth,\n    const int vCountSelectionMax,\n    void* vUserDatas,\n    ImGuiFileDialogFlags flags)\n{\n    if (vContext)\n    {\n        vContext-&gt;OpenDialog(\n            vKey, vTitle, vFilters,\n            vFilePathName,\n            vSidePane, vSidePaneWidth,\n            vCountSelectionMax, vUserDatas, flags);\n    }\n}\n\nIMGUIFILEDIALOG_API bool IGFD_DisplayDialog(ImGuiFileDialog* vContext,\n    const char* vKey, ImGuiWindowFlags vFlags, ImVec2 vMinSize, ImVec2 vMaxSize)\n{\n    if (vContext)\n    {\n        return vContext-&gt;Display(vKey, vFlags, vMinSize, vMaxSize);\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API void IGFD_CloseDialog(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        vContext-&gt;Close();\n    }\n}\n\nIMGUIFILEDIALOG_API bool IGFD_IsOk(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        return vContext-&gt;IsOk();\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API bool IGFD_WasKeyOpenedThisFrame(ImGuiFileDialog* vContext,\n    const char* vKey)\n{\n    if (vContext)\n    {\n        return vContext-&gt;WasOpenedThisFrame(vKey);\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API bool IGFD_WasOpenedThisFrame(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        return vContext-&gt;WasOpenedThisFrame();\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API bool IGFD_IsKeyOpened(ImGuiFileDialog* vContext,\n    const char* vCurrentOpenedKey)\n{\n    if (vContext)\n    {\n        return vContext-&gt;IsOpened(vCurrentOpenedKey);\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API bool IGFD_IsOpened(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        return vContext-&gt;IsOpened();\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API IGFD_Selection IGFD_GetSelection(ImGuiFileDialog* vContext)\n{\n    IGFD_Selection res = IGFD_Selection_Get();\n\n    if (vContext)\n    {\n        auto sel = vContext-&gt;GetSelection();\n        if (!sel.empty())\n        {\n            res.count = sel.size();\n            res.table = new IGFD_Selection_Pair[res.count];\n\n            size_t idx = 0U;\n            for (const auto&amp; s : sel)\n            {\n                IGFD_Selection_Pair* pair = res.table + idx++;\n\n                // fileNameExt\n                if (!s.first.empty())\n                {\n                    size_t siz = s.first.size() + 1U;\n                    pair-&gt;fileName = new char[siz];\n#ifndef _MSC_VER\n                    strncpy(pair-&gt;fileName, s.first.c_str(), siz);\n#else // _MSC_VER\n                    strncpy_s(pair-&gt;fileName, siz, s.first.c_str(), siz);\n#endif // _MSC_VER\n                    pair-&gt;fileName[siz - 1U] = '\\0';\n                }\n\n                // filePathName\n                if (!s.second.empty())\n                {\n                    size_t siz = s.first.size() + 1U;\n                    pair-&gt;filePathName = new char[siz];\n#ifndef _MSC_VER\n                    strncpy(pair-&gt;filePathName, s.first.c_str(), siz);\n#else // _MSC_VER\n                    strncpy_s(pair-&gt;filePathName, siz, s.first.c_str(), siz);\n#endif // _MSC_VER\n                    pair-&gt;filePathName[siz - 1U] = '\\0';\n                }\n            }\n\n            return res;\n        }\n    }\n\n    return res;\n}\n\nIMGUIFILEDIALOG_API char* IGFD_GetFilePathName(ImGuiFileDialog* vContext)\n{\n    char* res = nullptr;\n\n    if (vContext)\n    {\n        auto s = vContext-&gt;GetFilePathName();\n        if (!s.empty())\n        {\n            size_t siz = s.size() + 1U;\n            res = (char*)malloc(siz);\n            if (res)\n            {\n#ifndef _MSC_VER\n                strncpy(res, s.c_str(), siz);\n#else // _MSC_VER\n                strncpy_s(res, siz, s.c_str(), siz);\n#endif // _MSC_VER\n                res[siz - 1U] = '\\0';\n            }\n        }\n    }\n\n    return res;\n}\n\nIMGUIFILEDIALOG_API char* IGFD_GetCurrentFileName(ImGuiFileDialog* vContext)\n{\n    char* res = nullptr;\n\n    if (vContext)\n    {\n        auto s = vContext-&gt;GetCurrentFileName();\n        if (!s.empty())\n        {\n            size_t siz = s.size() + 1U;\n            res = (char*)malloc(siz);\n            if (res)\n            {\n#ifndef _MSC_VER\n                strncpy(res, s.c_str(), siz);\n#else // _MSC_VER\n                strncpy_s(res, siz, s.c_str(), siz);\n#endif // _MSC_VER\n                res[siz - 1U] = '\\0';\n            }\n        }\n    }\n\n    return res;\n}\n\nIMGUIFILEDIALOG_API char* IGFD_GetCurrentPath(ImGuiFileDialog* vContext)\n{\n    char* res = nullptr;\n\n    if (vContext)\n    {\n        auto s = vContext-&gt;GetCurrentPath();\n        if (!s.empty())\n        {\n            size_t siz = s.size() + 1U;\n            res = (char*)malloc(siz);\n            if (res)\n            {\n#ifndef _MSC_VER\n                strncpy(res, s.c_str(), siz);\n#else // _MSC_VER\n                strncpy_s(res, siz, s.c_str(), siz);\n#endif // _MSC_VER\n                res[siz - 1U] = '\\0';\n            }\n        }\n    }\n\n    return res;\n}\n\nIMGUIFILEDIALOG_API char* IGFD_GetCurrentFilter(ImGuiFileDialog* vContext)\n{\n    char* res = nullptr;\n\n    if (vContext)\n    {\n        auto s = vContext-&gt;GetCurrentFilter();\n        if (!s.empty())\n        {\n            size_t siz = s.size() + 1U;\n            res = (char*)malloc(siz);\n            if (res)\n            {\n#ifndef _MSC_VER\n                strncpy(res, s.c_str(), siz);\n#else // _MSC_VER\n                strncpy_s(res, siz, s.c_str(), siz);\n#endif // _MSC_VER\n                res[siz - 1U] = '\\0';\n            }\n        }\n    }\n\n    return res;\n}\n\nIMGUIFILEDIALOG_API void* IGFD_GetUserDatas(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        return vContext-&gt;GetUserDatas();\n    }\n\n    return nullptr;\n}\n\nIMGUIFILEDIALOG_API void IGFD_SetFileStyle(ImGuiFileDialog* vContext,\n    IGFD_FileStyleFlags vFlags, const char* vCriteria, ImVec4 vColor, const char* vIcon, ImFont* vFont) //-V813\n{\n    if (vContext)\n    {\n        vContext-&gt;SetFileStyle(vFlags, vCriteria, vColor, vIcon, vFont);\n    }\n}\n\nIMGUIFILEDIALOG_API void IGFD_SetFileStyle2(ImGuiFileDialog* vContext,\n    IGFD_FileStyleFlags vFlags, const char* vCriteria, float vR, float vG, float vB, float vA, const char* vIcon, ImFont* vFont)\n{\n    if (vContext)\n    {\n        vContext-&gt;SetFileStyle(vFlags, vCriteria, ImVec4(vR, vG, vB, vA), vIcon, vFont);\n    }\n}\n\nIMGUIFILEDIALOG_API bool IGFD_GetFileStyle(ImGuiFileDialog* vContext,\n    IGFD_FileStyleFlags vFlags, const char* vCriteria, ImVec4* vOutColor, char** vOutIconText, ImFont** vOutFont)\n{\n    if (vContext)\n    {\n        std::string icon;\n        bool res = vContext-&gt;GetFileStyle(vFlags, vCriteria, vOutColor, &amp;icon, vOutFont);\n        if (!icon.empty() &amp;&amp; vOutIconText)\n        {\n            size_t siz = icon.size() + 1U;\n            *vOutIconText = (char*)malloc(siz);\n            if (*vOutIconText)\n            {\n#ifndef _MSC_VER\n                strncpy(*vOutIconText, icon.c_str(), siz);\n#else // _MSC_VER\n                strncpy_s(*vOutIconText, siz, icon.c_str(), siz);\n#endif // _MSC_VER\n                (*vOutIconText)[siz - 1U] = '\\0';\n            }\n        }\n        return res;\n    }\n\n    return false;\n}\n\nIMGUIFILEDIALOG_API void IGFD_ClearFilesStyle(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        vContext-&gt;ClearFilesStyle();\n    }\n}\n\nIMGUIFILEDIALOG_API void SetLocales(ImGuiFileDialog* vContext, const int vCategory, const char* vBeginLocale, const char* vEndLocale)\n{\n    if (vContext)\n    {\n        vContext-&gt;SetLocales(vCategory, (vBeginLocale ? vBeginLocale : \"\"), (vEndLocale ? vEndLocale : \"\"));\n    }\n}\n\n#ifdef USE_EXPLORATION_BY_KEYS\nIMGUIFILEDIALOG_API void IGFD_SetFlashingAttenuationInSeconds(ImGuiFileDialog* vContext, float vAttenValue)\n{\n    if (vContext)\n    {\n        vContext-&gt;SetFlashingAttenuationInSeconds(vAttenValue);\n    }\n}\n#endif\n\n#ifdef USE_BOOKMARK\nIMGUIFILEDIALOG_API char* IGFD_SerializeBookmarks(ImGuiFileDialog* vContext, bool vDontSerializeCodeBasedBookmarks)\n{\n    char* res = nullptr;\n\n    if (vContext)\n    {\n        auto s = vContext-&gt;SerializeBookmarks(vDontSerializeCodeBasedBookmarks);\n        if (!s.empty())\n        {\n            size_t siz = s.size() + 1U;\n            res = (char*)malloc(siz);\n            if (res)\n            {\n#ifndef _MSC_VER\n                strncpy(res, s.c_str(), siz);\n#else // _MSC_VER\n                strncpy_s(res, siz, s.c_str(), siz);\n#endif // _MSC_VER\n                res[siz - 1U] = '\\0';\n            }\n        }\n    }\n\n    return res;\n}\n\nIMGUIFILEDIALOG_API void IGFD_DeserializeBookmarks(ImGuiFileDialog* vContext, const char* vBookmarks)\n{\n    if (vContext)\n    {\n        vContext-&gt;DeserializeBookmarks(vBookmarks);\n    }\n}\n\nIMGUIFILEDIALOG_API void IGFD_AddBookmark(ImGuiFileDialog* vContext, const char* vBookMarkName, const char* vBookMarkPath)\n{\n    if (vContext)\n    {\n        vContext-&gt;AddBookmark(vBookMarkName, vBookMarkPath);\n    }\n}\n\nIMGUIFILEDIALOG_API void IGFD_RemoveBookmark(ImGuiFileDialog* vContext, const char* vBookMarkName)\n{\n    if (vContext)\n    {\n        vContext-&gt;RemoveBookmark(vBookMarkName);\n    }\n}\n\n#endif\n\n#ifdef USE_THUMBNAILS\nIMGUIFILEDIALOG_API void SetCreateThumbnailCallback(ImGuiFileDialog* vContext, const IGFD_CreateThumbnailFun vCreateThumbnailFun)\n{\n    if (vContext)\n    {\n        vContext-&gt;SetCreateThumbnailCallback(vCreateThumbnailFun);\n    }\n}\n\nIMGUIFILEDIALOG_API void SetDestroyThumbnailCallback(ImGuiFileDialog* vContext, const IGFD_DestroyThumbnailFun vDestroyThumbnailFun)\n{\n    if (vContext)\n    {\n        vContext-&gt;SetDestroyThumbnailCallback(vDestroyThumbnailFun);\n    }\n}\n\nIMGUIFILEDIALOG_API void ManageGPUThumbnails(ImGuiFileDialog* vContext)\n{\n    if (vContext)\n    {\n        vContext-&gt;ManageGPUThumbnails();\n    }\n}\n#endif // USE_THUMBNAILS\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/","title":"File ImGuiFileDialog.h","text":"<p>FileList &gt; AIAC &gt; UI &gt; ImGuiFileDialog.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ImGuiFileDialogConfig.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#classes","title":"Classes","text":"Type Name struct IGFD_Selection struct IGFD_Selection_Pair"},{"location":"acdoxygen/ImGuiFileDialog_8h/#public-types","title":"Public Types","text":"Type Name typedef int IGFD_FileStyleFlags enum IGFD_FileStyleFlags_ typedef void(* IGFD_PaneFun typedef struct IGFD_Selection IGFD_Selection typedef struct IGFD_Selection_Pair IGFD_Selection_Pair typedef struct ImGuiFileDialog ImGuiFileDialog typedef int ImGuiFileDialogFlags enum ImGuiFileDialogFlags_"},{"location":"acdoxygen/ImGuiFileDialog_8h/#public-functions","title":"Public Functions","text":"Type Name IMGUIFILEDIALOG_API void IGFD_ClearFilesStyle (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void IGFD_CloseDialog (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API ImGuiFileDialog * IGFD_Create (void)  IMGUIFILEDIALOG_API void IGFD_Destroy (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_DisplayDialog (ImGuiFileDialog * vContext, const char * vKey, ImGuiWindowFlags vFlags, ImVec2 vMinSize, ImVec2 vMaxSize)  IMGUIFILEDIALOG_API char * IGFD_GetCurrentFileName (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API char * IGFD_GetCurrentFilter (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API char * IGFD_GetCurrentPath (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API char * IGFD_GetFilePathName (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_GetFileStyle (ImGuiFileDialog * vContext, IGFD_FileStyleFlags vFileStyleFlags, const char * vFilter, ImVec4 * vOutColor, char ** vOutIconText, ImFont ** vOutFont)  IMGUIFILEDIALOG_API IGFD_Selection IGFD_GetSelection (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void * IGFD_GetUserDatas (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_IsKeyOpened (ImGuiFileDialog * vContext, const char * vCurrentOpenedKey)  IMGUIFILEDIALOG_API bool IGFD_IsOk (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API bool IGFD_IsOpened (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void IGFD_OpenDialog (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vPath, const char * vFileName, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags vFlags)  IMGUIFILEDIALOG_API void IGFD_OpenDialog2 (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vFilePathName, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags vFlags)  IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vPath, const char * vFileName, const IGFD_PaneFun vSidePane, const float vSidePaneWidth, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags vFlags)  IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog2 (ImGuiFileDialog * vContext, const char * vKey, const char * vTitle, const char * vFilters, const char * vFilePathName, const IGFD_PaneFun vSidePane, const float vSidePaneWidth, const int vCountSelectionMax, void * vUserDatas, ImGuiFileDialogFlags vFlags)  IMGUIFILEDIALOG_API void IGFD_Selection_DestroyContent (IGFD_Selection * vSelection)  IMGUIFILEDIALOG_API IGFD_Selection IGFD_Selection_Get ()  IMGUIFILEDIALOG_API void IGFD_Selection_Pair_DestroyContent (IGFD_Selection_Pair * vSelection_Pair)  IMGUIFILEDIALOG_API IGFD_Selection_Pair IGFD_Selection_Pair_Get ()  IMGUIFILEDIALOG_API void IGFD_SetFileStyle (ImGuiFileDialog * vContext, IGFD_FileStyleFlags vFileStyleFlags, const char * vFilter, ImVec4 vColor, const char * vIconText, ImFont * vFont)  IMGUIFILEDIALOG_API void IGFD_SetFileStyle2 (ImGuiFileDialog * vContext, IGFD_FileStyleFlags vFileStyleFlags, const char * vFilter, float vR, float vG, float vB, float vA, const char * vIconText, ImFont * vFont)  IMGUIFILEDIALOG_API bool IGFD_WasKeyOpenedThisFrame (ImGuiFileDialog * vContext, const char * vKey)  IMGUIFILEDIALOG_API bool IGFD_WasOpenedThisFrame (ImGuiFileDialog * vContext)  IMGUIFILEDIALOG_API void SetLocales (ImGuiFileDialog * vContext, const int vCategory, const char * vBeginLocale, const char * vEndLocale)"},{"location":"acdoxygen/ImGuiFileDialog_8h/#macros","title":"Macros","text":"Type Name define API define IMGUIFILEDIALOG_API define IMGUIFILEDIALOG_VERSION <code>\"v0.6.5\"</code>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"acdoxygen/ImGuiFileDialog_8h/#typedef-igfd_filestyleflags","title":"typedef IGFD_FileStyleFlags","text":"<pre><code>typedef int IGFD_FileStyleFlags;\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#enum-igfd_filestyleflags_","title":"enum IGFD_FileStyleFlags_","text":"<pre><code>enum IGFD_FileStyleFlags_ {\n    IGFD_FileStyle_None = 0,\n    IGFD_FileStyleByTypeFile = (1 &lt;&lt; 0),\n    IGFD_FileStyleByTypeDir = (1 &lt;&lt; 1),\n    IGFD_FileStyleByTypeLink = (1 &lt;&lt; 2),\n    IGFD_FileStyleByExtention = (1 &lt;&lt; 3),\n    IGFD_FileStyleByFullName = (1 &lt;&lt; 4),\n    IGFD_FileStyleByContainedInFullName = (1 &lt;&lt; 5)\n};\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#typedef-igfd_panefun","title":"typedef IGFD_PaneFun","text":"<pre><code>typedef void(* IGFD_PaneFun) (const char *, void *, bool *);\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#typedef-igfd_selection","title":"typedef IGFD_Selection","text":"<pre><code>typedef struct IGFD_Selection IGFD_Selection;\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#typedef-igfd_selection_pair","title":"typedef IGFD_Selection_Pair","text":"<pre><code>typedef struct IGFD_Selection_Pair IGFD_Selection_Pair;\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#typedef-imguifiledialog","title":"typedef ImGuiFileDialog","text":"<pre><code>typedef struct ImGuiFileDialog ImGuiFileDialog;\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#typedef-imguifiledialogflags","title":"typedef ImGuiFileDialogFlags","text":"<pre><code>typedef int ImGuiFileDialogFlags;\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#enum-imguifiledialogflags_","title":"enum ImGuiFileDialogFlags_","text":"<pre><code>enum ImGuiFileDialogFlags_ {\n    ImGuiFileDialogFlags_None = 0,\n    ImGuiFileDialogFlags_ConfirmOverwrite = (1 &lt;&lt; 0),\n    ImGuiFileDialogFlags_DontShowHiddenFiles = (1 &lt;&lt; 1),\n    ImGuiFileDialogFlags_DisableCreateDirectoryButton = (1 &lt;&lt; 2),\n    ImGuiFileDialogFlags_HideColumnType = (1 &lt;&lt; 3),\n    ImGuiFileDialogFlags_HideColumnSize = (1 &lt;&lt; 4),\n    ImGuiFileDialogFlags_HideColumnDate = (1 &lt;&lt; 5),\n    ImGuiFileDialogFlags_NoDialog = (1 &lt;&lt; 6),\n    ImGuiFileDialogFlags_ReadOnlyFileNameField = (1 &lt;&lt; 7),\n    ImGuiFileDialogFlags_CaseInsensitiveExtention = (1 &lt;&lt; 8),\n    ImGuiFileDialogFlags_Modal = (1 &lt;&lt; 9),\n    ImGuiFileDialogFlags_Default = ImGuiFileDialogFlags_ConfirmOverwrite\n};\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_clearfilesstyle","title":"function IGFD_ClearFilesStyle","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_ClearFilesStyle (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_closedialog","title":"function IGFD_CloseDialog","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_CloseDialog (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_create","title":"function IGFD_Create","text":"<pre><code>IMGUIFILEDIALOG_API ImGuiFileDialog * IGFD_Create (\n    void\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_destroy","title":"function IGFD_Destroy","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_Destroy (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_displaydialog","title":"function IGFD_DisplayDialog","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_DisplayDialog (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    ImGuiWindowFlags vFlags,\n    ImVec2 vMinSize,\n    ImVec2 vMaxSize\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getcurrentfilename","title":"function IGFD_GetCurrentFileName","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetCurrentFileName (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getcurrentfilter","title":"function IGFD_GetCurrentFilter","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetCurrentFilter (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getcurrentpath","title":"function IGFD_GetCurrentPath","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetCurrentPath (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getfilepathname","title":"function IGFD_GetFilePathName","text":"<pre><code>IMGUIFILEDIALOG_API char * IGFD_GetFilePathName (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getfilestyle","title":"function IGFD_GetFileStyle","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_GetFileStyle (\n    ImGuiFileDialog * vContext,\n    IGFD_FileStyleFlags vFileStyleFlags,\n    const char * vFilter,\n    ImVec4 * vOutColor,\n    char ** vOutIconText,\n    ImFont ** vOutFont\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getselection","title":"function IGFD_GetSelection","text":"<pre><code>IMGUIFILEDIALOG_API IGFD_Selection IGFD_GetSelection (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_getuserdatas","title":"function IGFD_GetUserDatas","text":"<pre><code>IMGUIFILEDIALOG_API void * IGFD_GetUserDatas (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_iskeyopened","title":"function IGFD_IsKeyOpened","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_IsKeyOpened (\n    ImGuiFileDialog * vContext,\n    const char * vCurrentOpenedKey\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_isok","title":"function IGFD_IsOk","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_IsOk (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_isopened","title":"function IGFD_IsOpened","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_IsOpened (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_opendialog","title":"function IGFD_OpenDialog","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenDialog (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vPath,\n    const char * vFileName,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags vFlags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_opendialog2","title":"function IGFD_OpenDialog2","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenDialog2 (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vFilePathName,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags vFlags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_openpanedialog","title":"function IGFD_OpenPaneDialog","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vPath,\n    const char * vFileName,\n    const IGFD_PaneFun vSidePane,\n    const float vSidePaneWidth,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags vFlags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_openpanedialog2","title":"function IGFD_OpenPaneDialog2","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_OpenPaneDialog2 (\n    ImGuiFileDialog * vContext,\n    const char * vKey,\n    const char * vTitle,\n    const char * vFilters,\n    const char * vFilePathName,\n    const IGFD_PaneFun vSidePane,\n    const float vSidePaneWidth,\n    const int vCountSelectionMax,\n    void * vUserDatas,\n    ImGuiFileDialogFlags vFlags\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_selection_destroycontent","title":"function IGFD_Selection_DestroyContent","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_Selection_DestroyContent (\n    IGFD_Selection * vSelection\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_selection_get","title":"function IGFD_Selection_Get","text":"<pre><code>IMGUIFILEDIALOG_API IGFD_Selection IGFD_Selection_Get () \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_selection_pair_destroycontent","title":"function IGFD_Selection_Pair_DestroyContent","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_Selection_Pair_DestroyContent (\n    IGFD_Selection_Pair * vSelection_Pair\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_selection_pair_get","title":"function IGFD_Selection_Pair_Get","text":"<pre><code>IMGUIFILEDIALOG_API IGFD_Selection_Pair IGFD_Selection_Pair_Get () \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_setfilestyle","title":"function IGFD_SetFileStyle","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_SetFileStyle (\n    ImGuiFileDialog * vContext,\n    IGFD_FileStyleFlags vFileStyleFlags,\n    const char * vFilter,\n    ImVec4 vColor,\n    const char * vIconText,\n    ImFont * vFont\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_setfilestyle2","title":"function IGFD_SetFileStyle2","text":"<pre><code>IMGUIFILEDIALOG_API void IGFD_SetFileStyle2 (\n    ImGuiFileDialog * vContext,\n    IGFD_FileStyleFlags vFileStyleFlags,\n    const char * vFilter,\n    float vR,\n    float vG,\n    float vB,\n    float vA,\n    const char * vIconText,\n    ImFont * vFont\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_waskeyopenedthisframe","title":"function IGFD_WasKeyOpenedThisFrame","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_WasKeyOpenedThisFrame (\n    ImGuiFileDialog * vContext,\n    const char * vKey\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-igfd_wasopenedthisframe","title":"function IGFD_WasOpenedThisFrame","text":"<pre><code>IMGUIFILEDIALOG_API bool IGFD_WasOpenedThisFrame (\n    ImGuiFileDialog * vContext\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#function-setlocales","title":"function SetLocales","text":"<pre><code>IMGUIFILEDIALOG_API void SetLocales (\n    ImGuiFileDialog * vContext,\n    const int vCategory,\n    const char * vBeginLocale,\n    const char * vEndLocale\n) \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/ImGuiFileDialog_8h/#define-api","title":"define API","text":"<pre><code>#define API \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#define-imguifiledialog_api","title":"define IMGUIFILEDIALOG_API","text":"<pre><code>#define IMGUIFILEDIALOG_API \n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialog_8h/#define-imguifiledialog_version","title":"define IMGUIFILEDIALOG_VERSION","text":"<pre><code>#define IMGUIFILEDIALOG_VERSION `\"v0.6.5\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/ImGuiFileDialog.h</code></p>"},{"location":"acdoxygen/ImGuiFileDialog_8h_source/","title":"File ImGuiFileDialog.h","text":"<p>File List &gt; AIAC &gt; UI &gt; ImGuiFileDialog.h</p> <p>Go to the documentation of this file</p> <p><pre><code>/*\nMIT License\n\nCopyright (c) 2018-2022 Stephane Cuillerdier (aka aiekick)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/*\n-----------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------------------\n\ngithub repo : https://github.com/aiekick/ImGuiFileDialog\nthis section is the content of the ReadMe.md file\n\n# ImGuiFileDialog\n\n## Purpose\n\nImGuiFileDialog is a file selection dialog built for (and using only) [Dear ImGui](https://github.com/ocornut/imgui).\n\nMy primary goal was to have a custom pane with widgets according to file extension. This was not possible using other\nsolutions.\n\n## ImGui Supported Version\n\nImGuiFileDialog follow the master and docking branch of ImGui . currently ImGui 1.88 WIP\n\n## Structure\n\n* The library is in [Lib_Only branch](https://github.com/aiekick/ImGuiFileDialog/tree/Lib_Only)\n* A demo app can be found the [master branch](https://github.com/aiekick/ImGuiFileDialog/tree/master)\n\nThis library is designed to be dropped into your source code rather than compiled separately.\n\nFrom your project directory:\n</code></pre> mkdir lib     cd lib git clone https://github.com/aiekick/ImGuiFileDialog.git git checkout Lib_Only <pre><code>These commands create a `lib` directory where you can store any third-party dependencies used in your project, downloads\nthe ImGuiFileDialog git repository and checks out the Lib_Only branch where the actual library code is located.\n\nAdd `lib/ImGuiFileDialog/ImGuiFileDialog.cpp` to your build system and include\n`lib/ImGuiFileDialog/ImGuiFileDialog.h` in your source code. ImGuiFileLib will compile with and be included directly in\nyour executable file.\n\nIf, for example, your project uses cmake, look for a line like `add_executable(my_project_name main.cpp)`\nand change it to `add_executable(my_project_name lib/ImGuiFileDialog/ImGuiFileDialog.cpp main.cpp)`. This tells the\ncompiler where to find the source code declared in `ImGuiFileDialog.h` which you included in your own source code.\n\n## Requirements:\n\nYou must also, of course, have added [Dear ImGui](https://github.com/ocornut/imgui) to your project for this to work at\nall.\n\n[dirent v1.23](https://github.com/tronkko/dirent/tree/v1.23) is required to use ImGuiFileDialog under Windows. It is\nincluded in the Lib_Only branch for your convenience.\n\n## Features\n\n- Separate system for call and display\n    - Can have many function calls with different parameters for one display function, for example\n- Can create a custom pane with any widgets via function binding\n    - This pane can block the validation of the dialog\n    - Can also display different things according to current filter and UserDatas\n- Advanced file style for file/dir/link coloring / icons / font\n- Multi-selection (ctrl/shift + click) :\n    - 0 =&gt; Infinite\n    - 1 =&gt; One file (default)\n    - n =&gt; n files\n- Compatible with MacOs, Linux, Windows\n    - Windows version can list drives\n- Supports modal or standard dialog types\n- Select files or directories\n- Filter groups and custom filter names\n- can ignore filter Case for file searching\n- Keyboard navigation (arrows, backspace, enter)\n- Exploring by entering characters (case insensitive)\n- Directory bookmarks\n- Directory manual entry (right click on any path element)\n- Optional 'Confirm to Overwrite\" dialog if file exists\n- C Api (succesfully tested with CimGui)\n- Thumbnails Display (agnostic way for compatibility with any backend, sucessfully tested with OpenGl and Vulkan)\n- The dialog can be embedded in another user frame than the standard or modal dialog\n- Can tune validation buttons (placements, widths, inversion)\n- Can quick select a parrallel directory of a path, in the path composer (when you clikc on a / you have a popup)\n- regex support for filters, collection of fitler and filestyle (the regex is recognized when between ( and ) in a filter\n\n## Singleton Pattern vs. Multiple Instances\n\n### Single Dialog :\n\nIf you only need to display one file dialog at a time, use ImGuiFileDialog's singleton pattern to avoid explicitly\ndeclaring an object:\n\n```cpp\nImGuiFileDialog::Instance()-&gt;method_of_your_choice();\n```C++\n\n### Multiple Dialogs :\n\nIf you need to have multiple file dialogs open at once, declare each dialog explicity:\n\n```cpp\nImGuiFileDialog instance_a;\ninstance_a.method_of_your_choice();\nImGuiFileDialog instance_b;\ninstance_b.method_of_your_choice();\n```C++\n\n## Simple Dialog :\n\n```cpp\nvoid drawGui()\n{\n  // open Dialog Simple\n  if (ImGui::Button(\"Open File Dialog\"))\n    ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose File\", \".cpp,.h,.hpp\", \".\");\n\n  // display\n  if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseFileDlgKey\"))\n  {\n    // action if OK\n    if (ImGuiFileDialog::Instance()-&gt;IsOk())\n    {\n      std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n      std::string filePath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n      // action\n    }\n\n    // close\n    ImGuiFileDialog::Instance()-&gt;Close();\n  }\n}\n```C++\n\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/dlg_simple.gif)\n\n## Modal dialog :\n\nyou have now a flag for open modal dialog :\n\n```cpp\nImGuiFileDialogFlags_Modal\n```C++\n\nyou can use it like that :\n\n```cpp\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose File\", \".cpp,.h,.hpp\", \n    \".\", 1, nullptr, ImGuiFileDialogFlags_Modal);\n```C++\n\n## Directory Chooser :\n\nTo have a directory chooser, set the file extension filter to nullptr:\n\n```cpp\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseDirDlgKey\", \"Choose a Directory\", nullptr, \".\");\n```C++\n\nIn this mode you can select any directory with one click and open a directory with a double-click.\n\n![directoryChooser](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/directoryChooser.gif)\n\n## Dialog with Custom Pane :\n\nThe signature of the custom pane callback is:\n\n### for C++ :\n\n```cpp\nvoid(const char *vFilter, IGFDUserDatas vUserDatas, bool *vCantContinue)\n```C++\n\n### for C :\n\n```c\nvoid(const char *vFilter, void* vUserDatas, bool *vCantContinue)\n```C++\n\n### Example :\n\n```cpp\nstatic bool canValidateDialog = false;\ninline void InfosPane(cosnt char *vFilter, IGFDUserDatas vUserDatas, bool *vCantContinue) // if vCantContinue is false, the user cant validate the dialog\n{\n    ImGui::TextColored(ImVec4(0, 1, 1, 1), \"Infos Pane\");\n    ImGui::Text(\"Selected Filter : %s\", vFilter.c_str());\n    if (vUserDatas)\n        ImGui::Text(\"UserDatas : %s\", vUserDatas);\n    ImGui::Checkbox(\"if not checked you cant validate the dialog\", &amp;canValidateDialog);\n    if (vCantContinue)\n        *vCantContinue = canValidateDialog;\n}\n\nvoid drawGui()\n{\n  // open Dialog with Pane\n  if (ImGui::Button(\"Open File Dialog with a custom pane\"))\n    ImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose File\", \".cpp,.h,.hpp\",\n            \".\", \"\", std::bind(&amp;InfosPane, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3), 350, 1, UserDatas(\"InfosPane\"));\n\n  // display and action if ok\n  if (ImGuiFileDialog::Instance()-&gt;Display(\"ChooseFileDlgKey\"))\n  {\n    if (ImGuiFileDialog::Instance()-&gt;IsOk())\n    {\n        std::string filePathName = ImGuiFileDialog::Instance()-&gt;GetFilePathName();\n        std::string filePath = ImGuiFileDialog::Instance()-&gt;GetCurrentPath();\n        std::string filter = ImGuiFileDialog::Instance()-&gt;GetCurrentFilter();\n        // here convert from string because a string was passed as a userDatas, but it can be what you want\n        std::string userDatas;\n        if (ImGuiFileDialog::Instance()-&gt;GetUserDatas())\n            userDatas = std::string((const char*)ImGuiFileDialog::Instance()-&gt;GetUserDatas());\n        auto selection = ImGuiFileDialog::Instance()-&gt;GetSelection(); // multiselection\n\n        // action\n    }\n    // close\n    ImGuiFileDialog::Instance()-&gt;Close();\n  }\n}\n```C++\n\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/doc/dlg_with_pane.gif)\n\n## File Style : Custom icons and colors by extension\n\nYou can define style for files/dirs/links in many ways :\n\nthe style can be colors, icons and fonts\n\nthe general form is :\n```cpp\nImGuiFileDialog::Instance()-&gt;SetFileStyle(styleType, criteria, color, icon, font);\n\nstyleType can be thoses :\n\nIGFD_FileStyleByTypeFile                // define style for all files\nIGFD_FileStyleByTypeDir                 // define style for all dir\nIGFD_FileStyleByTypeLink                // define style for all link\nIGFD_FileStyleByExtention               // define style by extention, for files or links\nIGFD_FileStyleByFullName                // define style for particular file/dir/link full name (filename + extention)\nIGFD_FileStyleByContainedInFullName     // define style for file/dir/link when criteria is contained in full name\n```C++\n\nImGuiFileDialog accepts icon font macros as well as text tags for file types.\n\n[ImGuIFontStudio](https://github.com/aiekick/ImGuiFontStudio) is useful here. I wrote it to make it easy to create\ncustom icon sets for use with Dear ImGui.\n\nIt is inspired by [IconFontCppHeaders](https://github.com/juliettef/IconFontCppHeaders), which can also be used with\nImGuiFileDialog.\n\nsamples :\n\n```cpp\n// define style by file extention and Add an icon for .png files\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".png\", ImVec4(0.0f, 1.0f, 1.0f, 0.9f), ICON_IGFD_FILE_PIC, font1);\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".gif\", ImVec4(0.0f, 1.0f, 0.5f, 0.9f), \"[GIF]\");\n\n// define style for all directories\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeDir, \"\", ImVec4(0.5f, 1.0f, 0.9f, 0.9f), ICON_IGFD_FOLDER);\n// can be for a specific directory\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeDir, \".git\", ImVec4(0.5f, 1.0f, 0.9f, 0.9f), ICON_IGFD_FOLDER);\n\n// define style for all files\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeFile, \"\", ImVec4(0.5f, 1.0f, 0.9f, 0.9f), ICON_IGFD_FILE);\n// can be for a specific file\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeFile, \".git\", ImVec4(0.5f, 1.0f, 0.9f, 0.9f), ICON_IGFD_FILE);\n\n// define style for all links\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeLink, \"\", ImVec4(0.5f, 1.0f, 0.9f, 0.9f));\n// can be for a specific link\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeLink, \"Readme.md\", ImVec4(0.5f, 1.0f, 0.9f, 0.9f));\n\n// define style for any files/dirs/links by fullname\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByFullName, \"doc\", ImVec4(0.9f, 0.2f, 0.0f, 0.9f), ICON_IGFD_FILE_PIC);\n\n// define style by file who are containing this string\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByContainedInFullName, \".git\", ImVec4(0.9f, 0.2f, 0.0f, 0.9f), ICON_IGFD_BOOKMARK);\n\nall of theses can be miwed with IGFD_FileStyleByTypeDir / IGFD_FileStyleByTypeFile / IGFD_FileStyleByTypeLink\nlike theses by ex :\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeDir | IGFD_FileStyleByContainedInFullName, \".git\", ImVec4(0.9f, 0.2f, 0.0f, 0.9f), ICON_IGFD_BOOKMARK);\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeFile | IGFD_FileStyleByFullName, \"cmake\", ImVec4(0.5f, 0.8f, 0.5f, 0.9f), ICON_IGFD_SAVE);\n\n// for all these,s you can use a regex\n// ex for color files like Custom*.h\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByFullName, \"(Custom.+[.]h)\", ImVec4(0.0f, 1.0f, 1.0f, 0.9f), ICON_IGFD_FILE_PIC, font1);\n```C++\n\nthis sample code of [master/main.cpp](https://github.com/aiekick/ImGuiFileDialog/blob/master/main.cpp) produce the picture above :\n\n```cpp\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".cpp\", ImVec4(1.0f, 1.0f, 0.0f, 0.9f));\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".h\", ImVec4(0.0f, 1.0f, 0.0f, 0.9f));\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".hpp\", ImVec4(0.0f, 0.0f, 1.0f, 0.9f));\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".md\", ImVec4(1.0f, 0.0f, 1.0f, 0.9f));\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".png\", ImVec4(0.0f, 1.0f, 1.0f, 0.9f), ICON_IGFD_FILE_PIC); // add an icon for the filter type\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByExtention, \".gif\", ImVec4(0.0f, 1.0f, 0.5f, 0.9f), \"[GIF]\"); // add an text for a filter type\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeDir, nullptr, ImVec4(0.5f, 1.0f, 0.9f, 0.9f), ICON_IGFD_FOLDER); // for all dirs\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeFile, \"CMakeLists.txt\", ImVec4(0.1f, 0.5f, 0.5f, 0.9f), ICON_IGFD_ADD);\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByFullName, \"doc\", ImVec4(0.9f, 0.2f, 0.0f, 0.9f), ICON_IGFD_FILE_PIC);\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeDir | IGFD_FileStyleByContainedInFullName, \".git\", ImVec4(0.9f, 0.2f, 0.0f, 0.9f), ICON_IGFD_BOOKMARK);\nImGuiFileDialog::Instance()-&gt;SetFileStyle(IGFD_FileStyleByTypeFile | IGFD_FileStyleByContainedInFullName, \".git\", ImVec4(0.5f, 0.8f, 0.5f, 0.9f), ICON_IGFD_SAVE);\n```C++\n\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/color_filter.png)\n\n## Filter Collections\n\nYou can define a custom filter name that corresponds to a group of filters using this syntax:\n\n```custom_name1{filter1,filter2,filter3},custom_name2{filter1,filter2},filter1```C++\n\nWhen you select custom_name1, filters 1 to 3 will be applied. The characters `{` and `}` are reserved. Don't use them\nfor filter names.\n\nthis code :\n\n```cpp\nconst char *filters = \"Source files (*.cpp *.h *.hpp){.cpp,.h,.hpp},Image files (*.png *.gif *.jpg *.jpeg){.png,.gif,.jpg,.jpeg},.md\";\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", ICON_IMFDLG_FOLDER_OPEN \" Choose a File\", filters, \".\");\n```C++\n\nwill produce :\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/collectionFilters.gif)\n\n## Multi Selection\n\nYou can define in OpenDialog call the count file you want to select :\n\n- 0 =&gt; infinite\n- 1 =&gt; one file only (default)\n- n =&gt; n files only\n\nSee the define at the end of these funcs after path.\n\n```cpp\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose File\", \".*,.cpp,.h,.hpp\", \".\");\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose 1 File\", \".*,.cpp,.h,.hpp\", \".\", 1);\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose 5 File\", \".*,.cpp,.h,.hpp\", \".\", 5);\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose many File\", \".*,.cpp,.h,.hpp\", \".\", 0);\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\", \"Choose File\", \".png,.jpg\",\n   \".\", \"\", std::bind(&amp;InfosPane, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3), 350, 1, \"SaveFile\"); // 1 file\n```C++\n\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/multiSelection.gif)\n\n## File Dialog Constraints\n\nYou can set the minimum and/or maximum size of the dialog:\n\n```cpp\nImVec2 maxSize = ImVec2((float)display_w, (float)display_h);  // The full display area\nImVec2 minSize = maxSize * 0.5f;  // Half the display area\nImGuiFileDialog::Instance()-&gt;Display(\"ChooseFileDlgKey\", ImGuiWindowFlags_NoCollapse, minSize, maxSize);\n```C++\n\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/dialog_constraints.gif)\n\n## Detail View Mode\n\nDear ImGui just released an improved table API. If your downloaded version of Dear ImGui includes the beta version of\ntable support (included for some time now) you can enable table support by uncommenting `#define USE_IMGUI_TABLES` in\nyou custom config file (CustomImGuiFileDialogConfig.h)\n\nIf your version of Dear ImGui has finalized tables support, it will be enabled by default.\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/imgui_tables_branch.gif)\n\n## Exploring by keys\n\nYou can activate this feature by uncommenting `#define USE_EXPLORATION_BY_KEYS`\nin your custom config file (CustomImGuiFileDialogConfig.h)\n\nYou can also uncomment the next lines to define navigation keys:\n\n* IGFD_KEY_UP =&gt; Up key for explore to the top\n* IGFD_KEY_DOWN =&gt; Down key for explore to the bottom\n* IGFD_KEY_ENTER =&gt; Enter key for open directory\n* IGFD_KEY_BACKSPACE =&gt; BackSpace for comming back to the last directory\n\nYou can also jump to a point in the file list by pressing the corresponding key of the first filename character.\n\n![alt text](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/explore_ny_keys.gif)\n\nAs you see the current item is flashed by default for 1 second. You can define the flashing lifetime with the function\n\n```cpp\nImGuiFileDialog::Instance()-&gt;SetFlashingAttenuationInSeconds(1.0f);\n```C++\n\n## Bookmarks\n\nYou can create/edit/call path bookmarks and load/save them.\n\nActivate this feature by uncommenting: `#define USE_BOOKMARK` in your custom config file (CustomImGuiFileDialogConfig.h)\n\nMore customization options:\n\n```cpp\n#define bookmarkPaneWith 150.0f =&gt; width of the bookmark pane\n#define IMGUI_TOGGLE_BUTTON ToggleButton =&gt; customize the Toggled button (button stamp must be : (const char* label, bool *toggle)\n#define bookmarksButtonString \"Bookmark\" =&gt; the text in the toggle button\n#define bookmarksButtonHelpString \"Bookmark\" =&gt; the helper text when mouse over the button\n#define addBookmarkButtonString \"+\" =&gt; the button for add a bookmark\n#define removeBookmarkButtonString \"-\" =&gt; the button for remove the selected bookmark\n```C++\n\n* You can select each bookmark to edit the displayed name corresponding to a path\n* Double-click on the label to apply the bookmark\n\n![bookmarks.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/bookmarks.gif)\n\nYou can also serialize/deserialize bookmarks (for example to load/save from/to a file):\n```cpp\nLoad =&gt; ImGuiFileDialog::Instance()-&gt;DeserializeBookmarks(bookmarString);\nSave =&gt; std::string bookmarkString = ImGuiFileDialog::Instance()-&gt;SerializeBookmarks();\n```C++\n(please see example code for details)\n\nyou can also add/remove bookmark by code :\nand in this case, you can also avoid serialization of code based bookmark\n\n```cpp\nAdd =&gt; ImGuiFileDialog::Instance()-&gt;AddBookmark(bookmark_name, bookmark_path);\nRemove =&gt; ImGuiFileDialog::Instance()-&gt;RemoveBookmark(bookmark_name);\nSave =&gt; std::string bookmarkString = ImGuiFileDialog::Instance()-&gt;SerializeBookmarks(true); // true for prevent serialization of code based bookmarks\n```C++\n\n## Path Edition :\n\nRight clicking on any path element button allows the user to manually edit the path from that portion of the tree.\nPressing the completion key (GLFW uses `enter` by default) validates the new path. Pressing the cancel key (GLFW\nuses`escape` by default) cancels the manual entry and restores the original path.\n\nHere's the manual entry operation in action:\n![inputPathEdition.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/inputPathEdition.gif)\n\n## Confirm Overwrite Dialog :\n\nIf you want avoid overwriting files after selection, ImGuiFileDialog can show a dialog to confirm or cancel the\noperation.\n\nTo do so, define the flag ImGuiFileDialogFlags_ConfirmOverwrite in your call to OpenDialog.\n\nBy default this flag is not set since there is no pre-defined way to define if a dialog will be for Open or Save\nbehavior. (by design! :) )\n\nExample code For Standard Dialog :\n\n```cpp\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\",\n    ICON_IGFD_SAVE \" Choose a File\", filters,\n    \".\", \"\", 1, nullptr, ImGuiFileDialogFlags_ConfirmOverwrite);\n```C++\n\nExample code For Modal Dialog :\n\n```cpp\nImGuiFileDialog::Instance()-&gt;OpenDialog(\"ChooseFileDlgKey\",\n    ICON_IGFD_SAVE \" Choose a File\", filters,\n    \".\", \"\", 1, nullptr, ImGuiFileDialogFlags_Modal | ImGuiFileDialogFlags_ConfirmOverwrite);\n```C++\n\nThis dialog will only verify the file in the file field, not with `GetSelection()`.\n\nThe confirmation dialog will be a non-movable modal (input blocking) dialog displayed in the middle of the current\nImGuiFileDialog window.\n\nAs usual, you can customize the dialog in your custom config file (CustomImGuiFileDialogConfig.h in this example)\n\nUncomment these line for customization options:\n\n```cpp\n//#define OverWriteDialogTitleString \"The file Already Exist !\"\n//#define OverWriteDialogMessageString \"Would you like to OverWrite it ?\"\n//#define OverWriteDialogConfirmButtonString \"Confirm\"\n//#define OverWriteDialogCancelButtonString \"Cancel\"\n```C++\n\nSee the result :\n\n![ConfirmToOverWrite.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/ConfirmToOverWrite.gif)\n\n## Open / Save dialog Behavior :\n\nImGuiFileDialog uses the same code internally for Open and Save dialogs. To distinguish between them access the various\ndata return functions depending on what the dialog is doing.\n\nWhen selecting an existing file (for example, a Load or Open dialog), use\n\n```cpp\nstd::map&lt;std::string, std::string&gt; GetSelection(); // Returns selection via a map&lt;FileName, FilePathName&gt;\nUserDatas GetUserDatas();                          // Get user data provided by the Open dialog\n```C++\n\nTo selecting a new file (for example, a Save As... dialog), use:\n\n```cpp\nstd::string GetFilePathName();                     // Returns the content of the selection field with current file extension and current path\nstd::string GetCurrentFileName();                  // Returns the content of the selection field with current file extension but no path\nstd::string GetCurrentPath();                      // Returns current path only\nstd::string GetCurrentFilter();                    // The file extension\n```C++\n\n## Thumbnails Display\n\nYou can now, display thumbnails of pictures.\n\n![thumbnails.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/thumbnails.gif)\n\nThe file resize use stb/image so the following files extentions are supported :\n * .png (tested sucessfully)\n * .bmp (tested sucessfully)\n * .tga (tested sucessfully)\n * .jpg (tested sucessfully)\n * .jpeg (tested sucessfully)\n * .gif (tested sucessfully_ but not animation just first frame)\n * .psd (not tested)\n * .pic (not tested)\n * .ppm (not tested)\n * .pgm (not tested)\n\nCorresponding to your backend (ex : OpenGl) you need to define two callbacks :\n* the first is a callback who will be called by ImGuiFileDialog for create the backend texture\n* the second is a callback who will be called by ImGuiFileDialog for destroy the backend texture\n\nAfter that you need to call the function who is responsible to create / destroy the textures.\nthis function must be called in your GPU Rendering zone for avoid destroying of used texture.\nif you do that at the same place of your imgui code, some backend can crash your app, by ex with vulkan.\n\nTo Clarify :\n\nThis feature is spliited in two zones :\n - CPU Zone : for load/destroy picture file\n - GPU Zone : for load/destroy gpu textures.\nThis modern behavior for avoid destroying of used texture,\nwas needed for vulkan.\n\nThis feature was Successfully tested on my side with Opengl and Vulkan.\nBut im sure is perfectly compatible with other modern apis like DirectX and Metal\n\nex, for opengl :\n\n```cpp\n// Create thumbnails texture\nImGuiFileDialog::Instance()-&gt;SetCreateThumbnailCallback([](IGFD_Thumbnail_Info *vThumbnail_Info) -&gt; void\n{\n    if (vThumbnail_Info &amp;&amp;\n        vThumbnail_Info-&gt;isReadyToUpload &amp;&amp;\n        vThumbnail_Info-&gt;textureFileDatas)\n    {\n        GLuint textureId = 0;\n        glGenTextures(1, &amp;textureId);\n        vThumbnail_Info-&gt;textureID = (void*)textureId;\n\n        glBindTexture(GL_TEXTURE_2D, textureId);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,\n            (GLsizei)vThumbnail_Info-&gt;textureWidth, (GLsizei)vThumbnail_Info-&gt;textureHeight,\n            0, GL_RGBA, GL_UNSIGNED_BYTE, vThumbnail_Info-&gt;textureFileDatas);\n        glFinish();\n        glBindTexture(GL_TEXTURE_2D, 0);\n\n        delete[] vThumbnail_Info-&gt;textureFileDatas;\n        vThumbnail_Info-&gt;textureFileDatas = nullptr;\n\n        vThumbnail_Info-&gt;isReadyToUpload = false;\n        vThumbnail_Info-&gt;isReadyToDisplay = true;\n    }\n});\n```C++\n\n```cpp\n// Destroy thumbnails texture\nImGuiFileDialog::Instance()-&gt;SetDestroyThumbnailCallback([](IGFD_Thumbnail_Info* vThumbnail_Info)\n{\n    if (vThumbnail_Info)\n    {\n        GLuint texID = (GLuint)vThumbnail_Info-&gt;textureID;\n        glDeleteTextures(1, &amp;texID);\n        glFinish();\n    }\n});\n```C++\n\n```cpp\n// GPU Rendering Zone // To call for Create/ Destroy Textures\nImGuiFileDialog::Instance()-&gt;ManageGPUThumbnails();\n```C++\n\n## Embedded in other frames :\n\nThe dialog can be embedded in another user frame than the standard or modal dialog\n\nYou have to create a variable of type ImGuiFileDialog. (if you are suing the singleton, you will not have the possibility to open other dialog)\n\nex :\n\n```cpp\nImGuiFileDialog fileDialog;\n\n// open dialog; in this case, Bookmark, directory creation are disabled with, and also the file input field is readonly.\n// btw you can od what you want\nfileDialog.OpenDialog(\"embedded\", \"Select File\", \".*\", \"\", -1, nullptr,\n    ImGuiFileDialogFlags_NoDialog |\n    ImGuiFileDialogFlags_DisableBookmarkMode |\n    ImGuiFileDialogFlags_DisableCreateDirectoryButton |\n    ImGuiFileDialogFlags_ReadOnlyFileNameField);\n// then display, here\n// to note, when embedded the ImVec2(0,0) (MinSize) do nothing, only the ImVec2(0,350) (MaxSize) can size the dialog frame\nfileDialog.Display(\"embedded\", ImGuiWindowFlags_NoCollapse, ImVec2(0,0), ImVec2(0,350)))\n```C++\nthe result :\n\n![Embedded.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/Embedded.gif)\n\n## Quick Parallel Path Selection in Path Composer\n\nyou have a separator between two directories in the path composer\nwhen you click on it you can explore a list of parrallels directories of this point\n\nthis feature is disabled by default\nyou can enable it with the compiler flag : #define USE_QUICK_PATH_SELECT\n\nyou can also customize the spacing between path button's with and without this mode\nyou can do that by define the compiler flag : #define CUSTOM_PATH_SPACING 2\nif undefined the spacing is defined by the imgui theme\n\n![quick_composer_path_select.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/quick_composer_path_select.gif)\n\n## Case Insensitive Filtering\n\nyou can use this flag 'ImGuiFileDialogFlags_CaseInsensitiveExtention' when you call the display function\n</code></pre> by ex : if the flag ImGuiFileDialogFlags_CaseInsensitiveExtention is used with filters like .jpg or .Jpg or .JPG all files with extentions by ex : .jpg and .JPG will be displayed <pre><code>## Tune the validations button group\n\nYou can specify :\n- the width of \"ok\" and \"cancel\" buttons, by the set the defines \"okButtonWidth\" and \"cancelButtonWidth\"\n- the alignement of the button group (left, right, middle, etc..) by set the define \"okCancelButtonAlignement\"\n- if you want to have the ok button on the left and cancel button on the right or inverted by set the define \"invertOkAndCancelButtons\"\n\njust see theses defines in the config file\n```cpp\n//Validation buttons\n//#define okButtonString \" OK\"\n//#define okButtonWidth 0.0f\n//#define cancelButtonString \" Cancel\"\n//#define cancelButtonWidth 0.0f\n//alignement [0:1], 0.0 is left, 0.5 middle, 1.0 right, and other ratios\n//#define okCancelButtonAlignement 0.0f\n//#define invertOkAndCancelButtons false\n```C++\nwith Alignement 0.0 =&gt; left\n\n![alignement_0.0.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/alignement_0.0.png)\n\nwith Alignement 1.0 =&gt; right\n\n![alignement_1.0.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/alignement_1.0.png)\n\nwith Alignement 0.5 =&gt; middle\n\n![alignement_0.5.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/alignement_0.5.png)\n\nok and cancel buttons inverted (cancel on the left and ok on the right)\n\n![validation_buttons_inverted.gif](https://github.com/aiekick/ImGuiFileDialog/blob/master/doc/validation_buttons_inverted.png)\n\n## Filtering by a regex :\n\nyou can use a regex for filtering and file coloring \n\nfor have a filter recognized as a regex, you must have it between a ( and a )\n\nthis one will filter files who start by the word \"Common\" and finish by \".h\" \n```cpp\nex : \"(Custom.+[.]h)\" \n```C++\n\nuse cases :\n\n* Simple filter : \n```cpp\nOpenDialog(\"toto\", \"Choose File\", \"(Custom.+[.]h)\");\n```C++\n\n* Collections filter : \nfor this one the filter is between \"{\" and \"}\", so you can use the \"(\" and \")\" outside\n\n```cpp\nOpenDialog(\"toto\", \"Choose File\", \"Source files (*.cpp *.h *.hpp){(Custom.+[.]h),.h,.hpp}\");\n```C++\n\n* file coloring :\nthis one will colorized all files who start by the word \"Common\" and finish by \".h\" \n```cpp\nSetFileStyle(IGFD_FileStyleByFullName, \"(Custom.+[.]h)\", ImVec4(1.0f, 1.0f, 0.0f, 0.9f));\n```C++\n\n* with this feature you can by ex filter and colorize render frame pictures who have ext like .000, .001, .002, etc..\n```cpp\nOpenDialog(\"toto\", \"Choose File\", \"([.][0-9]{3})\");\nSetFileStyle(IGFD_FileStyleByFullName, \"([.][0-9]{3})\", ImVec4(1.0f, 1.0f, 0.0f, 0.9f));\n```C++\n\n## How to Integrate ImGuiFileDialog in your project\n\n### Customize ImGuiFileDialog :\n\nYou can customize many aspects of ImGuiFileDialog by overriding `ImGuiFileDialogConfig.h`.\n\nTo enable your customizations, define the preprocessor directive CUSTOM_IMGUIFILEDIALOG_CONFIG with the path of your\ncustom config file. This path must be relative to the directory where you put the ImGuiFileDialog module.\n\nThis operation is demonstrated in `CustomImGuiFileDialog.h` in the example project to:\n\n* Have a custom icon font instead of labels for buttons or message titles\n* Customize the button text (the button call signature must be the same, by the way! :)\n\nThe custom icon font used in the example code ([CustomFont.cpp](CustomFont.cpp) and [CustomFont.h](CustomFont.h)) was made\nwith [ImGuiFontStudio](https://github.com/aiekick/ImGuiFontStudio), which I wrote. :)\n\nImGuiFontStudio uses ImGuiFileDialog! Check it out.\n\n## Api's C/C++ :\n\n### the C Api\n\nthis api was sucessfully tested with CImGui\n\nA C API is available let you include ImGuiFileDialog in your C project.\nbtw, ImGuiFileDialog depend of ImGui and dirent (for windows)\n\nSample code with cimgui :\n\n```cpp\n// create ImGuiFileDialog\nImGuiFileDialog *cfileDialog = IGFD_Create();\n\n// open dialog\nif (igButton(\"Open File\", buttonSize))\n{\n    IGFD_OpenDialog(cfiledialog,\n        \"filedlg\",                              // dialog key (make it possible to have different treatment reagrding the dialog key\n        \"Open a File\",                          // dialog title\n        \"c files(*.c *.h){.c,.h}\",              // dialog filter syntax : simple =&gt; .h,.c,.pp, etc and collections : text1{filter0,filter1,filter2}, text2{filter0,filter1,filter2}, etc..\n        \".\",                                    // base directory for files scan\n        \"\",                                     // base filename\n        0,                                      // a fucntion for display a right pane if you want\n        0.0f,                                   // base width of the pane\n        0,                                      // count selection : 0 infinite, 1 one file (default), n (n files)\n        \"User data !\",                          // some user datas\n        ImGuiFileDialogFlags_ConfirmOverwrite); // ImGuiFileDialogFlags\n}\n\nImGuiIO* ioptr = igGetIO();\nImVec2 maxSize;\nmaxSize.x = ioptr-&gt;DisplaySize.x * 0.8f;\nmaxSize.y = ioptr-&gt;DisplaySize.y * 0.8f;\nImVec2 minSize;\nminSize.x = maxSize.x * 0.25f;\nminSize.y = maxSize.y * 0.25f;\n\n// display dialog\nif (IGFD_DisplayDialog(cfiledialog, \"filedlg\", ImGuiWindowFlags_NoCollapse, minSize, maxSize))\n{\n    if (IGFD_IsOk(cfiledialog)) // result ok\n    {\n        char* cfilePathName = IGFD_GetFilePathName(cfiledialog);\n        printf(\"GetFilePathName : %s\\n\", cfilePathName);\n        char* cfilePath = IGFD_GetCurrentPath(cfiledialog);\n        printf(\"GetCurrentPath : %s\\n\", cfilePath);\n        char* cfilter = IGFD_GetCurrentFilter(cfiledialog);\n        printf(\"GetCurrentFilter : %s\\n\", cfilter);\n        // here convert from string because a string was passed as a userDatas, but it can be what you want\n        void* cdatas = IGFD_GetUserDatas(cfiledialog);\n        if (cdatas)\n            printf(\"GetUserDatas : %s\\n\", (const char*)cdatas);\n        struct IGFD_Selection csel = IGFD_GetSelection(cfiledialog); // multi selection\n        printf(\"Selection :\\n\");\n        for (int i = 0; i &lt; (int)csel.count; i++)\n        {\n            printf(\"(%i) FileName %s =&gt; path %s\\n\", i, csel.table[i].fileName, csel.table[i].filePathName);\n        }\n        // action\n\n        // destroy\n        if (cfilePathName) free(cfilePathName);\n        if (cfilePath) free(cfilePath);\n        if (cfilter) free(cfilter);\n\n        IGFD_Selection_DestroyContent(&amp;csel);\n    }\n    IGFD_CloseDialog(cfiledialog);\n}\n\n// destroy ImGuiFileDialog\nIGFD_Destroy(cfiledialog);\n```C++\n\n-----------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------------------\n\nThats all.\n\nYou can check by example in this repo with the file CustomImGuiFileDialogConfig.h :\n- this trick was used for have custom icon font instead of labels for buttons or messages titles\n- you can also use your custom imgui button, the button call stamp must be same by the way :)\n\nThe Custom Icon Font (in CustomFont.cpp and CustomFont.h) was made with ImGuiFontStudio (https://github.com/aiekick/ImGuiFontStudio) i wrote for that :)\nImGuiFontStudio is using also ImGuiFileDialog.\n\n-----------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------------------\n*/\n\n#ifndef IMGUIFILEDIALOG_H\n#define IMGUIFILEDIALOG_H\n\n// compatible with 1.88 WIP\n#define IMGUIFILEDIALOG_VERSION \"v0.6.5\"\n\n#ifndef CUSTOM_IMGUIFILEDIALOG_CONFIG\n#include \"ImGuiFileDialogConfig.h\"\n#else // CUSTOM_IMGUIFILEDIALOG_CONFIG\n#include CUSTOM_IMGUIFILEDIALOG_CONFIG\n#endif // CUSTOM_IMGUIFILEDIALOG_CONFIG\n\n// file style enum for file display (color, icon, font)\ntypedef int IGFD_FileStyleFlags; // -&gt; enum IGFD_FileStyleFlags_\nenum IGFD_FileStyleFlags_ // by evaluation / priority order\n{\n    IGFD_FileStyle_None                 = 0,        // define none style\n    IGFD_FileStyleByTypeFile            = (1 &lt;&lt; 0), // define style for all files\n    IGFD_FileStyleByTypeDir             = (1 &lt;&lt; 1), // define style for all dir\n    IGFD_FileStyleByTypeLink            = (1 &lt;&lt; 2), // define style for all link\n    IGFD_FileStyleByExtention           = (1 &lt;&lt; 3), // define style by extention, for files or links\n    IGFD_FileStyleByFullName            = (1 &lt;&lt; 4), // define style for particular file/dir/link full name (filename + extention)\n    IGFD_FileStyleByContainedInFullName = (1 &lt;&lt; 5), // define style for file/dir/link when criteria is contained in full name\n};\n\ntypedef int ImGuiFileDialogFlags; // -&gt; enum ImGuiFileDialogFlags_\nenum ImGuiFileDialogFlags_\n{\n    ImGuiFileDialogFlags_None                           = 0,        // define none default flag\n    ImGuiFileDialogFlags_ConfirmOverwrite               = (1 &lt;&lt; 0), // show confirm to overwrite dialog\n    ImGuiFileDialogFlags_DontShowHiddenFiles            = (1 &lt;&lt; 1), // dont show hidden file (file starting with a .)\n    ImGuiFileDialogFlags_DisableCreateDirectoryButton   = (1 &lt;&lt; 2), // disable the create directory button\n    ImGuiFileDialogFlags_HideColumnType                 = (1 &lt;&lt; 3), // hide column file type\n    ImGuiFileDialogFlags_HideColumnSize                 = (1 &lt;&lt; 4), // hide column file size\n    ImGuiFileDialogFlags_HideColumnDate                 = (1 &lt;&lt; 5), // hide column file date\n    ImGuiFileDialogFlags_NoDialog                       = (1 &lt;&lt; 6), // let the dialog embedded in your own imgui begin / end scope\n    ImGuiFileDialogFlags_ReadOnlyFileNameField          = (1 &lt;&lt; 7), // don't let user type in filename field for file open style dialogs\n    ImGuiFileDialogFlags_CaseInsensitiveExtention       = (1 &lt;&lt; 8), // the file extentions treatments will not take into account the case \n    ImGuiFileDialogFlags_Modal                          = (1 &lt;&lt; 9), // modal\n#ifdef USE_THUMBNAILS\n    ImGuiFileDialogFlags_DisableThumbnailMode           = (1 &lt;&lt; 10),    // disable the thumbnail mode\n#endif // USE_THUMBNAILS\n#ifdef USE_BOOKMARK\n    ImGuiFileDialogFlags_DisableBookmarkMode            = (1 &lt;&lt; 11),    // disable the bookmark mode\n#endif // USE_BOOKMARK\n    ImGuiFileDialogFlags_Default = ImGuiFileDialogFlags_ConfirmOverwrite\n};\n\n#ifdef USE_THUMBNAILS\nstruct IGFD_Thumbnail_Info\n{\n    int isReadyToDisplay = 0;               // ready to be rendered, so texture created\n    int isReadyToUpload = 0;                // ready to upload to gpu\n    int isLoadingOrLoaded = 0;              // was sent to laoding or loaded\n    void* textureID = 0;                    // 2d texture id (void* is like ImtextureID type) (GL, DX, VK, Etc..)\n    unsigned char* textureFileDatas = 0;    // file texture datas, will be rested to null after gpu upload\n    int textureWidth = 0;                   // width of the texture to upload\n    int textureHeight = 0;                  // height of the texture to upload\n    int textureChannels = 0;                // count channels of the texture to upload\n    void* userDatas = 0;                    // user datas\n};\n#endif // USE_THUMBNAILS\n\n#ifdef __cplusplus\n\n#include &lt;imgui/imgui.h&gt;\n\n#include &lt;cfloat&gt;\n#include &lt;utility&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;regex&gt;\n\nnamespace IGFD\n{\n#ifndef defaultSortField\n#define defaultSortField FIELD_FILENAME\n#endif // defaultSortField\n\n#ifndef defaultSortOrderFilename\n#define defaultSortOrderFilename true\n#endif // defaultSortOrderFilename\n#ifndef defaultSortOrderType\n#define defaultSortOrderType true\n#endif // defaultSortOrderType\n#ifndef defaultSortOrderSize\n#define defaultSortOrderSize true\n#endif // defaultSortOrderSize\n#ifndef defaultSortOrderDate\n#define defaultSortOrderDate true\n#endif // defaultSortOrderDate\n#ifndef defaultSortOrderThumbnails\n#define defaultSortOrderThumbnails true\n#endif // defaultSortOrderThumbnails\n\n#ifndef MAX_FILE_DIALOG_NAME_BUFFER \n#define MAX_FILE_DIALOG_NAME_BUFFER 1024\n#endif // MAX_FILE_DIALOG_NAME_BUFFER\n\n#ifndef MAX_PATH_BUFFER_SIZE\n#define MAX_PATH_BUFFER_SIZE 1024\n#endif // MAX_PATH_BUFFER_SIZE\n\n\n    class FileDialogInternal;\n\n\n    class SearchManager\n    {\n    public:\n        std::string puSearchTag;\n        char puSearchBuffer[MAX_FILE_DIALOG_NAME_BUFFER] = \"\";\n        bool puSearchInputIsActive = false;\n\n    public:\n        void Clear();                                                                                           // clear datas\n        void DrawSearchBar(FileDialogInternal&amp; vFileDialogInternal);                                            // draw the search bar\n    };\n\n\n    class Utils\n    {\n    public:\n        struct PathStruct\n        {\n            std::string path;\n            std::string name;\n            std::string ext;\n            bool isOk = false;\n        };\n\n    public:\n        static bool Splitter(bool split_vertically, float thickness, float* size1, float* size2, float min_size1, float min_size2, float splitter_long_axis_size = -1.0f);\n        static bool ReplaceString(std::string&amp; str, const std::string&amp; oldStr, const std::string&amp; newStr);\n        static bool IsDirectoryCanBeOpened(const std::string&amp; name);            // by ex protected dirs (not user rights)\n        static bool IsDirectoryExist(const std::string&amp; name);\n        static bool CreateDirectoryIfNotExist(const std::string&amp; name);\n        static PathStruct ParsePathFileName(const std::string&amp; vPathFileName);\n        static void AppendToBuffer(char* vBuffer, size_t vBufferLen, const std::string&amp; vStr);\n        static void ResetBuffer(char* vBuffer);\n        static void SetBuffer(char* vBuffer, size_t vBufferLen, const std::string&amp; vStr);\n        static bool WReplaceString(std::wstring&amp; str, const std::wstring&amp; oldStr, const std::wstring&amp; newStr);\n        static std::vector&lt;std::wstring&gt; WSplitStringToVector(const std::wstring&amp; text, char delimiter, bool pushEmpty);\n        static std::string utf8_encode(const std::wstring&amp; wstr);\n        static std::wstring utf8_decode(const std::string&amp; str);\n        static std::vector&lt;std::string&gt; SplitStringToVector(const std::string&amp; text, char delimiter, bool pushEmpty);\n        static std::vector&lt;std::string&gt; GetDrivesList();\n        static std::string LowerCaseString(const std::string&amp; vString); // turn all text in lower case for search facilitie\n    };\n\n\n    class FileStyle\n    {\n    public:\n        ImVec4 color = ImVec4(0, 0, 0, 0);\n        std::string icon;\n        ImFont* font = nullptr;\n        IGFD_FileStyleFlags flags = 0;\n\n    public:\n        FileStyle();\n        FileStyle(const FileStyle&amp; vStyle);\n        FileStyle(const ImVec4&amp; vColor, const std::string&amp; vIcon = \"\", ImFont* vFont = nullptr);\n    };\n\n\n    class FileInfos;\n    class FilterManager\n    {\n    public:\n        class FilterInfos\n        {\n        public:\n            std::string filter;                                                                             // simple filter\n            std::regex filter_regex;                                                                        // filter fo type regex\n            std::set&lt;std::string&gt; collectionfilters;                                                        // collections of filters\n            std::string filter_optimized;                                                                   // opitmized for case insensitive search\n            std::set&lt;std::string&gt; collectionfilters_optimized;                                              // optimized collections of filters for case insensitive search\n            std::vector&lt;std::regex&gt; collectionfilters_regex;                                                // collection of regex filter type\n\n        public:\n            void clear();                                                                                   // clear the datas\n            bool empty() const;                                                                             // is filter empty\n            bool exist(const std::string&amp; vFilter, bool vIsCaseInsensitive) const;                          // is filter exist\n            bool regex_exist(const std::string&amp; vFilter) const;                                             // is regex filter exist\n        };\n\n    private:\n#ifdef NEED_TO_BE_PUBLIC_FOR_TESTS\n    public:\n#endif\n        std::vector&lt;FilterInfos&gt; prParsedFilters;\n        std::unordered_map&lt;IGFD_FileStyleFlags, std::unordered_map&lt;std::string, std::shared_ptr&lt;FileStyle&gt;&gt;&gt; prFilesStyle;      // file infos for file extention only\n        FilterInfos prSelectedFilter;\n\n    public:\n        std::string puDLGFilters;\n        std::string puDLGdefaultExt;\n\n    public:\n        void ParseFilters(const char* vFilters);                                                            // Parse filter syntax, detect and parse filter collection\n        void SetSelectedFilterWithExt(const std::string&amp; vFilter);                                          // Select filter\n\n        bool prFillFileStyle(std::shared_ptr&lt;FileInfos&gt; vFileInfos)  const;                                 // fill with the good style\n\n        void SetFileStyle(\n            const IGFD_FileStyleFlags&amp; vFlags,\n            const char* vCriteria,\n            const FileStyle&amp; vInfos);                                                                       // Set FileStyle\n        void SetFileStyle(\n            const IGFD_FileStyleFlags&amp; vFlags,\n            const char* vCriteria,\n            const ImVec4&amp; vColor,\n            const std::string&amp; vIcon,\n            ImFont* vFont);                                                                                 // link file style to Color and Icon and Font\n        bool GetFileStyle(\n            const IGFD_FileStyleFlags&amp; vFlags,\n            const std::string&amp; vCriteria,\n            ImVec4* vOutColor,\n            std::string* vOutIcon,\n            ImFont** vOutFont);                                                                             // Get Color and Icon for Filter\n        void ClearFilesStyle();                                                                             // clear prFileStyle\n\n        bool IsCoveredByFilters(                                                        // check if current file extention (vExt) is covered by current filter, ro by regex (vNameExt)\n            const std::string&amp; vNameExt, \n            const std::string&amp; vExt, \n            bool vIsCaseInsensitive) const;                                                                 \n        bool DrawFilterComboBox(FileDialogInternal&amp; vFileDialogInternal);                                   // draw the filter combobox\n        FilterInfos GetSelectedFilter();                                                                    // get the current selected filter\n        std::string ReplaceExtentionWithCurrentFilter(const std::string&amp; vFile) const;                      // replace the extention of the current file by the selected filter\n        void SetDefaultFilterIfNotDefined();                                                                // define the first filter if no filter is selected\n    };\n\n\n    class FileType\n    {\n    public:\n        enum class ContentType {\n            // The ordering will be used during sort.\n            Invalid = -1,\n            Directory = 0,\n            File = 1,\n            LinkToUnknown = 2, // link to something that is not a regular file or directory.\n        };\n\n    private:\n        ContentType m_Content = ContentType::Invalid;\n        bool m_Symlink = false;\n\n    public:\n        FileType() = default;\n        FileType(const ContentType&amp; vContentType, const bool&amp; vIsSymlink)\n            : m_Content(vContentType), m_Symlink(vIsSymlink)\n        {}\n\n        void SetContent(const ContentType&amp; vContentType) { m_Content = vContentType; }\n        void SetSymLink(const bool&amp; vIsSymlink) { m_Symlink = vIsSymlink; }\n\n        bool isValid () const { return m_Content != ContentType::Invalid; }\n        bool isDir () const { return m_Content == ContentType::Directory; }\n        bool isFile () const { return m_Content == ContentType::File; }\n        bool isLinkToUnknown () const { return m_Content == ContentType::LinkToUnknown; }\n        bool isSymLink() const { return m_Symlink; }\n\n        // Comparisons only care about the content type, ignoring whether it's a symlink or not.\n        bool operator== (const FileType&amp; rhs) const { return m_Content == rhs.m_Content; }\n        bool operator!= (const FileType&amp; rhs) const { return m_Content != rhs.m_Content; }\n        bool operator&lt;  (const FileType&amp; rhs) const { return m_Content &lt; rhs.m_Content; }\n        bool operator&gt;  (const FileType&amp; rhs) const { return m_Content &gt; rhs.m_Content; }\n    };\n\n    class FileInfos\n    {\n    public:\n        FileType fileType;                                  // fileType     \n        std::string filePath;                               // path of the file\n        std::string fileNameExt;                            // filename of the file (file name + extention) (but no path)\n        std::string fileNameExt_optimized;                  // optimized for search =&gt; insensitivecase\n        std::string fileExt;                                // extention of the file\n        size_t fileSize = 0;                                // for sorting operations\n        std::string formatedFileSize;                       // file size formated (10 o, 10 ko, 10 mo, 10 go)\n        std::string fileModifDate;                          // file user defined format of the date (data + time by default)\n        std::shared_ptr&lt;FileStyle&gt; fileStyle = nullptr;     // style of the file\n#ifdef USE_THUMBNAILS\n        IGFD_Thumbnail_Info thumbnailInfo;      // structre for the display for image file tetxure\n#endif // USE_THUMBNAILS\n\n    public:\n        bool IsTagFound(const std::string&amp; vTag) const;\n    };\n\n\n    class FileManager\n    {\n    public: // types\n        enum class SortingFieldEnum     // sorting for filetering of the file lsit\n        {\n            FIELD_NONE = 0,             // no sorting preference, result indetermined haha..\n            FIELD_FILENAME,             // sorted by filename\n            FIELD_TYPE,                 // sorted by filetype\n            FIELD_SIZE,                 // sorted by filesize (formated file size)\n            FIELD_DATE,                 // sorted by filedate\n#ifdef USE_THUMBNAILS\n            FIELD_THUMBNAILS,           // sorted by thumbnails (comparaison by width then by height)\n#endif // USE_THUMBNAILS\n        };\n\n    private:\n        std::string prCurrentPath;                                          // current path (to be decomposed in prCurrentPathDecomposition\n        std::vector&lt;std::string&gt; prCurrentPathDecomposition;                // part words\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt; prFileList;                 // base container\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt; prFilteredFileList;         // filtered container (search, sorting, etc..)\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt; prPathList;                 // base container for path selection\n        std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt; prFilteredPathList;         // filtered container for path selection (search, sorting, etc..)\n        std::vector&lt;std::string&gt;::iterator prPopupComposedPath;             // iterator on prCurrentPathDecomposition for Current Path popup\n        std::string prLastSelectedFileName;                                 // for shift multi selection\n        std::set&lt;std::string&gt; prSelectedFileNames;                          // the user selection of FilePathNames\n        bool prCreateDirectoryMode = false;                                 // for create directory widget\n\n    public:\n        char puVariadicBuffer[MAX_FILE_DIALOG_NAME_BUFFER] = \"\";            // called by prSelectableItem\n        bool puInputPathActivated = false;                                  // show input for path edition\n        bool puDrivesClicked = false;                                       // event when a drive button is clicked\n        bool puPathClicked = false;                                         // event when a path button was clicked\n        char puInputPathBuffer[MAX_PATH_BUFFER_SIZE] = \"\";                  // input path buffer for imgui widget input text (displayed in palce of composer)\n        char puFileNameBuffer[MAX_FILE_DIALOG_NAME_BUFFER] = \"\";            // file name buffer in footer for imgui widget input text\n        char puDirectoryNameBuffer[MAX_FILE_DIALOG_NAME_BUFFER] = \"\";       // directory name buffer in footer for imgui widget input text (when is directory mode)\n        std::string puHeaderFileName;                                       // detail view name of column file\n        std::string puHeaderFileType;                                       // detail view name of column type\n        std::string puHeaderFileSize;                                       // detail view name of column size\n        std::string puHeaderFileDate;                                       // detail view name of column date + time\n#ifdef USE_THUMBNAILS\n        std::string puHeaderFileThumbnails;                                 // detail view name of column thumbnails\n        bool puSortingDirection[5] = {                                      // true =&gt; Ascending, false =&gt; Descending\n            defaultSortOrderFilename,\n            defaultSortOrderType,\n            defaultSortOrderSize,\n            defaultSortOrderDate,\n            defaultSortOrderThumbnails };\n#else\n        bool puSortingDirection[4] = {                                      // true =&gt; Ascending, false =&gt; Descending\n            defaultSortOrderFilename,\n            defaultSortOrderType,\n            defaultSortOrderSize,\n            defaultSortOrderDate };\n#endif\n        SortingFieldEnum puSortingField = SortingFieldEnum::FIELD_FILENAME; // detail view sorting column\n        bool puShowDrives = false;                                          // drives are shown (only on os windows)\n\n        std::string puDLGpath;                                              // base path set by user when OpenDialog was called\n        std::string puDLGDefaultFileName;                                   // base default file path name set by user when OpenDialog was called\n        size_t puDLGcountSelectionMax = 1U; // 0 for infinite               // base max selection count set by user when OpenDialog was called\n        bool puDLGDirectoryMode = false;                                    // is directory mode (defiend like : puDLGDirectoryMode = (filters.empty()))\n\n        std::string puFsRoot;\n\n    private:\n        static std::string prRoundNumber(double vvalue, int n);                                         // custom rounding number\n        static std::string prFormatFileSize(size_t vByteSize);                                          // format file size field\n        static void prCompleteFileInfos(const std::shared_ptr&lt;FileInfos&gt;&amp; FileInfos);                   // set time and date infos of a file (detail view mode)\n        void prRemoveFileNameInSelection(const std::string&amp; vFileName);                                 // selection : remove a file name\n        void prAddFileNameInSelection(const std::string&amp; vFileName, bool vSetLastSelectionFileName);    // selection : add a file name\n        void AddFile(const FileDialogInternal&amp; vFileDialogInternal, \n            const std::string&amp; vPath, const std::string&amp; vFileName, const FileType&amp; vFileType);         // add file called by scandir\n        void AddPath(const FileDialogInternal&amp; vFileDialogInternal,\n            const std::string&amp; vPath, const std::string&amp; vFileName, const FileType&amp; vFileType);         // add file called by scandir\n\n#if defined(USE_QUICK_PATH_SELECT)\n        void ScanDirForPathSelection(const FileDialogInternal&amp; vFileDialogInternal, const std::string&amp; vPath);  // scan the directory for retrieve the path list\n        void OpenPathPopup(const FileDialogInternal&amp; vFileDialogInternal, std::vector&lt;std::string&gt;::iterator vPathIter);\n#endif // USE_QUICK_PATH_SELECT\n\n        void SetCurrentPath(std::vector&lt;std::string&gt;::iterator vPathIter);\n\n        void ApplyFilteringOnFileList(\n            const FileDialogInternal&amp; vFileDialogInternal,\n            std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosList,\n            std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosFilteredList);\n        void SortFields(\n            const FileDialogInternal&amp; vFileDialogInternal,\n            std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosList,\n            std::vector&lt;std::shared_ptr&lt;FileInfos&gt;&gt;&amp; vFileInfosFilteredList);                                   // will sort a column\n\n    public:\n        FileManager();\n        bool IsComposerEmpty();\n        size_t GetComposerSize();\n        bool IsFileListEmpty();\n        bool IsPathListEmpty();\n        bool IsFilteredListEmpty();\n        bool IsPathFilteredListEmpty();\n        size_t GetFullFileListSize();\n        std::shared_ptr&lt;FileInfos&gt; GetFullFileAt(size_t vIdx);\n        size_t GetFilteredListSize();\n        size_t GetPathFilteredListSize();\n        std::shared_ptr&lt;FileInfos&gt; GetFilteredFileAt(size_t vIdx);\n        std::shared_ptr&lt;FileInfos&gt; GetFilteredPathAt(size_t vIdx);\n        std::vector&lt;std::string&gt;::iterator GetCurrentPopupComposedPath();\n        bool IsFileNameSelected(const std::string&amp; vFileName);\n        std::string GetBack();\n        void ClearComposer();\n        void ClearFileLists();                                                                          // clear file list, will destroy thumbnail textures\n        void ClearPathLists();                                                                          // clear path list, will destroy thumbnail textures\n        void ClearAll();\n        void ApplyFilteringOnFileList(const FileDialogInternal&amp; vFileDialogInternal);\n        void SortFields(const FileDialogInternal&amp; vFileDialogInternal);                                 // will sort a column\n        void OpenCurrentPath(const FileDialogInternal&amp; vFileDialogInternal);                            // set the path of the dialog, will launch the directory scan for populate the file listview\n        bool GetDrives();                                                                               // list drives on windows platform\n        bool CreateDir(const std::string&amp; vPath);                                                       // create a directory on the file system\n        std::string ComposeNewPath(std::vector&lt;std::string&gt;::iterator vIter);                                   // compose a path from the compose path widget\n        bool SetPathOnParentDirectoryIfAny();                                                           // compose paht on parent directory\n        std::string GetCurrentPath();                                                                   // get the current path\n        void SetCurrentPath(const std::string&amp; vCurrentPath);                                           // set the current path\n        static bool IsFileExist(const std::string&amp; vFile);\n        void SetDefaultFileName(const std::string&amp; vFileName);\n        bool SelectDirectory(const std::shared_ptr&lt;FileInfos&gt;&amp; vInfos);                                     // enter directory\n        void SelectFileName(const FileDialogInternal&amp; vFileDialogInternal, \n            const std::shared_ptr&lt;FileInfos&gt;&amp; vInfos);                                                          // select filename\n\n        //depend of dirent.h\n        void SetCurrentDir(const std::string&amp; vPath);                                                   // define current directory for scan\n        void ScanDir(const FileDialogInternal&amp; vFileDialogInternal, const std::string&amp; vPath);          // scan the directory for retrieve the file list\n\n    public:\n        std::string GetResultingPath();\n        std::string GetResultingFileName(FileDialogInternal&amp; vFileDialogInternal);\n        std::string GetResultingFilePathName(FileDialogInternal&amp; vFileDialogInternal);\n        std::map&lt;std::string, std::string&gt; GetResultingSelection();\n\n    public:\n        void DrawDirectoryCreation(const FileDialogInternal&amp; vFileDialogInternal);                      // draw directory creation widget\n        void DrawPathComposer(const FileDialogInternal&amp; vFileDialogInternal);                           // draw path composer widget\n    };\n\n\n#ifdef USE_THUMBNAILS\n    typedef std::function&lt;void(IGFD_Thumbnail_Info*)&gt; CreateThumbnailFun;   // texture 2d creation function binding\n    typedef std::function&lt;void(IGFD_Thumbnail_Info*)&gt; DestroyThumbnailFun;  // texture 2d destroy function binding\n#endif\n    class ThumbnailFeature\n    {\n    protected:\n        ThumbnailFeature();\n        ~ThumbnailFeature();\n\n        void NewThumbnailFrame(FileDialogInternal&amp; vFileDialogInternal);\n        void EndThumbnailFrame(FileDialogInternal&amp; vFileDialogInternal);\n        void QuitThumbnailFrame(FileDialogInternal&amp; vFileDialogInternal);\n\n#ifdef USE_THUMBNAILS\n    protected:\n        enum class DisplayModeEnum\n        {\n            FILE_LIST = 0,\n            THUMBNAILS_LIST,\n            THUMBNAILS_GRID\n        };\n\n    private:\n        uint32_t prCountFiles = 0U;\n        bool prIsWorking = false;\n        std::shared_ptr&lt;std::thread&gt; prThumbnailGenerationThread = nullptr;\n        std::list&lt;std::shared_ptr&lt;FileInfos&gt;&gt; prThumbnailFileDatasToGet;    // base container\n        std::mutex prThumbnailFileDatasToGetMutex;\n        std::list&lt;std::shared_ptr&lt;FileInfos&gt;&gt; prThumbnailToCreate;          // base container\n        std::mutex prThumbnailToCreateMutex;\n        std::list&lt;IGFD_Thumbnail_Info&gt; prThumbnailToDestroy;                // base container\n        std::mutex prThumbnailToDestroyMutex;\n\n        CreateThumbnailFun prCreateThumbnailFun = nullptr;\n        DestroyThumbnailFun prDestroyThumbnailFun = nullptr;\n\n    protected:\n        DisplayModeEnum prDisplayMode = DisplayModeEnum::FILE_LIST;\n\n    protected:\n        // will be call in cpu zone (imgui computations, will call a texture file retrieval thread)\n        void prStartThumbnailFileDatasExtraction();                             // start the thread who will get byte buffer from image files\n        bool prStopThumbnailFileDatasExtraction();                              // stop the thread who will get byte buffer from image files\n        void prThreadThumbnailFileDatasExtractionFunc();                        // the thread who will get byte buffer from image files\n        void prDrawThumbnailGenerationProgress();                               // a little progressbar who will display the texture gen status\n        void prAddThumbnailToLoad(const std::shared_ptr&lt;FileInfos&gt;&amp; vFileInfos);        // add texture to load in the thread\n        void prAddThumbnailToCreate(const std::shared_ptr&lt;FileInfos&gt;&amp; vFileInfos);\n        void prAddThumbnailToDestroy(const IGFD_Thumbnail_Info&amp; vIGFD_Thumbnail_Info);\n        void prDrawDisplayModeToolBar();                                        // draw display mode toolbar (file list, thumbnails list, small thumbnails grid, big thumbnails grid)\n        void prClearThumbnails(FileDialogInternal&amp; vFileDialogInternal);\n\n    public:\n        void SetCreateThumbnailCallback(const CreateThumbnailFun&amp; vCreateThumbnailFun);\n        void SetDestroyThumbnailCallback(const DestroyThumbnailFun&amp; vCreateThumbnailFun);\n\n        // must be call in gpu zone (rendering, possibly one rendering thread)\n        void ManageGPUThumbnails(); // in gpu rendering zone, whill create or destroy texture\n#endif\n    };\n\n\n    class BookMarkFeature\n    {\n    protected:\n        BookMarkFeature();\n\n#ifdef USE_BOOKMARK\n    private:\n        struct BookmarkStruct\n        {\n            std::string name;           // name of the bookmark\n\n            // todo: the path could be relative, better if the app is movedn but bookmarked path can be outside of the app\n            std::string path;           // absolute path of the bookmarked directory \n\n            bool defined_by_code = false;   // defined by code, can be used for rpevent serialization / deserialization\n        };\n\n    private:\n        ImGuiListClipper prBookmarkClipper;\n        std::vector&lt;BookmarkStruct&gt; prBookmarks;\n        char prBookmarkEditBuffer[MAX_FILE_DIALOG_NAME_BUFFER] = \"\";\n\n    protected:\n        float prBookmarkWidth = 200.0f;\n        bool prBookmarkPaneShown = false;\n\n    protected:\n        void prDrawBookmarkButton();                                                            // draw bookmark button\n        bool prDrawBookmarkPane(FileDialogInternal&amp; vFileDialogInternal, const ImVec2&amp; vSize);  // draw bookmark Pane\n\n    public:\n        std::string SerializeBookmarks(                             // serialize bookmarks : return bookmark buffer to save in a file\n            const bool&amp; vDontSerializeCodeBasedBookmarks = true);   // for avoid serialization of bookmarks added by code\n        void DeserializeBookmarks(                                  // deserialize bookmarks : load bookmark buffer to load in the dialog (saved from previous use with SerializeBookmarks())\n            const std::string&amp; vBookmarks);                         // bookmark buffer to load\n        void AddBookmark(                                           // add a bookmark by code\n            const std::string&amp; vBookMarkName,                       // bookmark name\n            const std::string&amp; vBookMarkPath);                      // bookmark path\n        bool RemoveBookmark(                                        // remove a bookmark by code, return true if succeed\n            const std::string&amp; vBookMarkName);                      // bookmark name to remove\n\n#endif // USE_BOOKMARK\n    };\n\n\n    // file localization by input chat // widget flashing\n    class KeyExplorerFeature\n    {\n    protected:\n        KeyExplorerFeature();\n\n#ifdef USE_EXPLORATION_BY_KEYS\n    private:\n        size_t prFlashedItem = 0;                                                               // flash when select by char\n        float prFlashAlpha = 0.0f;                                                              // flash when select by char\n        float prFlashAlphaAttenInSecs = 1.0f;                                                   // fps display dependant\n        size_t prLocateFileByInputChar_lastFileIdx = 0;\n        ImWchar prLocateFileByInputChar_lastChar = 0;\n        int prLocateFileByInputChar_InputQueueCharactersSize = 0;\n        bool prLocateFileByInputChar_lastFound = false;\n\n    protected:\n        void prLocateByInputKey(FileDialogInternal&amp; vFileDialogInternal);                       // select a file line in listview according to char key\n        bool prLocateItem_Loop(FileDialogInternal&amp; vFileDialogInternal, ImWchar vC);            // restrat for start of list view if not found a corresponding file\n        void prExploreWithkeys(FileDialogInternal&amp; vFileDialogInternal, ImGuiID vListViewID);   // select file/directory line in listview accroding to up/down enter/backspace keys\n        static bool prFlashableSelectable(                                                              // custom flashing selectable widgets, for flash the selected line in a short time\n            const char* label, bool selected = false, ImGuiSelectableFlags flags = 0,\n            bool vFlashing = false, const ImVec2&amp; size = ImVec2(0, 0));\n        void prStartFlashItem(size_t vIdx);                                                     // define than an item must be flashed\n        bool prBeginFlashItem(size_t vIdx);                                                     // start the flashing of a line in lsit view\n        static void prEndFlashItem();                                                                   // end the fleshing accrdoin to var prFlashAlphaAttenInSecs\n\n    public:\n        void SetFlashingAttenuationInSeconds(                                                   // set the flashing time of the line in file list when use exploration keys\n            float vAttenValue);                                                                 // set the attenuation (from flashed to not flashed) in seconds\n#endif // USE_EXPLORATION_BY_KEYS\n    };\n\n\n    typedef void* UserDatas;\n    typedef std::function&lt;void(const char*, UserDatas, bool*)&gt; PaneFun;                         // side pane function binding\n    class FileDialogInternal\n    {\n    public:\n        FileManager puFileManager;\n        FilterManager puFilterManager;\n        SearchManager puSearchManager;\n\n    public:\n        std::string puName;\n        bool puShowDialog = false;\n        ImVec2 puDialogCenterPos = ImVec2(0, 0);                                                // center pos for display the confirm overwrite dialog\n        int puLastImGuiFrameCount = 0;                                                          // to be sure than only one dialog displayed per frame\n        float puFooterHeight = 0.0f;\n        bool puCanWeContinue = true;                                                            // events\n        bool puOkResultToConfirm = false;                                                       // to confim if ok for OverWrite\n        bool puIsOk = false;\n        bool puFileInputIsActive = false;                                                       // when input text for file or directory is active\n        bool puFileListViewIsActive = false;                                                    // when list view is active\n        std::string puDLGkey;\n        std::string puDLGtitle;\n        ImGuiFileDialogFlags puDLGflags = ImGuiFileDialogFlags_None;\n        UserDatas puDLGuserDatas = nullptr;\n        PaneFun puDLGoptionsPane = nullptr;\n        float puDLGoptionsPaneWidth = 0.0f;\n        bool puNeedToExitDialog = false;\n\n        bool puUseCustomLocale = false;\n        int puLocaleCategory = LC_ALL;  // locale category to use\n        std::string puLocaleBegin; // the locale who will be applied at start of the display dialog\n        std::string puLocaleEnd; // the locale who will be applaied at end of the display dialog\n\n    public:\n        void NewFrame();            // new frame, so maybe neded to do somethings, like reset events\n        void EndFrame();            // end frame, so maybe neded to do somethings fater all\n        void ResetForNewDialog();   // reset what is needed to reset for the openging of a new dialog\n    };\n\n\n    class FileDialog : \n        public BookMarkFeature, \n        public KeyExplorerFeature, \n        public ThumbnailFeature\n    {\n    private:\n        FileDialogInternal prFileDialogInternal;\n        ImGuiListClipper prFileListClipper;\n        ImGuiListClipper prPathListClipper;\n        float prOkCancelButtonWidth = 0.0f;\n\n    public:\n        bool puAnyWindowsHovered = false;                           // not remember why haha :) todo : to check if we can remove\n\n    public:\n        static FileDialog* Instance()                               // Singleton for easier accces form anywhere but only one dialog at a time\n        {\n            static FileDialog _instance;\n            return &amp;_instance;\n        }\n\n    public:\n        FileDialog();                                               // ImGuiFileDialog Constructor. can be used for have many dialog at same tiem (not possible with singleton)\n        virtual ~FileDialog();                                      // ImGuiFileDialog Destructor\n\n        // standard dialog\n        void OpenDialog(                                            // open simple dialog (path and fileName can be specified)\n            const std::string&amp; vKey,                                // key dialog\n            const std::string&amp; vTitle,                              // title\n            const char* vFilters,                                   // filters\n            const std::string&amp; vPath,                               // path\n            const std::string&amp; vFileName,                           // defaut file name\n            const int&amp; vCountSelectionMax = 1,                      // count selection max\n            UserDatas vUserDatas = nullptr,                         // user datas (can be retrieved in pane)\n            ImGuiFileDialogFlags vFlags = 0);                       // ImGuiFileDialogFlags \n\n        void OpenDialog(                                            // open simple dialog (path and filename are obtained from filePathName)\n            const std::string&amp; vKey,                                // key dialog\n            const std::string&amp; vTitle,                              // title\n            const char* vFilters,                                   // filters\n            const std::string&amp; vFilePathName,                       // file path name (will be decompsoed in path and fileName)\n            const int&amp; vCountSelectionMax = 1,                      // count selection max\n            UserDatas vUserDatas = nullptr,                         // user datas (can be retrieved in pane)\n            ImGuiFileDialogFlags vFlags = 0);                       // ImGuiFileDialogFlags \n\n        // with pane\n        void OpenDialog(                                            // open dialog with custom right pane (path and fileName can be specified)\n            const std::string&amp; vKey,                                // key dialog\n            const std::string&amp; vTitle,                              // title\n            const char* vFilters,                                   // filters\n            const std::string&amp; vPath,                               // path\n            const std::string&amp; vFileName,                           // defaut file name\n            const PaneFun&amp; vSidePane,                               // side pane\n            const float&amp; vSidePaneWidth = 250.0f,                   // side pane width\n            const int&amp; vCountSelectionMax = 1,                      // count selection max\n            UserDatas vUserDatas = nullptr,                         // user datas (can be retrieved in pane)\n            ImGuiFileDialogFlags vFlags = 0);                       // ImGuiFileDialogFlags \n\n        void OpenDialog(                                            // open dialog with custom right pane (path and filename are obtained from filePathName)\n            const std::string&amp; vKey,                                // key dialog\n            const std::string&amp; vTitle,                              // title\n            const char* vFilters,                                   // filters\n            const std::string&amp; vFilePathName,                       // file path name (will be decompsoed in path and fileName)\n            const PaneFun&amp; vSidePane,                               // side pane\n            const float&amp; vSidePaneWidth = 250.0f,                   // side pane width\n            const int&amp; vCountSelectionMax = 1,                      // count selection max\n            UserDatas vUserDatas = nullptr,                         // user datas (can be retrieved in pane)\n            ImGuiFileDialogFlags vFlags = 0);                       // ImGuiFileDialogFlags \n\n        // Display / Close dialog form\n        bool Display(                                               // Display the dialog. return true if a result was obtained (Ok or not)\n            const std::string&amp; vKey,                                // key dialog to display (if not the same key as defined by OpenDialog =&gt; no opening)\n            ImGuiWindowFlags vFlags = ImGuiWindowFlags_NoCollapse,  // ImGuiWindowFlags\n            ImVec2 vMinSize = ImVec2(0, 0),                         // mininmal size contraint for the ImGuiWindow\n            ImVec2 vMaxSize = ImVec2(FLT_MAX, FLT_MAX));            // maximal size contraint for the ImGuiWindow\n        void Close();                                               // close dialog\n\n        // queries\n        bool WasOpenedThisFrame(const std::string&amp; vKey) const;     // say if the dialog key was already opened this frame\n        bool WasOpenedThisFrame() const;                            // say if the dialog was already opened this frame\n        bool IsOpened(const std::string&amp; vKey) const;               // say if the key is opened\n        bool IsOpened() const;                                      // say if the dialog is opened somewhere\n        std::string GetOpenedKey() const;                           // return the dialog key who is opened, return nothing if not opened\n\n        // get result\n        bool IsOk() const;                                          // true =&gt; Dialog Closed with Ok result / false : Dialog closed with cancel result\n        std::map&lt;std::string, std::string&gt; GetSelection();          // Open File behavior : will return selection via a map&lt;FileName, FilePathName&gt;\n        std::string GetFilePathName();                              // Save File behavior : will always return the content of the field with current filter extention and current path\n        std::string GetCurrentFileName();                           // Save File behavior : will always return the content of the field with current filter extention\n        std::string GetCurrentPath();                               // will return current path\n        std::string GetCurrentFilter();                             // will return selected filter\n        UserDatas GetUserDatas() const;                             // will return user datas send with Open Dialog\n\n        // file style by extentions\n        void SetFileStyle(                                          // SetExtention datas for have custom display of particular file type\n            const IGFD_FileStyleFlags&amp; vFlags,                      // file style\n            const char* vCriteria,                                  // extention filter to tune\n            const FileStyle&amp; vInfos);                               // Filter Extention Struct who contain Color and Icon/Text for the display of the file with extention filter\n        void SetFileStyle(                                          // SetExtention datas for have custom display of particular file type\n            const IGFD_FileStyleFlags&amp; vFlags,                          // file style\n            const char* vCriteria,                                  // extention filter to tune\n            const ImVec4&amp; vColor,                                   // wanted color for the display of the file with extention filter\n            const std::string&amp; vIcon = \"\",                          // wanted text or icon of the file with extention filter\n            ImFont *vFont = nullptr);                               // wantes font\n        bool GetFileStyle(                                          // GetExtention datas. return true is extention exist\n            const IGFD_FileStyleFlags&amp; vFlags,                          // file style\n            const std::string&amp; vCriteria,                                   // extention filter (same as used in SetExtentionInfos)\n            ImVec4* vOutColor,                                      // color to retrieve\n            std::string* vOutIcon = nullptr,                        // icon or text to retrieve\n            ImFont** vOutFont = nullptr);                           // font to retreive\n        void ClearFilesStyle();                                     // clear extentions setttings\n\n        void SetLocales(                                            // set locales to use before and after the dialog display\n            const int&amp; vLocaleCategory,                             // set local category\n            const std::string&amp; vLocaleBegin,                        // locale to use at begining of the dialog display\n            const std::string&amp; vLocaleEnd);                         // locale to use at the end of the dialog display\n\n    protected:\n        void NewFrame();                                            // new frame just at begining of display\n        void EndFrame();                                            // end frame just at end of display\n        void QuitFrame();                                           // quit frame when qui quit the dialog\n\n        // others\n        bool prConfirm_Or_OpenOverWriteFileDialog_IfNeeded(\n            bool vLastAction, ImGuiWindowFlags vFlags);             // treatment of the result, start the confirm to overwrite dialog if needed (if defined with flag)\n\n    public:\n        // dialog parts\n        virtual void prDrawHeader();                                // draw header part of the dialog (bookmark btn, dir creation, path composer, search bar)\n        virtual void prDrawContent();                               // draw content part of the dialog (bookmark pane, file list, side pane)\n        virtual bool prDrawFooter();                                // draw footer part of the dialog (file field, fitler combobox, ok/cancel btn's)\n\n        // widgets components\n#if defined(USE_QUICK_PATH_SELECT)\n        virtual void DisplayPathPopup(ImVec2 vSize);                // draw path popup when click on a \\ or /\n#endif // USE_QUICK_PATH_SELECT\n        virtual bool prDrawValidationButtons();                     // draw validations btns, ok, cancel buttons\n        virtual bool prDrawOkButton();                              // draw ok button\n        virtual bool prDrawCancelButton();                          // draw cancel button\n        virtual void prDrawSidePane(float vHeight);                 // draw side pane\n        virtual void prSelectableItem(int vidx, \n            std::shared_ptr&lt;FileInfos&gt; vInfos, \n            bool vSelected, const char* vFmt, ...);                 // draw a custom selectable behavior item\n        virtual void prDrawFileListView(ImVec2 vSize);              // draw file list view (default mode)\n\n#ifdef USE_THUMBNAILS\n        virtual void prDrawThumbnailsListView(ImVec2 vSize);        // draw file list view with small thumbnails on the same line\n        virtual void prDrawThumbnailsGridView(ImVec2 vSize);        // draw a grid of small thumbnails\n#endif\n\n        // to be called only by these function and theirs overrides\n        // - prDrawFileListView\n        // - prDrawThumbnailsListView\n        // - prDrawThumbnailsGridView\n        void prBeginFileColorIconStyle(\n            std::shared_ptr&lt;FileInfos&gt; vFileInfos, \n            bool&amp; vOutShowColor, \n            std::string&amp; vOutStr, \n            ImFont** vOutFont);                                     // begin style apply of filter with color an icon if any\n        void prEndFileColorIconStyle(\n            const bool&amp; vShowColor,\n            ImFont* vFont);                                         // end style apply of filter\n    };\n}\n\ntypedef IGFD::UserDatas IGFDUserDatas;\ntypedef IGFD::PaneFun IGFDPaneFun;\ntypedef IGFD::FileDialog ImGuiFileDialog;\n#else // __cplusplus\ntypedef struct ImGuiFileDialog ImGuiFileDialog;\ntypedef struct IGFD_Selection_Pair IGFD_Selection_Pair;\ntypedef struct IGFD_Selection IGFD_Selection;\n#endif // __cplusplus\n\n// C Interface\n\n#include &lt;stdint.h&gt;\n\n#if defined _WIN32 || defined __CYGWIN__\n#ifdef IMGUIFILEDIALOG_NO_EXPORT\n#define API\n#else // IMGUIFILEDIALOG_NO_EXPORT\n#define API __declspec(dllexport)\n#endif // IMGUIFILEDIALOG_NO_EXPORT\n#else // defined _WIN32 || defined __CYGWIN__\n#ifdef __GNUC__\n#define API  __attribute__((__visibility__(\"default\")))\n#else // __GNUC__\n#define API\n#endif // __GNUC__\n#endif // defined _WIN32 || defined __CYGWIN__\n\n#ifdef __cplusplus\n#define IMGUIFILEDIALOG_API extern \"C\" API \n#else // __cplusplus\n#define IMGUIFILEDIALOG_API\n#endif // __cplusplus\n\n\nstruct IGFD_Selection_Pair\n{\n    char* fileName;\n    char* filePathName;\n};\n\nIMGUIFILEDIALOG_API IGFD_Selection_Pair IGFD_Selection_Pair_Get();                                      // return an initialized IGFD_Selection_Pair            \nIMGUIFILEDIALOG_API void IGFD_Selection_Pair_DestroyContent(IGFD_Selection_Pair* vSelection_Pair);      // destroy the content of a IGFD_Selection_Pair\n\nstruct IGFD_Selection\n{\n    IGFD_Selection_Pair* table; // 0\n    size_t count;                       // 0U\n};\n\nIMGUIFILEDIALOG_API IGFD_Selection IGFD_Selection_Get();                                            // return an initialized IGFD_Selection\nIMGUIFILEDIALOG_API void IGFD_Selection_DestroyContent(IGFD_Selection* vSelection);                 // destroy the content of a IGFD_Selection\n\n// constructor / destructor\nIMGUIFILEDIALOG_API ImGuiFileDialog* IGFD_Create(void);                                             // create the filedialog context\nIMGUIFILEDIALOG_API void IGFD_Destroy(ImGuiFileDialog* vContext);                                   // destroy the filedialog context\n\ntypedef void (*IGFD_PaneFun)(const char*, void*, bool*);                                            // callback fucntion for display the pane\n\n#ifdef USE_THUMBNAILS\ntypedef void (*IGFD_CreateThumbnailFun)(IGFD_Thumbnail_Info*);                                      // callback function for create thumbnail texture\ntypedef void (*IGFD_DestroyThumbnailFun)(IGFD_Thumbnail_Info*);                                     // callback fucntion for destroy thumbnail texture\n#endif // USE_THUMBNAILS\n\nIMGUIFILEDIALOG_API void IGFD_OpenDialog(                   // open a standard dialog\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vKey,                                       // key dialog\n    const char* vTitle,                                     // title\n    const char* vFilters,                                   // filters/filter collections. set it to null for directory mode \n    const char* vPath,                                      // path\n    const char* vFileName,                                  // defaut file name\n    const int vCountSelectionMax,                           // count selection max\n    void* vUserDatas,                                       // user datas (can be retrieved in pane)\n    ImGuiFileDialogFlags vFlags);                           // ImGuiFileDialogFlags \n\nIMGUIFILEDIALOG_API void IGFD_OpenDialog2(                  // open a standard dialog\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vKey,                                       // key dialog\n    const char* vTitle,                                     // title\n    const char* vFilters,                                   // filters/filter collections. set it to null for directory mode \n    const char* vFilePathName,                              // defaut file path name (path and filename witl be extracted from it)\n    const int vCountSelectionMax,                           // count selection max\n    void* vUserDatas,                                       // user datas (can be retrieved in pane)\n    ImGuiFileDialogFlags vFlags);                           // ImGuiFileDialogFlags \n\nIMGUIFILEDIALOG_API void IGFD_OpenPaneDialog(               // open a standard dialog with pane\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vKey,                                       // key dialog\n    const char* vTitle,                                     // title\n    const char* vFilters,                                   // filters/filter collections. set it to null for directory mode \n    const char* vPath,                                      // path\n    const char* vFileName,                                  // defaut file name\n    const IGFD_PaneFun vSidePane,                           // side pane\n    const float vSidePaneWidth,                             // side pane base width\n    const int vCountSelectionMax,                           // count selection max\n    void* vUserDatas,                                       // user datas (can be retrieved in pane)\n    ImGuiFileDialogFlags vFlags);                           // ImGuiFileDialogFlags \n\nIMGUIFILEDIALOG_API void IGFD_OpenPaneDialog2(              // open a standard dialog with pane\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vKey,                                       // key dialog\n    const char* vTitle,                                     // title\n    const char* vFilters,                                   // filters/filter collections. set it to null for directory mode \n    const char* vFilePathName,                              // defaut file name (path and filename witl be extracted from it)\n    const IGFD_PaneFun vSidePane,                           // side pane\n    const float vSidePaneWidth,                             // side pane base width\n    const int vCountSelectionMax,                           // count selection max\n    void* vUserDatas,                                       // user datas (can be retrieved in pane)\n    ImGuiFileDialogFlags vFlags);                           // ImGuiFileDialogFlags\n\nIMGUIFILEDIALOG_API bool IGFD_DisplayDialog(                // Display the dialog\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vKey,                                       // key dialog to display (if not the same key as defined by OpenDialog =&gt; no opening)\n    ImGuiWindowFlags vFlags,                                // ImGuiWindowFlags\n    ImVec2 vMinSize,                                        // mininmal size contraint for the ImGuiWindow\n    ImVec2 vMaxSize);                                       // maximal size contraint for the ImGuiWindow\n\nIMGUIFILEDIALOG_API void IGFD_CloseDialog(                  // Close the dialog\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context          \n\nIMGUIFILEDIALOG_API bool IGFD_IsOk(                         // true =&gt; Dialog Closed with Ok result / false : Dialog closed with cancel result\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context      \n\nIMGUIFILEDIALOG_API bool IGFD_WasKeyOpenedThisFrame(        // say if the dialog key was already opened this frame\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context      \n    const char* vKey);\n\nIMGUIFILEDIALOG_API bool IGFD_WasOpenedThisFrame(           // say if the dialog was already opened this frame\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context  \n\nIMGUIFILEDIALOG_API bool IGFD_IsKeyOpened(                  // say if the dialog key is opened\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context      \n    const char* vCurrentOpenedKey);                         // the dialog key\n\nIMGUIFILEDIALOG_API bool IGFD_IsOpened(                     // say if the dialog is opened somewhere    \n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context      \n\nIMGUIFILEDIALOG_API IGFD_Selection IGFD_GetSelection(       // Open File behavior : will return selection via a map&lt;FileName, FilePathName&gt;\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context      \n\nIMGUIFILEDIALOG_API char* IGFD_GetFilePathName(             // Save File behavior : will always return the content of the field with current filter extention and current path, WARNINGS you are responsible to free it\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context              \n\nIMGUIFILEDIALOG_API char* IGFD_GetCurrentFileName(          // Save File behavior : will always return the content of the field with current filter extention, WARNINGS you are responsible to free it\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context              \n\nIMGUIFILEDIALOG_API char* IGFD_GetCurrentPath(              // will return current path, WARNINGS you are responsible to free it\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context                  \n\nIMGUIFILEDIALOG_API char* IGFD_GetCurrentFilter(            // will return selected filter, WARNINGS you are responsible to free it\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context                      \n\nIMGUIFILEDIALOG_API void* IGFD_GetUserDatas(                // will return user datas send with Open Dialog\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context                                          \n\nIMGUIFILEDIALOG_API void IGFD_SetFileStyle(                 // SetExtention datas for have custom display of particular file type\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    IGFD_FileStyleFlags vFileStyleFlags,                    // file style type\n    const char* vFilter,                                    // extention filter to tune\n    ImVec4 vColor,                                          // wanted color for the display of the file with extention filter\n    const char* vIconText,                                  // wanted text or icon of the file with extention filter (can be sued with font icon)\n    ImFont* vFont);                                         // wanted font pointer\n\nIMGUIFILEDIALOG_API void IGFD_SetFileStyle2(                // SetExtention datas for have custom display of particular file type\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    IGFD_FileStyleFlags vFileStyleFlags,                    // file style type\n    const char* vFilter,                                    // extention filter to tune\n    float vR, float vG, float vB, float vA,                 // wanted color channels RGBA for the display of the file with extention filter\n    const char* vIconText,                                  // wanted text or icon of the file with extention filter (can be sued with font icon)\n    ImFont* vFont);                                         // wanted font pointer\n\nIMGUIFILEDIALOG_API bool IGFD_GetFileStyle(\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    IGFD_FileStyleFlags vFileStyleFlags,                    // file style type\n    const char* vFilter,                                    // extention filter (same as used in SetExtentionInfos)\n    ImVec4* vOutColor,                                      // color to retrieve\n    char** vOutIconText,                                    // icon or text to retrieve, WARNINGS you are responsible to free it\n    ImFont** vOutFont);                                     // font pointer to retrived\n\nIMGUIFILEDIALOG_API void IGFD_ClearFilesStyle(              // clear extentions setttings\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context\n\nIMGUIFILEDIALOG_API void SetLocales(                        // set locales to use before and after display\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    const int vCategory,                                    // set local category\n    const char* vBeginLocale,                               // locale to use at begining of the dialog display\n    const char* vEndLocale);                                // locale to set at end of the dialog display\n\n#ifdef USE_EXPLORATION_BY_KEYS\nIMGUIFILEDIALOG_API void IGFD_SetFlashingAttenuationInSeconds(  // set the flashing time of the line in file list when use exploration keys\n    ImGuiFileDialog* vContext,                                  // ImGuiFileDialog context \n    float vAttenValue);                                         // set the attenuation (from flashed to not flashed) in seconds\n#endif\n\n#ifdef USE_BOOKMARK\nIMGUIFILEDIALOG_API char* IGFD_SerializeBookmarks(          // serialize bookmarks : return bookmark buffer to save in a file, WARNINGS you are responsible to free it\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    bool vDontSerializeCodeBasedBookmarks);                 // for avoid serialization of bookmarks added by code\n\nIMGUIFILEDIALOG_API void IGFD_DeserializeBookmarks(         // deserialize bookmarks : load bookmar buffer to load in the dialog (saved from previous use with SerializeBookmarks())\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    const char* vBookmarks);                                // bookmark buffer to load \n\nIMGUIFILEDIALOG_API void IGFD_AddBookmark(                  // add a bookmark by code\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vBookMarkName,                              // bookmark name\n    const char* vBookMarkPath);                             // bookmark path\n\nIMGUIFILEDIALOG_API void IGFD_RemoveBookmark(                   // remove a bookmark by code, return true if succeed\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context\n    const char* vBookMarkName);                             // bookmark name to remove\n#endif\n\n#ifdef USE_THUMBNAILS\nIMGUIFILEDIALOG_API void SetCreateThumbnailCallback(        // define the callback for create the thumbnails texture\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    IGFD_CreateThumbnailFun vCreateThumbnailFun);           // the callback for create the thumbnails texture\n\nIMGUIFILEDIALOG_API void SetDestroyThumbnailCallback(       // define the callback for destroy the thumbnails texture\n    ImGuiFileDialog* vContext,                              // ImGuiFileDialog context \n    IGFD_DestroyThumbnailFun vDestroyThumbnailFun);         // the callback for destroy the thumbnails texture\n\nIMGUIFILEDIALOG_API void ManageGPUThumbnails(               // must be call in gpu zone, possibly a thread, will call the callback for create / destroy the textures\n    ImGuiFileDialog* vContext);                             // ImGuiFileDialog context \n#endif // USE_THUMBNAILS\n\n\n#endif // IMGUIFILEDIALOG_H\n</code></pre>"},{"location":"acdoxygen/ImGuiFileDialogConfig_8h/","title":"File ImGuiFileDialogConfig.h","text":"<p>FileList &gt; AIAC &gt; UI &gt; ImGuiFileDialogConfig.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>src/AIAC/UI/ImGuiFileDialogConfig.h</code></p>"},{"location":"acdoxygen/ImGuiFileDialogConfig_8h_source/","title":"File ImGuiFileDialogConfig.h","text":"<p>File List &gt; AIAC &gt; UI &gt; ImGuiFileDialogConfig.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// uncomment and modify defines under for customize ImGuiFileDialog\n\n//this options need c++17\n//#define USE_STD_FILESYSTEM\n\n//#define MAX_FILE_DIALOG_NAME_BUFFER 1024\n//#define MAX_PATH_BUFFER_SIZE 1024\n\n// the slash's buttons in path cna be used for quick select parallles directories\n//#define USE_QUICK_PATH_SELECT\n\n// the spacing between button path's can be customized. \n// if disabled the spacing is defined by the imgui theme\n// define the space between path buttons \n//#define CUSTOM_PATH_SPACING 2\n\n//#define USE_THUMBNAILS\n//the thumbnail generation use the stb_image and stb_resize lib who need to define the implementation\n//btw if you already use them in your app, you can have compiler error due to \"implemntation found in double\"\n//so uncomment these line for prevent the creation of implementation of these libs again\n//#define DONT_DEFINE_AGAIN__STB_IMAGE_IMPLEMENTATION\n//#define DONT_DEFINE_AGAIN__STB_IMAGE_RESIZE_IMPLEMENTATION\n//#define IMGUI_RADIO_BUTTON RadioButton\n//#define DisplayMode_ThumbailsList_ImageHeight 32.0f\n//#define tableHeaderFileThumbnailsString \"Thumbnails\"\n//#define DisplayMode_FilesList_ButtonString \"FL\"\n//#define DisplayMode_FilesList_ButtonHelp \"File List\"\n//#define DisplayMode_ThumbailsList_ButtonString \"TL\"\n//#define DisplayMode_ThumbailsList_ButtonHelp \"Thumbnails List\"\n// todo\n//#define DisplayMode_ThumbailsGrid_ButtonString \"TG\"\n//#define DisplayMode_ThumbailsGrid_ButtonHelp \"Thumbnails Grid\"\n\n//#define USE_EXPLORATION_BY_KEYS\n// this mapping by default is for GLFW but you can use another\n//#include &lt;GLFW/glfw3.h&gt; \n// Up key for explore to the top\n//#define IGFD_KEY_UP ImGuiKey_UpArrow\n// Down key for explore to the bottom\n//#define IGFD_KEY_DOWN ImGuiKey_DownArrow\n// Enter key for open directory\n//#define IGFD_KEY_ENTER ImGuiKey_Enter\n// BackSpace for comming back to the last directory\n//#define IGFD_KEY_BACKSPACE ImGuiKey_Backspace\n\n// by ex you can quit the dialog by pressing the key excape\n//#define USE_DIALOG_EXIT_WITH_KEY\n//#define IGFD_EXIT_KEY ImGuiKey_Escape\n\n// widget\n// filter combobox width\n//#define FILTER_COMBO_WIDTH 120.0f\n// button widget use for compose path\n//#define IMGUI_PATH_BUTTON ImGui::Button\n// standard button\n//#define IMGUI_BUTTON ImGui::Button\n\n// locales string\n//#define createDirButtonString \"+\"\n//#define resetButtonString \"R\"\n//#define drivesButtonString \"Drives\"\n//#define editPathButtonString \"E\"\n//#define searchString \"Search\"\n//#define dirEntryString \"[DIR] \"\n//#define linkEntryString \"[LINK] \"\n//#define fileEntryString \"[FILE] \"\n//#define fileNameString \"File Name : \"\n//#define dirNameString \"Directory Path :\"\n//#define buttonResetSearchString \"Reset search\"\n//#define buttonDriveString \"Drives\"\n//#define buttonEditPathString \"Edit path\\nYou can also right click on path buttons\"\n//#define buttonResetPathString \"Reset to current directory\"\n//#define buttonCreateDirString \"Create Directory\"\n//#define OverWriteDialogTitleString \"The file Already Exist !\"\n//#define OverWriteDialogMessageString \"Would you like to OverWrite it ?\"\n//#define OverWriteDialogConfirmButtonString \"Confirm\"\n//#define OverWriteDialogCancelButtonString \"Cancel\"\n\n//Validation buttons\n//#define okButtonString \" OK\"\n//#define okButtonWidth 0.0f\n//#define cancelButtonString \" Cancel\"\n//#define cancelButtonWidth 0.0f\n//alignement [0:1], 0.0 is left, 0.5 middle, 1.0 right, and other ratios\n//#define okCancelButtonAlignement 0.0f\n//#define invertOkAndCancelButtons 0\n\n// DateTimeFormat\n// see strftime functionin &lt;ctime&gt; for customize\n// \"%Y/%m/%d %H:%M\" give 2021:01:22 11:47\n// \"%Y/%m/%d %i:%M%p\" give 2021:01:22 11:45PM\n//#define DateTimeFormat \"%Y/%m/%d %i:%M%p\"\n\n// theses icons will appear in table headers\n//#define USE_CUSTOM_SORTING_ICON\n//#define tableHeaderAscendingIcon \"A|\"\n//#define tableHeaderDescendingIcon \"D|\"\n//#define tableHeaderFileNameString \" File name\"\n//#define tableHeaderFileTypeString \" Type\"\n//#define tableHeaderFileSizeString \" Size\"\n//#define tableHeaderFileDateTimeString \" Date\"\n//#define fileSizeBytes \"o\"\n//#define fileSizeKiloBytes \"Ko\"\n//#define fileSizeMegaBytes \"Mo\"\n//#define fileSizeGigaBytes \"Go\"\n\n// default table sort field (must be FIELD_FILENAME, FIELD_TYPE, FIELD_SIZE, FIELD_DATE or FIELD_THUMBNAILS)\n//#define defaultSortField FIELD_FILENAME\n\n// default table sort order for each field (true =&gt; Descending, false =&gt; Ascending)\n//#define defaultSortOrderFilename true\n//#define defaultSortOrderType true\n//#define defaultSortOrderSize true\n//#define defaultSortOrderDate true\n//#define defaultSortOrderThumbnails true\n\n//#define USE_BOOKMARK\n//#define bookmarkPaneWith 150.0f\n//#define IMGUI_TOGGLE_BUTTON ToggleButton\n//#define bookmarksButtonString \"Bookmark\"\n//#define bookmarksButtonHelpString \"Bookmark\"\n//#define addBookmarkButtonString \"+\"\n//#define removeBookmarkButtonString \"-\"\n</code></pre>"},{"location":"acdoxygen/dir_313caf1132e152dd9b58bea13a4052ca/","title":"Dir src/utils","text":"<p>FileList &gt; src &gt; utils</p>"},{"location":"acdoxygen/dir_313caf1132e152dd9b58bea13a4052ca/#files","title":"Files","text":"Type Name file CircularBuffer.h file GeometryUtils.h file HoleToolheadAxisExporter.cpp file HoleToolheadAxisExporter.h file Ini.h file MatrixUtils.h file Screenshot.cpp file Screenshot.h file SystemUtils.h file VideoRecorder.cpp file VideoRecorder.h file glob.cpp file glob.h file utils.h <p>The documentation for this class was generated from the following file <code>src/utils/</code></p>"},{"location":"acdoxygen/CircularBuffer_8h/","title":"File CircularBuffer.h","text":"<p>FileList &gt; src &gt; utils &gt; CircularBuffer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"acdoxygen/CircularBuffer_8h/#classes","title":"Classes","text":"Type Name class CircularBuffer &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/utils/CircularBuffer.h</code></p>"},{"location":"acdoxygen/CircularBuffer_8h_source/","title":"File CircularBuffer.h","text":"<p>File List &gt; src &gt; utils &gt; CircularBuffer.h</p> <p>Go to the documentation of this file</p> <pre><code>//https://github.com/vinitjames\n\n#ifndef CIRCULAR_BUFFER_H\n#define CIRCULAR_BUFFER_H\n\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;mutex&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;utility&gt;\n\n\ntemplate&lt;typename T&gt;\nclass CircularBuffer {\nprivate:\n\n    typedef T* pointer;\n    typedef const T* const_pointer;\n    typedef T&amp; reference;\n    typedef const T&amp; const_reference;\n    typedef size_t size_type;\n    typedef ptrdiff_t difference_type;\n    template &lt;bool isConst&gt; struct BufferIterator;\n\n\npublic:\n    typedef T value_type;\n\n    explicit CircularBuffer(size_t size)\n        :_buff{std::unique_ptr&lt;T[]&gt;(new value_type[size])}, _max_size{size}{}\n\n    CircularBuffer(const CircularBuffer&amp; other)\n        :_buff{std::unique_ptr&lt;T[]&gt;(new value_type[other._max_size])},\n         _max_size{other._max_size},\n         _size{other._size},\n         _head{other._head},\n         _tail{other._tail}{\n             std::copy(other.data(), other.data() + _max_size, _buff.get());\n         }\n\n\n    CircularBuffer&amp; operator=(const CircularBuffer&amp; other){\n        if ( this != &amp;other){\n            _buff.reset(new value_type[other._max_size]);\n            _max_size = other._max_size;\n            _size = other._size;\n            _head = other._head;\n            _tail = other._tail;\n            std::copy(other.data(), other.data() + _max_size, _buff.get());\n        }\n        return *this;\n    }\n\n    CircularBuffer(CircularBuffer&amp;&amp; other) noexcept\n        :_buff{std::move(other._buff)},\n         _max_size{other._max_size},\n         _size{other._size},\n         _head{other._head},\n         _tail{other._tail}{\n\n        other._buff = nullptr;\n        other._max_size = 0;\n        other._size = 0;\n        other._head = 0;\n        other._tail = 0;\n    }\n\n\n    CircularBuffer&amp; operator=(CircularBuffer&amp;&amp; other) noexcept{\n        if ( this != &amp;other){\n            _buff = std::move(other._buff);\n            _max_size = other._max_size;\n            _size = other._size;\n            _head = other._head;\n            _tail = other._tail;\n\n            other._buff = nullptr;\n            other._max_size = 0;\n            other._size = 0;\n            other._head = 0;\n            other._tail = 0;            \n        }\n        return *this;\n    }\n\n    void push_back(const value_type&amp; data);\n    void push_back(value_type&amp;&amp; data) noexcept;\n    void pop_front();\n    reference front();\n    reference back(); \n    const_reference front() const; \n    const_reference back() const;\n    void clear();\n    bool empty() const ;\n    bool full() const ;\n    size_type capacity() const ;\n    size_type size() const;\n    size_type buffer_size() const {return sizeof(value_type)*_max_size;};\n    const_pointer data() const { return _buff.get(); }\n\n    const_reference operator[](size_type index) const;\n    reference operator[](size_type index);\n    const_reference at(size_type index) const;\n    reference at(size_type index);\n\n    typedef BufferIterator&lt;false&gt; iterator;\n    typedef BufferIterator&lt;true&gt; const_iterator;\n\n    iterator begin();\n    const_iterator begin() const;\n    iterator end();\n    const_iterator end() const;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    iterator rbegin() noexcept;\n    const_iterator rbegin() const noexcept;\n    iterator rend() noexcept;\n    const_iterator rend() const noexcept;\n\n\nprivate:\n    void _increment_bufferstate();\n    void _decrement_bufferstate();\n    mutable std::mutex _mtx;\n    std::unique_ptr&lt;value_type[]&gt; _buff;\n    size_type _head = 0;\n    size_type _tail = 0;\n    size_type _size = 0;\n    size_type _max_size = 0;\n\n    template&lt;bool isConst = false&gt;\n    struct  BufferIterator{\n    public:\n        friend class CircularBuffer&lt;T&gt;;\n        typedef std::random_access_iterator_tag iterator_category;\n        typedef ptrdiff_t difference_type;\n        typedef T value_type;\n        typedef typename std::conditional&lt;isConst, const value_type&amp;, value_type&amp;&gt;::type reference;\n        typedef typename std::conditional&lt;isConst, const value_type*, value_type*&gt;::type pointer;\n        typedef typename std::conditional&lt;isConst, const CircularBuffer&lt;value_type&gt;*,\n                                          CircularBuffer&lt;value_type&gt;*&gt;::type cbuf_pointer;\n    private:\n        cbuf_pointer _ptrToBuffer;\n        size_type _offset;\n        size_type _index;\n        bool _reverse;\n\n        bool _comparable(const BufferIterator&lt;isConst&gt;&amp; other) const{\n            return (_ptrToBuffer == other._ptrToBuffer)&amp;&amp;(_reverse == other._reverse);\n        }\n\n    public:\n        BufferIterator()\n            :_ptrToBuffer{nullptr}, _offset{0}, _index{0}, _reverse{false}{}\n\n        BufferIterator(const BufferIterator&lt;false&gt;&amp; it)\n            :_ptrToBuffer{it._ptrToBuffer},\n             _offset{it._offset},\n             _index{it._index},\n             _reverse{it._reverse}{}\n\n        reference operator*(){\n            if(_reverse)\n                return (*_ptrToBuffer)[(_ptrToBuffer-&gt;size() - _index - 1)];\n            return (*_ptrToBuffer)[_index];\n        }\n\n        pointer  operator-&gt;() { return &amp;(operator*()); }\n\n        reference operator[](size_type index){\n            BufferIterator iter = *this;\n            iter._index += index;\n            return *iter;\n        }\n\n        BufferIterator&amp; operator++(){\n            ++_index;\n            return *this;\n        }\n\n        BufferIterator operator++(int){\n            BufferIterator iter = *this;\n            ++_index;\n            return iter;\n        }\n\n        BufferIterator&amp; operator--(){\n            --_index;\n            return *this;\n        }\n\n        BufferIterator operator--(int){\n            BufferIterator iter = *this;\n            --_index;\n            return iter;\n        }   \n\n        friend BufferIterator operator+(BufferIterator lhsiter, difference_type n){\n            lhsiter._index += n;\n            return lhsiter;\n        }\n\n        friend BufferIterator operator+(difference_type n, BufferIterator rhsiter){\n            rhsiter._index += n;\n            return rhsiter;\n        }\n\n\n        BufferIterator&amp; operator+=(difference_type n){\n            _index += n;\n            return *this;\n        }\n\n        friend BufferIterator operator-(BufferIterator lhsiter, difference_type n){\n            lhsiter._index -= n;\n            return lhsiter;\n        }\n\n        friend difference_type operator-(const BufferIterator&amp; lhsiter, const BufferIterator&amp; rhsiter){\n\n            return lhsiter._index - rhsiter._index;\n        }\n\n        BufferIterator&amp; operator-=(difference_type n){\n            _index -= n;\n            return *this;\n        }\n\n        bool operator==(const BufferIterator&amp; other) const{\n            if (!_comparable(other))\n                return false;\n            return ((_index == other._index)&amp;&amp;(_offset == other._offset));\n        }\n\n        bool operator!=(const BufferIterator&amp; other) const{\n            if (!_comparable(other))\n                return true;\n            return ((_index != other._index)||(_offset != other._offset));\n        }\n\n        bool operator&lt;(const BufferIterator&amp; other) const {\n            if (!_comparable(other))\n                return false;\n            return ((_index + _offset)&lt;(other._index+other._offset));\n        }\n\n        bool operator&gt;(const BufferIterator&amp; other) const{\n            if (!_comparable(other))\n                return false;\n            return ((_index + _offset)&gt;(other._index+other._offset));\n        }\n\n        bool operator&lt;=(const BufferIterator&amp; other) const {\n            if (!_comparable(other))\n                return false;\n            return ((_index + _offset)&lt;=(other._index+other._offset));\n        }\n\n        bool operator&gt;=(const BufferIterator&amp; other) const {\n            if (!_comparable(other))\n                return false;\n            return ((_index + _offset)&gt;=(other._index+other._offset));\n        }\n    };\n};\n\ntemplate&lt;typename T&gt;\ninline \nbool CircularBuffer&lt;T&gt;::full() const{\n    return _size == _max_size;\n}\n\ntemplate&lt;typename T&gt;\ninline \nbool CircularBuffer&lt;T&gt;::empty() const{\n    return _size == 0;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::size_type CircularBuffer&lt;T&gt;::capacity() const{\n    return _max_size;\n}\n\ntemplate&lt;typename T&gt;\ninline \nvoid  CircularBuffer&lt;T&gt;::clear(){\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    _head = _tail = _size = 0;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::size_type CircularBuffer&lt;T&gt;::size() const{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    return _size;\n    }\n\ntemplate&lt;typename T&gt;\ninline\ntypename CircularBuffer&lt;T&gt;::reference CircularBuffer&lt;T&gt;::front() {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if(empty())\n        throw std::length_error(\"front function called on empty buffer\");\n    return _buff[_tail];\n}\n\ntemplate&lt;typename T&gt;\ninline\ntypename CircularBuffer&lt;T&gt;::reference CircularBuffer&lt;T&gt;::back() {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if(empty())\n        throw std::length_error(\"back function called on empty buffer\");\n    return _head == 0 ? _buff[_max_size - 1] : _buff[_head - 1];\n}\n\ntemplate&lt;typename T&gt;\ninline\ntypename CircularBuffer&lt;T&gt;::const_reference CircularBuffer&lt;T&gt;::front() const{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if(empty())\n        throw std::length_error(\"front function called on empty buffer\");\n    return _buff[_tail];\n}\n\ntemplate&lt;typename T&gt;\ninline\ntypename CircularBuffer&lt;T&gt;::const_reference CircularBuffer&lt;T&gt;::back() const{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if(empty())\n        throw std::length_error(\"back function called on empty buffer\");\n    return _head == 0 ? _buff[_max_size - 1] : _buff[_head - 1];\n}\n\ntemplate&lt;typename T&gt;\ninline\nvoid CircularBuffer&lt;T&gt;::push_back(const T&amp; data){\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    //if(full())\n    //  _buff[_tail].~T();\n    _buff[_head] = data;\n    _increment_bufferstate();\n}\n\ntemplate&lt;typename T&gt;\ninline\nvoid CircularBuffer&lt;T&gt;::push_back(T&amp;&amp; data) noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    _buff[_head] = std::move(data);\n    _increment_bufferstate();\n}\n\n\ntemplate&lt;typename T&gt;\ninline \nvoid CircularBuffer&lt;T&gt;::_increment_bufferstate(){\n    if(full())\n        _tail = (_tail + 1)%_max_size;\n    else\n        ++_size;\n    _head = (_head + 1)%_max_size;  \n}\n\ntemplate&lt;typename T&gt;\ninline \nvoid CircularBuffer&lt;T&gt;::pop_front(){\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if(empty())\n        throw std::length_error(\"pop_front called on empty buffer\");\n    _decrement_bufferstate();\n}\n\ntemplate&lt;typename T&gt;\ninline \nvoid CircularBuffer&lt;T&gt;::_decrement_bufferstate(){\n    --_size;\n    _tail = (_tail + 1)%_max_size;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::reference CircularBuffer&lt;T&gt;::operator[](size_t index) {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if((index&lt;0)||(index&gt;=_size))\n        throw std::out_of_range(\"Index is out of Range of buffer size\");\n    index += _tail;\n    index %= _max_size;\n    return _buff[index];\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_reference CircularBuffer&lt;T&gt;::operator[](size_t index) const {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if((index&lt;0)||(index&gt;=_size))\n        throw std::out_of_range(\"Index is out of Range of buffer size\");\n    index += _tail;\n    index %= _max_size;\n    return _buff[index];\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::reference CircularBuffer&lt;T&gt;::at(size_t index) {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if((index&lt;0)||(index&gt;=_size))\n        throw std::out_of_range(\"Index is out of Range of buffer size\");\n    index += _tail;\n    index %= _max_size;\n    return _buff[index];\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_reference CircularBuffer&lt;T&gt;::at(size_t index) const {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    if((index&lt;0)||(index&gt;=_size))\n        throw std::out_of_range(\"Index is out of Range of buffer size\");\n    index += _tail;\n    index %= _max_size;\n    return _buff[index];\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::iterator CircularBuffer&lt;T&gt;::begin() {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = 0;\n    iter._reverse = false;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_iterator CircularBuffer&lt;T&gt;::begin() const{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    const_iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = 0;\n    iter._reverse = false;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::iterator CircularBuffer&lt;T&gt;::end() {\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = _size;\n    iter._reverse = false;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_iterator CircularBuffer&lt;T&gt;::end() const{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    const_iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = _size;\n    iter._reverse = false;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_iterator CircularBuffer&lt;T&gt;::cbegin() const noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    const_iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = 0;\n    iter._reverse = false;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_iterator CircularBuffer&lt;T&gt;::cend() const noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    const_iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = _size;\n    iter._reverse = false;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::iterator CircularBuffer&lt;T&gt;::rbegin() noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = 0;\n    iter._reverse = true;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_iterator CircularBuffer&lt;T&gt;::rbegin() const noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    const_iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = 0;\n    iter._reverse = true;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::iterator CircularBuffer&lt;T&gt;::rend()  noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = _size;\n    iter._reverse = true;\n    return iter;\n}\n\ntemplate&lt;typename T&gt;\ninline \ntypename CircularBuffer&lt;T&gt;::const_iterator CircularBuffer&lt;T&gt;::rend() const noexcept{\n    std::lock_guard&lt;std::mutex&gt; _lck(_mtx);\n    const_iterator iter;\n    iter._ptrToBuffer = this;\n    iter._offset = _tail;\n    iter._index = _size;\n    iter._reverse = true;\n    return iter;\n}\n\n#endif /* CIRCULAR_BUFFER_H */\n</code></pre>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/","title":"File GeometryUtils.h","text":"<p>FileList &gt; src &gt; utils &gt; GeometryUtils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"glm/glm.hpp\"</code></li> </ul>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#public-functions","title":"Public Functions","text":"Type Name void ExtendLineSeg (glm::vec3 &amp; pt1, glm::vec3 &amp; pt2, float extendLen) Make a line segment longer by a certain length. bool FormLongestLineSeg (const std::vector&lt; glm::vec3 &gt; &amp; pts, glm::vec3 &amp; pt1, glm::vec3 &amp; pt2) From a list of points, find 2 point that forms the longest line segment. float GetAngleBetweenVectors (glm::vec3 v1, glm::vec3 v2, bool useDegree=false) Get the angle between 2 vectors. bool GetIntersectLineOf2Planes (glm::vec3 p1Norm, glm::vec3 pt1, glm::vec3 p2Norm, glm::vec3 pt2, glm::vec3 &amp; lineVec, glm::vec3 &amp; linePt) Get the Intersect Line Of 2 Planes. bool GetIntersectPointOf2Lines (glm::vec3 dir1, glm::vec3 pt1, glm::vec3 dir2, glm::vec3 pt2, glm::vec3 &amp; pt) Get the Intersect Point Of 2 Lines. bool GetIntersectPointOfLineAndLineSeg (glm::vec3 lineVec, glm::vec3 linePt, glm::vec3 lineSegPt1, glm::vec3 lineSegPt2, glm::vec3 &amp; ptInLineSeg) Get the Intersect Point Of Line And Line Seg object. bool GetIntersectPointOfLineAndPlane (glm::vec3 lineVec, glm::vec3 linePt, glm::vec3 planeNormal, glm::vec3 planePt, glm::vec3 &amp; intersectPt) Get the Intersect Point Of Line And Plane object. bool GetIntersectPointOfLineSegAndPlane (glm::vec3 lineSegPt1, glm::vec3 lineSegPt2, glm::vec3 planeNormal, glm::vec3 planePt, glm::vec3 &amp; intersectPt) Get the Intersect Point Of Line Seg And Plane object. glm::vec3 GetNearestPtOnLine (glm::vec3 lineVec, glm::vec3 linePt, glm::vec3 pt) Get the Nearest Pt On Line object. glm::vec3 GetProjectionPointOnPlane (glm::vec3 planeNormal, glm::vec3 planePt, glm::vec3 pt) Get the projection point of a point on a plane. bool IsPointBetweenLineSeg (glm::vec3 pt, glm::vec3 lineSegPt1, glm::vec3 lineSegPt2) Check if a point is between a line segment, no matter if the point is on the line segment or not. bool IsSameDirection (glm::vec3 v1, glm::vec3 v2) Check if 2 vectors are in the same direction (angle &lt; 180 degree)"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-extendlineseg","title":"function ExtendLineSeg","text":"<p>Make a line segment longer by a certain length. <pre><code>inline void ExtendLineSeg (\n    glm::vec3 &amp; pt1,\n    glm::vec3 &amp; pt2,\n    float extendLen\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pt1</code> Start of the line segment </li> <li><code>pt2</code> End of the line segment </li> <li><code>extendLen</code> Length to extend </li> </ul>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-formlongestlineseg","title":"function FormLongestLineSeg","text":"<p>From a list of points, find 2 point that forms the longest line segment. <pre><code>inline bool FormLongestLineSeg (\n    const std::vector&lt; glm::vec3 &gt; &amp; pts,\n    glm::vec3 &amp; pt1,\n    glm::vec3 &amp; pt2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pts</code> Candidate points </li> <li><code>pt1</code> Start of the line segment </li> <li><code>pt2</code> End of the line segment </li> </ul> <p>Returns:</p> <p>true if the line segment is formed successfully </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getanglebetweenvectors","title":"function GetAngleBetweenVectors","text":"<p>Get the angle between 2 vectors. <pre><code>inline float GetAngleBetweenVectors (\n    glm::vec3 v1,\n    glm::vec3 v2,\n    bool useDegree=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v1</code> </li> <li><code>v2</code> </li> </ul> <p>Returns:</p> <p>float </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getintersectlineof2planes","title":"function GetIntersectLineOf2Planes","text":"<p>Get the Intersect Line Of 2 Planes. <pre><code>inline bool GetIntersectLineOf2Planes (\n    glm::vec3 p1Norm,\n    glm::vec3 pt1,\n    glm::vec3 p2Norm,\n    glm::vec3 pt2,\n    glm::vec3 &amp; lineVec,\n    glm::vec3 &amp; linePt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p1Norm</code> </li> <li><code>pt1</code> </li> <li><code>p2Norm</code> </li> <li><code>pt2</code> </li> <li><code>lineVec</code> </li> <li><code>linePt</code> </li> </ul> <p>Returns:</p> <p>true if intersect, false if not </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getintersectpointof2lines","title":"function GetIntersectPointOf2Lines","text":"<p>Get the Intersect Point Of 2 Lines. <pre><code>inline bool GetIntersectPointOf2Lines (\n    glm::vec3 dir1,\n    glm::vec3 pt1,\n    glm::vec3 dir2,\n    glm::vec3 pt2,\n    glm::vec3 &amp; pt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dir1</code> </li> <li><code>pt1</code> </li> <li><code>dir2</code> </li> <li><code>pt2</code> </li> <li><code>pt</code> </li> </ul> <p>Returns:</p> <p>true if intersect, false if not </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getintersectpointoflineandlineseg","title":"function GetIntersectPointOfLineAndLineSeg","text":"<p>Get the Intersect Point Of Line And Line Seg object. <pre><code>inline bool GetIntersectPointOfLineAndLineSeg (\n    glm::vec3 lineVec,\n    glm::vec3 linePt,\n    glm::vec3 lineSegPt1,\n    glm::vec3 lineSegPt2,\n    glm::vec3 &amp; ptInLineSeg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lineVec</code> </li> <li><code>linePt</code> </li> <li><code>lineSegPt1</code> </li> <li><code>lineSegPt2</code> </li> <li><code>ptInLineSeg</code> </li> </ul> <p>Returns:</p> <p>true if intersect, false if not </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getintersectpointoflineandplane","title":"function GetIntersectPointOfLineAndPlane","text":"<p>Get the Intersect Point Of Line And Plane object. <pre><code>inline bool GetIntersectPointOfLineAndPlane (\n    glm::vec3 lineVec,\n    glm::vec3 linePt,\n    glm::vec3 planeNormal,\n    glm::vec3 planePt,\n    glm::vec3 &amp; intersectPt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lineVec</code> </li> <li><code>linePt</code> </li> <li><code>planeNormal</code> </li> <li><code>planePt</code> </li> <li><code>intersectPt</code> </li> </ul> <p>Returns:</p> <p>true if intersect, false if not </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getintersectpointoflinesegandplane","title":"function GetIntersectPointOfLineSegAndPlane","text":"<p>Get the Intersect Point Of Line Seg And Plane object. <pre><code>inline bool GetIntersectPointOfLineSegAndPlane (\n    glm::vec3 lineSegPt1,\n    glm::vec3 lineSegPt2,\n    glm::vec3 planeNormal,\n    glm::vec3 planePt,\n    glm::vec3 &amp; intersectPt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lineSegPt1</code> </li> <li><code>lineSegPt2</code> </li> <li><code>planeNormal</code> </li> <li><code>planePt</code> </li> <li><code>intersectPt</code> </li> </ul> <p>Returns:</p> <p>true </p> <p>Returns:</p> <p>false </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getnearestptonline","title":"function GetNearestPtOnLine","text":"<p>Get the Nearest Pt On Line object. <pre><code>inline glm::vec3 GetNearestPtOnLine (\n    glm::vec3 lineVec,\n    glm::vec3 linePt,\n    glm::vec3 pt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lineVec</code> </li> <li><code>linePt</code> </li> <li><code>pt</code> </li> </ul> <p>Returns:</p> <p>glm::vec3 </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-getprojectionpointonplane","title":"function GetProjectionPointOnPlane","text":"<p>Get the projection point of a point on a plane. <pre><code>inline glm::vec3 GetProjectionPointOnPlane (\n    glm::vec3 planeNormal,\n    glm::vec3 planePt,\n    glm::vec3 pt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>planeNormal</code> Normal of the plane </li> <li><code>planePt</code> A point on the plane </li> <li><code>point</code> The point to project </li> </ul> <p>Returns:</p> <p>glm::vec3 The projection point </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-ispointbetweenlineseg","title":"function IsPointBetweenLineSeg","text":"<p>Check if a point is between a line segment, no matter if the point is on the line segment or not. <pre><code>inline bool IsPointBetweenLineSeg (\n    glm::vec3 pt,\n    glm::vec3 lineSegPt1,\n    glm::vec3 lineSegPt2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pt</code> Point to check </li> <li><code>lineSegPt1</code> Start of the line segment </li> <li><code>lineSegPt2</code> End of the line segment </li> </ul> <p>Returns:</p> <p>true if the point is between the line segment </p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h/#function-issamedirection","title":"function IsSameDirection","text":"<p>Check if 2 vectors are in the same direction (angle &lt; 180 degree) <pre><code>inline bool IsSameDirection (\n    glm::vec3 v1,\n    glm::vec3 v2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v1</code> </li> <li><code>v2</code> </li> </ul> <p>Returns:</p> <p>true if in the same direction </p> <p>The documentation for this class was generated from the following file <code>src/utils/GeometryUtils.h</code></p>"},{"location":"acdoxygen/utils_2GeometryUtils_8h_source/","title":"File GeometryUtils.h","text":"<p>File List &gt; src &gt; utils &gt; GeometryUtils.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n// #ifndef GEOMETRY_UTILS_H\n// #define GEOMETRY_UTILS_H\n\n#include \"glm/glm.hpp\"\n\n// --------------------------- //\n// Function related to vectors //\n// --------------------------- //\n\ninline float GetAngleBetweenVectors(glm::vec3 v1, glm::vec3 v2, bool useDegree = false){\n    v1 = glm::normalize(v1);\n    v2 = glm::normalize(v2);\n    auto rad = glm::acos(glm::dot(v1, v2));\n    if(useDegree){\n        return glm::degrees(rad);\n    }\n    return rad;\n}\n\ninline bool IsSameDirection(glm::vec3 v1, glm::vec3 v2){\n    v1 = glm::normalize(v1);\n    v2 = glm::normalize(v2);\n    return glm::dot(v1, v2) &gt; 0;\n}\n\n// --------------------------------- //\n// Function related to point &amp; plane //\n// --------------------------------- //\n\ninline glm::vec3 GetProjectionPointOnPlane(glm::vec3 planeNormal, glm::vec3 planePt, glm::vec3 pt)\n{\n    planeNormal = glm::normalize(planeNormal);\n    glm::vec3 v = pt - planePt;\n    float d = glm::dot(planeNormal, v);\n    return pt - d * planeNormal;\n}\n\n// FIXME: This one may have a bug\ninline glm::vec3 GetNearestPtOnLine(glm::vec3 lineVec, glm::vec3 linePt, glm::vec3 pt)\n{\n    auto dir = glm::normalize(lineVec);\n    auto pt2LinePt = pt - linePt;\n    auto projLen = glm::dot(pt2LinePt, dir);\n    return linePt + projLen * dir;\n}\n\n// ---------------------------- //\n// Function related to line seg //\n// ---------------------------- //\n\ninline bool IsPointBetweenLineSeg(glm::vec3 pt, glm::vec3 lineSegPt1, glm::vec3 lineSegPt2)\n{\n    auto dir1 = glm::normalize(pt - lineSegPt1);\n    auto dir2 = glm::normalize(pt - lineSegPt2);\n    auto dir3 = glm::normalize(lineSegPt2 - lineSegPt1);\n    return glm::dot(dir1, dir3) &gt; 0 &amp;&amp; glm::dot(dir2, dir3) &lt; 0;\n}\n\ninline void ExtendLineSeg(glm::vec3 &amp;pt1, glm::vec3 &amp;pt2, float extendLen)\n{\n    auto dir = glm::normalize(pt2 - pt1);\n    pt1 -= dir * extendLen;\n    pt2 += dir * extendLen;\n}\n\ninline bool FormLongestLineSeg(const std::vector&lt;glm::vec3&gt; &amp;pts, glm::vec3 &amp;pt1, glm::vec3 &amp;pt2)\n{\n    if(pts.size() &lt; 2){\n        return false;\n    }\n\n    // initial line seg\n    pt1 = pts[0];\n    pt2 = pts[1];\n    if(pts.size() == 2){\n        return true;\n    }\n    auto maxDist = glm::distance(pt1, pt2);\n\n    // try all point and see if we can make it longer\n    for(int i = 2; i &lt; pts.size(); i++){\n        auto pt = pts[i];\n        auto dist1 = glm::distance(pt, pt1);\n        auto dist2 = glm::distance(pt, pt2);\n        if(dist1 &gt; maxDist){\n            maxDist = dist1;\n            pt2 = pt;\n        }\n        if(dist2 &gt; maxDist){\n            maxDist = dist2;\n            pt1 = pt;\n        }\n    }\n    return true;\n}\n\n// ------------------------------ //\n// Different intersection methods //\n// ------------------------------ //\n\ninline bool GetIntersectPointOfLineAndPlane(glm::vec3 lineVec, glm::vec3 linePt, glm::vec3 planeNormal, glm::vec3 planePt, glm::vec3 &amp;intersectPt)\n{\n    lineVec = glm::normalize(lineVec);\n    planeNormal = glm::normalize(planeNormal);\n\n    if(glm::dot(lineVec, planeNormal) == 0) return false;\n\n    auto d = glm::dot(planeNormal, planePt - linePt);\n    auto t = d / glm::dot(planeNormal, lineVec);\n    intersectPt = linePt + t * lineVec;\n    return true;\n}\n\ninline bool GetIntersectPointOfLineSegAndPlane(glm::vec3 lineSegPt1, glm::vec3 lineSegPt2, glm::vec3 planeNormal, glm::vec3 planePt, glm::vec3 &amp;intersectPt)\n{\n    auto lineVec = lineSegPt2 - lineSegPt1;\n    if(GetIntersectPointOfLineAndPlane(lineVec, lineSegPt1, planeNormal, planePt, intersectPt)){\n        if(IsPointBetweenLineSeg(intersectPt, lineSegPt1, lineSegPt2)){\n            return true;\n        }\n    }\n    return false;\n}\n\ninline bool GetIntersectPointOf2Lines(glm::vec3 dir1, glm::vec3 pt1, glm::vec3 dir2, glm::vec3 pt2, glm::vec3 &amp;pt)\n{\n    dir1 = glm::normalize(dir1);\n    dir2 = glm::normalize(dir2);\n    auto dir3 = glm::cross(dir1, dir2);\n    auto dir3Len = glm::length(dir3);\n    if (dir3Len &lt; 1e-4f)\n    {\n        return false;\n    }\n    auto dir3Norm = dir3 / dir3Len;\n    auto dir1Len = glm::length(dir1);\n    auto dir2Len = glm::length(dir2);\n    auto dir1Norm = dir1 / dir1Len;\n    auto dir2Norm = dir2 / dir2Len;\n    auto det = glm::dot(dir3Norm, glm::cross(dir1Norm, dir2Norm));\n    if (det &lt; 1e-4f)\n    {\n        return false;\n    }\n    auto t1 = glm::dot(dir3Norm, glm::cross(pt2 - pt1, dir2Norm)) / det;\n    auto t2 = glm::dot(dir3Norm, glm::cross(pt2 - pt1, dir1Norm)) / det;\n    pt = pt1 + t1 * dir1;\n    return true;\n}\n\ninline bool GetIntersectPointOfLineAndLineSeg(glm::vec3 lineVec, glm::vec3 linePt,\n                                              glm::vec3 lineSegPt1, glm::vec3 lineSegPt2,\n                                              glm::vec3&amp; ptInLineSeg)\n{\n    lineVec = glm::normalize(lineVec);\n    glm::vec3 intersectPt;\n    auto lineSegVec = glm::normalize(lineSegPt2 - lineSegPt1);\n    if(GetIntersectPointOf2Lines(lineVec, linePt, lineSegVec, lineSegPt1, intersectPt)){\n        if(IsPointBetweenLineSeg(intersectPt, lineSegPt1, lineSegPt2)){\n            ptInLineSeg = intersectPt;\n            return true;\n        }\n    }\n    return false;\n}\n\ninline bool GetIntersectLineOf2Planes(glm::vec3 p1Norm, glm::vec3 pt1,\n                                      glm::vec3 p2Norm, glm::vec3 pt2,\n                                      glm::vec3 &amp;lineVec, glm::vec3 &amp;linePt){\n    // https://math.stackexchange.com/questions/475953/how-to-calculate-the-intersection-of-two-planes\n    p1Norm = glm::normalize(p1Norm);\n    p2Norm = glm::normalize(p2Norm);\n\n    lineVec = glm::normalize(glm::cross(p1Norm, p2Norm));\n    auto line1Dir = glm::cross(p1Norm, lineVec);\n    auto line2Dir = glm::cross(p2Norm, lineVec);\n    if(GetIntersectPointOf2Lines(line1Dir, pt1, line2Dir, pt2, linePt)){\n        return true;\n    }\n    return false;\n}\n\n// #endif //GEOMETRY_UTILS_H\n</code></pre>"},{"location":"acdoxygen/HoleToolheadAxisExporter_8cpp/","title":"File HoleToolheadAxisExporter.cpp","text":"<p>FileList &gt; src &gt; utils &gt; HoleToolheadAxisExporter.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"HoleToolheadAxisExporter.h\"</code></li> <li><code>#include \"AIAC/ACInfoModel.h\"</code></li> <li><code>#include \"AIAC/Application.h\"</code></li> <li><code>#include \"utils/VideoRecorder.h\"</code></li> <li><code>#include \"AIAC/LayerUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/HoleToolheadAxisExporter_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC namespace Utils <p>The documentation for this class was generated from the following file <code>src/utils/HoleToolheadAxisExporter.cpp</code></p>"},{"location":"acdoxygen/HoleToolheadAxisExporter_8cpp_source/","title":"File HoleToolheadAxisExporter.cpp","text":"<p>File List &gt; src &gt; utils &gt; HoleToolheadAxisExporter.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"HoleToolheadAxisExporter.h\"\n#include \"AIAC/ACInfoModel.h\"\n#include \"AIAC/Application.h\"\n#include \"utils/VideoRecorder.h\"\n#include \"AIAC/LayerUtils.h\"\n\nnamespace AIAC::Utils {\n\n    HoleToolheadAxisExporter::HoleToolheadAxisExporter(const std::string&amp; basePath)\n    : m_BasePath(basePath)\n    {\n        LayerUtils::CreateFolder(this-&gt;m_BasePath);\n    };\n\n    void HoleToolheadAxisExporter::ExportCoordinates(){\n        this-&gt;ExportToolheadAxis();\n        this-&gt;ExportHoleAxis();\n        this-&gt;WriteBufferToFile();\n    }\n\n    void HoleToolheadAxisExporter::ExportToolheadAxis(){\n        ACToolHeadType activeToolheadType = AC_FF_TOOL-&gt;GetType();\n        if (activeToolheadType == ACToolHeadType::DRILLBIT){\n            auto drillBitData = AC_FF_TOOL-&gt;GetData&lt;DrillBitData&gt;();\n            this-&gt;WriteCoordToBuffer(\"Toolhead\", AC_FF_TOOL-&gt;GetName(), \"ToolbaseGO\", drillBitData.ToolbaseGO);\n            this-&gt;WriteCoordToBuffer(\"Toolhead\", AC_FF_TOOL-&gt;GetName(), \"TooltipGO\", drillBitData.TooltipGO);\n        }\n        if (activeToolheadType == ACToolHeadType::CHAINSAW){\n            auto chainSawData = AC_FF_TOOL-&gt;GetData&lt;ChainSawData&gt;();\n            this-&gt;WriteCoordToBuffer(\"Toolhead\", AC_FF_TOOL-&gt;GetName(), \"NormStartGO\", chainSawData.NormStartGO);\n            this-&gt;WriteCoordToBuffer(\"Toolhead\", AC_FF_TOOL-&gt;GetName(), \"NormEndGO\", chainSawData.NormEndGO);\n        }\n        if (activeToolheadType == ACToolHeadType::CIRCULARSAW){\n            auto circularSawData = AC_FF_TOOL-&gt;GetData&lt;CircularSawData&gt;();\n            this-&gt;WriteCoordToBuffer(\"Toolhead\", AC_FF_TOOL-&gt;GetName(), \"CenterGO\", circularSawData.CenterGO);\n            this-&gt;WriteCoordToBuffer(\"Toolhead\", AC_FF_TOOL-&gt;GetName(), \"NormEndGO\", circularSawData.NormEndGO);\n        }\n    }\n\n    void HoleToolheadAxisExporter::ExportHoleAxis(){\n        std::string activeHoleType = AC_FF_COMP-&gt;GetTypeString();\n        if (activeHoleType == \"HOLE\"){\n            TimberInfo::Hole* hole = dynamic_cast&lt;TimberInfo::Hole*&gt;(AC_FF_COMP);\n            if (hole) {\n                std::string currentComponentID = AIAC_APP.GetLayer&lt;LayerModel&gt;()-&gt;GetACInfoModel().GetTimberInfo().GetCurrentComponentID();\n                this-&gt;WriteCoordToBuffer(activeHoleType, currentComponentID, \"StartPoint\", hole-&gt;GetStartPointGO());\n                this-&gt;WriteCoordToBuffer(activeHoleType, currentComponentID, \"EndPoint\", hole-&gt;GetEndPointGO());\n            }\n        }\n    }\n\n\n    void HoleToolheadAxisExporter::WriteCoordToBuffer(const std::string&amp; itemType,\n                                                    std::string itemName,\n                                                    const std::string&amp; pointType,\n                                                    std::shared_ptr&lt;GOPoint&gt; goPoint){\n        m_Buffer &lt;&lt; itemType &lt;&lt; \",\" &lt;&lt; itemName &lt;&lt;\",\" &lt;&lt; pointType &lt;&lt; \",\" &lt;&lt; goPoint-&gt;X() &lt;&lt; \",\" &lt;&lt; goPoint-&gt;Y() &lt;&lt; \",\" &lt;&lt; goPoint-&gt;Z() &lt;&lt; \"\\n\";\n        AIAC_INFO(\"[{0},{1},{2},(X:{3},Y:{4},Z:{5})]\",itemType, itemName, pointType, goPoint-&gt;X(), goPoint-&gt;Y(), goPoint-&gt;Z());\n    }\n\n    void HoleToolheadAxisExporter::WriteBufferToFile(){\n        std::string filePath = this-&gt;m_BasePath + \"/\" + this-&gt;m_FileName;\n        std::ofstream myFile;\n\n        myFile.open(filePath, std::ios_base::app);\n        if (myFile.is_open()) {\n            myFile &lt;&lt; this-&gt;GetCurrentTimestamp() &lt;&lt; \"\\n\";\n            myFile &lt;&lt; m_Buffer.str();\n            myFile &lt;&lt; \"\\n\";\n            myFile.close();\n        }\n        m_Buffer.str(\"\");\n        m_Buffer.clear();\n    }\n\n    std::string HoleToolheadAxisExporter::GetCurrentTimestamp() {\n        auto now = std::chrono::system_clock::now();\n        auto now_c = std::chrono::system_clock::to_time_t(now);\n        char buf[100];\n        strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", std::localtime(&amp;now_c));\n        return buf;\n    }\n}\n</code></pre>"},{"location":"acdoxygen/HoleToolheadAxisExporter_8h/","title":"File HoleToolheadAxisExporter.h","text":"<p>FileList &gt; src &gt; utils &gt; HoleToolheadAxisExporter.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AIAC/GOSys/GOPrimitive.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> </ul>"},{"location":"acdoxygen/HoleToolheadAxisExporter_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC namespace Utils"},{"location":"acdoxygen/HoleToolheadAxisExporter_8h/#classes","title":"Classes","text":"Type Name class HoleToolheadAxisExporter <p>The documentation for this class was generated from the following file <code>src/utils/HoleToolheadAxisExporter.h</code></p>"},{"location":"acdoxygen/HoleToolheadAxisExporter_8h_source/","title":"File HoleToolheadAxisExporter.h","text":"<p>File List &gt; src &gt; utils &gt; HoleToolheadAxisExporter.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include \"AIAC/GOSys/GOPrimitive.h\"\n#include \"AIAC/Config.h\"\n\nnamespace AIAC::Utils {\n    class HoleToolheadAxisExporter {\n    public:\n        explicit HoleToolheadAxisExporter(const std::string&amp; basePath);\n        ~HoleToolheadAxisExporter() = default;\n        void WriteCoordToBuffer(const std::string&amp; itemType,\n                                std::string itemName,\n                                const std::string&amp; pointType,\n                                std::shared_ptr&lt;GOPoint&gt; goPoint);\n        void ExportCoordinates();\n        void ExportToolheadAxis();\n        void ExportHoleAxis();\n        void WriteBufferToFile();\n        std::string GetCurrentTimestamp();\n\n    private:\n        std::string m_BasePath;\n        std::string m_FileName = \"coordinates.log\";\n        std::ostringstream m_Buffer;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/Ini_8h/","title":"File Ini.h","text":"<p>FileList &gt; src &gt; utils &gt; Ini.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;ctype.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;sys/stat.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cctype&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"acdoxygen/Ini_8h/#namespaces","title":"Namespaces","text":"Type Name namespace inih"},{"location":"acdoxygen/Ini_8h/#classes","title":"Classes","text":"Type Name class INIReader class INIWriter"},{"location":"acdoxygen/Ini_8h/#macros","title":"Macros","text":"Type Name define HANDLER (u, s, n, v) <code>handler(u, s, n, v)</code> define INI_INITIAL_ALLOC <code>200</code> define INI_INLINE_COMMENT_PREFIXES <code>\";\"</code> define INI_MAX_LINE <code>2000</code> define INI_START_COMMENT_PREFIXES <code>\";#\"</code> define INI_STOP_ON_FIRST_ERROR <code>1</code> define MAX_NAME <code>50</code> define MAX_SECTION <code>50</code> define __INIREADER_H__ define __INIREADER__ define __INIWRITER_H__"},{"location":"acdoxygen/Ini_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"acdoxygen/Ini_8h/#define-handler","title":"define HANDLER","text":"<pre><code>#define HANDLER (\n    u,\n    s,\n    n,\n    v\n) `handler(u, s, n, v)`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-ini_initial_alloc","title":"define INI_INITIAL_ALLOC","text":"<pre><code>#define INI_INITIAL_ALLOC `200`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-ini_inline_comment_prefixes","title":"define INI_INLINE_COMMENT_PREFIXES","text":"<pre><code>#define INI_INLINE_COMMENT_PREFIXES `\";\"`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-ini_max_line","title":"define INI_MAX_LINE","text":"<pre><code>#define INI_MAX_LINE `2000`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-ini_start_comment_prefixes","title":"define INI_START_COMMENT_PREFIXES","text":"<pre><code>#define INI_START_COMMENT_PREFIXES `\";#\"`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-ini_stop_on_first_error","title":"define INI_STOP_ON_FIRST_ERROR","text":"<pre><code>#define INI_STOP_ON_FIRST_ERROR `1`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-max_name","title":"define MAX_NAME","text":"<pre><code>#define MAX_NAME `50`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-max_section","title":"define MAX_SECTION","text":"<pre><code>#define MAX_SECTION `50`\n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-__inireader_h__","title":"define __INIREADER_H__","text":"<pre><code>#define __INIREADER_H__ \n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-__inireader__","title":"define __INIREADER__","text":"<pre><code>#define __INIREADER__ \n</code></pre>"},{"location":"acdoxygen/Ini_8h/#define-__iniwriter_h__","title":"define __INIWRITER_H__","text":"<pre><code>#define __INIWRITER_H__ \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/Ini.h</code></p>"},{"location":"acdoxygen/Ini_8h_source/","title":"File Ini.h","text":"<p>File List &gt; src &gt; utils &gt; Ini.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __INI_H__\n#define __INI_H__\n\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n\n#include &lt;algorithm&gt;\n#include &lt;cctype&gt;\n#include &lt;cstdlib&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nnamespace inih {\n\n/* Typedef for prototype of handler function. */\ntypedef int (*ini_handler)(void* user, const char* section, const char* name,\n                           const char* value);\n\n/* Typedef for prototype of fgets-style reader function. */\ntypedef char* (*ini_reader)(char* str, int num, void* stream);\n\n#define INI_STOP_ON_FIRST_ERROR 1\n#define INI_MAX_LINE 2000\n#define INI_INITIAL_ALLOC 200\n#define MAX_SECTION 50\n#define MAX_NAME 50\n#define INI_START_COMMENT_PREFIXES \";#\"\n#define INI_INLINE_COMMENT_PREFIXES \";\"\n\n/* Strip whitespace chars off end of given string, in place. Return s. */\ninline static char* rstrip(char* s) {\n    char* p = s + strlen(s);\n    while (p &gt; s &amp;&amp; isspace((unsigned char)(*--p))) *p = '\\0';\n    return s;\n}\n\n/* Return pointer to first non-whitespace char in given string. */\ninline static char* lskip(const char* s) {\n    while (*s &amp;&amp; isspace((unsigned char)(*s))) s++;\n    return (char*)s;\n}\n\n/* Return pointer to first char (of chars) or inline comment in given string,\n   or pointer to null at end of string if neither found. Inline comment must\n   be prefixed by a whitespace character to register as a comment. */\ninline static char* find_chars_or_comment(const char* s, const char* chars) {\n    int was_space = 0;\n    while (*s &amp;&amp; (!chars || !strchr(chars, *s)) &amp;&amp;\n           !(was_space &amp;&amp; strchr(INI_INLINE_COMMENT_PREFIXES, *s))) {\n        was_space = isspace((unsigned char)(*s));\n        s++;\n    }\n    return (char*)s;\n}\n\n/* Version of strncpy that ensures dest (size bytes) is null-terminated. */\ninline static char* strncpy0(char* dest, const char* src, size_t size) {\n    strncpy(dest, src, size - 1);\n    dest[size - 1] = '\\0';\n    return dest;\n}\n\n/* See documentation in header file. */\ninline int ini_parse_stream(ini_reader reader, void* stream,\n                            ini_handler handler, void* user) {\n    /* Uses a fair bit of stack (use heap instead if you need to) */\n    char* line;\n    size_t max_line = INI_INITIAL_ALLOC;\n    char* new_line;\n    size_t offset;\n    char section[MAX_SECTION] = \"\";\n    char prev_name[MAX_NAME] = \"\";\n\n    char* start;\n    char* end;\n    char* name;\n    char* value;\n    int lineno = 0;\n    int error = 0;\n\n    line = (char*)malloc(INI_INITIAL_ALLOC);\n    if (!line) {\n        return -2;\n    }\n\n#if INI_HANDLER_LINENO\n#define HANDLER(u, s, n, v) handler(u, s, n, v, lineno)\n#else\n#define HANDLER(u, s, n, v) handler(u, s, n, v)\n#endif\n\n    /* Scan through stream line by line */\n    while (reader(line, (int)max_line, stream) != NULL) {\n        offset = strlen(line);\n        while (offset == max_line - 1 &amp;&amp; line[offset - 1] != '\\n') {\n            max_line *= 2;\n            if (max_line &gt; INI_MAX_LINE) max_line = INI_MAX_LINE;\n            new_line = (char*)realloc(line, max_line);\n            if (!new_line) {\n                free(line);\n                return -2;\n            }\n            line = new_line;\n            if (reader(line + offset, (int)(max_line - offset), stream) == NULL)\n                break;\n            if (max_line &gt;= INI_MAX_LINE) break;\n            offset += strlen(line + offset);\n        }\n\n        lineno++;\n\n        start = line;\n        if (lineno == 1 &amp;&amp; (unsigned char)start[0] == 0xEF &amp;&amp;\n            (unsigned char)start[1] == 0xBB &amp;&amp;\n            (unsigned char)start[2] == 0xBF) {\n            start += 3;\n        }\n        start = lskip(rstrip(start));\n\n        if (strchr(INI_START_COMMENT_PREFIXES, *start)) {\n            /* Start-of-line comment */\n        } else if (*start == '[') {\n            /* A \"[section]\" line */\n            end = find_chars_or_comment(start + 1, \"]\");\n            if (*end == ']') {\n                *end = '\\0';\n                strncpy0(section, start + 1, sizeof(section));\n                *prev_name = '\\0';\n            } else if (!error) {\n                /* No ']' found on section line */\n                error = lineno;\n            }\n        } else if (*start) {\n            /* Not a comment, must be a name[=:]value pair */\n            end = find_chars_or_comment(start, \"=:\");\n            if (*end == '=' || *end == ':') {\n                *end = '\\0';\n                name = rstrip(start);\n                value = end + 1;\n                end = find_chars_or_comment(value, NULL);\n                if (*end) *end = '\\0';\n                value = lskip(value);\n                rstrip(value);\n\n                /* Valid name[=:]value pair found, call handler */\n                strncpy0(prev_name, name, sizeof(prev_name));\n                if (!HANDLER(user, section, name, value) &amp;&amp; !error)\n                    error = lineno;\n            } else if (!error) {\n                /* No '=' or ':' found on name[=:]value line */\n                error = lineno;\n            }\n        }\n\n        if (error) break;\n    }\n\n    free(line);\n\n    return error;\n}\n\ninline int ini_parse_file(FILE* file, ini_handler handler, void* user) {\n    return ini_parse_stream((ini_reader)fgets, file, handler, user);\n}\n\ninline int ini_parse(const char* filename, ini_handler handler, void* user) {\n    FILE* file;\n    int error;\n\n    file = fopen(filename, \"a+\");\n    if (!file) {\n        return -1;\n    }\n    error = ini_parse_file(file, handler, user);\n    fclose(file);\n    return error;\n}\n\n#endif /* __INI_H__ */\n\n#ifndef __INIREADER_H__\n#define __INIREADER_H__\n\n// Read an INI file into easy-to-access name/value pairs. (Note that I've gone\n// for simplicity here rather than speed, but it should be pretty decent.)\nclass INIReader {\n   public:\n    // Empty Constructor\n    INIReader(){};\n\n    // Construct INIReader and parse given filename. See ini.h for more info\n    // about the parsing.\n    INIReader(std::string filename);\n\n    // Construct INIReader and parse given file. See ini.h for more info\n    // about the parsing.\n    INIReader(FILE* file);\n\n    // Return the result of ini_parse(), i.e., 0 on success, line number of\n    // first error on parse error, or -1 on file open error.\n    int ParseError() const;\n\n    // Return the list of sections found in ini file\n    const std::set&lt;std::string&gt; Sections() const;\n\n    // Return the list of keys in the given section\n    const std::set&lt;std::string&gt; Keys(std::string section) const;\n\n    const std::unordered_map&lt;std::string, std::string&gt; Get(\n        std::string section) const;\n\n    template &lt;typename T = std::string&gt;\n    T Get(const std::string&amp; section, const std::string&amp; name) ;\n\n    template &lt;typename T&gt;\n    T Get(const std::string&amp; section, const std::string&amp; name,\n          T&amp; default_v) ;\n\n    template &lt;typename T = std::string&gt;\n    std::vector&lt;T&gt; GetVector(const std::string&amp; section,\n                             const std::string&amp; name);\n\n    template &lt;typename T&gt;\n    std::vector&lt;T&gt; GetVector(const std::string&amp; section,\n                             const std::string&amp; name,\n                             const std::vector&lt;T&gt;&amp; default_v);\n\n    template &lt;typename T = std::string&gt;\n    void InsertEntry(const std::string&amp; section, const std::string&amp; name,\n                     const T&amp; v);\n\n    template &lt;typename T = std::string&gt;\n    void InsertEntry(const std::string&amp; section, const std::string&amp; name,\n                     const std::vector&lt;T&gt;&amp; vs);\n\n    template &lt;typename T = std::string&gt;\n    void UpdateEntry(const std::string&amp; section, const std::string&amp; name,\n                     const T&amp; v);\n\n    template &lt;typename T = std::string&gt;\n    void UpdateEntry(const std::string&amp; section, const std::string&amp; name,\n                     const std::vector&lt;T&gt;&amp; vs);\n\n   protected:\n    int _error;\n    std::unordered_map&lt;std::string,\n                       std::unordered_map&lt;std::string, std::string&gt;&gt;\n        _values;\n    static int ValueHandler(void* user, const char* section, const char* name,\n                            const char* value);\n\n    template &lt;typename T&gt;\n    T Converter(const std::string&amp; s) const;\n\n    const bool BoolConverter(std::string s) const;\n\n    template &lt;typename T&gt;\n    std::string V2String(const T&amp; v) const;\n\n    template &lt;typename T&gt;\n    std::string Vec2String(const std::vector&lt;T&gt;&amp; v) const;\n};\n\n#endif  // __INIREADER_H__\n\n#ifndef __INIREADER__\n#define __INIREADER__\n\ninline INIReader::INIReader(std::string filename) {\n    _error = ini_parse(filename.c_str(), ValueHandler, this);\n    ParseError();\n}\n\ninline INIReader::INIReader(FILE* file) {\n    _error = ini_parse_file(file, ValueHandler, this);\n    ParseError();\n}\n\ninline int INIReader::ParseError() const {\n    switch (_error) {\n        case 0:\n            break;\n        case -1:\n            throw std::runtime_error(\"ini file not found.\");\n        case -2:\n            throw std::runtime_error(\"memory alloc error\");\n        default:\n            throw std::runtime_error(\"parse error on line no: \" +\n                                     std::to_string(_error));\n    }\n    return 0;\n}\n\ninline const std::set&lt;std::string&gt; INIReader::Sections() const {\n    std::set&lt;std::string&gt; retval;\n    for (auto const&amp; element : _values) {\n        retval.insert(element.first);\n    }\n    return retval;\n}\n\ninline const std::set&lt;std::string&gt; INIReader::Keys(std::string section) const {\n    auto const _section = Get(section);\n    std::set&lt;std::string&gt; retval;\n    for (auto const&amp; element : _section) {\n        retval.insert(element.first);\n    }\n    return retval;\n}\n\ninline const std::unordered_map&lt;std::string, std::string&gt; INIReader::Get(\n    std::string section) const {\n    auto const _section = _values.find(section);\n    if (_section == _values.end()) {\n        throw std::runtime_error(\"section '\" + section + \"' not found.\");\n    }\n    return _section-&gt;second;\n}\n\ntemplate &lt;typename T&gt;\ninline T INIReader::Get(const std::string&amp; section,\n                        const std::string&amp; name) {\n    auto const _section = Get(section);\n    auto const _value = _section.find(name);\n\n    if (_value == _section.end()) {\n        throw std::runtime_error(\"key '\" + name + \"' not found in section '\" +\n                                 section + \"'.\");\n    }\n\n    std::string value = _value-&gt;second;\n\n    if constexpr (std::is_same&lt;T, std::string&gt;()) {\n        return value;\n    } else if constexpr (std::is_same&lt;T, bool&gt;()) {\n        return BoolConverter(value);\n    } else {\n        return Converter&lt;T&gt;(value);\n    };\n}\n\ntemplate &lt;typename T&gt;\ninline T INIReader::Get(const std::string&amp; section, const std::string&amp; name,\n                        T&amp; default_v) {\n    try {\n        return Get&lt;T&gt;(section, name);\n    } catch (std::runtime_error&amp; e) {\n        INIReader::InsertEntry(section, name, default_v);\n        return default_v;\n    }\n}\n\ntemplate &lt;typename T&gt;\ninline std::vector&lt;T&gt; INIReader::GetVector(const std::string&amp; section,\n                                           const std::string&amp; name) {\n    std::string value = Get(section, name);\n\n    std::istringstream out{value};\n    const std::vector&lt;std::string&gt; strs{std::istream_iterator&lt;std::string&gt;{out},\n                                        std::istream_iterator&lt;std::string&gt;()};\n    try {\n        std::vector&lt;T&gt; vs{};\n        for (const std::string&amp; s : strs) {\n            vs.emplace_back(Converter&lt;T&gt;(s));\n        }\n        return vs;\n    } catch (std::exception&amp; e) {\n        throw std::runtime_error(\"cannot parse value \" + value +\n                                 \" to vector&lt;T&gt;.\");\n    }\n}\n\ntemplate &lt;typename T&gt;\ninline std::vector&lt;T&gt; INIReader::GetVector(\n    const std::string&amp; section, const std::string&amp; name,\n    const std::vector&lt;T&gt;&amp; default_v) {\n    try {\n        return GetVector&lt;T&gt;(section, name);\n    } catch (std::runtime_error&amp; e) {\n        INIReader::InsertEntry(section, name, default_v);\n        return default_v;\n    };\n}\n\ntemplate &lt;typename T&gt;\ninline void INIReader::InsertEntry(const std::string&amp; section,\n                                   const std::string&amp; name, const T&amp; v) {\n    // if (_values[section][name].size() &gt; 0) {\n    //     throw std::runtime_error(\"duplicate key '\" + std::string(name) +\n    //                              \"' in section '\" + section + \"'.\");\n    // }\n    _values[section][name] = V2String(v);\n}\n\ntemplate &lt;typename T&gt;\ninline void INIReader::InsertEntry(const std::string&amp; section,\n                                   const std::string&amp; name,\n                                   const std::vector&lt;T&gt;&amp; vs) {\n    // if (_values[section][name].size() &gt; 0) {\n    //     throw std::runtime_error(\"duplicate key '\" + std::string(name) +\n    //                              \"' in section '\" + section + \"'.\");\n    // }\n    _values[section][name] = Vec2String(vs);\n}\n\ntemplate &lt;typename T&gt;\ninline void INIReader::UpdateEntry(const std::string&amp; section,\n                                   const std::string&amp; name, const T&amp; v) {\n    // if (!_values[section][name].size()) {\n    //     throw std::runtime_error(\"key '\" + std::string(name) +\n    //                              \"' not exist in section '\" + section + \"'.\");\n    // }\n    _values[section][name] = V2String(v);\n}\n\ntemplate &lt;typename T&gt;\ninline void INIReader::UpdateEntry(const std::string&amp; section,\n                                   const std::string&amp; name,\n                                   const std::vector&lt;T&gt;&amp; vs) {\n    // if (!_values[section][name].size()) {\n    //     throw std::runtime_error(\"key '\" + std::string(name) +\n    //                              \"' not exist in section '\" + section + \"'.\");\n    // }\n    _values[section][name] = Vec2String(vs);\n}\n\ntemplate &lt;typename T&gt;\ninline std::string INIReader::V2String(const T&amp; v) const {\n    std::stringstream ss;\n    ss &lt;&lt; v;\n    return ss.str();\n}\n\ntemplate &lt;typename T&gt;\ninline std::string INIReader::Vec2String(const std::vector&lt;T&gt;&amp; v) const {\n    if (v.empty()) {\n        return \"\";\n    }\n    std::ostringstream oss;\n    std::copy(v.begin(), v.end() - 1, std::ostream_iterator&lt;T&gt;(oss, \" \"));\n    oss &lt;&lt; v.back();\n\n    return oss.str();\n}\n\ntemplate &lt;typename T&gt;\ninline T INIReader::Converter(const std::string&amp; s) const {\n    try {\n        T v{};\n        std::istringstream _{s};\n        _.exceptions(std::ios::failbit);\n        _ &gt;&gt; v;\n        return v;\n    } catch (std::exception&amp; e) {\n        throw std::runtime_error(\"cannot parse value '\" + s + \"' to type&lt;T&gt;.\");\n    };\n}\n\ninline const bool INIReader::BoolConverter(std::string s) const {\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    static const std::unordered_map&lt;std::string, bool&gt; s2b{\n        {\"1\", true},  {\"true\", true},   {\"yes\", true}, {\"on\", true},\n        {\"0\", false}, {\"false\", false}, {\"no\", false}, {\"off\", false},\n    };\n    auto const value = s2b.find(s);\n    if (value == s2b.end()) {\n        throw std::runtime_error(\"'\" + s + \"' is not a valid boolean value.\");\n    }\n    return value-&gt;second;\n}\n\ninline int INIReader::ValueHandler(void* user, const char* section,\n                                   const char* name, const char* value) {\n    INIReader* reader = (INIReader*)user;\n    if (reader-&gt;_values[section][name].size() &gt; 0) {\n        throw std::runtime_error(\"duplicate key '\" + std::string(name) +\n                                 \"' in section '\" + section + \"'.\");\n    }\n    reader-&gt;_values[section][name] = value;\n    return 1;\n}\n#endif  // __INIREADER__\n\n#ifndef __INIWRITER_H__\n#define __INIWRITER_H__\n\nclass INIWriter {\n   public:\n    INIWriter(){};\n    inline static void write(const std::string&amp; filepath,\n                             INIReader&amp; reader) {\n        // if (struct stat buf; stat(filepath.c_str(), &amp;buf) == 0) {\n        //     throw std::runtime_error(\"file: \" + filepath + \" already exist.\");\n        // }\n        std::ofstream out;\n        out.open(filepath);\n        if (!out.is_open()) {\n            throw std::runtime_error(\"cannot open output file: \" + filepath);\n        }\n        for (auto&amp; section : reader.Sections()) {\n            out &lt;&lt; \"[\" &lt;&lt; section &lt;&lt; \"]\\n\";\n            for (auto&amp; key : reader.Keys(section)) {\n                out &lt;&lt; key &lt;&lt; \" = \" &lt;&lt; reader.Get(section, key) &lt;&lt; \"\\n\";\n            }\n            out &lt;&lt; \"\\n\";\n        }\n        out.close();\n    }\n};\n}\n#endif /* __INIWRITER_H__ */\n</code></pre>"},{"location":"acdoxygen/MatrixUtils_8h/","title":"File MatrixUtils.h","text":"<p>FileList &gt; src &gt; utils &gt; MatrixUtils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;glm/glm.hpp&gt;</code></li> </ul>"},{"location":"acdoxygen/MatrixUtils_8h/#public-functions","title":"Public Functions","text":"Type Name cv::Vec4f ConvertRotationMatrixToQuaternion (cv::Mat R) Convert a rotation matrix to a quaternion. void ConvertTransMatToTvecAndQvec (cv::Matx44f transMat, cv::Vec3f &amp; tvec, cv::Vec4f &amp; qvec) Convert a Transformation matrix to a translation vector and a quaternion vector. void CvtCvMat2GlmMat (const cv::Mat &amp; cvMat, glm::mat4 &amp; glmMat)  void CvtCvMat2GlmMat (const cv::Mat &amp; cvMat, glm::mat3 &amp; glmMat)  void CvtGlmMat2CvMat (const glm::mat4 &amp; glmMat, cv::Mat &amp; cvMat)"},{"location":"acdoxygen/MatrixUtils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/MatrixUtils_8h/#function-convertrotationmatrixtoquaternion","title":"function ConvertRotationMatrixToQuaternion","text":"<p>Convert a rotation matrix to a quaternion. <pre><code>inline cv::Vec4f ConvertRotationMatrixToQuaternion (\n    cv::Mat R\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>R</code> The rotation matrix </li> </ul> <p>Returns:</p> <p>cv::Vec4f The quaternion </p>"},{"location":"acdoxygen/MatrixUtils_8h/#function-converttransmattotvecandqvec","title":"function ConvertTransMatToTvecAndQvec","text":"<p>Convert a Transformation matrix to a translation vector and a quaternion vector. <pre><code>inline void ConvertTransMatToTvecAndQvec (\n    cv::Matx44f transMat,\n    cv::Vec3f &amp; tvec,\n    cv::Vec4f &amp; qvec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transMat</code> cv::Mat4x4 The transformation matrix </li> <li><code>tvec</code> cv::Vec3f The output of the translation vector </li> <li><code>qvec</code> cv::Vec4f The output of the quaternion vector</li> </ul> <p>Returns:</p> <p>empty </p>"},{"location":"acdoxygen/MatrixUtils_8h/#function-cvtcvmat2glmmat","title":"function CvtCvMat2GlmMat","text":"<pre><code>inline void CvtCvMat2GlmMat (\n    const cv::Mat &amp; cvMat,\n    glm::mat4 &amp; glmMat\n) \n</code></pre>"},{"location":"acdoxygen/MatrixUtils_8h/#function-cvtcvmat2glmmat_1","title":"function CvtCvMat2GlmMat","text":"<pre><code>inline void CvtCvMat2GlmMat (\n    const cv::Mat &amp; cvMat,\n    glm::mat3 &amp; glmMat\n) \n</code></pre>"},{"location":"acdoxygen/MatrixUtils_8h/#function-cvtglmmat2cvmat","title":"function CvtGlmMat2CvMat","text":"<pre><code>inline void CvtGlmMat2CvMat (\n    const glm::mat4 &amp; glmMat,\n    cv::Mat &amp; cvMat\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/MatrixUtils.h</code></p>"},{"location":"acdoxygen/MatrixUtils_8h_source/","title":"File MatrixUtils.h","text":"<p>File List &gt; src &gt; utils &gt; MatrixUtils.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;glm/glm.hpp&gt;\n\ninline void CvtGlmMat2CvMat(const glm::mat4 &amp;glmMat, cv::Mat &amp;cvMat)\n{\n    cvMat = cv::Mat(4, 4, CV_32FC1);\n    for (int i = 0; i &lt; 4; i++) {\n        for (int j = 0; j &lt; 4; j++) {\n            cvMat.at&lt;float&gt;(i, j) = glmMat[j][i];\n        }\n    }\n}\n\ninline void CvtCvMat2GlmMat(const cv::Mat &amp;cvMat, glm::mat4 &amp;glmMat)\n{\n    for (int i = 0; i &lt; 4; i++) {\n        for (int j = 0; j &lt; 4; j++) {\n            glmMat[j][i] = cvMat.at&lt;float&gt;(i, j);\n        }\n    }\n}\n\ninline void CvtCvMat2GlmMat(const cv::Mat &amp;cvMat, glm::mat3 &amp;glmMat)\n{\n    for (int i = 0; i &lt; 3; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            glmMat[j][i] = cvMat.at&lt;float&gt;(i, j);\n        }\n    }\n}\n\ninline cv::Vec4f ConvertRotationMatrixToQuaternion(cv::Mat R) {\n    cv::Vec4f q;\n    q[3] = sqrt(1.0 + R.at&lt;float&gt;(0,0) + R.at&lt;float&gt;(1,1) + R.at&lt;float&gt;(2,2)) / 2.0;\n    q[0] = (R.at&lt;float&gt;(2,1) - R.at&lt;float&gt;(1,2)) / (4.0 * q[3]);\n    q[1] = (R.at&lt;float&gt;(0,2) - R.at&lt;float&gt;(2,0)) / (4.0 * q[3]);\n    q[2] = (R.at&lt;float&gt;(1,0) - R.at&lt;float&gt;(0,1)) / (4.0 * q[3]);\n    return q;\n}\n\ninline void ConvertTransMatToTvecAndQvec(cv::Matx44f transMat, cv::Vec3f &amp;tvec, cv::Vec4f &amp;qvec) {\n    auto tTransMat = cv::Mat(transMat);\n\n    tvec[0] = tTransMat.at&lt;float&gt;(0, 3);\n    tvec[1] = tTransMat.at&lt;float&gt;(1, 3);\n    tvec[2] = tTransMat.at&lt;float&gt;(2, 3);\n\n    cv::Mat R = tTransMat(cv::Rect(0, 0, 3, 3));\n    qvec = ConvertRotationMatrixToQuaternion(R);\n}\n</code></pre>"},{"location":"acdoxygen/Screenshot_8cpp/","title":"File Screenshot.cpp","text":"<p>FileList &gt; src &gt; utils &gt; Screenshot.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Screenshot.h\"</code></li> <li><code>#include \"AIAC/Config.h\"</code></li> <li><code>#include \"../AIAC/Application.h\"</code></li> <li><code>#include \"AIAC/LayerCamera.h\"</code></li> <li><code>#include \"AIAC/LayerUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/Screenshot_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC namespace Utils <p>The documentation for this class was generated from the following file <code>src/utils/Screenshot.cpp</code></p>"},{"location":"acdoxygen/Screenshot_8cpp_source/","title":"File Screenshot.cpp","text":"<p>File List &gt; src &gt; utils &gt; Screenshot.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#include \"Screenshot.h\"\n#include \"AIAC/Config.h\"\n#include \"../AIAC/Application.h\"\n#include \"AIAC/LayerCamera.h\"\n#include \"AIAC/LayerUtils.h\"\n\nnamespace AIAC::Utils{\n    Screenshot::Screenshot(const std::string&amp; basePath)\n            : m_BasePath(basePath)\n    {\n        LayerUtils::CreateFolder(this-&gt;m_BasePath + this-&gt;m_ScreenshotPath);\n    }\n\n    void Screenshot::CaptureWindow(){\n        int width = AIAC_APP.GetWindow()-&gt;GetDisplayW();\n        int height = AIAC_APP.GetWindow()-&gt;GetDisplayH();\n\n        std::vector&lt;unsigned char&gt; pixels(width * height * 4);\n\n        glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());\n        cv::Mat image(height, width, CV_8UC4, pixels.data());\n        cv::flip(image, image, 0);\n        cv::cvtColor(image, image, cv::COLOR_RGBA2BGR);\n\n        this-&gt;GenerateImageName(true);\n        this-&gt;SaveScreenshot(image);\n    }\n\n    void Screenshot::CaptureBuffer() {\n        cv::Mat currentFrame;\n        AIAC_APP.GetLayer&lt;AIAC::LayerCamera&gt;()-&gt;MainCamera.GetColorCurrentFrame().GetCvMat().copyTo(currentFrame);\n\n        this-&gt;GenerateImageName(false);\n        this-&gt;SaveScreenshot(currentFrame);\n    }\n\n    void Screenshot::GenerateImageName(bool isWindow){\n        auto now = std::chrono::system_clock::now();\n        auto timestamp = std::chrono::system_clock::to_time_t(now);\n\n        std::stringstream imagename;\n        if (isWindow) {\n            imagename &lt;&lt; \"window-\";\n        } else {\n            imagename &lt;&lt; \"buffer-\";\n        }\n        struct std::tm* tm;\n        tm = std::localtime(&amp;timestamp);\n\n        imagename &lt;&lt; std::put_time(tm, \"%Y-%m-%d-%H-%M-%S\") &lt;&lt; \".png\";\n\n        const std::string imagePath = this-&gt;m_BasePath + this-&gt;m_ScreenshotPath + \"/\" + imagename.str();\n        this-&gt;m_ImageName = imagePath;\n    }\n\n    void Screenshot::SaveScreenshot(cv::Mat image){\n        if(std::filesystem::exists(this-&gt;m_BasePath + this-&gt;m_ScreenshotPath)) {\n            cv::imwrite(m_ImageName, image);\n            AIAC_INFO(\"The image is saved to : {0}\", m_ImageName);\n        } else {\n            AIAC_ERROR(\"Error: {0} does not exist!\", this-&gt;m_BasePath + this-&gt;m_ScreenshotPath);\n        }\n    }\n}\n</code></pre>"},{"location":"acdoxygen/Screenshot_8h/","title":"File Screenshot.h","text":"<p>FileList &gt; src &gt; utils &gt; Screenshot.h</p> <p>Go to the source code of this file</p>"},{"location":"acdoxygen/Screenshot_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC namespace Utils"},{"location":"acdoxygen/Screenshot_8h/#classes","title":"Classes","text":"Type Name class Screenshot <p>The documentation for this class was generated from the following file <code>src/utils/Screenshot.h</code></p>"},{"location":"acdoxygen/Screenshot_8h_source/","title":"File Screenshot.h","text":"<p>File List &gt; src &gt; utils &gt; Screenshot.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n\n#pragma once\n\nnamespace AIAC::Utils{\n    class Screenshot {\n    public:\n        explicit Screenshot(const std::string&amp; basePath);\n        void CaptureWindow();\n        void CaptureBuffer();\n        void GenerateImageName(bool isWindow);\n        void SaveScreenshot(cv::Mat image);\n\n    private:\n        std::string m_BasePath;\n        std::string m_ScreenshotPath = \"/screenshots\";\n        std::string m_ImageName;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/SystemUtils_8h/","title":"File SystemUtils.h","text":"<p>FileList &gt; src &gt; utils &gt; SystemUtils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"acdoxygen/SystemUtils_8h/#public-functions","title":"Public Functions","text":"Type Name std::string ExecuteSystemCommand (const char * cmd) Execute a system command and return the output as a string."},{"location":"acdoxygen/SystemUtils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/SystemUtils_8h/#function-executesystemcommand","title":"function ExecuteSystemCommand","text":"<p>Execute a system command and return the output as a string. <pre><code>std::string ExecuteSystemCommand (\n    const char * cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cmd</code> The command to execute </li> </ul> <p>Returns:</p> <p>std::string The output of the command </p> <p>The documentation for this class was generated from the following file <code>src/utils/SystemUtils.h</code></p>"},{"location":"acdoxygen/SystemUtils_8h_source/","title":"File SystemUtils.h","text":"<p>File List &gt; src &gt; utils &gt; SystemUtils.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n\n// ref: https://stackoverflow.com/questions/478898/how-do-i-execute-a-command-and-get-the-output-of-the-command-within-c-using-po\nstd::string ExecuteSystemCommand(const char* cmd) {\n    std::array&lt;char, 128&gt; buffer;\n    std::string result;\n    std::unique_ptr&lt;FILE, decltype(&amp;pclose)&gt; pipe(popen(cmd, \"r\"), pclose);\n    if (!pipe) {\n        throw std::runtime_error(\"popen() failed!\");\n    }\n    while (fgets(buffer.data(), static_cast&lt;int&gt;(buffer.size()), pipe.get()) != nullptr) {\n        result += buffer.data();\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"acdoxygen/VideoRecorder_8cpp/","title":"File VideoRecorder.cpp","text":"<p>FileList &gt; src &gt; utils &gt; VideoRecorder.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"VideoRecorder.h\"</code></li> <li><code>#include \"../AIAC/Application.h\"</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include \"AIAC/LayerUtils.h\"</code></li> </ul>"},{"location":"acdoxygen/VideoRecorder_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC namespace Utils <p>The documentation for this class was generated from the following file <code>src/utils/VideoRecorder.cpp</code></p>"},{"location":"acdoxygen/VideoRecorder_8cpp_source/","title":"File VideoRecorder.cpp","text":"<p>File List &gt; src &gt; utils &gt; VideoRecorder.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n\n#include \"VideoRecorder.h\"\n#include \"../AIAC/Application.h\"\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;filesystem&gt;\n#include \"AIAC/LayerUtils.h\"\n\nnamespace AIAC::Utils {\n    VideoRecorder::VideoRecorder(const std::string&amp; basePath)\n    : m_BasePath(basePath)\n    {   this-&gt;UpdatePaths();\n        this-&gt;InitializeDirectories();\n    }\n\n    VideoRecorder::~VideoRecorder() {\n        this-&gt;DeleteFrameFolder();\n    }\n\n    void VideoRecorder::UpdatePaths() {\n        auto now = std::chrono::system_clock::now();\n        auto timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now.time_since_epoch()).count();\n\n        this-&gt;m_RecorderPath = this-&gt;m_BasePath + \"/recorder\";\n        this-&gt;m_FramesPath = this-&gt;m_RecorderPath + \"/frames_\"+ std::to_string(timestamp);\n        this-&gt;m_VideoPath = this-&gt;m_RecorderPath + \"/video_\"+ std::to_string(timestamp);\n    }\n\n    void VideoRecorder::CaptureFrames() {\n        int width = AIAC_APP.GetWindow()-&gt;GetDisplayW();\n        int height = AIAC_APP.GetWindow()-&gt;GetDisplayH();\n        std::vector&lt;unsigned char&gt; pixels(width * height * 4);  // 4 for RGBA\n\n        glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());\n\n        if(std::filesystem::exists(this-&gt;m_FramesPath)) {\n            this-&gt;SaveFrames(height, width, pixels);\n        } else {\n            AIAC_ERROR(\"Error: {0} does not exist!\", this-&gt;m_FramesPath);\n    }\n    }\n\n    void VideoRecorder::SaveFrames(int height, int width, std::vector&lt;unsigned char&gt; pixels) {\n        cv::Mat image(height, width, CV_8UC4, pixels.data());\n\n        cv::flip(image, image, 0);\n        cv::cvtColor(image, image, cv::COLOR_RGBA2BGR);\n\n        auto now = std::chrono::system_clock::now();\n        auto timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now.time_since_epoch()).count();\n\n        std::stringstream filename;\n        filename &lt;&lt; std::setfill('0') &lt;&lt; std::setw(13) &lt;&lt; timestamp &lt;&lt; \".jpg\";\n\n        cv::imwrite(this-&gt;m_FramesPath + \"/\" + filename.str(), image);\n    }\n\n    void VideoRecorder::MakeVideoFromFrames() {\n        const std::string framesFolder = this-&gt;m_FramesPath;\n\n        std::vector&lt;std::string&gt; framePaths;\n        for (const auto&amp; entry : std::filesystem::directory_iterator(framesFolder)) {\n            framePaths.push_back(entry.path().string());\n        }\n        std::sort(framePaths.begin(), framePaths.end());\n\n        const std::string imageListFile = \"image_list.txt\";\n        std::ofstream imageList(imageListFile);\n        for (const std::string&amp; framePath : framePaths) {\n            imageList &lt;&lt; \"file '\" &lt;&lt; framePath &lt;&lt; \"'\\n\";\n        }\n        imageList.close();\n\n        auto now = std::chrono::system_clock::now();\n        auto timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now.time_since_epoch()).count();\n\n        std::stringstream videoname;\n        videoname &lt;&lt; std::setfill('0') &lt;&lt; std::setw(13) &lt;&lt; timestamp &lt;&lt; \".mp4\";\n\n        const std::string videoPath = this-&gt;m_VideoPath + \"/\" + videoname.str();\n        std::string ffmpegCommand = \"ffmpeg -y -f concat -safe 0 -i \" + imageListFile + \" -vf \\\"fps=30\\\" -c:v libx264 -pix_fmt yuv420p \" + videoPath + \" 2&gt;/dev/null\";\n\n        int result = std::system(ffmpegCommand.c_str());\n        if (result == 0) {\n            AIAC_INFO(\"Video saved to: {0}\", videoPath);\n        } else {\n            AIAC_ERROR(\"Error: ffmpeg could not create video!\");\n        }\n\n        std::remove(imageListFile.c_str());\n    }\n\n    void VideoRecorder::InitializeDirectories(){\n        for(const auto&amp; path: {this-&gt;m_RecorderPath,this-&gt;m_FramesPath, this-&gt;m_VideoPath}) {\n            LayerUtils::CreateFolder(path);\n        }\n    }\n\n    void VideoRecorder::DeleteFrameFolder(){\n        if (std::filesystem::exists(this-&gt;m_FramesPath)) {\n            std::filesystem::remove_all(this-&gt;m_FramesPath);\n        } else {\n        AIAC_ERROR(\"Could not delete {0} folder\", this-&gt;m_FramesPath);}\n    }\n}\n</code></pre>"},{"location":"acdoxygen/VideoRecorder_8h/","title":"File VideoRecorder.h","text":"<p>FileList &gt; src &gt; utils &gt; VideoRecorder.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;GL/glew.h&gt;</code></li> <li><code>#include &lt;GLFW/glfw3.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"acdoxygen/VideoRecorder_8h/#namespaces","title":"Namespaces","text":"Type Name namespace AIAC namespace Utils"},{"location":"acdoxygen/VideoRecorder_8h/#classes","title":"Classes","text":"Type Name class VideoRecorder <p>The documentation for this class was generated from the following file <code>src/utils/VideoRecorder.h</code></p>"},{"location":"acdoxygen/VideoRecorder_8h_source/","title":"File VideoRecorder.h","text":"<p>File List &gt; src &gt; utils &gt; VideoRecorder.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n\n#pragma once\n\n#include &lt;GL/glew.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nnamespace AIAC::Utils {\n\n    class VideoRecorder {\n    public:\n        explicit VideoRecorder(const std::string&amp; basePath);\n        ~VideoRecorder();\n\n        void CaptureFrames();\n        void SaveFrames(int height, int width, std::vector&lt;unsigned char&gt; pixels);\n        void MakeVideoFromFrames();\n        void InitializeDirectories();\n        void DeleteFrameFolder();\n        void UpdatePaths();\n\n\n    private:\n        std::string m_BasePath;\n        std::string m_RecorderPath;\n        std::string m_FramesPath;\n        std::string m_VideoPath;\n    };\n}\n</code></pre>"},{"location":"acdoxygen/glob_8cpp/","title":"File glob.cpp","text":"<p>FileList &gt; src &gt; utils &gt; glob.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"glob.h\"</code></li> <li><code>#include &lt;dirent.h&gt;</code></li> <li><code>#include &lt;fnmatch.h&gt;</code></li> </ul>"},{"location":"acdoxygen/glob_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace glob"},{"location":"acdoxygen/glob_8cpp/#classes","title":"Classes","text":"Type Name class glob_impl <p>The documentation for this class was generated from the following file <code>src/utils/glob.cpp</code></p>"},{"location":"acdoxygen/glob_8cpp_source/","title":"File glob.cpp","text":"<p>File List &gt; src &gt; utils &gt; glob.cpp</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by ibois on 12/14/22.\n//\n\n#include \"glob.h\"\n#include \"glob.h\"\n#ifdef _WIN32\n#include &lt;windows.h&gt;\n#else\n#include &lt;dirent.h&gt;\n#include &lt;fnmatch.h&gt;\n#endif\n\nnamespace glob {\n\n#ifdef _WIN32\n\n    class glob_impl\n{\npublic:\n    glob_impl():\n        find_handle(INVALID_HANDLE_VALUE),\n        find_data(),\n        has_next(false)\n    {}\n\n    HANDLE find_handle;\n    WIN32_FIND_DATAA find_data;\n    bool has_next;\n};\n\nglob::glob(const std::string &amp;pattern):\n    impl_(std::make_unique&lt;glob_impl&gt;())\n{\n    open(pattern);\n}\n\nglob::~glob()\n{\n    close();\n}\n\nvoid glob::open(const std::string &amp;pattern)\n{\n    impl_-&gt;find_handle =\n        FindFirstFileA(pattern.c_str(), &amp;impl_-&gt;find_data);\n    impl_-&gt;has_next = impl_-&gt;find_handle != INVALID_HANDLE_VALUE;\n}\n\nvoid glob::close()\n{\n    if (impl_-&gt;find_handle != INVALID_HANDLE_VALUE) {\n        FindClose(impl_-&gt;find_handle);\n        impl_-&gt;find_handle = INVALID_HANDLE_VALUE;\n        impl_-&gt;has_next = false;\n    }\n}\n\nstd::string glob::current_match() const\n{\n    return impl_-&gt;find_data.cFileName;\n}\n\nbool glob::is_valid() const\n{\n    return impl_-&gt;has_next;\n}\n\nbool glob::next()\n{\n    impl_-&gt;has_next =\n        FindNextFileA(impl_-&gt;find_handle, &amp;impl_-&gt;find_data) != 0;\n    return impl_-&gt;has_next;\n}\n\n#else // _WIN32\n\n    namespace {\n\n        std::pair&lt;std::string, std::string&gt; split_path(const std::string &amp;path)\n        {\n            std::string::size_type last_sep = path.find_last_of(\"/\");\n            if (last_sep != std::string::npos) {\n                return std::make_pair(\n                        std::string(path.begin(), path.begin() + last_sep),\n                        std::string(path.begin() + last_sep + 1, path.end()));\n            }\n            return std::make_pair(\".\", path);\n        }\n\n    } // namespace\n\n    class glob_impl\n    {\n    public:\n        glob_impl():\n                dir(nullptr),\n                dir_entry(nullptr)\n        {}\n\n        std::string file_pattern;\n        DIR *dir;\n        struct dirent *dir_entry;\n    };\n\n    glob::glob(const std::string &amp;pattern):\n            impl_(std::make_unique&lt;glob_impl&gt;())\n    {\n        open(pattern);\n    }\n\n    glob::~glob()\n    {\n        close();\n    }\n\n    void glob::open(const std::string &amp;pattern)\n    {\n        auto dir_and_file = split_path(pattern);\n        dir_path = dir_and_file.first;\n        impl_-&gt;dir = opendir(dir_and_file.first.c_str());\n        impl_-&gt;file_pattern = dir_and_file.second;\n\n        if (impl_-&gt;dir != nullptr) {\n            next();\n        }\n    }\n\n    void glob::close()\n    {\n        if (impl_-&gt;dir != nullptr) {\n            closedir(impl_-&gt;dir);\n            impl_-&gt;dir = nullptr;\n        }\n    }\n\n    std::string glob::current_match() const\n    {\n\n        return dir_path + '/' + impl_-&gt;dir_entry-&gt;d_name;\n    }\n\n    bool glob::next()\n    {\n        while ((impl_-&gt;dir_entry = readdir(impl_-&gt;dir)) != nullptr) {\n            if (!fnmatch(impl_-&gt;file_pattern.c_str(),\n                         impl_-&gt;dir_entry-&gt;d_name,\n                         FNM_CASEFOLD | FNM_NOESCAPE | FNM_PERIOD)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool glob::is_valid() const\n    {\n        return impl_-&gt;dir != nullptr &amp;&amp; impl_-&gt;dir_entry != nullptr;\n    }\n\n#endif // !_WIN32\n\n} // namespace glob\n</code></pre>"},{"location":"acdoxygen/glob_8h/","title":"File glob.h","text":"<p>FileList &gt; src &gt; utils &gt; glob.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"acdoxygen/glob_8h/#namespaces","title":"Namespaces","text":"Type Name namespace glob"},{"location":"acdoxygen/glob_8h/#classes","title":"Classes","text":"Type Name class glob <p>The documentation for this class was generated from the following file <code>src/utils/glob.h</code></p>"},{"location":"acdoxygen/glob_8h_source/","title":"File glob.h","text":"<p>File List &gt; src &gt; utils &gt; glob.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef GLOB_H\n#define GLOB_H\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace glob {\n\n    class glob_impl;\n\n    class glob final\n    {\n    public:\n        glob(const std::string &amp;pattern);\n        ~glob();\n\n        operator bool() const {\n            return is_valid();\n        }\n\n        void open(const std::string &amp;pattern);\n        void close();\n\n        std::string dir_path;\n        std::string current_match() const;\n\n        bool next();\n        bool is_valid() const;\n\n    private:\n        glob(const glob &amp;) = delete;\n        void operator=(const glob &amp;) = delete;\n\n    private:\n        std::unique_ptr&lt;glob_impl&gt; impl_;\n    };\n\n} // namespace glob\n\n#endif // !GLOB_H\n</code></pre>"},{"location":"acdoxygen/utils_8h/","title":"File utils.h","text":"<p>FileList &gt; src &gt; utils &gt; utils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;sys/stat.h&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"AIAC/Log.h\"</code></li> <li><code>#include \"glm/glm.hpp\"</code></li> </ul>"},{"location":"acdoxygen/utils_8h/#public-functions","title":"Public Functions","text":"Type Name void CopyFile (const std::string &amp; source, const std::string &amp; destination) Copy the file from source to destination. std::string GetCurrentDateTime () Get current date/time, format is YYYY-MM-DD.HH:mm. long GetCurrentTimestamp () Get current timestamp in milliseconds. std::string GetFileNameFromPath (const std::string &amp; path, bool withExtension=true) Get the name of the file from the given path. std::vector&lt; std::string &gt; GetFilePaths (const std::string &amp; dirPath, const std::string &amp; extension) Get all file paths with the given extension in the given directory. std::vector&lt; std::string &gt; GetFolderPaths (const std::string &amp; dirPath) Get all sub-folders' paths in the given directory. bool IsFileExist (const std::string &amp; name) Check if the given file exists. std::vector&lt; std::string &gt; ParseConfigFile (const std::string &amp; configPath, const std::string &amp; entryName) Parse the config file and get the file paths."},{"location":"acdoxygen/utils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"acdoxygen/utils_8h/#function-copyfile","title":"function CopyFile","text":"<p>Copy the file from source to destination. <pre><code>inline void CopyFile (\n    const std::string &amp; source,\n    const std::string &amp; destination\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>source</code> the source file path </li> <li><code>destination</code> the destination file path </li> </ul>"},{"location":"acdoxygen/utils_8h/#function-getcurrentdatetime","title":"function GetCurrentDateTime","text":"<p>Get current date/time, format is YYYY-MM-DD.HH:mm. <pre><code>inline std::string GetCurrentDateTime () \n</code></pre></p>"},{"location":"acdoxygen/utils_8h/#function-getcurrenttimestamp","title":"function GetCurrentTimestamp","text":"<p>Get current timestamp in milliseconds. <pre><code>inline long GetCurrentTimestamp () \n</code></pre></p>"},{"location":"acdoxygen/utils_8h/#function-getfilenamefrompath","title":"function GetFileNameFromPath","text":"<p>Get the name of the file from the given path. <pre><code>inline std::string GetFileNameFromPath (\n    const std::string &amp; path,\n    bool withExtension=true\n) \n</code></pre></p>"},{"location":"acdoxygen/utils_8h/#function-getfilepaths","title":"function GetFilePaths","text":"<p>Get all file paths with the given extension in the given directory. <pre><code>inline std::vector&lt; std::string &gt; GetFilePaths (\n    const std::string &amp; dirPath,\n    const std::string &amp; extension\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirPath</code> </li> <li><code>extension</code> </li> </ul>"},{"location":"acdoxygen/utils_8h/#function-getfolderpaths","title":"function GetFolderPaths","text":"<p>Get all sub-folders' paths in the given directory. <pre><code>inline std::vector&lt; std::string &gt; GetFolderPaths (\n    const std::string &amp; dirPath\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>folderPath</code> </li> </ul>"},{"location":"acdoxygen/utils_8h/#function-isfileexist","title":"function IsFileExist","text":"<p>Check if the given file exists. <pre><code>inline bool IsFileExist (\n    const std::string &amp; name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> </li> </ul>"},{"location":"acdoxygen/utils_8h/#function-parseconfigfile","title":"function ParseConfigFile","text":"<p>Parse the config file and get the file paths. <pre><code>inline std::vector&lt; std::string &gt; ParseConfigFile (\n    const std::string &amp; configPath,\n    const std::string &amp; entryName\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>configPath</code> </li> <li><code>entryName</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>src/utils/utils.h</code></p>"},{"location":"acdoxygen/utils_8h_source/","title":"File utils.h","text":"<p>File List &gt; src &gt; utils &gt; utils.h</p> <p>Go to the documentation of this file</p> <pre><code>// #####################################################################\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BEGINNING OF LEGAL NOTICE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n//######################################################################\n//\n// This source file, along with its associated content, was authored by\n// Andrea Settimi, Hong-Bin Yang, Naravich Chutisilp, and numerous other\n// contributors. The code was originally developed at the Laboratory for\n// Timber Construction (IBOIS, director: Prof. Yves Weinand) at the School of \n// Architecture, Civil and Environmental Engineering (ENAC) at the Swiss\n// Federal Institute of Technology in Lausanne (EPFL) for the Doctoral\n// Research \"Augmented Carpentry\" (PhD researcher: Andrea Settimi,\n// co-director: Dr. Julien Gamerro, director: Prof. Yves Weinand).\n//\n// Although the entire repository is distributed under the GPL license,\n// these particular source files may also be used under the terms of the\n// MIT license. By accessing or using this file, you agree to the following:\n//\n// 1. You may reproduce, modify, and distribute this file in accordance\n//    with the terms of the MIT license.\n// 2. You must retain this legal notice in all copies or substantial\n//    portions of this file.\n// 3. This file is provided \"AS IS,\" without any express or implied\n//    warranties, including but not limited to the implied warranties of\n//    merchantability and fitness for a particular purpose.\n//\n// If you cannot or will not comply with the above conditions, you are\n// not permitted to use this file. By proceeding, you acknowledge and\n// accept all terms and conditions herein.\n//\n//######################################################################\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; END OF LEGAL NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n// #####################################################################\n//\n#pragma once\n\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;ctime&gt;\n#include &lt;sstream&gt;\n#include \"AIAC/Log.h\"\n#include \"glm/glm.hpp\"\n\n\ninline std::string GetCurrentDateTime() {\n    std::time_t t = std::time(nullptr);   // get time now\n    std::tm* now = std::localtime(&amp;t);\n\n    std::ostringstream ss;\n    ss &lt;&lt; (now-&gt;tm_year + 1900) &lt;&lt; '-'\n       &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (now-&gt;tm_mon + 1) &lt;&lt; '-'\n       &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;  now-&gt;tm_mday &lt;&lt; '-'\n       &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;  now-&gt;tm_hour &lt;&lt; '-'\n       &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;  now-&gt;tm_min &lt;&lt; '-'\n       &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;  now-&gt;tm_sec;\n\n    return ss.str();\n}\n\n\ninline long GetCurrentTimestamp()\n{\n    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();\n}\n\n\ninline bool IsFileExist (const std::string&amp; name) {\n    struct stat buffer{};\n    return (stat(name.c_str(), &amp;buffer) == 0);\n}\n\n\ninline std::vector&lt;std::string&gt; GetFolderPaths(const std::string&amp; dirPath)\n{\n    // check the dirPath is a directory and it exists\n    if (!std::filesystem::is_directory(dirPath) || !std::filesystem::exists(dirPath))\n    {\n        AIAC_ERROR(\"Error: {0} is not a directory or it does not exist!\", dirPath);\n        return {};\n    }\n\n    std::vector&lt;std::string&gt; folderPaths;\n\n    for (const auto &amp; entry : std::filesystem::directory_iterator(dirPath))\n    {\n        if (entry.is_directory())\n        {\n            folderPaths.push_back(entry.path());\n        }\n    }\n\n    return folderPaths;\n}\n\n\ninline std::vector&lt;std::string&gt; GetFilePaths(const std::string&amp; dirPath, const std::string&amp; extension)\n{\n    // check the dirPath is a directory and it exists\n    if (!std::filesystem::is_directory(dirPath) || !std::filesystem::exists(dirPath))\n    {\n        AIAC_ERROR(\"Error: {0} is not a directory or it does not exist!\", dirPath);\n        return {};\n    }\n\n    std::vector&lt;std::string&gt; filePaths;\n\n    for (const auto &amp; entry : std::filesystem::directory_iterator(dirPath))\n    {\n        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == extension)\n        {\n            filePaths.push_back(entry.path());\n        }\n    }\n\n    return filePaths;\n}\n\n\ninline void CopyFile(const std::string&amp; source, const std::string&amp; destination)\n{\n    std::filesystem::copy_file(source, destination, std::filesystem::copy_options::overwrite_existing);\n}\n\n\ninline std::vector&lt;std::string&gt; ParseConfigFile(const std::string&amp; configPath, const std::string&amp; entryName)\n{\n    cv::FileStorage fs(configPath, cv::FileStorage::READ);\n\n    if (!fs.isOpened())\n    {\n        AIAC_ERROR(\"Error: {0} is not a valid file!\", configPath);\n        return {};\n    }\n\n    cv::FileNode fn = fs[entryName];\n\n    if (fn.empty())\n    {\n        AIAC_ERROR(\"Error: {0} is not a valid entry name!\", entryName);\n        return {};\n    }\n\n    std::vector&lt;std::string&gt; filePaths;\n\n    for(auto &amp;&amp; it : fn)\n    {\n        filePaths.push_back((std::string)it);\n    }\n\n    return filePaths;\n}\n\ninline std::string GetFileNameFromPath(const std::string&amp; path, bool withExtension = true)\n{\n    std::filesystem::path p(path);\n    if (withExtension)\n    {\n        return p.filename().string();\n    }\n    return p.stem().string();\n}\n</code></pre>"},{"location":"acdoxygen/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace AIAC <ul> <li>namespace Utils </li> </ul> </li> <li>namespace glob </li> <li>namespace glob </li> <li>namespace inih </li> </ul>"},{"location":"acdoxygen/classes/","title":"Class Index","text":""},{"location":"acdoxygen/classes/#a","title":"a","text":"<ul> <li>ACInfoModel (AIAC)</li> <li>ACInfoToolhead (AIAC)</li> <li>ACInfoToolheadManager (AIAC)</li> <li>AppCloseEvent (AIAC)</li> <li>Application (AIAC)</li> <li>ApplicationSpecification (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#b","title":"b","text":"<ul> <li>BufferIterator</li> </ul>"},{"location":"acdoxygen/classes/#c","title":"c","text":"<ul> <li>Camera (AIAC)</li> <li>CameraCalibrationLoadedEvent (AIAC)</li> <li>CameraCalibrator (AIAC)</li> <li>ChainSawCutPlaneVisualizer (AIAC)</li> <li>ChainSawData (AIAC)</li> <li>Character (AIAC)</li> <li>CircularBuffer</li> <li>CircularSawCutBladeThicknessVisualizer (AIAC)</li> <li>CircularSawCutPlaneVisualizer (AIAC)</li> <li>CircularSawData (AIAC)</li> <li>CombineMapParams</li> <li>Component (AIAC::TimberInfo)</li> <li>Config (AIAC)</li> <li>Cut (AIAC::TimberInfo)</li> <li>CutBladeThicknessVisualizer (AIAC)</li> <li>CutChainSawAngleFeedVisualizer (AIAC)</li> <li>CutChainSawDepthFeedVisualizer (AIAC)</li> <li>CutChainSawFeedback (AIAC)</li> <li>CutChainSawFeedVisualizer (AIAC)</li> <li>CutCircularOrientationVisualizer (AIAC)</li> <li>CutCircularSawDepthVisualizer (AIAC)</li> <li>CutCircularSawFeedback (AIAC)</li> <li>CutCircularSawPositionStartVisualizer (AIAC)</li> <li>CutOrientationVisualizer (AIAC)</li> <li>CutPlaneVisualizer (AIAC)</li> <li>CylinderPole (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#d","title":"d","text":"<ul> <li>DLoader (AIAC)</li> <li>DrillBitData (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#e","title":"e","text":"<ul> <li>Edge (AIAC::TimberInfo::Cut)</li> <li>Event (AIAC)</li> <li>EventBus (AIAC)</li> <li>EventCompare (AIAC)</li> <li>EventPolicy (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#f","title":"f","text":"<ul> <li>FabFeedback (AIAC)</li> <li>Face (AIAC::TimberInfo::Cut)</li> <li>FeedbackVisualizer (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#g","title":"g","text":"<ul> <li>GLLineObject (AIAC)</li> <li>GLMeshObject (AIAC)</li> <li>glob (glob)</li> <li>glob_impl (glob)</li> <li>GLObject (AIAC)</li> <li>GLPointObject (AIAC)</li> <li>GOCircle (AIAC)</li> <li>GOColor (AIAC)</li> <li>GOCylinder (AIAC)</li> <li>GOLine (AIAC)</li> <li>GOMesh (AIAC)</li> <li>GOPoint (AIAC)</li> <li>GOPolyline (AIAC)</li> <li>GOPrimitive (AIAC)</li> <li>GORegistry (AIAC)</li> <li>GOText (AIAC)</li> <li>GOTextSize (AIAC)</li> <li>GOTriangle (AIAC)</li> <li>GOWeight (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#h","title":"h","text":"<ul> <li>Hole (AIAC::TimberInfo)</li> <li>HoleFeedback (AIAC)</li> <li>HoleFeedbackPosition (AIAC)</li> <li>HoleFeedbackRotation (AIAC)</li> <li>HoleFeedbackText (AIAC)</li> <li>HoleToolheadAxisExporter (AIAC::Utils)</li> </ul>"},{"location":"acdoxygen/classes/#i","title":"i","text":"<ul> <li>IGFD_Selection</li> <li>IGFD_Selection_Pair</li> <li>Image (AIAC)</li> <li>ImTexture (AIAC)</li> <li>INIReader (inih)</li> <li>INIWriter (inih)</li> </ul>"},{"location":"acdoxygen/classes/#l","title":"l","text":"<ul> <li>Layer (AIAC)</li> <li>LayerCamera (AIAC)</li> <li>LayerCameraCalib (AIAC)</li> <li>LayerFeedback (AIAC)</li> <li>LayerLogRecorder (AIAC)</li> <li>LayerModel (AIAC)</li> <li>LayerSlam (AIAC)</li> <li>LayerToolhead (AIAC)</li> <li>LayerUI (AIAC)</li> <li>LayerUtils (AIAC)</li> <li>Log (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#m","title":"m","text":"<ul> <li>MappingParams</li> </ul>"},{"location":"acdoxygen/classes/#p","title":"p","text":"<ul> <li>PaneUI (AIAC)</li> <li>Position (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#r","title":"r","text":"<ul> <li>ReconstructParams</li> <li>Renderer (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#s","title":"s","text":"<ul> <li>SaberSawData (AIAC)</li> <li>ScannedModel (AIAC)</li> <li>Screenshot (AIAC::Utils)</li> <li>SLAMCombineMapEvent (AIAC)</li> <li>SLAMMapLoadedEvent (AIAC)</li> <li>SLAMStartMappingEvent (AIAC)</li> <li>SLAMStopMappingEvent (AIAC)</li> <li>SLAMVocabularyLoadedEvent (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#t","title":"t","text":"<ul> <li>TextRenderer (AIAC)</li> <li>TimberInfo (AIAC)</li> <li>ToolHeadData (AIAC)</li> <li>TouchMonitor (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#v","title":"v","text":"<ul> <li>VideoRecorder (AIAC::Utils)</li> <li>Viewport (AIAC)</li> </ul>"},{"location":"acdoxygen/classes/#w","title":"w","text":"<ul> <li>Window (AIAC)</li> <li>WindowData</li> <li>WindowProps (AIAC)</li> </ul>"},{"location":"acdoxygen/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AIAC::ACInfoModel </li> <li>class AIAC::ACInfoToolhead the class holding the information of the toolhead (GOs, metadata, etc) </li> <li>class AIAC::ACInfoToolheadManager </li> <li>class AIAC::Event <ul> <li>class AIAC::AppCloseEvent </li> <li>class AIAC::CameraCalibrationLoadedEvent </li> <li>class AIAC::SLAMCombineMapEvent </li> <li>class AIAC::SLAMMapLoadedEvent </li> <li>class AIAC::SLAMStartMappingEvent </li> <li>class AIAC::SLAMStopMappingEvent </li> <li>class AIAC::SLAMVocabularyLoadedEvent </li> </ul> </li> <li>class AIAC::Application </li> <li>class AIAC::Camera </li> <li>class AIAC::CameraCalibrator </li> <li>class AIAC::FeedbackVisualizer <ul> <li>class AIAC::CutBladeThicknessVisualizer The idea behind the CutBladeThicknessVisualizer is to give a visual feedback on the thickness of the blade. We do this by intersecting the two neighbours faces of the current highlighted face. <ul> <li>class AIAC::CircularSawCutBladeThicknessVisualizer This is an inherited class to show the thickness of the blade on circular saws. </li> </ul> </li> <li>class AIAC::CutChainSawAngleFeedVisualizer </li> <li>class AIAC::CutChainSawDepthFeedVisualizer </li> <li>class AIAC::CutChainSawFeedVisualizer </li> <li>class AIAC::CutCircularOrientationVisualizer This visualizer ggdb ives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. </li> <li>class AIAC::CutCircularSawDepthVisualizer Visualizer for showing the depth of the cut. </li> <li>class AIAC::CutCircularSawPositionStartVisualizer This visualizer gives guidance on the start position of the lateral cuts for the circular saw. </li> <li>class AIAC::CutOrientationVisualizer This visualizer gives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45*. This way we can also have the direction towards which the blade needs to be tilted. </li> <li>class AIAC::CutPlaneVisualizer <ul> <li>class AIAC::ChainSawCutPlaneVisualizer </li> <li>class AIAC::CircularSawCutPlaneVisualizer </li> </ul> </li> <li>class AIAC::HoleFeedbackPosition The UI widget for providing feedback on position. </li> <li>class AIAC::HoleFeedbackRotation The UI widget for providing feedback on rotation. </li> <li>class AIAC::HoleFeedbackText The general visualizer for the info displayed as text. </li> </ul> </li> <li>class AIAC::Config </li> <li>class AIAC::FabFeedback <ul> <li>class AIAC::CutChainSawFeedback </li> <li>class AIAC::CutCircularSawFeedback </li> <li>class AIAC::HoleFeedback The UI widget for providing feedback on orientation Feeds (in chronological order): </li> </ul> </li> <li>class AIAC::DLoader </li> <li>class AIAC::EventBus </li> <li>class AIAC::GLObject <ul> <li>class AIAC::GLLineObject </li> <li>class AIAC::GLMeshObject </li> <li>class AIAC::GLPointObject </li> </ul> </li> <li>class AIAC::GOPrimitive <ul> <li>class AIAC::GOCircle </li> <li>class AIAC::GOCylinder </li> <li>class AIAC::GOLine </li> <li>class AIAC::GOMesh </li> <li>class AIAC::GOPoint </li> <li>class AIAC::GOPolyline </li> <li>class AIAC::GOText </li> <li>class AIAC::GOTriangle </li> </ul> </li> <li>class AIAC::GORegistry </li> <li>class AIAC::Image Class representing the main iamge object for AC. </li> <li>class AIAC::Layer <ul> <li>class AIAC::LayerCamera </li> <li>class AIAC::LayerCameraCalib </li> <li>class AIAC::LayerFeedback </li> <li>class AIAC::LayerLogRecorder </li> <li>class AIAC::LayerModel </li> <li>class AIAC::LayerSlam </li> <li>class AIAC::LayerToolhead </li> <li>class AIAC::LayerUI </li> <li>class AIAC::LayerUtils </li> </ul> </li> <li>class AIAC::Log </li> <li>class AIAC::PaneUI </li> <li>class AIAC::Renderer </li> <li>class AIAC::ScannedModel </li> <li>class AIAC::TextRenderer </li> <li>class AIAC::TimberInfo </li> <li>class AIAC::TimberInfo::Component <ul> <li>class AIAC::TimberInfo::Cut </li> <li>class AIAC::TimberInfo::Cut::Edge </li> <li>class AIAC::TimberInfo::Cut::Face </li> <li>class AIAC::TimberInfo::Hole </li> </ul> </li> <li>class AIAC::ToolHeadData Class holding and parse and create data from the .acit file of the toolhead. </li> <li>class AIAC::TouchMonitor </li> <li>class AIAC::Utils::HoleToolheadAxisExporter </li> <li>class AIAC::Utils::Screenshot </li> <li>class AIAC::Utils::VideoRecorder </li> <li>class AIAC::Viewport </li> <li>class AIAC::Window </li> <li>class CircularBuffer </li> <li>class glob::glob </li> <li>class glob::glob_impl </li> <li>class inih::INIReader </li> <li>class inih::INIWriter </li> <li>struct AIAC::ApplicationSpecification </li> <li>struct AIAC::ChainSawData </li> <li>struct AIAC::Character </li> <li>struct AIAC::CircularSawData </li> <li>struct AIAC::CylinderPole </li> <li>struct AIAC::DrillBitData </li> <li>struct AIAC::EventCompare </li> <li>struct AIAC::EventPolicy </li> <li>struct AIAC::GOColor </li> <li>struct AIAC::GOTextSize </li> <li>struct AIAC::GOWeight </li> <li>struct AIAC::ImTexture Structure representing an ImGui texture. </li> <li>struct AIAC::Position </li> <li>struct AIAC::SaberSawData </li> <li>struct AIAC::WindowProps </li> <li>struct AIAC::LayerUI::CombineMapParams </li> <li>struct AIAC::LayerUI::MappingParams </li> <li>struct AIAC::LayerUI::ReconstructParams </li> <li>struct AIAC::Window::WindowData </li> <li>struct CircularBuffer::BufferIterator </li> <li>struct IGFD_Selection </li> <li>struct IGFD_Selection_Pair </li> </ul>"},{"location":"acdoxygen/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"acdoxygen/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"acdoxygen/class_members/","title":"Class Members","text":""},{"location":"acdoxygen/class_members/#a","title":"a","text":"<ul> <li>ACInfoModel (AIAC::ACInfoModel)</li> <li>AddMeasuredBboxLength (AIAC::ACInfoModel)</li> <li>AdjustScale (AIAC::ACInfoModel)</li> <li>ACInfoToolhead (AIAC::ACInfoToolhead)</li> <li>AddGOsInfo (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoChainSaw (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoCircularSaw (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoDrillBit (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoSaberSaw (AIAC::ACInfoToolhead)</li> <li>ACInfoToolheadManager (AIAC::ACInfoToolheadManager, AIAC::LayerToolhead)</li> <li>AppCloseEvent (AIAC::AppCloseEvent)</li> <li>Application (AIAC::Application)</li> <li>AddImage (AIAC::CameraCalibrator)</li> <li>aspectRatio (AIAC::CameraCalibrator)</li> <li>Advance (AIAC::Character)</li> <li>AC_INFO_MODEL (AIAC::Config)</li> <li>ALIGN_FLIP (AIAC::Config)</li> <li>ALIGN_OFFSET (AIAC::Config)</li> <li>ALIGN_ROTATION (AIAC::Config)</li> <li>Activate (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::CutPlaneVisualizer, AIAC::FabFeedback, AIAC::FeedbackVisualizer, AIAC::HoleFeedback, AIAC::Viewport)</li> <li>Add (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle)</li> <li>Average (AIAC::GOTextSize)</li> <li>AvailableDevices (AIAC::LayerCamera)</li> <li>AutoCapture (AIAC::LayerCameraCalib)</li> <li>ActivateCurrentFeedbackVisibility (AIAC::LayerFeedback)</li> <li>AddAlignOffset (AIAC::LayerModel)</li> <li>AlignModels (AIAC::LayerModel)</li> <li>AdjustTarget (AIAC::LayerUI)</li> <li>AABBScaleFactor (AIAC::LayerUI::ReconstructParams)</li> <li>at (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_members/#b","title":"b","text":"<ul> <li>boardSize (AIAC::CameraCalibrator)</li> <li>Bearing (AIAC::Character)</li> <li>BindVBOs (AIAC::GLObject)</li> <li>BufferData (AIAC::GLObject)</li> <li>BLACK (AIAC::GOColor)</li> <li>BLUE (AIAC::GOColor)</li> <li>BROWN (AIAC::GOColor)</li> <li>Big (AIAC::GOTextSize)</li> <li>BitSmall (AIAC::GOTextSize)</li> <li>Bold (AIAC::GOWeight)</li> <li>BoldThick (AIAC::GOWeight)</li> <li>BuildBoundingBox (AIAC::ScannedModel)</li> <li>back (CircularBuffer)</li> <li>begin (CircularBuffer)</li> <li>buffer_size (CircularBuffer)</li> <li>BufferIterator (CircularBuffer::BufferIterator)</li> <li>BoolConverter (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_members/#c","title":"c","text":"<ul> <li>Clear (AIAC::ACInfoModel, AIAC::GORegistry, AIAC::LayerCameraCalib)</li> <li>CopyGOsInfoOriginal (AIAC::ACInfoToolhead)</li> <li>Close (AIAC::Application)</li> <li>Camera (AIAC::Camera)</li> <li>CameraCalibrationLoadedEvent (AIAC::CameraCalibrationLoadedEvent)</li> <li>CalcBoardCornerPositions (AIAC::CameraCalibrator)</li> <li>CameraCalibrator (AIAC::CameraCalibrator)</li> <li>ClearImages (AIAC::CameraCalibrator)</li> <li>calibFixPrincipalPoint (AIAC::CameraCalibrator)</li> <li>calibFlag (AIAC::CameraCalibrator)</li> <li>calibZeroTangentDist (AIAC::CameraCalibrator)</li> <li>calibrationPattern (AIAC::CameraCalibrator)</li> <li>cameraMatrix (AIAC::CameraCalibrator)</li> <li>ChainSawCutPlaneVisualizer (AIAC::ChainSawCutPlaneVisualizer)</li> <li>ChainBaseACIT (AIAC::ChainSawData)</li> <li>ChainBaseGO (AIAC::ChainSawData)</li> <li>ChainEndGO (AIAC::ChainSawData)</li> <li>ChainMidACIT (AIAC::ChainSawData)</li> <li>ChainMidGO (AIAC::ChainSawData)</li> <li>ChainNormEndACIT (AIAC::ChainSawData)</li> <li>ChainSawData (AIAC::ChainSawData)</li> <li>CircularSawCutBladeThicknessVisualizer (AIAC::CircularSawCutBladeThicknessVisualizer)</li> <li>CircularSawCutPlaneVisualizer (AIAC::CircularSawCutPlaneVisualizer)</li> <li>CenterACIT (AIAC::CircularSawData)</li> <li>CenterGO (AIAC::CircularSawData)</li> <li>CircularSawData (AIAC::CircularSawData)</li> <li>CACHED_TOOLHEAD (AIAC::Config)</li> <li>CAM_FLIP_HORIZONTAL (AIAC::Config)</li> <li>CAM_FLIP_VERTICAL (AIAC::Config)</li> <li>CAM_ID (AIAC::Config)</li> <li>CAM_PARAMS_FILE (AIAC::Config)</li> <li>CONFIG_FILE (AIAC::Config)</li> <li>Config (AIAC::Config)</li> <li>CutBladeThicknessVisualizer (AIAC::CutBladeThicknessVisualizer)</li> <li>CutChainSawAngleFeedVisualizer (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>CutChainSawDepthFeedVisualizer (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>CutChainSawFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>CutChainSawFeedback (AIAC::CutChainSawFeedback)</li> <li>CutCircularOrientationVisualizer (AIAC::CutCircularOrientationVisualizer)</li> <li>CutCircularSawDepthVisualizer (AIAC::CutCircularSawDepthVisualizer)</li> <li>CutCircularSawFeedback (AIAC::CutCircularSawFeedback)</li> <li>CutCircularSawPositionStartVisualizer (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>CutOrientationVisualizer (AIAC::CutOrientationVisualizer)</li> <li>CutPlaneVisualizer (AIAC::CutPlaneVisualizer)</li> <li>CvtAssimpMeshColorsToGlmVector (AIAC::DLoader)</li> <li>CvtAssimpMeshFacesToGlmVector (AIAC::DLoader)</li> <li>CvtAssimpMeshNormalsToGlmVector (AIAC::DLoader)</li> <li>CvtAssimpMeshToGOMesh (AIAC::DLoader)</li> <li>CvtAssimpMeshVerticesToGlmVector (AIAC::DLoader)</li> <li>ChucktipACIT (AIAC::DrillBitData)</li> <li>ChucktipGO (AIAC::DrillBitData)</li> <li>colorBuf (AIAC::GLObject)</li> <li>ClosestDistanceFromLineToCircle (AIAC::GOCircle)</li> <li>ClosestDistanceFromSegmentToCircle (AIAC::GOCircle)</li> <li>ClosestPointToCircle (AIAC::GOCircle)</li> <li>ClosestPointToPoint (AIAC::GOCircle)</li> <li>CYAN (AIAC::GOColor)</li> <li>ComputeAngle (AIAC::GOLine)</li> <li>ComputeSignedAngle (AIAC::GOLine)</li> <li>ClearGLObject (AIAC::GOPrimitive)</li> <li>CheckIfKeyExists (AIAC::GORegistry)</li> <li>Count (AIAC::GORegistry)</li> <li>ChangeAlignRotation (AIAC::LayerModel)</li> <li>CreateFolder (AIAC::LayerUtils)</li> <li>CheckOnCollapsing (AIAC::PaneUI)</li> <li>CollapseState (AIAC::PaneUI)</li> <li>CameraFrameType (AIAC::Renderer)</li> <li>Characters (AIAC::TextRenderer)</li> <li>Component (AIAC::TimberInfo::Component)</li> <li>ClearCotas (AIAC::TimberInfo::Cut::Edge)</li> <li>Cut (AIAC::TimberInfo::Cut)</li> <li>CaptureBuffer (AIAC::Utils::Screenshot)</li> <li>CaptureWindow (AIAC::Utils::Screenshot)</li> <li>CaptureFrames (AIAC::Utils::VideoRecorder)</li> <li>CreaseAngleThreshold (AIAC::LayerUI::ReconstructParams)</li> <li>CircularBuffer (CircularBuffer)</li> <li>capacity (CircularBuffer)</li> <li>cbegin (CircularBuffer)</li> <li>cend (CircularBuffer)</li> <li>clear (CircularBuffer)</li> <li>const_iterator (CircularBuffer)</li> <li>const_pointer (CircularBuffer)</li> <li>const_reference (CircularBuffer)</li> <li>cbuf_pointer (CircularBuffer::BufferIterator)</li> <li>count (IGFD_Selection)</li> <li>close (glob::glob)</li> <li>current_match (glob::glob)</li> <li>Converter (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_members/#d","title":"d","text":"<ul> <li>DetectPattern (AIAC::CameraCalibrator)</li> <li>distCoeffs (AIAC::CameraCalibrator)</li> <li>DATASET_DIR (AIAC::Config)</li> <li>Deactivate (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::CutPlaneVisualizer, AIAC::FabFeedback, AIAC::FeedbackVisualizer, AIAC::HoleFeedback)</li> <li>DLoader (AIAC::DLoader)</li> <li>DrillBitData (AIAC::DrillBitData)</li> <li>DispatchEvent (AIAC::EventBus)</li> <li>Draw (AIAC::GLLineObject, AIAC::GLMeshObject, AIAC::GLObject, AIAC::GLPointObject, AIAC::GOPrimitive)</li> <li>DeleteVBOs (AIAC::GLObject)</li> <li>DistanceTo (AIAC::GOPoint)</li> <li>Default (AIAC::GOTextSize, AIAC::GOWeight)</li> <li>DeleteGlTexture (AIAC::Image)</li> <li>Delay (AIAC::LayerCameraCalib)</li> <li>DeactivateCurrentFeedbackVisibility (AIAC::LayerFeedback)</li> <li>DetectToolhead (AIAC::LayerToolhead)</li> <li>DeleteFrameFolder (AIAC::Utils::VideoRecorder)</li> <li>data (CircularBuffer)</li> <li>difference_type (CircularBuffer, CircularBuffer::BufferIterator)</li> <li>dir_path (glob::glob)</li> <li>dir (glob::glob_impl)</li> <li>dir_entry (glob::glob_impl)</li> </ul>"},{"location":"acdoxygen/class_members/#e","title":"e","text":"<ul> <li>EnableCutPlane (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::LayerFeedback)</li> <li>EattipACIT (AIAC::DrillBitData)</li> <li>EattipGO (AIAC::DrillBitData)</li> <li>Event (AIAC::Event)</li> <li>EnqueueEvent (AIAC::EventBus)</li> <li>ExtendBothEnds (AIAC::GOLine)</li> <li>ExtendFromEnd (AIAC::GOLine)</li> <li>ExtendFromStart (AIAC::GOLine)</li> <li>ExtraSmall (AIAC::GOTextSize)</li> <li>ExtraThick (AIAC::GOWeight)</li> <li>ExportHoleToolheadAxis (AIAC::LayerUtils)</li> <li>Edge (AIAC::TimberInfo::Cut::Edge)</li> <li>ExportCoordinates (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>ExportHoleAxis (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>ExportToolheadAxis (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>Eps (AIAC::LayerUI::ReconstructParams)</li> <li>ExportPath (AIAC::LayerUI::ReconstructParams)</li> <li>empty (CircularBuffer)</li> <li>end (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_members/#f","title":"f","text":"<ul> <li>FlipHorizontal (AIAC::Camera)</li> <li>FlipVertical (AIAC::Camera)</li> <li>fixDistortion (AIAC::CameraCalibrator)</li> <li>flipVertical (AIAC::CameraCalibrator)</li> <li>FabFeedback (AIAC::FabFeedback)</li> <li>FeedbackVisualizer (AIAC::FeedbackVisualizer)</li> <li>FlipAlign (AIAC::LayerModel)</li> <li>ForceAlignToEnd (AIAC::LayerModel)</li> <li>Func (AIAC::PaneUI)</li> <li>Face (AIAC::TimberInfo::Cut::Face)</li> <li>FilePathTarget (AIAC::LayerUI::CombineMapParams)</li> <li>front (CircularBuffer)</li> <li>full (CircularBuffer)</li> <li>fileName (IGFD_Selection_Pair)</li> <li>filePathName (IGFD_Selection_Pair)</li> <li>file_pattern (glob::glob_impl)</li> </ul>"},{"location":"acdoxygen/class_members/#g","title":"g","text":"<ul> <li>GetDoc (AIAC::ACInfoModel)</li> <li>GetFilePath (AIAC::ACInfoModel)</li> <li>GetLength (AIAC::ACInfoModel, AIAC::GOLine, AIAC::ScannedModel)</li> <li>GetMeasuredBboxLength (AIAC::ACInfoModel)</li> <li>GetName (AIAC::ACInfoModel, AIAC::ACInfoToolhead, AIAC::GOPrimitive, AIAC::ToolHeadData)</li> <li>GetRealWorldLength (AIAC::ACInfoModel)</li> <li>GetTimberInfo (AIAC::ACInfoModel)</li> <li>GetData (AIAC::ACInfoToolhead, AIAC::ToolHeadData)</li> <li>GetId (AIAC::ACInfoToolhead, AIAC::GOPrimitive)</li> <li>GetType (AIAC::ACInfoToolhead, AIAC::Event, AIAC::GOPrimitive, AIAC::ToolHeadData)</li> <li>GetTypeString (AIAC::ACInfoToolhead, AIAC::TimberInfo::Component, AIAC::ToolHeadData)</li> <li>GetActiveToolhead (AIAC::ACInfoToolheadManager)</li> <li>GetActiveToolheadName (AIAC::ACInfoToolheadManager)</li> <li>GetActiveToolheadType (AIAC::ACInfoToolheadManager)</li> <li>GetToolhead (AIAC::ACInfoToolheadManager)</li> <li>GetToolheadNames (AIAC::ACInfoToolheadManager)</li> <li>GetToolheadType (AIAC::ACInfoToolheadManager)</li> <li>GetEventBus (AIAC::Application)</li> <li>GetGORegistry (AIAC::Application)</li> <li>GetInstance (AIAC::Application)</li> <li>GetLayer (AIAC::Application)</li> <li>GetRenderer (AIAC::Application)</li> <li>GetSpecification (AIAC::Application)</li> <li>GetWindow (AIAC::Application)</li> <li>GetCalibrationFilePath (AIAC::Camera)</li> <li>GetCameraMatrix (AIAC::Camera)</li> <li>GetCenterCroppedCurrentFrame (AIAC::Camera)</li> <li>GetColorCurrentFrame (AIAC::Camera)</li> <li>GetCurrentFrame (AIAC::Camera)</li> <li>GetDistortionCoef (AIAC::Camera)</li> <li>GetFov (AIAC::Camera)</li> <li>GetHeight (AIAC::Camera, AIAC::Image, AIAC::Window)</li> <li>GetNextFrame (AIAC::Camera)</li> <li>GetRawCurrentFrame (AIAC::Camera)</li> <li>GetRawHeight (AIAC::Camera)</li> <li>GetRawWidth (AIAC::Camera)</li> <li>GetWidth (AIAC::Camera, AIAC::Image, AIAC::Window)</li> <li>GetImageAmount (AIAC::CameraCalibrator)</li> <li>goodInput (AIAC::CameraCalibrator)</li> <li>gridWidth (AIAC::CameraCalibrator)</li> <li>Get (AIAC::Config, AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle, inih::INIReader)</li> <li>GetVector (AIAC::Config, inih::INIReader)</li> <li>GetAngleFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>GetDepthFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>GetCategory (AIAC::Event, AIAC::EventPolicy)</li> <li>GetEvent (AIAC::EventPolicy)</li> <li>GLLineObject (AIAC::GLLineObject)</li> <li>GLMeshObject (AIAC::GLMeshObject)</li> <li>GLObject (AIAC::GLObject)</li> <li>GLPointObject (AIAC::GLPointObject)</li> <li>GOCircle (AIAC::GOCircle)</li> <li>GetAll (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle)</li> <li>GetCenter (AIAC::GOCircle, AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut::Face, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>GetEdgeColor (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>GetNormal (AIAC::GOCircle, AIAC::TimberInfo::Cut::Face)</li> <li>GetRadius (AIAC::GOCircle, AIAC::GOCylinder, AIAC::TimberInfo::Hole)</li> <li>GRAY (AIAC::GOColor)</li> <li>GREEN (AIAC::GOColor)</li> <li>GREEN_DARKER_TRANSP07 (AIAC::GOColor)</li> <li>GREEN_PUNK_TRANSP07 (AIAC::GOColor)</li> <li>GREEN_TRANSP07 (AIAC::GOColor)</li> <li>GOCylinder (AIAC::GOCylinder)</li> <li>GetPEnd (AIAC::GOCylinder, AIAC::GOLine)</li> <li>GetPStart (AIAC::GOCylinder, AIAC::GOLine)</li> <li>GOLine (AIAC::GOLine)</li> <li>GetMidPoint (AIAC::GOLine)</li> <li>GetMidPointValues (AIAC::GOLine)</li> <li>GetNormalValues (AIAC::GOLine)</li> <li>GOMesh (AIAC::GOMesh)</li> <li>GetColors (AIAC::GOMesh)</li> <li>GetIndices (AIAC::GOMesh)</li> <li>GetNormals (AIAC::GOMesh)</li> <li>GetVertices (AIAC::GOMesh, AIAC::GOTriangle)</li> <li>GOPoint (AIAC::GOPoint)</li> <li>GetPosition (AIAC::GOPoint)</li> <li>GOPolyline (AIAC::GOPolyline)</li> <li>GetPoints (AIAC::GOPolyline)</li> <li>GOPrimitive (AIAC::GOPrimitive)</li> <li>GenerateId (AIAC::GOPrimitive)</li> <li>GetColor (AIAC::GOPrimitive)</li> <li>GetState (AIAC::GOPrimitive)</li> <li>GetVisibility (AIAC::GOPrimitive)</li> <li>GetWeight (AIAC::GOPrimitive)</li> <li>GORegistry (AIAC::GORegistry)</li> <li>GetAllGOs (AIAC::GORegistry)</li> <li>GetGO (AIAC::GORegistry)</li> <li>GOText (AIAC::GOText)</li> <li>GetAnchor (AIAC::GOText)</li> <li>GetText (AIAC::GOText)</li> <li>GetTextSize (AIAC::GOText)</li> <li>GOTriangle (AIAC::GOTriangle)</li> <li>GetCvMat (AIAC::Image)</li> <li>GetGlTextureObj (AIAC::Image)</li> <li>GetImTexture (AIAC::Image)</li> <li>GetPath (AIAC::Image)</li> <li>GetPureCvMat (AIAC::Image)</li> <li>GetCurrentDevice (AIAC::LayerCamera)</li> <li>GetCurrentDeviceIndex (AIAC::LayerCamera)</li> <li>GetCameraCalibrator (AIAC::LayerCameraCalib)</li> <li>GetCurrentFabFeedback (AIAC::LayerFeedback)</li> <li>GetACInfoModel (AIAC::LayerModel)</li> <li>GetACInfoModelName (AIAC::LayerModel)</li> <li>GetACInfoModelPath (AIAC::LayerModel)</li> <li>GetAlignFlip (AIAC::LayerModel)</li> <li>GetAlignOffset (AIAC::LayerModel)</li> <li>GetAlignRotation (AIAC::LayerModel)</li> <li>GetScannedModel (AIAC::LayerModel)</li> <li>GetScannedModelPath (AIAC::LayerModel)</li> <li>GetTransformMat (AIAC::LayerModel)</li> <li>GetCamPoseCv (AIAC::LayerSlam)</li> <li>GetCamPoseGlm (AIAC::LayerSlam)</li> <li>GetCamPoseInObjCoord (AIAC::LayerSlam)</li> <li>GetCamPoseQuaternionAndTvec (AIAC::LayerSlam)</li> <li>GetInvCamPoseGlm (AIAC::LayerSlam)</li> <li>GetNumLostFrame (AIAC::LayerSlam)</li> <li>GetProcessedFrame (AIAC::LayerSlam)</li> <li>GetClassifierLog (AIAC::LayerToolhead)</li> <li>GetClassifierToolheadList (AIAC::LayerToolhead)</li> <li>GetPose (AIAC::LayerToolhead)</li> <li>GetTrackingStatus (AIAC::LayerToolhead)</li> <li>GetTtoolState (AIAC::LayerToolhead)</li> <li>GetWorldPose (AIAC::LayerToolhead)</li> <li>GetOpenedPaneUI (AIAC::LayerUI)</li> <li>GetSaveFolderPath (AIAC::LayerUtils)</li> <li>GetLogger (AIAC::Log)</li> <li>GetCamCalibView (AIAC::Renderer)</li> <li>GetGlobalView (AIAC::Renderer)</li> <li>GetMappingView (AIAC::Renderer)</li> <li>GetBboxEdgesIndices (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>GetBoundingBox (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>GetEndPt (AIAC::TimberInfo::Cut::Edge)</li> <li>GetStartPt (AIAC::TimberInfo::Cut::Edge)</li> <li>GetCorners (AIAC::TimberInfo::Cut::Face)</li> <li>GetEdges (AIAC::TimberInfo::Cut::Face)</li> <li>GetNeighbors (AIAC::TimberInfo::Cut::Face)</li> <li>GetAllEdges (AIAC::TimberInfo::Cut)</li> <li>GetAllFaces (AIAC::TimberInfo::Cut)</li> <li>GetAllNonExposedEdgeIDs (AIAC::TimberInfo::Cut)</li> <li>GetAllNonExposedFaceIDs (AIAC::TimberInfo::Cut)</li> <li>GetEdge (AIAC::TimberInfo::Cut)</li> <li>GetFace (AIAC::TimberInfo::Cut)</li> <li>GetFaceNeighbors (AIAC::TimberInfo::Cut)</li> <li>GetHighlightedFace (AIAC::TimberInfo::Cut)</li> <li>GetHighlightedFaceID (AIAC::TimberInfo::Cut)</li> <li>GetHighlightedFaceNeighbors (AIAC::TimberInfo::Cut)</li> <li>GetEndPointGO (AIAC::TimberInfo::Hole)</li> <li>GetStartPointGO (AIAC::TimberInfo::Hole)</li> <li>GetAllComponentsIDs (AIAC::TimberInfo)</li> <li>GetComponent (AIAC::TimberInfo)</li> <li>GetCurrentComponent (AIAC::TimberInfo)</li> <li>GetCurrentComponentID (AIAC::TimberInfo)</li> <li>GetFabricatedComponents (AIAC::TimberInfo)</li> <li>GetFabricationProgress (AIAC::TimberInfo)</li> <li>GetID (AIAC::TimberInfo)</li> <li>GetTotalComponents (AIAC::TimberInfo)</li> <li>GetScaleF (AIAC::ToolHeadData)</li> <li>GetGLFWMonitor (AIAC::TouchMonitor)</li> <li>GetMonitorID (AIAC::TouchMonitor)</li> <li>GetCurrentTimestamp (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>GenerateImageName (AIAC::Utils::Screenshot)</li> <li>GetH (AIAC::Viewport)</li> <li>GetTexture (AIAC::Viewport)</li> <li>GetW (AIAC::Viewport)</li> <li>GetDisplayH (AIAC::Window)</li> <li>GetDisplayW (AIAC::Window)</li> <li>GetGLFWWindow (AIAC::Window)</li> <li>GetGlslVersion (AIAC::Window)</li> <li>glob (glob::glob)</li> <li>glob_impl (glob::glob_impl)</li> </ul>"},{"location":"acdoxygen/class_members/#h","title":"h","text":"<ul> <li>HoleFeedback (AIAC::HoleFeedback)</li> <li>HoleFeedbackPosition (AIAC::HoleFeedbackPosition)</li> <li>HoleFeedbackRotation (AIAC::HoleFeedbackRotation)</li> <li>HoleFeedbackText (AIAC::HoleFeedbackText)</li> <li>HasGlTextureObj (AIAC::Image)</li> <li>HasImTexture (AIAC::Image)</li> <li>HighlightFace (AIAC::TimberInfo::Cut)</li> <li>Hole (AIAC::TimberInfo::Hole)</li> <li>HideAllComponentsExceptCurrent (AIAC::TimberInfo)</li> <li>HoleToolheadAxisExporter (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>Height (AIAC::WindowProps, AIAC::Window::WindowData)</li> </ul>"},{"location":"acdoxygen/class_members/#i","title":"i","text":"<ul> <li>Init (AIAC::Application, AIAC::EventBus, AIAC::GORegistry, AIAC::Log, AIAC::Renderer, AIAC::TextRenderer, AIAC::TouchMonitor, AIAC::Viewport, AIAC::Window)</li> <li>IsResizable (AIAC::ApplicationSpecification, AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>IsOpened (AIAC::Camera)</li> <li>IsPhysicalAndParamWidthHeightMatched (AIAC::Camera)</li> <li>imageList (AIAC::CameraCalibrator)</li> <li>imagePoints (AIAC::CameraCalibrator)</li> <li>imageSize (AIAC::CameraCalibrator)</li> <li>IntersectBladeWithNeighbours (AIAC::CircularSawCutBladeThicknessVisualizer, AIAC::CutBladeThicknessVisualizer)</li> <li>InsertEntry (AIAC::Config, inih::INIReader)</li> <li>IsSegmenDetectToolPlaneVisible (AIAC::CutBladeThicknessVisualizer)</li> <li>IsRefFacesSelectedManually (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>IsEventQueueEmpty (AIAC::EventBus)</li> <li>indexBuf (AIAC::GLMeshObject)</li> <li>InitGLObject (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOTriangle)</li> <li>IsClosed (AIAC::GOPolyline)</li> <li>IsVisible (AIAC::GOPrimitive)</li> <li>ID (AIAC::ImTexture)</li> <li>Image (AIAC::Image)</li> <li>IsCalibrating (AIAC::LayerCameraCalib)</li> <li>IsCapturing (AIAC::LayerCameraCalib)</li> <li>InitACIMStatus (AIAC::LayerLogRecorder)</li> <li>InitTToolStatus (AIAC::LayerLogRecorder)</li> <li>IsPaused (AIAC::LayerLogRecorder)</li> <li>IsRecording (AIAC::LayerLogRecorder)</li> <li>InitSlamMapGOs (AIAC::LayerSlam)</li> <li>IsMapping (AIAC::LayerSlam)</li> <li>IsTracked (AIAC::LayerSlam)</li> <li>IsSavePoseLog (AIAC::LayerToolhead)</li> <li>IsShowShaded (AIAC::LayerToolhead)</li> <li>IsShowSilouhette (AIAC::LayerToolhead)</li> <li>IsShowToolheadGOInfo (AIAC::LayerToolhead)</li> <li>IsProcessing (AIAC::LayerUtils)</li> <li>InitCamCalibView (AIAC::Renderer)</li> <li>InitGlobalView (AIAC::Renderer)</li> <li>InitMappingView (AIAC::Renderer)</li> <li>InitProjMatrix (AIAC::Renderer)</li> <li>IsMarkedDone (AIAC::TimberInfo::Component)</li> <li>IsExposed (AIAC::TimberInfo::Cut::Face)</li> <li>IsSingleFace (AIAC::TimberInfo::Cut)</li> <li>IsShowingAllComponents (AIAC::TimberInfo)</li> <li>IsShowingCotas (AIAC::TimberInfo)</li> <li>ImportNameFromConfig (AIAC::TouchMonitor)</li> <li>ImportResolutionFromConfig (AIAC::TouchMonitor)</li> <li>ImportVideoModeFromConfig (AIAC::TouchMonitor)</li> <li>InitializeDirectories (AIAC::Utils::VideoRecorder)</li> <li>IsOpen (AIAC::Window)</li> <li>IsVSync (AIAC::Window)</li> <li>iterator (CircularBuffer)</li> <li>iterator_category (CircularBuffer::BufferIterator)</li> <li>impl_ (glob::glob)</li> <li>is_valid (glob::glob)</li> <li>INIReader (inih::INIReader)</li> <li>INIWriter (inih::INIWriter)</li> </ul>"},{"location":"acdoxygen/class_members/#j","title":"j","text":"<ul> <li>JustCaptured (AIAC::LayerCameraCalib)</li> </ul>"},{"location":"acdoxygen/class_members/#k","title":"k","text":"<ul> <li>Keys (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_members/#l","title":"l","text":"<ul> <li>Load (AIAC::ACInfoModel, AIAC::ScannedModel)</li> <li>LoadToolheadModels (AIAC::ACInfoToolheadManager)</li> <li>LoadCameraParams (AIAC::Camera)</li> <li>LINK_MODE (AIAC::Config)</li> <li>LoadGOMesh (AIAC::DLoader)</li> <li>lineWidth (AIAC::GLLineObject)</li> <li>LoadPly (AIAC::GOMesh)</li> <li>Light (AIAC::GOWeight)</li> <li>LayerCamera (AIAC::LayerCamera)</li> <li>LayerCameraCalib (AIAC::LayerCameraCalib)</li> <li>LayerFeedback (AIAC::LayerFeedback)</li> <li>LayerLogRecorder (AIAC::LayerLogRecorder)</li> <li>LogACIM (AIAC::LayerLogRecorder)</li> <li>LogACIMTransformation (AIAC::LayerLogRecorder)</li> <li>LogHeader (AIAC::LayerLogRecorder)</li> <li>LogSlamStatus (AIAC::LayerLogRecorder)</li> <li>LogTToolHead (AIAC::LayerLogRecorder)</li> <li>LogTToolPose (AIAC::LayerLogRecorder)</li> <li>LogTToolTransformation (AIAC::LayerLogRecorder)</li> <li>LayerModel (AIAC::LayerModel)</li> <li>LoadACInfoModel (AIAC::LayerModel)</li> <li>LoadScannedModel (AIAC::LayerModel)</li> <li>LayerSlam (AIAC::LayerSlam)</li> <li>LayerToolhead (AIAC::LayerToolhead)</li> <li>LayerUI (AIAC::LayerUI)</li> <li>LoadReconstructParams (AIAC::LayerUI)</li> <li>LoadReconstructParamsFromFile (AIAC::LayerUI)</li> <li>LayerUtils (AIAC::LayerUtils)</li> <li>LoadACIT (AIAC::ToolHeadData)</li> </ul>"},{"location":"acdoxygen/class_members/#m","title":"m","text":"<ul> <li>m_ACIMDoc (AIAC::ACInfoModel)</li> <li>m_BboxGOLines (AIAC::ACInfoModel, AIAC::ScannedModel)</li> <li>m_EdgeWeight (AIAC::ACInfoModel)</li> <li>m_FilePath (AIAC::ACInfoModel, AIAC::CameraCalibrationLoadedEvent, AIAC::SLAMMapLoadedEvent, AIAC::SLAMVocabularyLoadedEvent)</li> <li>m_LabelSize (AIAC::ACInfoModel)</li> <li>m_MeasuredBboxLength (AIAC::ACInfoModel)</li> <li>m_Scale (AIAC::ACInfoModel, AIAC::TimberInfo::Component)</li> <li>m_TimberInfo (AIAC::ACInfoModel)</li> <li>m_ACITPath (AIAC::ACInfoToolhead)</li> <li>m_Data (AIAC::ACInfoToolhead, AIAC::Window)</li> <li>m_GOPrimitivesInfo (AIAC::ACInfoToolhead)</li> <li>m_GOPrimitivesInfoOriginal (AIAC::ACInfoToolhead)</li> <li>m_ID (AIAC::ACInfoToolhead, AIAC::TimberInfo::Component, AIAC::TimberInfo, AIAC::TouchMonitor)</li> <li>m_OBJPath (AIAC::ACInfoToolhead)</li> <li>m_ACInfoToolheadMap (AIAC::ACInfoToolheadManager)</li> <li>m_ActiveACInfoToolhead (AIAC::ACInfoToolheadManager)</li> <li>m_AppSpec (AIAC::Application)</li> <li>m_EventBus (AIAC::Application)</li> <li>m_GORegistry (AIAC::Application)</li> <li>m_IsRunning (AIAC::Application)</li> <li>m_LayerMap (AIAC::Application)</li> <li>m_LayerStack (AIAC::Application)</li> <li>m_Renderer (AIAC::Application)</li> <li>m_Window (AIAC::Application)</li> <li>m_CalibFilePath (AIAC::Camera)</li> <li>m_CalibratedCurrentFrame (AIAC::Camera)</li> <li>m_CameraMatrix (AIAC::Camera)</li> <li>m_CenterCroppedCurrentFrame (AIAC::Camera)</li> <li>m_DistortionCoef (AIAC::Camera)</li> <li>m_FovX (AIAC::Camera)</li> <li>m_FovY (AIAC::Camera)</li> <li>m_GrayCalibratedCurrentFrame (AIAC::Camera)</li> <li>m_IsCamMatrixInit (AIAC::Camera)</li> <li>m_IsFisheye (AIAC::Camera)</li> <li>m_IsOpened (AIAC::Camera)</li> <li>m_ParamHeight (AIAC::Camera)</li> <li>m_ParamWidth (AIAC::Camera)</li> <li>m_PhysicalHeight (AIAC::Camera)</li> <li>m_PhysicalWidth (AIAC::Camera)</li> <li>m_RawCurrentFrame (AIAC::Camera)</li> <li>m_UndistortMap (AIAC::Camera)</li> <li>m_VideoCapture (AIAC::Camera)</li> <li>MAP_FILE (AIAC::Config)</li> <li>m_Filename (AIAC::Config)</li> <li>m_IniReader (AIAC::Config)</li> <li>m_UpdateFile (AIAC::Config)</li> <li>m_BladeOverhangScaled (AIAC::CutBladeThicknessVisualizer)</li> <li>m_BladeTotalThicknessScaled (AIAC::CutBladeThicknessVisualizer)</li> <li>m_DisplacedCenterAwayFromCamera (AIAC::CutBladeThicknessVisualizer)</li> <li>m_DisplacedCenterTowardsCamera (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmenDetectToolPlane (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentAwayFromCameraA (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentAwayFromCameraB (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentTowardsCameraA (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentTowardsCameraB (AIAC::CutBladeThicknessVisualizer)</li> <li>m_NormalOppositeUnitized (AIAC::CutBladeThicknessVisualizer)</li> <li>m_NormalUnitized (AIAC::CutBladeThicknessVisualizer)</li> <li>m_ToolheadRefCenter (AIAC::CutBladeThicknessVisualizer)</li> <li>m_ToolheadRefNormEnd (AIAC::CutBladeThicknessVisualizer)</li> <li>m_ToolheadRefNormStart (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LineChainBase (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>m_LineChainEnd (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>m_LineEnd (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>m_LineDepthFaceEdge1 (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_LineDepthFaceEdge2 (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_LineIntersect (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_LineIntersectThickness (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_AngleFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>m_DepthFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>m_DistDepthAcceptance (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtChainBase (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtChainEnd (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtEnd (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtFaceEdgeDepth (AIAC::CutChainSawFeedVisualizer)</li> <li>ManuallyScrollRefFace (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_ChainBase (AIAC::CutChainSawFeedback)</li> <li>m_ChainEnd (AIAC::CutChainSawFeedback)</li> <li>m_ChainMid (AIAC::CutChainSawFeedback)</li> <li>m_Cut (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_CutOrientationVisualizer (AIAC::CutChainSawFeedback)</li> <li>m_CutPlaneVisualizer (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_NearestParallelFaceID (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_NearestPerpendicularFaceID (AIAC::CutChainSawFeedback)</li> <li>m_NormEnd (AIAC::CutChainSawFeedback)</li> <li>m_NormStart (AIAC::CutChainSawFeedback)</li> <li>m_NormalVec (AIAC::CutChainSawFeedback)</li> <li>m_ToShowCutPlane (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_Visualizer (AIAC::CutChainSawFeedback)</li> <li>m_GuideTxtRollPitch (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineBladeNormal (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugA (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugB (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugC (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugD (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugE (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineFaceNormal (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LinePitchFeed (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_tolAangleAcceptance (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDepth (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_PtBlade2ThicknessLineA (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_PtBlade2ThicknessLineB (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_ToleranceDepthThreshold (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_TxtDepth (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_BottomPoint (AIAC::CutCircularSawFeedback)</li> <li>m_Center (AIAC::CutCircularSawFeedback, AIAC::GOCircle, AIAC::TimberInfo::Component)</li> <li>m_DepthVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_DownVec (AIAC::CutCircularSawFeedback)</li> <li>m_NearestNeighbourFaceIDToParallelFace (AIAC::CutCircularSawFeedback)</li> <li>m_Normal (AIAC::CutCircularSawFeedback, AIAC::GOCircle, AIAC::TimberInfo::Cut::Face)</li> <li>m_NormalEnd (AIAC::CutCircularSawFeedback)</li> <li>m_NormalStart (AIAC::CutCircularSawFeedback)</li> <li>m_OrientationVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_PositionStartVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_Radius (AIAC::CutCircularSawFeedback, AIAC::GOCircle, AIAC::GOCylinder, AIAC::TimberInfo::Hole)</li> <li>m_SecondNearestNeighbourFaceIDToParallelFace (AIAC::CutCircularSawFeedback)</li> <li>m_ThicknessVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_LineDistStart (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>m_LineToBottomPt (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>m_TxtDistStart (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>m_LongestIntersectSegmentA1 (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentA2 (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentAppCenterA (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentAppCenterB (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentB1 (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentB2 (AIAC::CutPlaneVisualizer)</li> <li>m_Category (AIAC::Event)</li> <li>m_Priority (AIAC::Event)</li> <li>m_Type (AIAC::Event, AIAC::GOPrimitive, AIAC::TimberInfo::Component, AIAC::ToolHeadData)</li> <li>m_EventQueue (AIAC::EventBus)</li> <li>m_ScaleFactor (AIAC::FabFeedback)</li> <li>m_AllPrimitives (AIAC::FeedbackVisualizer)</li> <li>m_Colors (AIAC::GLMeshObject, AIAC::GOMesh)</li> <li>m_Indices (AIAC::GLMeshObject, AIAC::GOMesh)</li> <li>m_Vertices (AIAC::GLMeshObject, AIAC::GOMesh)</li> <li>m_EdgeColor (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>MAGENTA (AIAC::GOColor)</li> <li>MAGENTA_TRANSP07 (AIAC::GOColor)</li> <li>m_PEnd (AIAC::GOCylinder, AIAC::GOLine)</li> <li>m_PStart (AIAC::GOCylinder, AIAC::GOLine)</li> <li>m_IsUsingUniformColor (AIAC::GOMesh)</li> <li>m_Normals (AIAC::GOMesh)</li> <li>m_UniformColor (AIAC::GOMesh)</li> <li>m_Position (AIAC::GOPoint)</li> <li>m_IsClosed (AIAC::GOPolyline)</li> <li>m_Points (AIAC::GOPolyline)</li> <li>m_Weight (AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOTriangle)</li> <li>m_Color (AIAC::GOPrimitive)</li> <li>m_GLObjects (AIAC::GOPrimitive)</li> <li>m_Id (AIAC::GOPrimitive)</li> <li>m_IsVisible (AIAC::GOPrimitive)</li> <li>m_Name (AIAC::GOPrimitive, AIAC::ToolHeadData, AIAC::TouchMonitor)</li> <li>m_State (AIAC::GOPrimitive, AIAC::TimberInfo::Component, AIAC::TimberInfo)</li> <li>m_GOMap (AIAC::GORegistry)</li> <li>m_Anchor (AIAC::GOText)</li> <li>m_Size (AIAC::GOText)</li> <li>m_Text (AIAC::GOText)</li> <li>Medium (AIAC::GOTextSize, AIAC::GOWeight)</li> <li>m_P1 (AIAC::GOTriangle)</li> <li>m_P2 (AIAC::GOTriangle)</li> <li>m_P3 (AIAC::GOTriangle)</li> <li>MaxThick (AIAC::GOWeight)</li> <li>MediumThick (AIAC::GOWeight)</li> <li>m_DrillBitLineAxis (AIAC::HoleFeedback)</li> <li>m_HoleLineAxis (AIAC::HoleFeedback)</li> <li>m_InsideOutDetection (AIAC::HoleFeedback)</li> <li>m_OrientationTolerance (AIAC::HoleFeedback)</li> <li>m_VisPosition (AIAC::HoleFeedback)</li> <li>m_VisRotation (AIAC::HoleFeedback)</li> <li>m_VisText (AIAC::HoleFeedback)</li> <li>m_HoleLine2ToolEnd (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolEnd_A (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolEnd_B (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolStart (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolStart_A (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolStart_B (AIAC::HoleFeedbackPosition)</li> <li>m_GUILineOrientation (AIAC::HoleFeedbackRotation)</li> <li>m_GUILineOrientation_A (AIAC::HoleFeedbackRotation)</li> <li>m_GUILineOrientation_B (AIAC::HoleFeedbackRotation)</li> <li>m_InfoText (AIAC::HoleFeedbackText)</li> <li>m_CvMat (AIAC::Image)</li> <li>m_DataUpdatedAfterGenGlTexture (AIAC::Image)</li> <li>m_DataUpdatedAfterGenImTexture (AIAC::Image)</li> <li>m_Format (AIAC::Image)</li> <li>m_GlTextureObj (AIAC::Image)</li> <li>m_ImTexture (AIAC::Image)</li> <li>m_Path (AIAC::Image)</li> <li>m_PureCvMat (AIAC::Image)</li> <li>MainCamera (AIAC::LayerCamera)</li> <li>m_CurrentDeviceIndex (AIAC::LayerCamera)</li> <li>m_CameraCalibrator (AIAC::LayerCameraCalib)</li> <li>m_IsCalibrating (AIAC::LayerCameraCalib)</li> <li>m_IsCapturing (AIAC::LayerCameraCalib)</li> <li>m_CurrentFabFeedbackPtr (AIAC::LayerFeedback)</li> <li>m_CutChainSawFeedback (AIAC::LayerFeedback)</li> <li>m_CutCircularSawFeedback (AIAC::LayerFeedback)</li> <li>m_HoleFeedback (AIAC::LayerFeedback)</li> <li>m_IsCurrentFabFeedbackVisible (AIAC::LayerFeedback)</li> <li>m_ACIMComponentStatus (AIAC::LayerLogRecorder)</li> <li>m_ACIMFlip (AIAC::LayerLogRecorder)</li> <li>m_ACIMOffset (AIAC::LayerLogRecorder)</li> <li>m_ACIMPreviousActivatedComponentID (AIAC::LayerLogRecorder)</li> <li>m_ACIMRotation (AIAC::LayerLogRecorder)</li> <li>m_FrameCount (AIAC::LayerLogRecorder)</li> <li>m_IsActivatedComponentDone (AIAC::LayerLogRecorder)</li> <li>m_IsPaused (AIAC::LayerLogRecorder)</li> <li>m_IsRecording (AIAC::LayerLogRecorder)</li> <li>m_LogFile (AIAC::LayerLogRecorder)</li> <li>m_LogFilePath (AIAC::LayerLogRecorder)</li> <li>m_LogFolderPath (AIAC::LayerLogRecorder)</li> <li>m_TToolPreviousToolheadName (AIAC::LayerLogRecorder)</li> <li>m_TToolStatusToLog (AIAC::LayerLogRecorder)</li> <li>m_ACIMTransformMat (AIAC::LayerModel)</li> <li>m_ACInfoModel (AIAC::LayerModel)</li> <li>m_ACInfoModelPath (AIAC::LayerModel)</li> <li>m_AlignFlip (AIAC::LayerModel)</li> <li>m_AlignOffset (AIAC::LayerModel)</li> <li>m_AlignRotation (AIAC::LayerModel)</li> <li>m_ScannedModel (AIAC::LayerModel)</li> <li>m_ScannedModelPath (AIAC::LayerModel)</li> <li>m_CamPose (AIAC::LayerSlam)</li> <li>m_CamPoseBuffer (AIAC::LayerSlam)</li> <li>m_IsMapping (AIAC::LayerSlam)</li> <li>m_IsShowingTag (AIAC::LayerSlam)</li> <li>m_IsTracked (AIAC::LayerSlam)</li> <li>m_LastTrackedCamPose (AIAC::LayerSlam)</li> <li>m_MaxCamPoseBufferSize (AIAC::LayerSlam)</li> <li>m_NumLongDistFrame (AIAC::LayerSlam)</li> <li>m_NumLostFrame (AIAC::LayerSlam)</li> <li>m_ProcessedFrame (AIAC::LayerSlam)</li> <li>m_SlamMapGOs (AIAC::LayerSlam)</li> <li>m_ToStartMapping (AIAC::LayerSlam)</li> <li>m_ACScaleFactor (AIAC::LayerToolhead)</li> <li>m_ClassifierToolList (AIAC::LayerToolhead)</li> <li>m_Pose (AIAC::LayerToolhead)</li> <li>m_TtoolState (AIAC::LayerToolhead)</li> <li>m_ARCameraViewportImTexture (AIAC::LayerUI)</li> <li>m_AdjustTarget (AIAC::LayerUI)</li> <li>m_CamCalibViewImTexture (AIAC::LayerUI)</li> <li>m_CombMapParams (AIAC::LayerUI)</li> <li>m_FileSelectDefaultPath (AIAC::LayerUI)</li> <li>m_FileSelectionCallback (AIAC::LayerUI)</li> <li>m_FileSelectionTargetBuf (AIAC::LayerUI)</li> <li>m_IsChoosingCamCalibFileSavePath (AIAC::LayerUI)</li> <li>m_IsCombiningMap (AIAC::LayerUI)</li> <li>m_IsMouseLDown (AIAC::LayerUI)</li> <li>m_IsMouseRDown (AIAC::LayerUI)</li> <li>m_IsOpen (AIAC::LayerUI)</li> <li>m_IsReconstructing3D (AIAC::LayerUI)</li> <li>m_LastMouseLPos (AIAC::LayerUI)</li> <li>m_LastMouseRPos (AIAC::LayerUI)</li> <li>m_LogoLightClr (AIAC::LayerUI)</li> <li>m_MappingParams (AIAC::LayerUI)</li> <li>m_MappingViewImTexture (AIAC::LayerUI)</li> <li>m_OpenedPaneUI (AIAC::LayerUI)</li> <li>m_PaneUIStack (AIAC::LayerUI)</li> <li>m_ReconstructParams (AIAC::LayerUI)</li> <li>m_SceneViewportImTexture (AIAC::LayerUI)</li> <li>m_TmpPathBuf (AIAC::LayerUI)</li> <li>m_VideoRecorderPathName (AIAC::LayerUI)</li> <li>m_HoleToolheadAxisExporter (AIAC::LayerUtils)</li> <li>m_Processing (AIAC::LayerUtils)</li> <li>m_Recording (AIAC::LayerUtils)</li> <li>m_UtilsPath (AIAC::LayerUtils)</li> <li>m_VideoRecorder (AIAC::LayerUtils)</li> <li>m_WindowScreenshot (AIAC::LayerUtils)</li> <li>m_CollapseState (AIAC::PaneUI)</li> <li>m_IsCollapsed (AIAC::PaneUI)</li> <li>m_Label (AIAC::PaneUI)</li> <li>m_func (AIAC::PaneUI)</li> <li>m_onCollapseCallback (AIAC::PaneUI)</li> <li>m_BasicShaderProgram (AIAC::Renderer)</li> <li>m_CamCalibView (AIAC::Renderer)</li> <li>m_CamH (AIAC::Renderer)</li> <li>m_CamVisualizationEdges (AIAC::Renderer)</li> <li>m_CamW (AIAC::Renderer)</li> <li>m_DefaultEdgeColor (AIAC::Renderer)</li> <li>m_DigitalModelBoundingBoxColor (AIAC::Renderer)</li> <li>m_DigitalModelFaceColor (AIAC::Renderer)</li> <li>m_GlobalCamLookAtCenter (AIAC::Renderer)</li> <li>m_GlobalCamMatrix (AIAC::Renderer)</li> <li>m_GlobalProjMatrix (AIAC::Renderer)</li> <li>m_GlobalProjOrthoSize (AIAC::Renderer)</li> <li>m_GlobalView (AIAC::Renderer)</li> <li>m_MappingView (AIAC::Renderer)</li> <li>m_MatrixId (AIAC::Renderer)</li> <li>m_PointCloudMapColor (AIAC::Renderer)</li> <li>m_ProjMatrix (AIAC::Renderer)</li> <li>m_TestGLObject (AIAC::Renderer)</li> <li>m_VAO (AIAC::Renderer)</li> <li>m_AABBScaleFactor (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_CreaseAngleThreshold (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_EPS (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MapPathA (AIAC::SLAMCombineMapEvent)</li> <li>m_MapPathB (AIAC::SLAMCombineMapEvent)</li> <li>m_MaxPlnAngle2Merge (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MaxPlnDist2Merge (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MaxPolyTagDist (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MinClusterSize (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_OptimizeIterations (AIAC::SLAMCombineMapEvent)</li> <li>m_OutputPath (AIAC::SLAMCombineMapEvent)</li> <li>m_RadiusSearch (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_SavePath (AIAC::SLAMStopMappingEvent)</li> <li>m_ToOptimize (AIAC::SLAMStopMappingEvent)</li> <li>m_ToSave (AIAC::SLAMStopMappingEvent)</li> <li>m_Bbox (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>m_BboxEdgesIndices (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>m_Mesh (AIAC::ScannedModel)</li> <li>m_ACIMDocNode (AIAC::TimberInfo::Component)</li> <li>m_GOPrimitives (AIAC::TimberInfo::Component)</li> <li>m_CotaLines (AIAC::TimberInfo::Cut::Edge)</li> <li>m_CotaPts (AIAC::TimberInfo::Cut::Edge)</li> <li>m_Cotas (AIAC::TimberInfo::Cut::Edge)</li> <li>m_End (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Hole)</li> <li>m_GO (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Cut::Face)</li> <li>m_Neighbors (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Cut::Face, AIAC::TimberInfo::Hole)</li> <li>m_Start (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Hole)</li> <li>m_Corners (AIAC::TimberInfo::Cut::Face)</li> <li>m_Edges (AIAC::TimberInfo::Cut::Face, AIAC::TimberInfo::Cut)</li> <li>m_Exposed (AIAC::TimberInfo::Cut::Face)</li> <li>m_Faces (AIAC::TimberInfo::Cut)</li> <li>m_HighlightedFaceID (AIAC::TimberInfo::Cut)</li> <li>m_IDLabelGO (AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>m_NonExposedEdgeIDs (AIAC::TimberInfo::Cut)</li> <li>m_NonExposedFaceIDs (AIAC::TimberInfo::Cut)</li> <li>m_AxisGO (AIAC::TimberInfo::Hole)</li> <li>m_CylinderGO (AIAC::TimberInfo::Hole)</li> <li>m_EndExposed (AIAC::TimberInfo::Hole)</li> <li>m_EndPointGO (AIAC::TimberInfo::Hole)</li> <li>m_StartExposed (AIAC::TimberInfo::Hole)</li> <li>m_StartPointGO (AIAC::TimberInfo::Hole)</li> <li>m_Components (AIAC::TimberInfo)</li> <li>m_CurrentComponentID (AIAC::TimberInfo)</li> <li>m_Cuts (AIAC::TimberInfo)</li> <li>m_Holes (AIAC::TimberInfo)</li> <li>m_ChainSawD (AIAC::ToolHeadData)</li> <li>m_CircularSawD (AIAC::ToolHeadData)</li> <li>m_DrillBitD (AIAC::ToolHeadData)</li> <li>m_SaberSawD (AIAC::ToolHeadData)</li> <li>m_ScaleF (AIAC::ToolHeadData)</li> <li>MapMonitor (AIAC::TouchMonitor)</li> <li>m_IsConnected (AIAC::TouchMonitor)</li> <li>m_IsPrintMonitorsInfo (AIAC::TouchMonitor)</li> <li>m_Resolution (AIAC::TouchMonitor)</li> <li>m_SiftedMonitors (AIAC::TouchMonitor)</li> <li>m_VideoMode (AIAC::TouchMonitor)</li> <li>m_BasePath (AIAC::Utils::HoleToolheadAxisExporter, AIAC::Utils::Screenshot, AIAC::Utils::VideoRecorder)</li> <li>m_Buffer (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>m_FileName (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>m_ImageName (AIAC::Utils::Screenshot)</li> <li>m_ScreenshotPath (AIAC::Utils::Screenshot)</li> <li>MakeVideoFromFrames (AIAC::Utils::VideoRecorder)</li> <li>m_FramesPath (AIAC::Utils::VideoRecorder)</li> <li>m_RecorderPath (AIAC::Utils::VideoRecorder)</li> <li>m_VideoPath (AIAC::Utils::VideoRecorder)</li> <li>m_DepthBuffer (AIAC::Viewport)</li> <li>m_FrameBuffer (AIAC::Viewport)</li> <li>m_H (AIAC::Viewport)</li> <li>m_Texture (AIAC::Viewport)</li> <li>m_W (AIAC::Viewport)</li> <li>MakeCurrent (AIAC::Window)</li> <li>m_DisplayH (AIAC::Window)</li> <li>m_DisplayW (AIAC::Window)</li> <li>m_GLFWWindow (AIAC::Window)</li> <li>m_GlslVersion (AIAC::Window)</li> <li>m_IsWindowOpen (AIAC::Window)</li> <li>m_TouchMonitor (AIAC::Window)</li> <li>MapPathA (AIAC::LayerUI::CombineMapParams)</li> <li>MapPathB (AIAC::LayerUI::CombineMapParams)</li> <li>MapSavingPath (AIAC::LayerUI::MappingParams)</li> <li>MaxPlnAngle (AIAC::LayerUI::ReconstructParams)</li> <li>MaxPlnDist (AIAC::LayerUI::ReconstructParams)</li> <li>MaxPolyDist (AIAC::LayerUI::ReconstructParams)</li> <li>MinClusterSize (AIAC::LayerUI::ReconstructParams)</li> </ul>"},{"location":"acdoxygen/class_members/#n","title":"n","text":"<ul> <li>Name (AIAC::ApplicationSpecification)</li> <li>NameACIT (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>NormEndACIT (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NormEndGO (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NormStartACIT (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NormStartGO (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NAME (AIAC::Config)</li> <li>NumOfFrame (AIAC::LayerCameraCalib)</li> <li>next (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_members/#o","title":"o","text":"<ul> <li>OnAppClose (AIAC::AppCloseEvent)</li> <li>Open (AIAC::Camera)</li> <li>OnCameraCalibrationFileLoaded (AIAC::CameraCalibrationLoadedEvent)</li> <li>OverhangACIT (AIAC::ChainSawData, AIAC::CircularSawData)</li> <li>operator() (AIAC::EventCompare)</li> <li>operator= (AIAC::GLLineObject, AIAC::GLMeshObject, AIAC::GLObject, AIAC::GLPointObject, AIAC::Image, CircularBuffer, glob::glob)</li> <li>ORANGE (AIAC::GOColor)</li> <li>ORANGE_TRANSP (AIAC::GOColor)</li> <li>operator* (AIAC::GOMesh, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle, CircularBuffer::BufferIterator)</li> <li>OnAttach (AIAC::Layer, AIAC::LayerCamera, AIAC::LayerCameraCalib, AIAC::LayerFeedback, AIAC::LayerLogRecorder, AIAC::LayerModel, AIAC::LayerSlam, AIAC::LayerToolhead, AIAC::LayerUI)</li> <li>OnDetach (AIAC::Layer, AIAC::LayerUI)</li> <li>OnFrameAwake (AIAC::Layer)</li> <li>OnFrameEnd (AIAC::Layer, AIAC::LayerUtils)</li> <li>OnFrameFall (AIAC::Layer)</li> <li>OnFrameStart (AIAC::Layer, AIAC::LayerCamera, AIAC::LayerCameraCalib, AIAC::LayerFeedback, AIAC::LayerLogRecorder, AIAC::LayerModel, AIAC::LayerSlam, AIAC::LayerToolhead, AIAC::LayerUI)</li> <li>OnCollapsingPaneUIToolhead (AIAC::LayerUI)</li> <li>OnUIRender (AIAC::LayerUI)</li> <li>OpenFileSelectDialog (AIAC::LayerUI)</li> <li>OnRender (AIAC::Renderer)</li> <li>OnSLAMCombineMap (AIAC::SLAMCombineMapEvent)</li> <li>OnSLAMMapLoaded (AIAC::SLAMMapLoadedEvent)</li> <li>OnSLAMStartMapping (AIAC::SLAMStartMappingEvent)</li> <li>OnSLAMStopMapping (AIAC::SLAMStopMappingEvent)</li> <li>OnSLAMVocabularyLoaded (AIAC::SLAMVocabularyLoadedEvent)</li> <li>OnBufferSwap (AIAC::Window)</li> <li>OnUpdate (AIAC::Window)</li> <li>OutputPath (AIAC::LayerUI::CombineMapParams)</li> <li>operator[] (CircularBuffer, CircularBuffer::BufferIterator)</li> <li>operator!= (CircularBuffer::BufferIterator)</li> <li>operator++ (CircularBuffer::BufferIterator)</li> <li>operator+= (CircularBuffer::BufferIterator)</li> <li>operator-- (CircularBuffer::BufferIterator)</li> <li>operator-= (CircularBuffer::BufferIterator)</li> <li>operator-&gt; (CircularBuffer::BufferIterator)</li> <li>operator&lt; (CircularBuffer::BufferIterator)</li> <li>operator&lt;= (CircularBuffer::BufferIterator)</li> <li>operator== (CircularBuffer::BufferIterator)</li> <li>operator&gt; (CircularBuffer::BufferIterator)</li> <li>operator&gt;= (CircularBuffer::BufferIterator)</li> <li>open (glob::glob)</li> <li>operator bool (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_members/#p","title":"p","text":"<ul> <li>PushLayer (AIAC::Application)</li> <li>Pattern (AIAC::CameraCalibrator)</li> <li>ProcessQueue (AIAC::EventBus)</li> <li>PrioriQueueListtyQueue (AIAC::EventPolicy)</li> <li>pointSize (AIAC::GLPointObject)</li> <li>PINK (AIAC::GOColor)</li> <li>PINK_TRANSP (AIAC::GOColor)</li> <li>PINK_TRANSP07 (AIAC::GOColor)</li> <li>PURPLE (AIAC::GOColor)</li> <li>PURPLE_TRANSP (AIAC::GOColor)</li> <li>PURPLE_TRANSP07 (AIAC::GOColor)</li> <li>prevCaptureTimestamp (AIAC::LayerCameraCalib)</li> <li>PauseRecording (AIAC::LayerLogRecorder)</li> <li>PaneUI (AIAC::PaneUI)</li> <li>ParseString2GlmVector (AIAC::ToolHeadData)</li> <li>PrintInfoMonitors (AIAC::TouchMonitor)</li> <li>pointer (CircularBuffer, CircularBuffer::BufferIterator)</li> <li>pop_front (CircularBuffer)</li> <li>push_back (CircularBuffer)</li> <li>ParseError (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_members/#r","title":"r","text":"<ul> <li>Run (AIAC::Application)</li> <li>RunCalibration (AIAC::CameraCalibrator)</li> <li>reprojErrs (AIAC::CameraCalibrator)</li> <li>rvecs (AIAC::CameraCalibrator)</li> <li>RadiusACIT (AIAC::CircularSawData, AIAC::DrillBitData)</li> <li>RECONSTRUCT_CONFIG_DEFAULT_FILE (AIAC::Config)</li> <li>RESOLUTION (AIAC::Config)</li> <li>ReorderIntersectPoints (AIAC::CutPlaneVisualizer)</li> <li>RED (AIAC::GOColor)</li> <li>RED_TRANSP07 (AIAC::GOColor)</li> <li>Remove (AIAC::GOPrimitive)</li> <li>Register (AIAC::GORegistry)</li> <li>ReplaceCvMat (AIAC::Image)</li> <li>Resize (AIAC::Image)</li> <li>ResumeRecording (AIAC::LayerLogRecorder)</li> <li>ReloadACInfoModel (AIAC::LayerModel)</li> <li>ResetAlignFlip (AIAC::LayerModel)</li> <li>ResetAlignOffset (AIAC::LayerModel)</li> <li>ResetAlignRotation (AIAC::LayerModel)</li> <li>ReloadCameraFromFile (AIAC::LayerToolhead)</li> <li>ReloadCameraFromMatrix (AIAC::LayerToolhead)</li> <li>ResetPoseFromConfig (AIAC::LayerToolhead)</li> <li>ResetToLastSavedPose (AIAC::LayerToolhead)</li> <li>RenderCamCalibView (AIAC::Renderer)</li> <li>RenderCameraFrame (AIAC::Renderer)</li> <li>RenderGlobalView (AIAC::Renderer)</li> <li>RenderMainView (AIAC::Renderer)</li> <li>RenderMappingView (AIAC::Renderer)</li> <li>Renderer (AIAC::Renderer)</li> <li>RenderText (AIAC::TextRenderer)</li> <li>RenderTextIn3DSpace (AIAC::TextRenderer)</li> <li>ReleaseCurrent (AIAC::Window)</li> <li>RadiusSearch (AIAC::LayerUI::ReconstructParams)</li> <li>rbegin (CircularBuffer)</li> <li>reference (CircularBuffer, CircularBuffer::BufferIterator)</li> <li>rend (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_members/#s","title":"s","text":"<ul> <li>Save (AIAC::ACInfoModel, AIAC::CameraCalibrator)</li> <li>SetBboxVisibility (AIAC::ACInfoModel)</li> <li>SetVisibility (AIAC::ACInfoToolhead, AIAC::GOPrimitive, AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetActiveToolhead (AIAC::ACInfoToolheadManager)</li> <li>Shutdown (AIAC::Application, AIAC::Log, AIAC::Window)</li> <li>s_Instance (AIAC::Application, AIAC::Config)</li> <li>squareSize (AIAC::CameraCalibrator)</li> <li>Size (AIAC::Character, AIAC::ImTexture)</li> <li>SAVE_DIR_MAPS (AIAC::Config)</li> <li>SCALE_FACTOR (AIAC::Config)</li> <li>SCANNED_MODEL (AIAC::Config)</li> <li>SEC_AIAC (AIAC::Config)</li> <li>SEC_TEST (AIAC::Config)</li> <li>SEC_TOUCH_MONITOR_SPECS (AIAC::Config)</li> <li>SEC_TSLAM (AIAC::Config)</li> <li>SEC_TTOOL (AIAC::Config)</li> <li>SEC_UTILS (AIAC::Config)</li> <li>STABILIZATION_FRAME_COUNT (AIAC::Config)</li> <li>size (AIAC::GLObject, CircularBuffer)</li> <li>SetCenter (AIAC::GOCircle)</li> <li>SetEdgeColor (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>SetNormal (AIAC::GOCircle)</li> <li>SetRadius (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>SetValueFrom (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOPoint, AIAC::GOPrimitive, AIAC::GOText)</li> <li>SetPEnd (AIAC::GOCylinder, AIAC::GOLine)</li> <li>SetPStart (AIAC::GOCylinder, AIAC::GOLine)</li> <li>SetPts (AIAC::GOLine)</li> <li>SetColor (AIAC::GOMesh, AIAC::GOPrimitive)</li> <li>SetColors (AIAC::GOMesh)</li> <li>SetIndices (AIAC::GOMesh)</li> <li>SetNormals (AIAC::GOMesh)</li> <li>SetVertices (AIAC::GOMesh)</li> <li>SetPosition (AIAC::GOPoint)</li> <li>SetWeight (AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOTriangle)</li> <li>SetX (AIAC::GOPoint)</li> <li>SetY (AIAC::GOPoint)</li> <li>SetZ (AIAC::GOPoint)</li> <li>SetClosed (AIAC::GOPolyline)</li> <li>SetPoints (AIAC::GOPolyline)</li> <li>SetName (AIAC::GOPrimitive)</li> <li>SetState (AIAC::GOPrimitive)</li> <li>SetAnchor (AIAC::GOText)</li> <li>SetText (AIAC::GOText)</li> <li>SetTextSize (AIAC::GOText)</li> <li>Small (AIAC::GOTextSize)</li> <li>SetImTextureSize (AIAC::Image)</li> <li>SetCurrentDevice (AIAC::LayerCamera)</li> <li>SetCurrentDeviceIndex (AIAC::LayerCamera)</li> <li>SaveFilename (AIAC::LayerCameraCalib)</li> <li>SetSaveFilename (AIAC::LayerCameraCalib)</li> <li>StartCalibration (AIAC::LayerCameraCalib)</li> <li>StartCapturing (AIAC::LayerCameraCalib)</li> <li>StopCalibration (AIAC::LayerCameraCalib)</li> <li>StartRecording (AIAC::LayerLogRecorder, AIAC::LayerUtils)</li> <li>StopRecording (AIAC::LayerLogRecorder, AIAC::LayerUtils)</li> <li>Slam (AIAC::LayerSlam)</li> <li>StartMapping (AIAC::LayerSlam)</li> <li>StopMapping (AIAC::LayerSlam)</li> <li>SavePose (AIAC::LayerToolhead)</li> <li>SetCurrentObject (AIAC::LayerToolhead)</li> <li>syncTToolAndACInfoToolhead (AIAC::LayerToolhead)</li> <li>SetGlobalViewUI (AIAC::LayerUI)</li> <li>SetOpenedPaneUI (AIAC::LayerUI)</li> <li>SetPaneUIACIM (AIAC::LayerUI)</li> <li>SetPaneUICamera (AIAC::LayerUI)</li> <li>SetPaneUISlam (AIAC::LayerUI)</li> <li>SetPaneUIToolhead (AIAC::LayerUI)</li> <li>SetPaneUIUtils (AIAC::LayerUI)</li> <li>ShowCamCalibPopup (AIAC::LayerUI)</li> <li>ShowCombineMapPopup (AIAC::LayerUI)</li> <li>ShowFileSelectDialog (AIAC::LayerUI)</li> <li>ShowLogRecorderUI (AIAC::LayerUI)</li> <li>ShowMainUI (AIAC::LayerUI)</li> <li>ShowMapFileDialog (AIAC::LayerUI)</li> <li>ShowMappingPopup (AIAC::LayerUI)</li> <li>ShowMenuBar (AIAC::LayerUI)</li> <li>ShowReconExportFilePathDialog (AIAC::LayerUI)</li> <li>ShowReconstruct3DPopup (AIAC::LayerUI)</li> <li>ShowSaveCamCalibFileDialog (AIAC::LayerUI)</li> <li>ShowSaveMapFileDialog (AIAC::LayerUI)</li> <li>ShowSaveVideoRecorderFileDialog (AIAC::LayerUI)</li> <li>ShowSceneViewport (AIAC::LayerUI)</li> <li>StackPane (AIAC::LayerUI)</li> <li>SetSaveFolderPath (AIAC::LayerUtils)</li> <li>SetWindowScreenshot (AIAC::LayerUtils)</li> <li>s_Logger (AIAC::Log)</li> <li>Show (AIAC::PaneUI)</li> <li>SetCamCalibViewSize (AIAC::Renderer)</li> <li>SetGlobalViewSize (AIAC::Renderer)</li> <li>SetGlobalViewToActivatedComponent (AIAC::Renderer)</li> <li>SetMappingViewSize (AIAC::Renderer)</li> <li>StandardView (AIAC::Renderer)</li> <li>SLAMCombineMapEvent (AIAC::SLAMCombineMapEvent)</li> <li>SLAMMapLoadedEvent (AIAC::SLAMMapLoadedEvent)</li> <li>SLAMStartMappingEvent (AIAC::SLAMStartMappingEvent)</li> <li>SLAMStopMappingEvent (AIAC::SLAMStopMappingEvent)</li> <li>SLAMVocabularyLoadedEvent (AIAC::SLAMVocabularyLoadedEvent)</li> <li>SaberSawData (AIAC::SaberSawData)</li> <li>ScannedModel (AIAC::ScannedModel)</li> <li>SetProjection (AIAC::TextRenderer)</li> <li>s_Initialized (AIAC::TextRenderer)</li> <li>s_Projection (AIAC::TextRenderer)</li> <li>s_ShaderProgram (AIAC::TextRenderer)</li> <li>s_VBO (AIAC::TextRenderer)</li> <li>s_instance (AIAC::TextRenderer)</li> <li>SetAsCurrent (AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetAsDone (AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetAsNotDone (AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetCotasVisibility (AIAC::TimberInfo::Cut::Edge)</li> <li>SetVisibilityAllCotas (AIAC::TimberInfo::Cut)</li> <li>SwapStartEnd (AIAC::TimberInfo::Hole)</li> <li>SetCurrentComponentTo (AIAC::TimberInfo)</li> <li>SetNextComponentAsCurrent (AIAC::TimberInfo)</li> <li>SetPrevComponentAsCurrent (AIAC::TimberInfo)</li> <li>ShortenComponentID (AIAC::TimberInfo)</li> <li>ShowAllComponents (AIAC::TimberInfo)</li> <li>SiftMonitorsByMode (AIAC::TouchMonitor)</li> <li>SiftMonitorsByResolution (AIAC::TouchMonitor)</li> <li>SaveScreenshot (AIAC::Utils::Screenshot)</li> <li>Screenshot (AIAC::Utils::Screenshot)</li> <li>SaveFrames (AIAC::Utils::VideoRecorder)</li> <li>SetSize (AIAC::Viewport)</li> <li>SetVSync (AIAC::Window)</li> <li>size_type (CircularBuffer)</li> <li>Sections (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_members/#t","title":"t","text":"<ul> <li>Transform (AIAC::ACInfoModel, AIAC::ACInfoToolhead, AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOText, AIAC::GOTriangle)</li> <li>ToString (AIAC::ACInfoToolhead, AIAC::ToolHeadData)</li> <li>TransformGO (AIAC::ACInfoToolhead)</li> <li>TransformSync (AIAC::ACInfoToolhead)</li> <li>totalAvgErr (AIAC::CameraCalibrator)</li> <li>tvecs (AIAC::CameraCalibrator)</li> <li>ThicknessACIT (AIAC::ChainSawData, AIAC::CircularSawData)</li> <li>TextureID (AIAC::Character)</li> <li>TTOOL_ROOT_PATH (AIAC::Config)</li> <li>ToleranceStartThreshold (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>ToolbaseACIT (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>ToolbaseGO (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>TooltipACIT (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>TooltipGO (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>toString (AIAC::FeedbackVisualizer)</li> <li>type (AIAC::GLObject)</li> <li>Translate (AIAC::GOLine, AIAC::GOPrimitive)</li> <li>Thick (AIAC::GOWeight)</li> <li>ToShowCutPlane (AIAC::LayerFeedback)</li> <li>ToEnhance (AIAC::LayerSlam)</li> <li>ToProcess (AIAC::LayerSlam)</li> <li>ToShowTag (AIAC::LayerSlam)</li> <li>TTool (AIAC::LayerToolhead)</li> <li>ToolheadStateUI (AIAC::LayerToolhead)</li> <li>TakeBufferScreenshot (AIAC::LayerUtils)</li> <li>TakeWindowScreenshot (AIAC::LayerUtils)</li> <li>TextRenderer (AIAC::TextRenderer)</li> <li>ToolHeadData (AIAC::ToolHeadData)</li> <li>TouchMonitor (AIAC::TouchMonitor)</li> <li>Title (AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>ToOptimizeMap (AIAC::LayerUI::MappingParams)</li> <li>ToSaveMap (AIAC::LayerUI::MappingParams)</li> <li>TagMapPath (AIAC::LayerUI::ReconstructParams)</li> <li>table (IGFD_Selection)</li> </ul>"},{"location":"acdoxygen/class_members/#u","title":"u","text":"<ul> <li>UpdateBboxGOLine (AIAC::ACInfoModel, AIAC::ScannedModel)</li> <li>UpdateCameraParamFromFile (AIAC::Camera)</li> <li>UpdateCameraParamFromSlamMap (AIAC::Camera)</li> <li>UpdateFov (AIAC::Camera)</li> <li>useFisheye (AIAC::CameraCalibrator)</li> <li>useFixedPoint (AIAC::CameraCalibrator)</li> <li>UpdateToolheadsData (AIAC::CircularSawCutBladeThicknessVisualizer, AIAC::CutBladeThicknessVisualizer)</li> <li>UTILS_PATH (AIAC::Config)</li> <li>UpdateEntry (AIAC::Config, inih::INIReader)</li> <li>Update (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::CutPlaneVisualizer, AIAC::FabFeedback, AIAC::HoleFeedback)</li> <li>UpdateCutPlane (AIAC::CutChainSawFeedback)</li> <li>UpdateRefFaces (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>UpdateCutPlaneFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateDepthFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateOrientationFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateStartPosFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateThicknessFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateToolPosition (AIAC::CutCircularSawFeedback)</li> <li>Unregister (AIAC::GORegistry)</li> <li>UpdateData (AIAC::Image)</li> <li>UpdateGlTextureObj (AIAC::Image)</li> <li>UpdateImTexture (AIAC::Image)</li> <li>UpdateAvailableDevices (AIAC::LayerCamera)</li> <li>UpdateMap (AIAC::LayerSlam)</li> <li>UpdateToolheadStateUI (AIAC::LayerToolhead)</li> <li>UpdateGlobalViewCameraRotation (AIAC::Renderer)</li> <li>UpdateGlobalViewCameraScale (AIAC::Renderer)</li> <li>UpdateGlobalViewCameraTranslation (AIAC::Renderer)</li> <li>UpdateCotasVisibility (AIAC::TimberInfo)</li> <li>UpdatePaths (AIAC::Utils::VideoRecorder)</li> </ul>"},{"location":"acdoxygen/class_members/#v","title":"v","text":"<ul> <li>VSync (AIAC::ApplicationSpecification, AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>ValidateAndUpdateFlag (AIAC::CameraCalibrator)</li> <li>VIDEO_PATH (AIAC::Config)</li> <li>VocFile (AIAC::Config)</li> <li>vertexBuf (AIAC::GLObject)</li> <li>vec3 (AIAC::GOPoint)</li> <li>VideoRecorder (AIAC::Utils::VideoRecorder)</li> <li>Viewport (AIAC::Viewport)</li> <li>value_type (CircularBuffer, CircularBuffer::BufferIterator)</li> <li>V2String (inih::INIReader)</li> <li>ValueHandler (inih::INIReader)</li> <li>Vec2String (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_members/#w","title":"w","text":"<ul> <li>WinHeight (AIAC::ApplicationSpecification)</li> <li>WinWidth (AIAC::ApplicationSpecification)</li> <li>WindowBackColor (AIAC::ApplicationSpecification)</li> <li>winSize (AIAC::CameraCalibrator)</li> <li>writeExtrinsics (AIAC::CameraCalibrator)</li> <li>WidthACIT (AIAC::ChainSawData)</li> <li>WriteToFile (AIAC::Config)</li> <li>WHITE (AIAC::GOColor)</li> <li>WriteBufferToFile (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>WriteCoordToBuffer (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>Window (AIAC::Window)</li> <li>Width (AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>WindowProps (AIAC::WindowProps)</li> <li>write (inih::INIWriter)</li> </ul>"},{"location":"acdoxygen/class_members/#x","title":"x","text":"<ul> <li>x (AIAC::CylinderPole, AIAC::Position)</li> <li>X (AIAC::GOPoint)</li> </ul>"},{"location":"acdoxygen/class_members/#y","title":"y","text":"<ul> <li>YELLOW (AIAC::GOColor)</li> <li>YELLOW_TRANSP07 (AIAC::GOColor)</li> <li>Y (AIAC::GOPoint)</li> <li>y (AIAC::Position)</li> </ul>"},{"location":"acdoxygen/class_members/#z","title":"z","text":"<ul> <li>z (AIAC::CylinderPole)</li> <li>Z (AIAC::GOPoint)</li> </ul>"},{"location":"acdoxygen/class_members/#_1","title":"~","text":"<ul> <li>~ACInfoModel (AIAC::ACInfoModel)</li> <li>~Application (AIAC::Application)</li> <li>~Camera (AIAC::Camera)</li> <li>~CameraCalibrator (AIAC::CameraCalibrator)</li> <li>~CutCircularSawFeedback (AIAC::CutCircularSawFeedback)</li> <li>~DLoader (AIAC::DLoader)</li> <li>~Event (AIAC::Event)</li> <li>~EventBus (AIAC::EventBus)</li> <li>~FabFeedback (AIAC::FabFeedback)</li> <li>~FeedbackVisualizer (AIAC::FeedbackVisualizer)</li> <li>~GLObject (AIAC::GLObject)</li> <li>~GOCircle (AIAC::GOCircle)</li> <li>~GOCylinder (AIAC::GOCylinder)</li> <li>~GOLine (AIAC::GOLine)</li> <li>~GOMesh (AIAC::GOMesh)</li> <li>~GOPoint (AIAC::GOPoint)</li> <li>~GOPolyline (AIAC::GOPolyline)</li> <li>~GOPrimitive (AIAC::GOPrimitive)</li> <li>~GORegistry (AIAC::GORegistry)</li> <li>~GOText (AIAC::GOText)</li> <li>~GOTriangle (AIAC::GOTriangle)</li> <li>~HoleFeedback (AIAC::HoleFeedback)</li> <li>~Image (AIAC::Image)</li> <li>~Layer (AIAC::Layer)</li> <li>~LayerCamera (AIAC::LayerCamera)</li> <li>~LayerCameraCalib (AIAC::LayerCameraCalib)</li> <li>~LayerFeedback (AIAC::LayerFeedback)</li> <li>~LayerLogRecorder (AIAC::LayerLogRecorder)</li> <li>~LayerModel (AIAC::LayerModel)</li> <li>~LayerSlam (AIAC::LayerSlam)</li> <li>~LayerUI (AIAC::LayerUI)</li> <li>~Renderer (AIAC::Renderer)</li> <li>~ScannedModel (AIAC::ScannedModel)</li> <li>~TextRenderer (AIAC::TextRenderer)</li> <li>~ToolHeadData (AIAC::ToolHeadData)</li> <li>~TouchMonitor (AIAC::TouchMonitor)</li> <li>~HoleToolheadAxisExporter (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>~VideoRecorder (AIAC::Utils::VideoRecorder)</li> <li>~Viewport (AIAC::Viewport)</li> <li>~Window (AIAC::Window)</li> <li>~glob (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_members/#_","title":"_","text":"<ul> <li>_buff (CircularBuffer)</li> <li>_decrement_bufferstate (CircularBuffer)</li> <li>_head (CircularBuffer)</li> <li>_increment_bufferstate (CircularBuffer)</li> <li>_max_size (CircularBuffer)</li> <li>_mtx (CircularBuffer)</li> <li>_size (CircularBuffer)</li> <li>_tail (CircularBuffer)</li> <li>_comparable (CircularBuffer::BufferIterator)</li> <li>_index (CircularBuffer::BufferIterator)</li> <li>_offset (CircularBuffer::BufferIterator)</li> <li>_ptrToBuffer (CircularBuffer::BufferIterator)</li> <li>_reverse (CircularBuffer::BufferIterator)</li> <li>_error (inih::INIReader)</li> <li>_values (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/","title":"Class Member Functions","text":""},{"location":"acdoxygen/class_member_functions/#a","title":"a","text":"<ul> <li>ACInfoModel (AIAC::ACInfoModel)</li> <li>AddMeasuredBboxLength (AIAC::ACInfoModel)</li> <li>AdjustScale (AIAC::ACInfoModel)</li> <li>ACInfoToolhead (AIAC::ACInfoToolhead)</li> <li>AddGOsInfo (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoChainSaw (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoCircularSaw (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoDrillBit (AIAC::ACInfoToolhead)</li> <li>AddGOsInfoSaberSaw (AIAC::ACInfoToolhead)</li> <li>ACInfoToolheadManager (AIAC::ACInfoToolheadManager)</li> <li>AppCloseEvent (AIAC::AppCloseEvent)</li> <li>Application (AIAC::Application)</li> <li>AddImage (AIAC::CameraCalibrator)</li> <li>Activate (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::CutPlaneVisualizer, AIAC::FabFeedback, AIAC::FeedbackVisualizer, AIAC::HoleFeedback, AIAC::Viewport)</li> <li>Add (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle)</li> <li>ActivateCurrentFeedbackVisibility (AIAC::LayerFeedback)</li> <li>AddAlignOffset (AIAC::LayerModel)</li> <li>AlignModels (AIAC::LayerModel)</li> <li>at (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#b","title":"b","text":"<ul> <li>BindVBOs (AIAC::GLObject)</li> <li>BufferData (AIAC::GLObject)</li> <li>BuildBoundingBox (AIAC::ScannedModel)</li> <li>back (CircularBuffer)</li> <li>begin (CircularBuffer)</li> <li>buffer_size (CircularBuffer)</li> <li>BufferIterator (CircularBuffer::BufferIterator)</li> <li>BoolConverter (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#c","title":"c","text":"<ul> <li>Clear (AIAC::ACInfoModel, AIAC::GORegistry, AIAC::LayerCameraCalib)</li> <li>CopyGOsInfoOriginal (AIAC::ACInfoToolhead)</li> <li>Close (AIAC::Application)</li> <li>Camera (AIAC::Camera)</li> <li>CameraCalibrationLoadedEvent (AIAC::CameraCalibrationLoadedEvent)</li> <li>CalcBoardCornerPositions (AIAC::CameraCalibrator)</li> <li>CameraCalibrator (AIAC::CameraCalibrator)</li> <li>ClearImages (AIAC::CameraCalibrator)</li> <li>ChainSawCutPlaneVisualizer (AIAC::ChainSawCutPlaneVisualizer)</li> <li>ChainSawData (AIAC::ChainSawData)</li> <li>CircularSawCutBladeThicknessVisualizer (AIAC::CircularSawCutBladeThicknessVisualizer)</li> <li>CircularSawCutPlaneVisualizer (AIAC::CircularSawCutPlaneVisualizer)</li> <li>CircularSawData (AIAC::CircularSawData)</li> <li>Config (AIAC::Config)</li> <li>CutBladeThicknessVisualizer (AIAC::CutBladeThicknessVisualizer)</li> <li>CutChainSawAngleFeedVisualizer (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>CutChainSawDepthFeedVisualizer (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>CutChainSawFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>CutChainSawFeedback (AIAC::CutChainSawFeedback)</li> <li>CutCircularOrientationVisualizer (AIAC::CutCircularOrientationVisualizer)</li> <li>CutCircularSawDepthVisualizer (AIAC::CutCircularSawDepthVisualizer)</li> <li>CutCircularSawFeedback (AIAC::CutCircularSawFeedback)</li> <li>CutCircularSawPositionStartVisualizer (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>CutOrientationVisualizer (AIAC::CutOrientationVisualizer)</li> <li>CutPlaneVisualizer (AIAC::CutPlaneVisualizer)</li> <li>CvtAssimpMeshColorsToGlmVector (AIAC::DLoader)</li> <li>CvtAssimpMeshFacesToGlmVector (AIAC::DLoader)</li> <li>CvtAssimpMeshNormalsToGlmVector (AIAC::DLoader)</li> <li>CvtAssimpMeshToGOMesh (AIAC::DLoader)</li> <li>CvtAssimpMeshVerticesToGlmVector (AIAC::DLoader)</li> <li>ClosestDistanceFromLineToCircle (AIAC::GOCircle)</li> <li>ClosestDistanceFromSegmentToCircle (AIAC::GOCircle)</li> <li>ClosestPointToCircle (AIAC::GOCircle)</li> <li>ClosestPointToPoint (AIAC::GOCircle)</li> <li>ComputeAngle (AIAC::GOLine)</li> <li>ComputeSignedAngle (AIAC::GOLine)</li> <li>ClearGLObject (AIAC::GOPrimitive)</li> <li>CheckIfKeyExists (AIAC::GORegistry)</li> <li>Count (AIAC::GORegistry)</li> <li>ChangeAlignRotation (AIAC::LayerModel)</li> <li>CreateFolder (AIAC::LayerUtils)</li> <li>CheckOnCollapsing (AIAC::PaneUI)</li> <li>Component (AIAC::TimberInfo::Component)</li> <li>ClearCotas (AIAC::TimberInfo::Cut::Edge)</li> <li>Cut (AIAC::TimberInfo::Cut)</li> <li>CaptureBuffer (AIAC::Utils::Screenshot)</li> <li>CaptureWindow (AIAC::Utils::Screenshot)</li> <li>CaptureFrames (AIAC::Utils::VideoRecorder)</li> <li>CircularBuffer (CircularBuffer)</li> <li>capacity (CircularBuffer)</li> <li>cbegin (CircularBuffer)</li> <li>cend (CircularBuffer)</li> <li>clear (CircularBuffer)</li> <li>close (glob::glob)</li> <li>current_match (glob::glob)</li> <li>Converter (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#d","title":"d","text":"<ul> <li>DetectPattern (AIAC::CameraCalibrator)</li> <li>Deactivate (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::CutPlaneVisualizer, AIAC::FabFeedback, AIAC::FeedbackVisualizer, AIAC::HoleFeedback)</li> <li>DLoader (AIAC::DLoader)</li> <li>DrillBitData (AIAC::DrillBitData)</li> <li>DispatchEvent (AIAC::EventBus)</li> <li>Draw (AIAC::GLLineObject, AIAC::GLMeshObject, AIAC::GLObject, AIAC::GLPointObject, AIAC::GOPrimitive)</li> <li>DeleteVBOs (AIAC::GLObject)</li> <li>DistanceTo (AIAC::GOPoint)</li> <li>DeleteGlTexture (AIAC::Image)</li> <li>DeactivateCurrentFeedbackVisibility (AIAC::LayerFeedback)</li> <li>DetectToolhead (AIAC::LayerToolhead)</li> <li>DeleteFrameFolder (AIAC::Utils::VideoRecorder)</li> <li>data (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#e","title":"e","text":"<ul> <li>EnableCutPlane (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::LayerFeedback)</li> <li>Event (AIAC::Event)</li> <li>EnqueueEvent (AIAC::EventBus)</li> <li>ExtendBothEnds (AIAC::GOLine)</li> <li>ExtendFromEnd (AIAC::GOLine)</li> <li>ExtendFromStart (AIAC::GOLine)</li> <li>ExportHoleToolheadAxis (AIAC::LayerUtils)</li> <li>Edge (AIAC::TimberInfo::Cut::Edge)</li> <li>ExportCoordinates (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>ExportHoleAxis (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>ExportToolheadAxis (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>empty (CircularBuffer)</li> <li>end (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#f","title":"f","text":"<ul> <li>FabFeedback (AIAC::FabFeedback)</li> <li>FeedbackVisualizer (AIAC::FeedbackVisualizer)</li> <li>FlipAlign (AIAC::LayerModel)</li> <li>ForceAlignToEnd (AIAC::LayerModel)</li> <li>Face (AIAC::TimberInfo::Cut::Face)</li> <li>front (CircularBuffer)</li> <li>full (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#g","title":"g","text":"<ul> <li>GetDoc (AIAC::ACInfoModel)</li> <li>GetFilePath (AIAC::ACInfoModel)</li> <li>GetLength (AIAC::ACInfoModel, AIAC::GOLine, AIAC::ScannedModel)</li> <li>GetMeasuredBboxLength (AIAC::ACInfoModel)</li> <li>GetName (AIAC::ACInfoModel, AIAC::ACInfoToolhead, AIAC::GOPrimitive, AIAC::ToolHeadData)</li> <li>GetRealWorldLength (AIAC::ACInfoModel)</li> <li>GetTimberInfo (AIAC::ACInfoModel)</li> <li>GetData (AIAC::ACInfoToolhead, AIAC::ToolHeadData)</li> <li>GetId (AIAC::ACInfoToolhead, AIAC::GOPrimitive)</li> <li>GetType (AIAC::ACInfoToolhead, AIAC::Event, AIAC::GOPrimitive, AIAC::ToolHeadData)</li> <li>GetTypeString (AIAC::ACInfoToolhead, AIAC::TimberInfo::Component, AIAC::ToolHeadData)</li> <li>GetActiveToolhead (AIAC::ACInfoToolheadManager)</li> <li>GetActiveToolheadName (AIAC::ACInfoToolheadManager)</li> <li>GetActiveToolheadType (AIAC::ACInfoToolheadManager)</li> <li>GetToolhead (AIAC::ACInfoToolheadManager)</li> <li>GetToolheadNames (AIAC::ACInfoToolheadManager)</li> <li>GetToolheadType (AIAC::ACInfoToolheadManager)</li> <li>GetEventBus (AIAC::Application)</li> <li>GetGORegistry (AIAC::Application)</li> <li>GetInstance (AIAC::Application)</li> <li>GetLayer (AIAC::Application)</li> <li>GetRenderer (AIAC::Application)</li> <li>GetSpecification (AIAC::Application)</li> <li>GetWindow (AIAC::Application)</li> <li>GetCalibrationFilePath (AIAC::Camera)</li> <li>GetCameraMatrix (AIAC::Camera)</li> <li>GetCenterCroppedCurrentFrame (AIAC::Camera)</li> <li>GetColorCurrentFrame (AIAC::Camera)</li> <li>GetCurrentFrame (AIAC::Camera)</li> <li>GetDistortionCoef (AIAC::Camera)</li> <li>GetFov (AIAC::Camera)</li> <li>GetHeight (AIAC::Camera, AIAC::Image, AIAC::Window)</li> <li>GetNextFrame (AIAC::Camera)</li> <li>GetRawCurrentFrame (AIAC::Camera)</li> <li>GetRawHeight (AIAC::Camera)</li> <li>GetRawWidth (AIAC::Camera)</li> <li>GetWidth (AIAC::Camera, AIAC::Image, AIAC::Window)</li> <li>GetImageAmount (AIAC::CameraCalibrator)</li> <li>Get (AIAC::Config, AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle, inih::INIReader)</li> <li>GetVector (AIAC::Config, inih::INIReader)</li> <li>GetAngleFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>GetDepthFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>GetCategory (AIAC::Event, AIAC::EventPolicy)</li> <li>GetEvent (AIAC::EventPolicy)</li> <li>GLLineObject (AIAC::GLLineObject)</li> <li>GLMeshObject (AIAC::GLMeshObject)</li> <li>GLObject (AIAC::GLObject)</li> <li>GLPointObject (AIAC::GLPointObject)</li> <li>GOCircle (AIAC::GOCircle)</li> <li>GetAll (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle)</li> <li>GetCenter (AIAC::GOCircle, AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut::Face, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>GetEdgeColor (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>GetNormal (AIAC::GOCircle, AIAC::TimberInfo::Cut::Face)</li> <li>GetRadius (AIAC::GOCircle, AIAC::GOCylinder, AIAC::TimberInfo::Hole)</li> <li>GOCylinder (AIAC::GOCylinder)</li> <li>GetPEnd (AIAC::GOCylinder, AIAC::GOLine)</li> <li>GetPStart (AIAC::GOCylinder, AIAC::GOLine)</li> <li>GOLine (AIAC::GOLine)</li> <li>GetMidPoint (AIAC::GOLine)</li> <li>GetMidPointValues (AIAC::GOLine)</li> <li>GetNormalValues (AIAC::GOLine)</li> <li>GOMesh (AIAC::GOMesh)</li> <li>GetColors (AIAC::GOMesh)</li> <li>GetIndices (AIAC::GOMesh)</li> <li>GetNormals (AIAC::GOMesh)</li> <li>GetVertices (AIAC::GOMesh, AIAC::GOTriangle)</li> <li>GOPoint (AIAC::GOPoint)</li> <li>GetPosition (AIAC::GOPoint)</li> <li>GOPolyline (AIAC::GOPolyline)</li> <li>GetPoints (AIAC::GOPolyline)</li> <li>GOPrimitive (AIAC::GOPrimitive)</li> <li>GenerateId (AIAC::GOPrimitive)</li> <li>GetColor (AIAC::GOPrimitive)</li> <li>GetState (AIAC::GOPrimitive)</li> <li>GetVisibility (AIAC::GOPrimitive)</li> <li>GetWeight (AIAC::GOPrimitive)</li> <li>GORegistry (AIAC::GORegistry)</li> <li>GetAllGOs (AIAC::GORegistry)</li> <li>GetGO (AIAC::GORegistry)</li> <li>GOText (AIAC::GOText)</li> <li>GetAnchor (AIAC::GOText)</li> <li>GetText (AIAC::GOText)</li> <li>GetTextSize (AIAC::GOText)</li> <li>GOTriangle (AIAC::GOTriangle)</li> <li>GetCvMat (AIAC::Image)</li> <li>GetGlTextureObj (AIAC::Image)</li> <li>GetImTexture (AIAC::Image)</li> <li>GetPath (AIAC::Image)</li> <li>GetPureCvMat (AIAC::Image)</li> <li>GetCurrentDevice (AIAC::LayerCamera)</li> <li>GetCurrentDeviceIndex (AIAC::LayerCamera)</li> <li>GetCameraCalibrator (AIAC::LayerCameraCalib)</li> <li>GetCurrentFabFeedback (AIAC::LayerFeedback)</li> <li>GetACInfoModel (AIAC::LayerModel)</li> <li>GetACInfoModelName (AIAC::LayerModel)</li> <li>GetACInfoModelPath (AIAC::LayerModel)</li> <li>GetAlignFlip (AIAC::LayerModel)</li> <li>GetAlignOffset (AIAC::LayerModel)</li> <li>GetAlignRotation (AIAC::LayerModel)</li> <li>GetScannedModel (AIAC::LayerModel)</li> <li>GetScannedModelPath (AIAC::LayerModel)</li> <li>GetTransformMat (AIAC::LayerModel)</li> <li>GetCamPoseCv (AIAC::LayerSlam)</li> <li>GetCamPoseGlm (AIAC::LayerSlam)</li> <li>GetCamPoseInObjCoord (AIAC::LayerSlam)</li> <li>GetCamPoseQuaternionAndTvec (AIAC::LayerSlam)</li> <li>GetInvCamPoseGlm (AIAC::LayerSlam)</li> <li>GetNumLostFrame (AIAC::LayerSlam)</li> <li>GetProcessedFrame (AIAC::LayerSlam)</li> <li>GetClassifierLog (AIAC::LayerToolhead)</li> <li>GetClassifierToolheadList (AIAC::LayerToolhead)</li> <li>GetPose (AIAC::LayerToolhead)</li> <li>GetTrackingStatus (AIAC::LayerToolhead)</li> <li>GetTtoolState (AIAC::LayerToolhead)</li> <li>GetWorldPose (AIAC::LayerToolhead)</li> <li>GetOpenedPaneUI (AIAC::LayerUI)</li> <li>GetSaveFolderPath (AIAC::LayerUtils)</li> <li>GetLogger (AIAC::Log)</li> <li>GetCamCalibView (AIAC::Renderer)</li> <li>GetGlobalView (AIAC::Renderer)</li> <li>GetMappingView (AIAC::Renderer)</li> <li>GetBboxEdgesIndices (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>GetBoundingBox (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>GetEndPt (AIAC::TimberInfo::Cut::Edge)</li> <li>GetStartPt (AIAC::TimberInfo::Cut::Edge)</li> <li>GetCorners (AIAC::TimberInfo::Cut::Face)</li> <li>GetEdges (AIAC::TimberInfo::Cut::Face)</li> <li>GetNeighbors (AIAC::TimberInfo::Cut::Face)</li> <li>GetAllEdges (AIAC::TimberInfo::Cut)</li> <li>GetAllFaces (AIAC::TimberInfo::Cut)</li> <li>GetAllNonExposedEdgeIDs (AIAC::TimberInfo::Cut)</li> <li>GetAllNonExposedFaceIDs (AIAC::TimberInfo::Cut)</li> <li>GetEdge (AIAC::TimberInfo::Cut)</li> <li>GetFace (AIAC::TimberInfo::Cut)</li> <li>GetFaceNeighbors (AIAC::TimberInfo::Cut)</li> <li>GetHighlightedFace (AIAC::TimberInfo::Cut)</li> <li>GetHighlightedFaceID (AIAC::TimberInfo::Cut)</li> <li>GetHighlightedFaceNeighbors (AIAC::TimberInfo::Cut)</li> <li>GetEndPointGO (AIAC::TimberInfo::Hole)</li> <li>GetStartPointGO (AIAC::TimberInfo::Hole)</li> <li>GetAllComponentsIDs (AIAC::TimberInfo)</li> <li>GetComponent (AIAC::TimberInfo)</li> <li>GetCurrentComponent (AIAC::TimberInfo)</li> <li>GetCurrentComponentID (AIAC::TimberInfo)</li> <li>GetFabricatedComponents (AIAC::TimberInfo)</li> <li>GetFabricationProgress (AIAC::TimberInfo)</li> <li>GetID (AIAC::TimberInfo)</li> <li>GetTotalComponents (AIAC::TimberInfo)</li> <li>GetScaleF (AIAC::ToolHeadData)</li> <li>GetGLFWMonitor (AIAC::TouchMonitor)</li> <li>GetMonitorID (AIAC::TouchMonitor)</li> <li>GetCurrentTimestamp (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>GenerateImageName (AIAC::Utils::Screenshot)</li> <li>GetH (AIAC::Viewport)</li> <li>GetTexture (AIAC::Viewport)</li> <li>GetW (AIAC::Viewport)</li> <li>GetDisplayH (AIAC::Window)</li> <li>GetDisplayW (AIAC::Window)</li> <li>GetGLFWWindow (AIAC::Window)</li> <li>GetGlslVersion (AIAC::Window)</li> <li>glob (glob::glob)</li> <li>glob_impl (glob::glob_impl)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#h","title":"h","text":"<ul> <li>HoleFeedback (AIAC::HoleFeedback)</li> <li>HoleFeedbackPosition (AIAC::HoleFeedbackPosition)</li> <li>HoleFeedbackRotation (AIAC::HoleFeedbackRotation)</li> <li>HoleFeedbackText (AIAC::HoleFeedbackText)</li> <li>HasGlTextureObj (AIAC::Image)</li> <li>HasImTexture (AIAC::Image)</li> <li>HighlightFace (AIAC::TimberInfo::Cut)</li> <li>Hole (AIAC::TimberInfo::Hole)</li> <li>HideAllComponentsExceptCurrent (AIAC::TimberInfo)</li> <li>HoleToolheadAxisExporter (AIAC::Utils::HoleToolheadAxisExporter)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#i","title":"i","text":"<ul> <li>Init (AIAC::Application, AIAC::EventBus, AIAC::GORegistry, AIAC::Log, AIAC::Renderer, AIAC::TextRenderer, AIAC::TouchMonitor, AIAC::Viewport, AIAC::Window)</li> <li>IsOpened (AIAC::Camera)</li> <li>IsPhysicalAndParamWidthHeightMatched (AIAC::Camera)</li> <li>IntersectBladeWithNeighbours (AIAC::CircularSawCutBladeThicknessVisualizer, AIAC::CutBladeThicknessVisualizer)</li> <li>InsertEntry (AIAC::Config, inih::INIReader)</li> <li>IsEventQueueEmpty (AIAC::EventBus)</li> <li>InitGLObject (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOTriangle)</li> <li>IsClosed (AIAC::GOPolyline)</li> <li>IsVisible (AIAC::GOPrimitive)</li> <li>Image (AIAC::Image)</li> <li>IsCalibrating (AIAC::LayerCameraCalib)</li> <li>IsCapturing (AIAC::LayerCameraCalib)</li> <li>InitACIMStatus (AIAC::LayerLogRecorder)</li> <li>InitTToolStatus (AIAC::LayerLogRecorder)</li> <li>IsPaused (AIAC::LayerLogRecorder)</li> <li>IsRecording (AIAC::LayerLogRecorder)</li> <li>InitSlamMapGOs (AIAC::LayerSlam)</li> <li>IsMapping (AIAC::LayerSlam)</li> <li>IsTracked (AIAC::LayerSlam)</li> <li>IsProcessing (AIAC::LayerUtils)</li> <li>InitCamCalibView (AIAC::Renderer)</li> <li>InitGlobalView (AIAC::Renderer)</li> <li>InitMappingView (AIAC::Renderer)</li> <li>InitProjMatrix (AIAC::Renderer)</li> <li>IsExposed (AIAC::TimberInfo::Cut::Face)</li> <li>IsSingleFace (AIAC::TimberInfo::Cut)</li> <li>ImportNameFromConfig (AIAC::TouchMonitor)</li> <li>ImportResolutionFromConfig (AIAC::TouchMonitor)</li> <li>ImportVideoModeFromConfig (AIAC::TouchMonitor)</li> <li>InitializeDirectories (AIAC::Utils::VideoRecorder)</li> <li>IsOpen (AIAC::Window)</li> <li>IsVSync (AIAC::Window)</li> <li>is_valid (glob::glob)</li> <li>INIReader (inih::INIReader)</li> <li>INIWriter (inih::INIWriter)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#k","title":"k","text":"<ul> <li>Keys (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#l","title":"l","text":"<ul> <li>Load (AIAC::ACInfoModel, AIAC::ScannedModel)</li> <li>LoadToolheadModels (AIAC::ACInfoToolheadManager)</li> <li>LoadCameraParams (AIAC::Camera)</li> <li>LoadGOMesh (AIAC::DLoader)</li> <li>LoadPly (AIAC::GOMesh)</li> <li>LayerCamera (AIAC::LayerCamera)</li> <li>LayerCameraCalib (AIAC::LayerCameraCalib)</li> <li>LayerFeedback (AIAC::LayerFeedback)</li> <li>LayerLogRecorder (AIAC::LayerLogRecorder)</li> <li>LogACIM (AIAC::LayerLogRecorder)</li> <li>LogACIMTransformation (AIAC::LayerLogRecorder)</li> <li>LogHeader (AIAC::LayerLogRecorder)</li> <li>LogSlamStatus (AIAC::LayerLogRecorder)</li> <li>LogTToolHead (AIAC::LayerLogRecorder)</li> <li>LogTToolPose (AIAC::LayerLogRecorder)</li> <li>LogTToolTransformation (AIAC::LayerLogRecorder)</li> <li>LayerModel (AIAC::LayerModel)</li> <li>LoadACInfoModel (AIAC::LayerModel)</li> <li>LoadScannedModel (AIAC::LayerModel)</li> <li>LayerSlam (AIAC::LayerSlam)</li> <li>LayerToolhead (AIAC::LayerToolhead)</li> <li>LayerUI (AIAC::LayerUI)</li> <li>LoadReconstructParams (AIAC::LayerUI)</li> <li>LoadReconstructParamsFromFile (AIAC::LayerUI)</li> <li>LayerUtils (AIAC::LayerUtils)</li> <li>LoadACIT (AIAC::ToolHeadData)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#m","title":"m","text":"<ul> <li>ManuallyScrollRefFace (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>MapMonitor (AIAC::TouchMonitor)</li> <li>MakeVideoFromFrames (AIAC::Utils::VideoRecorder)</li> <li>MakeCurrent (AIAC::Window)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#n","title":"n","text":"<ul> <li>next (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#o","title":"o","text":"<ul> <li>OnAppClose (AIAC::AppCloseEvent)</li> <li>Open (AIAC::Camera)</li> <li>OnCameraCalibrationFileLoaded (AIAC::CameraCalibrationLoadedEvent)</li> <li>operator() (AIAC::EventCompare)</li> <li>operator= (AIAC::GLLineObject, AIAC::GLMeshObject, AIAC::GLObject, AIAC::GLPointObject, AIAC::Image, CircularBuffer, glob::glob)</li> <li>operator* (AIAC::GOMesh, AIAC::GOPolyline, AIAC::GOText, AIAC::GOTriangle, CircularBuffer::BufferIterator)</li> <li>OnAttach (AIAC::Layer, AIAC::LayerCamera, AIAC::LayerCameraCalib, AIAC::LayerFeedback, AIAC::LayerLogRecorder, AIAC::LayerModel, AIAC::LayerSlam, AIAC::LayerToolhead, AIAC::LayerUI)</li> <li>OnDetach (AIAC::Layer, AIAC::LayerUI)</li> <li>OnFrameAwake (AIAC::Layer)</li> <li>OnFrameEnd (AIAC::Layer, AIAC::LayerUtils)</li> <li>OnFrameFall (AIAC::Layer)</li> <li>OnFrameStart (AIAC::Layer, AIAC::LayerCamera, AIAC::LayerCameraCalib, AIAC::LayerFeedback, AIAC::LayerLogRecorder, AIAC::LayerModel, AIAC::LayerSlam, AIAC::LayerToolhead, AIAC::LayerUI)</li> <li>OnCollapsingPaneUIToolhead (AIAC::LayerUI)</li> <li>OnUIRender (AIAC::LayerUI)</li> <li>OpenFileSelectDialog (AIAC::LayerUI)</li> <li>OnRender (AIAC::Renderer)</li> <li>OnSLAMCombineMap (AIAC::SLAMCombineMapEvent)</li> <li>OnSLAMMapLoaded (AIAC::SLAMMapLoadedEvent)</li> <li>OnSLAMStartMapping (AIAC::SLAMStartMappingEvent)</li> <li>OnSLAMStopMapping (AIAC::SLAMStopMappingEvent)</li> <li>OnSLAMVocabularyLoaded (AIAC::SLAMVocabularyLoadedEvent)</li> <li>OnBufferSwap (AIAC::Window)</li> <li>OnUpdate (AIAC::Window)</li> <li>operator[] (CircularBuffer, CircularBuffer::BufferIterator)</li> <li>operator!= (CircularBuffer::BufferIterator)</li> <li>operator++ (CircularBuffer::BufferIterator)</li> <li>operator+= (CircularBuffer::BufferIterator)</li> <li>operator-- (CircularBuffer::BufferIterator)</li> <li>operator-= (CircularBuffer::BufferIterator)</li> <li>operator-&gt; (CircularBuffer::BufferIterator)</li> <li>operator&lt; (CircularBuffer::BufferIterator)</li> <li>operator&lt;= (CircularBuffer::BufferIterator)</li> <li>operator== (CircularBuffer::BufferIterator)</li> <li>operator&gt; (CircularBuffer::BufferIterator)</li> <li>operator&gt;= (CircularBuffer::BufferIterator)</li> <li>open (glob::glob)</li> <li>operator bool (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#p","title":"p","text":"<ul> <li>PushLayer (AIAC::Application)</li> <li>ProcessQueue (AIAC::EventBus)</li> <li>PauseRecording (AIAC::LayerLogRecorder)</li> <li>PaneUI (AIAC::PaneUI)</li> <li>ParseString2GlmVector (AIAC::ToolHeadData)</li> <li>PrintInfoMonitors (AIAC::TouchMonitor)</li> <li>pop_front (CircularBuffer)</li> <li>push_back (CircularBuffer)</li> <li>ParseError (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#r","title":"r","text":"<ul> <li>Run (AIAC::Application)</li> <li>RunCalibration (AIAC::CameraCalibrator)</li> <li>ReorderIntersectPoints (AIAC::CutPlaneVisualizer)</li> <li>Remove (AIAC::GOPrimitive)</li> <li>Register (AIAC::GORegistry)</li> <li>ReplaceCvMat (AIAC::Image)</li> <li>Resize (AIAC::Image)</li> <li>ResumeRecording (AIAC::LayerLogRecorder)</li> <li>ReloadACInfoModel (AIAC::LayerModel)</li> <li>ResetAlignFlip (AIAC::LayerModel)</li> <li>ResetAlignOffset (AIAC::LayerModel)</li> <li>ResetAlignRotation (AIAC::LayerModel)</li> <li>ReloadCameraFromFile (AIAC::LayerToolhead)</li> <li>ReloadCameraFromMatrix (AIAC::LayerToolhead)</li> <li>ResetPoseFromConfig (AIAC::LayerToolhead)</li> <li>ResetToLastSavedPose (AIAC::LayerToolhead)</li> <li>RenderCamCalibView (AIAC::Renderer)</li> <li>RenderCameraFrame (AIAC::Renderer)</li> <li>RenderGlobalView (AIAC::Renderer)</li> <li>RenderMainView (AIAC::Renderer)</li> <li>RenderMappingView (AIAC::Renderer)</li> <li>Renderer (AIAC::Renderer)</li> <li>RenderText (AIAC::TextRenderer)</li> <li>RenderTextIn3DSpace (AIAC::TextRenderer)</li> <li>ReleaseCurrent (AIAC::Window)</li> <li>rbegin (CircularBuffer)</li> <li>rend (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#s","title":"s","text":"<ul> <li>Save (AIAC::ACInfoModel, AIAC::CameraCalibrator)</li> <li>SetBboxVisibility (AIAC::ACInfoModel)</li> <li>SetVisibility (AIAC::ACInfoToolhead, AIAC::GOPrimitive, AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetActiveToolhead (AIAC::ACInfoToolheadManager)</li> <li>Shutdown (AIAC::Application, AIAC::Log, AIAC::Window)</li> <li>SetCenter (AIAC::GOCircle)</li> <li>SetEdgeColor (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>SetNormal (AIAC::GOCircle)</li> <li>SetRadius (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>SetValueFrom (AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOPoint, AIAC::GOPrimitive, AIAC::GOText)</li> <li>SetPEnd (AIAC::GOCylinder, AIAC::GOLine)</li> <li>SetPStart (AIAC::GOCylinder, AIAC::GOLine)</li> <li>SetPts (AIAC::GOLine)</li> <li>SetColor (AIAC::GOMesh, AIAC::GOPrimitive)</li> <li>SetColors (AIAC::GOMesh)</li> <li>SetIndices (AIAC::GOMesh)</li> <li>SetNormals (AIAC::GOMesh)</li> <li>SetVertices (AIAC::GOMesh)</li> <li>SetPosition (AIAC::GOPoint)</li> <li>SetWeight (AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOTriangle)</li> <li>SetX (AIAC::GOPoint)</li> <li>SetY (AIAC::GOPoint)</li> <li>SetZ (AIAC::GOPoint)</li> <li>SetClosed (AIAC::GOPolyline)</li> <li>SetPoints (AIAC::GOPolyline)</li> <li>SetName (AIAC::GOPrimitive)</li> <li>SetState (AIAC::GOPrimitive)</li> <li>SetAnchor (AIAC::GOText)</li> <li>SetText (AIAC::GOText)</li> <li>SetTextSize (AIAC::GOText)</li> <li>SetImTextureSize (AIAC::Image)</li> <li>SetCurrentDevice (AIAC::LayerCamera)</li> <li>SetCurrentDeviceIndex (AIAC::LayerCamera)</li> <li>SetSaveFilename (AIAC::LayerCameraCalib)</li> <li>StartCalibration (AIAC::LayerCameraCalib)</li> <li>StartCapturing (AIAC::LayerCameraCalib)</li> <li>StopCalibration (AIAC::LayerCameraCalib)</li> <li>StartRecording (AIAC::LayerLogRecorder, AIAC::LayerUtils)</li> <li>StopRecording (AIAC::LayerLogRecorder, AIAC::LayerUtils)</li> <li>StartMapping (AIAC::LayerSlam)</li> <li>StopMapping (AIAC::LayerSlam)</li> <li>SavePose (AIAC::LayerToolhead)</li> <li>SetCurrentObject (AIAC::LayerToolhead)</li> <li>syncTToolAndACInfoToolhead (AIAC::LayerToolhead)</li> <li>SetGlobalViewUI (AIAC::LayerUI)</li> <li>SetOpenedPaneUI (AIAC::LayerUI)</li> <li>SetPaneUIACIM (AIAC::LayerUI)</li> <li>SetPaneUICamera (AIAC::LayerUI)</li> <li>SetPaneUISlam (AIAC::LayerUI)</li> <li>SetPaneUIToolhead (AIAC::LayerUI)</li> <li>SetPaneUIUtils (AIAC::LayerUI)</li> <li>ShowCamCalibPopup (AIAC::LayerUI)</li> <li>ShowCombineMapPopup (AIAC::LayerUI)</li> <li>ShowFileSelectDialog (AIAC::LayerUI)</li> <li>ShowLogRecorderUI (AIAC::LayerUI)</li> <li>ShowMainUI (AIAC::LayerUI)</li> <li>ShowMapFileDialog (AIAC::LayerUI)</li> <li>ShowMappingPopup (AIAC::LayerUI)</li> <li>ShowMenuBar (AIAC::LayerUI)</li> <li>ShowReconExportFilePathDialog (AIAC::LayerUI)</li> <li>ShowReconstruct3DPopup (AIAC::LayerUI)</li> <li>ShowSaveCamCalibFileDialog (AIAC::LayerUI)</li> <li>ShowSaveMapFileDialog (AIAC::LayerUI)</li> <li>ShowSaveVideoRecorderFileDialog (AIAC::LayerUI)</li> <li>ShowSceneViewport (AIAC::LayerUI)</li> <li>StackPane (AIAC::LayerUI)</li> <li>SetSaveFolderPath (AIAC::LayerUtils)</li> <li>SetWindowScreenshot (AIAC::LayerUtils)</li> <li>Show (AIAC::PaneUI)</li> <li>SetCamCalibViewSize (AIAC::Renderer)</li> <li>SetGlobalViewSize (AIAC::Renderer)</li> <li>SetGlobalViewToActivatedComponent (AIAC::Renderer)</li> <li>SetMappingViewSize (AIAC::Renderer)</li> <li>SLAMCombineMapEvent (AIAC::SLAMCombineMapEvent)</li> <li>SLAMMapLoadedEvent (AIAC::SLAMMapLoadedEvent)</li> <li>SLAMStartMappingEvent (AIAC::SLAMStartMappingEvent)</li> <li>SLAMStopMappingEvent (AIAC::SLAMStopMappingEvent)</li> <li>SLAMVocabularyLoadedEvent (AIAC::SLAMVocabularyLoadedEvent)</li> <li>SaberSawData (AIAC::SaberSawData)</li> <li>ScannedModel (AIAC::ScannedModel)</li> <li>SetProjection (AIAC::TextRenderer)</li> <li>SetAsCurrent (AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetAsDone (AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetAsNotDone (AIAC::TimberInfo::Component, AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>SetCotasVisibility (AIAC::TimberInfo::Cut::Edge)</li> <li>SetVisibilityAllCotas (AIAC::TimberInfo::Cut)</li> <li>SwapStartEnd (AIAC::TimberInfo::Hole)</li> <li>SetCurrentComponentTo (AIAC::TimberInfo)</li> <li>SetNextComponentAsCurrent (AIAC::TimberInfo)</li> <li>SetPrevComponentAsCurrent (AIAC::TimberInfo)</li> <li>ShortenComponentID (AIAC::TimberInfo)</li> <li>ShowAllComponents (AIAC::TimberInfo)</li> <li>SiftMonitorsByMode (AIAC::TouchMonitor)</li> <li>SiftMonitorsByResolution (AIAC::TouchMonitor)</li> <li>SaveScreenshot (AIAC::Utils::Screenshot)</li> <li>Screenshot (AIAC::Utils::Screenshot)</li> <li>SaveFrames (AIAC::Utils::VideoRecorder)</li> <li>SetSize (AIAC::Viewport)</li> <li>SetVSync (AIAC::Window)</li> <li>size (CircularBuffer)</li> <li>Sections (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#t","title":"t","text":"<ul> <li>Transform (AIAC::ACInfoModel, AIAC::ACInfoToolhead, AIAC::GOCircle, AIAC::GOCylinder, AIAC::GOLine, AIAC::GOMesh, AIAC::GOPoint, AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOText, AIAC::GOTriangle)</li> <li>ToString (AIAC::ACInfoToolhead, AIAC::ToolHeadData)</li> <li>TransformGO (AIAC::ACInfoToolhead)</li> <li>TransformSync (AIAC::ACInfoToolhead)</li> <li>toString (AIAC::FeedbackVisualizer)</li> <li>Translate (AIAC::GOLine, AIAC::GOPrimitive)</li> <li>TakeBufferScreenshot (AIAC::LayerUtils)</li> <li>TakeWindowScreenshot (AIAC::LayerUtils)</li> <li>TextRenderer (AIAC::TextRenderer)</li> <li>ToolHeadData (AIAC::ToolHeadData)</li> <li>TouchMonitor (AIAC::TouchMonitor)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateBboxGOLine (AIAC::ACInfoModel, AIAC::ScannedModel)</li> <li>UpdateCameraParamFromFile (AIAC::Camera)</li> <li>UpdateCameraParamFromSlamMap (AIAC::Camera)</li> <li>UpdateFov (AIAC::Camera)</li> <li>UpdateToolheadsData (AIAC::CircularSawCutBladeThicknessVisualizer, AIAC::CutBladeThicknessVisualizer)</li> <li>UpdateEntry (AIAC::Config, inih::INIReader)</li> <li>Update (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback, AIAC::CutPlaneVisualizer, AIAC::FabFeedback, AIAC::HoleFeedback)</li> <li>UpdateCutPlane (AIAC::CutChainSawFeedback)</li> <li>UpdateRefFaces (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>UpdateCutPlaneFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateDepthFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateOrientationFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateStartPosFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateThicknessFeedback (AIAC::CutCircularSawFeedback)</li> <li>UpdateToolPosition (AIAC::CutCircularSawFeedback)</li> <li>Unregister (AIAC::GORegistry)</li> <li>UpdateData (AIAC::Image)</li> <li>UpdateGlTextureObj (AIAC::Image)</li> <li>UpdateImTexture (AIAC::Image)</li> <li>UpdateAvailableDevices (AIAC::LayerCamera)</li> <li>UpdateMap (AIAC::LayerSlam)</li> <li>UpdateToolheadStateUI (AIAC::LayerToolhead)</li> <li>UpdateGlobalViewCameraRotation (AIAC::Renderer)</li> <li>UpdateGlobalViewCameraScale (AIAC::Renderer)</li> <li>UpdateGlobalViewCameraTranslation (AIAC::Renderer)</li> <li>UpdateCotasVisibility (AIAC::TimberInfo)</li> <li>UpdatePaths (AIAC::Utils::VideoRecorder)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#v","title":"v","text":"<ul> <li>ValidateAndUpdateFlag (AIAC::CameraCalibrator)</li> <li>vec3 (AIAC::GOPoint)</li> <li>VideoRecorder (AIAC::Utils::VideoRecorder)</li> <li>Viewport (AIAC::Viewport)</li> <li>V2String (inih::INIReader)</li> <li>ValueHandler (inih::INIReader)</li> <li>Vec2String (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#w","title":"w","text":"<ul> <li>WriteToFile (AIAC::Config)</li> <li>WriteBufferToFile (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>WriteCoordToBuffer (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>Window (AIAC::Window)</li> <li>WindowProps (AIAC::WindowProps)</li> <li>write (inih::INIWriter)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#x","title":"x","text":"<ul> <li>X (AIAC::GOPoint)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#y","title":"y","text":"<ul> <li>Y (AIAC::GOPoint)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#z","title":"z","text":"<ul> <li>Z (AIAC::GOPoint)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#_1","title":"~","text":"<ul> <li>~ACInfoModel (AIAC::ACInfoModel)</li> <li>~Application (AIAC::Application)</li> <li>~Camera (AIAC::Camera)</li> <li>~CameraCalibrator (AIAC::CameraCalibrator)</li> <li>~CutCircularSawFeedback (AIAC::CutCircularSawFeedback)</li> <li>~DLoader (AIAC::DLoader)</li> <li>~Event (AIAC::Event)</li> <li>~EventBus (AIAC::EventBus)</li> <li>~FabFeedback (AIAC::FabFeedback)</li> <li>~FeedbackVisualizer (AIAC::FeedbackVisualizer)</li> <li>~GLObject (AIAC::GLObject)</li> <li>~GOCircle (AIAC::GOCircle)</li> <li>~GOCylinder (AIAC::GOCylinder)</li> <li>~GOLine (AIAC::GOLine)</li> <li>~GOMesh (AIAC::GOMesh)</li> <li>~GOPoint (AIAC::GOPoint)</li> <li>~GOPolyline (AIAC::GOPolyline)</li> <li>~GOPrimitive (AIAC::GOPrimitive)</li> <li>~GORegistry (AIAC::GORegistry)</li> <li>~GOText (AIAC::GOText)</li> <li>~GOTriangle (AIAC::GOTriangle)</li> <li>~HoleFeedback (AIAC::HoleFeedback)</li> <li>~Image (AIAC::Image)</li> <li>~Layer (AIAC::Layer)</li> <li>~LayerCamera (AIAC::LayerCamera)</li> <li>~LayerCameraCalib (AIAC::LayerCameraCalib)</li> <li>~LayerFeedback (AIAC::LayerFeedback)</li> <li>~LayerLogRecorder (AIAC::LayerLogRecorder)</li> <li>~LayerModel (AIAC::LayerModel)</li> <li>~LayerSlam (AIAC::LayerSlam)</li> <li>~LayerUI (AIAC::LayerUI)</li> <li>~Renderer (AIAC::Renderer)</li> <li>~ScannedModel (AIAC::ScannedModel)</li> <li>~TextRenderer (AIAC::TextRenderer)</li> <li>~ToolHeadData (AIAC::ToolHeadData)</li> <li>~TouchMonitor (AIAC::TouchMonitor)</li> <li>~HoleToolheadAxisExporter (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>~VideoRecorder (AIAC::Utils::VideoRecorder)</li> <li>~Viewport (AIAC::Viewport)</li> <li>~Window (AIAC::Window)</li> <li>~glob (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_member_functions/#_","title":"_","text":"<ul> <li>_decrement_bufferstate (CircularBuffer)</li> <li>_increment_bufferstate (CircularBuffer)</li> <li>_comparable (CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_variables/","title":"Class Member Variables","text":""},{"location":"acdoxygen/class_member_variables/#a","title":"a","text":"<ul> <li>aspectRatio (AIAC::CameraCalibrator)</li> <li>Advance (AIAC::Character)</li> <li>AC_INFO_MODEL (AIAC::Config)</li> <li>ALIGN_FLIP (AIAC::Config)</li> <li>ALIGN_OFFSET (AIAC::Config)</li> <li>ALIGN_ROTATION (AIAC::Config)</li> <li>Average (AIAC::GOTextSize)</li> <li>AvailableDevices (AIAC::LayerCamera)</li> <li>AutoCapture (AIAC::LayerCameraCalib)</li> <li>ACInfoToolheadManager (AIAC::LayerToolhead)</li> <li>AABBScaleFactor (AIAC::LayerUI::ReconstructParams)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#b","title":"b","text":"<ul> <li>boardSize (AIAC::CameraCalibrator)</li> <li>Bearing (AIAC::Character)</li> <li>BLACK (AIAC::GOColor)</li> <li>BLUE (AIAC::GOColor)</li> <li>BROWN (AIAC::GOColor)</li> <li>Big (AIAC::GOTextSize)</li> <li>BitSmall (AIAC::GOTextSize)</li> <li>Bold (AIAC::GOWeight)</li> <li>BoldThick (AIAC::GOWeight)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#c","title":"c","text":"<ul> <li>calibFixPrincipalPoint (AIAC::CameraCalibrator)</li> <li>calibFlag (AIAC::CameraCalibrator)</li> <li>calibZeroTangentDist (AIAC::CameraCalibrator)</li> <li>calibrationPattern (AIAC::CameraCalibrator)</li> <li>cameraMatrix (AIAC::CameraCalibrator)</li> <li>ChainBaseACIT (AIAC::ChainSawData)</li> <li>ChainBaseGO (AIAC::ChainSawData)</li> <li>ChainEndGO (AIAC::ChainSawData)</li> <li>ChainMidACIT (AIAC::ChainSawData)</li> <li>ChainMidGO (AIAC::ChainSawData)</li> <li>ChainNormEndACIT (AIAC::ChainSawData)</li> <li>CenterACIT (AIAC::CircularSawData)</li> <li>CenterGO (AIAC::CircularSawData)</li> <li>CACHED_TOOLHEAD (AIAC::Config)</li> <li>CAM_FLIP_HORIZONTAL (AIAC::Config)</li> <li>CAM_FLIP_VERTICAL (AIAC::Config)</li> <li>CAM_ID (AIAC::Config)</li> <li>CAM_PARAMS_FILE (AIAC::Config)</li> <li>CONFIG_FILE (AIAC::Config)</li> <li>ChucktipACIT (AIAC::DrillBitData)</li> <li>ChucktipGO (AIAC::DrillBitData)</li> <li>colorBuf (AIAC::GLObject)</li> <li>CYAN (AIAC::GOColor)</li> <li>Characters (AIAC::TextRenderer)</li> <li>CreaseAngleThreshold (AIAC::LayerUI::ReconstructParams)</li> <li>count (IGFD_Selection)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#d","title":"d","text":"<ul> <li>distCoeffs (AIAC::CameraCalibrator)</li> <li>DATASET_DIR (AIAC::Config)</li> <li>Default (AIAC::GOTextSize, AIAC::GOWeight)</li> <li>Delay (AIAC::LayerCameraCalib)</li> <li>dir_path (glob::glob)</li> <li>dir (glob::glob_impl)</li> <li>dir_entry (glob::glob_impl)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#e","title":"e","text":"<ul> <li>EattipACIT (AIAC::DrillBitData)</li> <li>EattipGO (AIAC::DrillBitData)</li> <li>ExtraSmall (AIAC::GOTextSize)</li> <li>ExtraThick (AIAC::GOWeight)</li> <li>Eps (AIAC::LayerUI::ReconstructParams)</li> <li>ExportPath (AIAC::LayerUI::ReconstructParams)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#f","title":"f","text":"<ul> <li>FlipHorizontal (AIAC::Camera)</li> <li>FlipVertical (AIAC::Camera)</li> <li>fixDistortion (AIAC::CameraCalibrator)</li> <li>flipVertical (AIAC::CameraCalibrator)</li> <li>FilePathTarget (AIAC::LayerUI::CombineMapParams)</li> <li>fileName (IGFD_Selection_Pair)</li> <li>filePathName (IGFD_Selection_Pair)</li> <li>file_pattern (glob::glob_impl)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#g","title":"g","text":"<ul> <li>goodInput (AIAC::CameraCalibrator)</li> <li>gridWidth (AIAC::CameraCalibrator)</li> <li>GRAY (AIAC::GOColor)</li> <li>GREEN (AIAC::GOColor)</li> <li>GREEN_DARKER_TRANSP07 (AIAC::GOColor)</li> <li>GREEN_PUNK_TRANSP07 (AIAC::GOColor)</li> <li>GREEN_TRANSP07 (AIAC::GOColor)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#h","title":"h","text":"<ul> <li>Height (AIAC::WindowProps, AIAC::Window::WindowData)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#i","title":"i","text":"<ul> <li>IsResizable (AIAC::ApplicationSpecification, AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>imageList (AIAC::CameraCalibrator)</li> <li>imagePoints (AIAC::CameraCalibrator)</li> <li>imageSize (AIAC::CameraCalibrator)</li> <li>IsSegmenDetectToolPlaneVisible (AIAC::CutBladeThicknessVisualizer)</li> <li>IsRefFacesSelectedManually (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>indexBuf (AIAC::GLMeshObject)</li> <li>ID (AIAC::ImTexture)</li> <li>IsSavePoseLog (AIAC::LayerToolhead)</li> <li>IsShowShaded (AIAC::LayerToolhead)</li> <li>IsShowSilouhette (AIAC::LayerToolhead)</li> <li>IsShowToolheadGOInfo (AIAC::LayerToolhead)</li> <li>IsMarkedDone (AIAC::TimberInfo::Component)</li> <li>IsShowingAllComponents (AIAC::TimberInfo)</li> <li>IsShowingCotas (AIAC::TimberInfo)</li> <li>impl_ (glob::glob)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#j","title":"j","text":"<ul> <li>JustCaptured (AIAC::LayerCameraCalib)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#l","title":"l","text":"<ul> <li>LINK_MODE (AIAC::Config)</li> <li>lineWidth (AIAC::GLLineObject)</li> <li>Light (AIAC::GOWeight)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#m","title":"m","text":"<ul> <li>m_ACIMDoc (AIAC::ACInfoModel)</li> <li>m_BboxGOLines (AIAC::ACInfoModel, AIAC::ScannedModel)</li> <li>m_EdgeWeight (AIAC::ACInfoModel)</li> <li>m_FilePath (AIAC::ACInfoModel, AIAC::CameraCalibrationLoadedEvent, AIAC::SLAMMapLoadedEvent, AIAC::SLAMVocabularyLoadedEvent)</li> <li>m_LabelSize (AIAC::ACInfoModel)</li> <li>m_MeasuredBboxLength (AIAC::ACInfoModel)</li> <li>m_Scale (AIAC::ACInfoModel, AIAC::TimberInfo::Component)</li> <li>m_TimberInfo (AIAC::ACInfoModel)</li> <li>m_ACITPath (AIAC::ACInfoToolhead)</li> <li>m_Data (AIAC::ACInfoToolhead, AIAC::Window)</li> <li>m_GOPrimitivesInfo (AIAC::ACInfoToolhead)</li> <li>m_GOPrimitivesInfoOriginal (AIAC::ACInfoToolhead)</li> <li>m_ID (AIAC::ACInfoToolhead, AIAC::TimberInfo::Component, AIAC::TimberInfo, AIAC::TouchMonitor)</li> <li>m_OBJPath (AIAC::ACInfoToolhead)</li> <li>m_ACInfoToolheadMap (AIAC::ACInfoToolheadManager)</li> <li>m_ActiveACInfoToolhead (AIAC::ACInfoToolheadManager)</li> <li>m_AppSpec (AIAC::Application)</li> <li>m_EventBus (AIAC::Application)</li> <li>m_GORegistry (AIAC::Application)</li> <li>m_IsRunning (AIAC::Application)</li> <li>m_LayerMap (AIAC::Application)</li> <li>m_LayerStack (AIAC::Application)</li> <li>m_Renderer (AIAC::Application)</li> <li>m_Window (AIAC::Application)</li> <li>m_CalibFilePath (AIAC::Camera)</li> <li>m_CalibratedCurrentFrame (AIAC::Camera)</li> <li>m_CameraMatrix (AIAC::Camera)</li> <li>m_CenterCroppedCurrentFrame (AIAC::Camera)</li> <li>m_DistortionCoef (AIAC::Camera)</li> <li>m_FovX (AIAC::Camera)</li> <li>m_FovY (AIAC::Camera)</li> <li>m_GrayCalibratedCurrentFrame (AIAC::Camera)</li> <li>m_IsCamMatrixInit (AIAC::Camera)</li> <li>m_IsFisheye (AIAC::Camera)</li> <li>m_IsOpened (AIAC::Camera)</li> <li>m_ParamHeight (AIAC::Camera)</li> <li>m_ParamWidth (AIAC::Camera)</li> <li>m_PhysicalHeight (AIAC::Camera)</li> <li>m_PhysicalWidth (AIAC::Camera)</li> <li>m_RawCurrentFrame (AIAC::Camera)</li> <li>m_UndistortMap (AIAC::Camera)</li> <li>m_VideoCapture (AIAC::Camera)</li> <li>MAP_FILE (AIAC::Config)</li> <li>m_Filename (AIAC::Config)</li> <li>m_IniReader (AIAC::Config)</li> <li>m_UpdateFile (AIAC::Config)</li> <li>m_BladeOverhangScaled (AIAC::CutBladeThicknessVisualizer)</li> <li>m_BladeTotalThicknessScaled (AIAC::CutBladeThicknessVisualizer)</li> <li>m_DisplacedCenterAwayFromCamera (AIAC::CutBladeThicknessVisualizer)</li> <li>m_DisplacedCenterTowardsCamera (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmenDetectToolPlane (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentAwayFromCameraA (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentAwayFromCameraB (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentTowardsCameraA (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LongestIntersectSegmentTowardsCameraB (AIAC::CutBladeThicknessVisualizer)</li> <li>m_NormalOppositeUnitized (AIAC::CutBladeThicknessVisualizer)</li> <li>m_NormalUnitized (AIAC::CutBladeThicknessVisualizer)</li> <li>m_ToolheadRefCenter (AIAC::CutBladeThicknessVisualizer)</li> <li>m_ToolheadRefNormEnd (AIAC::CutBladeThicknessVisualizer)</li> <li>m_ToolheadRefNormStart (AIAC::CutBladeThicknessVisualizer)</li> <li>m_LineChainBase (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>m_LineChainEnd (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>m_LineEnd (AIAC::CutChainSawAngleFeedVisualizer)</li> <li>m_LineDepthFaceEdge1 (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_LineDepthFaceEdge2 (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_LineIntersect (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_LineIntersectThickness (AIAC::CutChainSawDepthFeedVisualizer)</li> <li>m_AngleFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>m_DepthFeedVisualizer (AIAC::CutChainSawFeedVisualizer)</li> <li>m_DistDepthAcceptance (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtChainBase (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtChainEnd (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtEnd (AIAC::CutChainSawFeedVisualizer)</li> <li>m_GuideTxtFaceEdgeDepth (AIAC::CutChainSawFeedVisualizer)</li> <li>m_ChainBase (AIAC::CutChainSawFeedback)</li> <li>m_ChainEnd (AIAC::CutChainSawFeedback)</li> <li>m_ChainMid (AIAC::CutChainSawFeedback)</li> <li>m_Cut (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_CutOrientationVisualizer (AIAC::CutChainSawFeedback)</li> <li>m_CutPlaneVisualizer (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_NearestParallelFaceID (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_NearestPerpendicularFaceID (AIAC::CutChainSawFeedback)</li> <li>m_NormEnd (AIAC::CutChainSawFeedback)</li> <li>m_NormStart (AIAC::CutChainSawFeedback)</li> <li>m_NormalVec (AIAC::CutChainSawFeedback)</li> <li>m_ToShowCutPlane (AIAC::CutChainSawFeedback, AIAC::CutCircularSawFeedback)</li> <li>m_Visualizer (AIAC::CutChainSawFeedback)</li> <li>m_GuideTxtRollPitch (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineBladeNormal (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugA (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugB (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugC (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugD (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDebugE (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineFaceNormal (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LinePitchFeed (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_tolAangleAcceptance (AIAC::CutCircularOrientationVisualizer, AIAC::CutOrientationVisualizer)</li> <li>m_LineDepth (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_PtBlade2ThicknessLineA (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_PtBlade2ThicknessLineB (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_ToleranceDepthThreshold (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_TxtDepth (AIAC::CutCircularSawDepthVisualizer)</li> <li>m_BottomPoint (AIAC::CutCircularSawFeedback)</li> <li>m_Center (AIAC::CutCircularSawFeedback, AIAC::GOCircle, AIAC::TimberInfo::Component)</li> <li>m_DepthVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_DownVec (AIAC::CutCircularSawFeedback)</li> <li>m_NearestNeighbourFaceIDToParallelFace (AIAC::CutCircularSawFeedback)</li> <li>m_Normal (AIAC::CutCircularSawFeedback, AIAC::GOCircle, AIAC::TimberInfo::Cut::Face)</li> <li>m_NormalEnd (AIAC::CutCircularSawFeedback)</li> <li>m_NormalStart (AIAC::CutCircularSawFeedback)</li> <li>m_OrientationVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_PositionStartVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_Radius (AIAC::CutCircularSawFeedback, AIAC::GOCircle, AIAC::GOCylinder, AIAC::TimberInfo::Hole)</li> <li>m_SecondNearestNeighbourFaceIDToParallelFace (AIAC::CutCircularSawFeedback)</li> <li>m_ThicknessVisualizer (AIAC::CutCircularSawFeedback)</li> <li>m_LineDistStart (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>m_LineToBottomPt (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>m_TxtDistStart (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>m_LongestIntersectSegmentA1 (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentA2 (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentAppCenterA (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentAppCenterB (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentB1 (AIAC::CutPlaneVisualizer)</li> <li>m_LongestIntersectSegmentB2 (AIAC::CutPlaneVisualizer)</li> <li>m_Category (AIAC::Event)</li> <li>m_Priority (AIAC::Event)</li> <li>m_Type (AIAC::Event, AIAC::GOPrimitive, AIAC::TimberInfo::Component, AIAC::ToolHeadData)</li> <li>m_EventQueue (AIAC::EventBus)</li> <li>m_ScaleFactor (AIAC::FabFeedback)</li> <li>m_AllPrimitives (AIAC::FeedbackVisualizer)</li> <li>m_Colors (AIAC::GLMeshObject, AIAC::GOMesh)</li> <li>m_Indices (AIAC::GLMeshObject, AIAC::GOMesh)</li> <li>m_Vertices (AIAC::GLMeshObject, AIAC::GOMesh)</li> <li>m_EdgeColor (AIAC::GOCircle, AIAC::GOCylinder)</li> <li>MAGENTA (AIAC::GOColor)</li> <li>MAGENTA_TRANSP07 (AIAC::GOColor)</li> <li>m_PEnd (AIAC::GOCylinder, AIAC::GOLine)</li> <li>m_PStart (AIAC::GOCylinder, AIAC::GOLine)</li> <li>m_IsUsingUniformColor (AIAC::GOMesh)</li> <li>m_Normals (AIAC::GOMesh)</li> <li>m_UniformColor (AIAC::GOMesh)</li> <li>m_Position (AIAC::GOPoint)</li> <li>m_IsClosed (AIAC::GOPolyline)</li> <li>m_Points (AIAC::GOPolyline)</li> <li>m_Weight (AIAC::GOPolyline, AIAC::GOPrimitive, AIAC::GOTriangle)</li> <li>m_Color (AIAC::GOPrimitive)</li> <li>m_GLObjects (AIAC::GOPrimitive)</li> <li>m_Id (AIAC::GOPrimitive)</li> <li>m_IsVisible (AIAC::GOPrimitive)</li> <li>m_Name (AIAC::GOPrimitive, AIAC::ToolHeadData, AIAC::TouchMonitor)</li> <li>m_State (AIAC::GOPrimitive, AIAC::TimberInfo::Component, AIAC::TimberInfo)</li> <li>m_GOMap (AIAC::GORegistry)</li> <li>m_Anchor (AIAC::GOText)</li> <li>m_Size (AIAC::GOText)</li> <li>m_Text (AIAC::GOText)</li> <li>Medium (AIAC::GOTextSize, AIAC::GOWeight)</li> <li>m_P1 (AIAC::GOTriangle)</li> <li>m_P2 (AIAC::GOTriangle)</li> <li>m_P3 (AIAC::GOTriangle)</li> <li>MaxThick (AIAC::GOWeight)</li> <li>MediumThick (AIAC::GOWeight)</li> <li>m_DrillBitLineAxis (AIAC::HoleFeedback)</li> <li>m_HoleLineAxis (AIAC::HoleFeedback)</li> <li>m_InsideOutDetection (AIAC::HoleFeedback)</li> <li>m_OrientationTolerance (AIAC::HoleFeedback)</li> <li>m_VisPosition (AIAC::HoleFeedback)</li> <li>m_VisRotation (AIAC::HoleFeedback)</li> <li>m_VisText (AIAC::HoleFeedback)</li> <li>m_HoleLine2ToolEnd (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolEnd_A (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolEnd_B (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolStart (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolStart_A (AIAC::HoleFeedbackPosition)</li> <li>m_HoleLine2ToolStart_B (AIAC::HoleFeedbackPosition)</li> <li>m_GUILineOrientation (AIAC::HoleFeedbackRotation)</li> <li>m_GUILineOrientation_A (AIAC::HoleFeedbackRotation)</li> <li>m_GUILineOrientation_B (AIAC::HoleFeedbackRotation)</li> <li>m_InfoText (AIAC::HoleFeedbackText)</li> <li>m_CvMat (AIAC::Image)</li> <li>m_DataUpdatedAfterGenGlTexture (AIAC::Image)</li> <li>m_DataUpdatedAfterGenImTexture (AIAC::Image)</li> <li>m_Format (AIAC::Image)</li> <li>m_GlTextureObj (AIAC::Image)</li> <li>m_ImTexture (AIAC::Image)</li> <li>m_Path (AIAC::Image)</li> <li>m_PureCvMat (AIAC::Image)</li> <li>MainCamera (AIAC::LayerCamera)</li> <li>m_CurrentDeviceIndex (AIAC::LayerCamera)</li> <li>m_CameraCalibrator (AIAC::LayerCameraCalib)</li> <li>m_IsCalibrating (AIAC::LayerCameraCalib)</li> <li>m_IsCapturing (AIAC::LayerCameraCalib)</li> <li>m_CurrentFabFeedbackPtr (AIAC::LayerFeedback)</li> <li>m_CutChainSawFeedback (AIAC::LayerFeedback)</li> <li>m_CutCircularSawFeedback (AIAC::LayerFeedback)</li> <li>m_HoleFeedback (AIAC::LayerFeedback)</li> <li>m_IsCurrentFabFeedbackVisible (AIAC::LayerFeedback)</li> <li>m_ACIMComponentStatus (AIAC::LayerLogRecorder)</li> <li>m_ACIMFlip (AIAC::LayerLogRecorder)</li> <li>m_ACIMOffset (AIAC::LayerLogRecorder)</li> <li>m_ACIMPreviousActivatedComponentID (AIAC::LayerLogRecorder)</li> <li>m_ACIMRotation (AIAC::LayerLogRecorder)</li> <li>m_FrameCount (AIAC::LayerLogRecorder)</li> <li>m_IsActivatedComponentDone (AIAC::LayerLogRecorder)</li> <li>m_IsPaused (AIAC::LayerLogRecorder)</li> <li>m_IsRecording (AIAC::LayerLogRecorder)</li> <li>m_LogFile (AIAC::LayerLogRecorder)</li> <li>m_LogFilePath (AIAC::LayerLogRecorder)</li> <li>m_LogFolderPath (AIAC::LayerLogRecorder)</li> <li>m_TToolPreviousToolheadName (AIAC::LayerLogRecorder)</li> <li>m_TToolStatusToLog (AIAC::LayerLogRecorder)</li> <li>m_ACIMTransformMat (AIAC::LayerModel)</li> <li>m_ACInfoModel (AIAC::LayerModel)</li> <li>m_ACInfoModelPath (AIAC::LayerModel)</li> <li>m_AlignFlip (AIAC::LayerModel)</li> <li>m_AlignOffset (AIAC::LayerModel)</li> <li>m_AlignRotation (AIAC::LayerModel)</li> <li>m_ScannedModel (AIAC::LayerModel)</li> <li>m_ScannedModelPath (AIAC::LayerModel)</li> <li>m_CamPose (AIAC::LayerSlam)</li> <li>m_CamPoseBuffer (AIAC::LayerSlam)</li> <li>m_IsMapping (AIAC::LayerSlam)</li> <li>m_IsShowingTag (AIAC::LayerSlam)</li> <li>m_IsTracked (AIAC::LayerSlam)</li> <li>m_LastTrackedCamPose (AIAC::LayerSlam)</li> <li>m_MaxCamPoseBufferSize (AIAC::LayerSlam)</li> <li>m_NumLongDistFrame (AIAC::LayerSlam)</li> <li>m_NumLostFrame (AIAC::LayerSlam)</li> <li>m_ProcessedFrame (AIAC::LayerSlam)</li> <li>m_SlamMapGOs (AIAC::LayerSlam)</li> <li>m_ToStartMapping (AIAC::LayerSlam)</li> <li>m_ACScaleFactor (AIAC::LayerToolhead)</li> <li>m_ClassifierToolList (AIAC::LayerToolhead)</li> <li>m_Pose (AIAC::LayerToolhead)</li> <li>m_TtoolState (AIAC::LayerToolhead)</li> <li>m_ARCameraViewportImTexture (AIAC::LayerUI)</li> <li>m_AdjustTarget (AIAC::LayerUI)</li> <li>m_CamCalibViewImTexture (AIAC::LayerUI)</li> <li>m_CombMapParams (AIAC::LayerUI)</li> <li>m_FileSelectDefaultPath (AIAC::LayerUI)</li> <li>m_FileSelectionCallback (AIAC::LayerUI)</li> <li>m_FileSelectionTargetBuf (AIAC::LayerUI)</li> <li>m_IsChoosingCamCalibFileSavePath (AIAC::LayerUI)</li> <li>m_IsCombiningMap (AIAC::LayerUI)</li> <li>m_IsMouseLDown (AIAC::LayerUI)</li> <li>m_IsMouseRDown (AIAC::LayerUI)</li> <li>m_IsOpen (AIAC::LayerUI)</li> <li>m_IsReconstructing3D (AIAC::LayerUI)</li> <li>m_LastMouseLPos (AIAC::LayerUI)</li> <li>m_LastMouseRPos (AIAC::LayerUI)</li> <li>m_LogoLightClr (AIAC::LayerUI)</li> <li>m_MappingParams (AIAC::LayerUI)</li> <li>m_MappingViewImTexture (AIAC::LayerUI)</li> <li>m_OpenedPaneUI (AIAC::LayerUI)</li> <li>m_PaneUIStack (AIAC::LayerUI)</li> <li>m_ReconstructParams (AIAC::LayerUI)</li> <li>m_SceneViewportImTexture (AIAC::LayerUI)</li> <li>m_TmpPathBuf (AIAC::LayerUI)</li> <li>m_VideoRecorderPathName (AIAC::LayerUI)</li> <li>m_HoleToolheadAxisExporter (AIAC::LayerUtils)</li> <li>m_Processing (AIAC::LayerUtils)</li> <li>m_Recording (AIAC::LayerUtils)</li> <li>m_UtilsPath (AIAC::LayerUtils)</li> <li>m_VideoRecorder (AIAC::LayerUtils)</li> <li>m_WindowScreenshot (AIAC::LayerUtils)</li> <li>m_CollapseState (AIAC::PaneUI)</li> <li>m_IsCollapsed (AIAC::PaneUI)</li> <li>m_Label (AIAC::PaneUI)</li> <li>m_func (AIAC::PaneUI)</li> <li>m_onCollapseCallback (AIAC::PaneUI)</li> <li>m_BasicShaderProgram (AIAC::Renderer)</li> <li>m_CamCalibView (AIAC::Renderer)</li> <li>m_CamH (AIAC::Renderer)</li> <li>m_CamVisualizationEdges (AIAC::Renderer)</li> <li>m_CamW (AIAC::Renderer)</li> <li>m_DefaultEdgeColor (AIAC::Renderer)</li> <li>m_DigitalModelBoundingBoxColor (AIAC::Renderer)</li> <li>m_DigitalModelFaceColor (AIAC::Renderer)</li> <li>m_GlobalCamLookAtCenter (AIAC::Renderer)</li> <li>m_GlobalCamMatrix (AIAC::Renderer)</li> <li>m_GlobalProjMatrix (AIAC::Renderer)</li> <li>m_GlobalProjOrthoSize (AIAC::Renderer)</li> <li>m_GlobalView (AIAC::Renderer)</li> <li>m_MappingView (AIAC::Renderer)</li> <li>m_MatrixId (AIAC::Renderer)</li> <li>m_PointCloudMapColor (AIAC::Renderer)</li> <li>m_ProjMatrix (AIAC::Renderer)</li> <li>m_TestGLObject (AIAC::Renderer)</li> <li>m_VAO (AIAC::Renderer)</li> <li>m_AABBScaleFactor (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_CreaseAngleThreshold (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_EPS (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MapPathA (AIAC::SLAMCombineMapEvent)</li> <li>m_MapPathB (AIAC::SLAMCombineMapEvent)</li> <li>m_MaxPlnAngle2Merge (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MaxPlnDist2Merge (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MaxPolyTagDist (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_MinClusterSize (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_OptimizeIterations (AIAC::SLAMCombineMapEvent)</li> <li>m_OutputPath (AIAC::SLAMCombineMapEvent)</li> <li>m_RadiusSearch (AIAC::SLAMCombineMapEvent, AIAC::SLAMStopMappingEvent)</li> <li>m_SavePath (AIAC::SLAMStopMappingEvent)</li> <li>m_ToOptimize (AIAC::SLAMStopMappingEvent)</li> <li>m_ToSave (AIAC::SLAMStopMappingEvent)</li> <li>m_Bbox (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>m_BboxEdgesIndices (AIAC::ScannedModel, AIAC::TimberInfo)</li> <li>m_Mesh (AIAC::ScannedModel)</li> <li>m_ACIMDocNode (AIAC::TimberInfo::Component)</li> <li>m_GOPrimitives (AIAC::TimberInfo::Component)</li> <li>m_CotaLines (AIAC::TimberInfo::Cut::Edge)</li> <li>m_CotaPts (AIAC::TimberInfo::Cut::Edge)</li> <li>m_Cotas (AIAC::TimberInfo::Cut::Edge)</li> <li>m_End (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Hole)</li> <li>m_GO (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Cut::Face)</li> <li>m_Neighbors (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Cut::Face, AIAC::TimberInfo::Hole)</li> <li>m_Start (AIAC::TimberInfo::Cut::Edge, AIAC::TimberInfo::Hole)</li> <li>m_Corners (AIAC::TimberInfo::Cut::Face)</li> <li>m_Edges (AIAC::TimberInfo::Cut::Face, AIAC::TimberInfo::Cut)</li> <li>m_Exposed (AIAC::TimberInfo::Cut::Face)</li> <li>m_Faces (AIAC::TimberInfo::Cut)</li> <li>m_HighlightedFaceID (AIAC::TimberInfo::Cut)</li> <li>m_IDLabelGO (AIAC::TimberInfo::Cut, AIAC::TimberInfo::Hole)</li> <li>m_NonExposedEdgeIDs (AIAC::TimberInfo::Cut)</li> <li>m_NonExposedFaceIDs (AIAC::TimberInfo::Cut)</li> <li>m_AxisGO (AIAC::TimberInfo::Hole)</li> <li>m_CylinderGO (AIAC::TimberInfo::Hole)</li> <li>m_EndExposed (AIAC::TimberInfo::Hole)</li> <li>m_EndPointGO (AIAC::TimberInfo::Hole)</li> <li>m_StartExposed (AIAC::TimberInfo::Hole)</li> <li>m_StartPointGO (AIAC::TimberInfo::Hole)</li> <li>m_Components (AIAC::TimberInfo)</li> <li>m_CurrentComponentID (AIAC::TimberInfo)</li> <li>m_Cuts (AIAC::TimberInfo)</li> <li>m_Holes (AIAC::TimberInfo)</li> <li>m_ChainSawD (AIAC::ToolHeadData)</li> <li>m_CircularSawD (AIAC::ToolHeadData)</li> <li>m_DrillBitD (AIAC::ToolHeadData)</li> <li>m_SaberSawD (AIAC::ToolHeadData)</li> <li>m_ScaleF (AIAC::ToolHeadData)</li> <li>m_IsConnected (AIAC::TouchMonitor)</li> <li>m_IsPrintMonitorsInfo (AIAC::TouchMonitor)</li> <li>m_Resolution (AIAC::TouchMonitor)</li> <li>m_SiftedMonitors (AIAC::TouchMonitor)</li> <li>m_VideoMode (AIAC::TouchMonitor)</li> <li>m_BasePath (AIAC::Utils::HoleToolheadAxisExporter, AIAC::Utils::Screenshot, AIAC::Utils::VideoRecorder)</li> <li>m_Buffer (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>m_FileName (AIAC::Utils::HoleToolheadAxisExporter)</li> <li>m_ImageName (AIAC::Utils::Screenshot)</li> <li>m_ScreenshotPath (AIAC::Utils::Screenshot)</li> <li>m_FramesPath (AIAC::Utils::VideoRecorder)</li> <li>m_RecorderPath (AIAC::Utils::VideoRecorder)</li> <li>m_VideoPath (AIAC::Utils::VideoRecorder)</li> <li>m_DepthBuffer (AIAC::Viewport)</li> <li>m_FrameBuffer (AIAC::Viewport)</li> <li>m_H (AIAC::Viewport)</li> <li>m_Texture (AIAC::Viewport)</li> <li>m_W (AIAC::Viewport)</li> <li>m_DisplayH (AIAC::Window)</li> <li>m_DisplayW (AIAC::Window)</li> <li>m_GLFWWindow (AIAC::Window)</li> <li>m_GlslVersion (AIAC::Window)</li> <li>m_IsWindowOpen (AIAC::Window)</li> <li>m_TouchMonitor (AIAC::Window)</li> <li>MapPathA (AIAC::LayerUI::CombineMapParams)</li> <li>MapPathB (AIAC::LayerUI::CombineMapParams)</li> <li>MapSavingPath (AIAC::LayerUI::MappingParams)</li> <li>MaxPlnAngle (AIAC::LayerUI::ReconstructParams)</li> <li>MaxPlnDist (AIAC::LayerUI::ReconstructParams)</li> <li>MaxPolyDist (AIAC::LayerUI::ReconstructParams)</li> <li>MinClusterSize (AIAC::LayerUI::ReconstructParams)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#n","title":"n","text":"<ul> <li>Name (AIAC::ApplicationSpecification)</li> <li>NameACIT (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>NormEndACIT (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NormEndGO (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NormStartACIT (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NormStartGO (AIAC::ChainSawData, AIAC::CircularSawData, AIAC::SaberSawData)</li> <li>NAME (AIAC::Config)</li> <li>NumOfFrame (AIAC::LayerCameraCalib)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#o","title":"o","text":"<ul> <li>OverhangACIT (AIAC::ChainSawData, AIAC::CircularSawData)</li> <li>ORANGE (AIAC::GOColor)</li> <li>ORANGE_TRANSP (AIAC::GOColor)</li> <li>OutputPath (AIAC::LayerUI::CombineMapParams)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#p","title":"p","text":"<ul> <li>pointSize (AIAC::GLPointObject)</li> <li>PINK (AIAC::GOColor)</li> <li>PINK_TRANSP (AIAC::GOColor)</li> <li>PINK_TRANSP07 (AIAC::GOColor)</li> <li>PURPLE (AIAC::GOColor)</li> <li>PURPLE_TRANSP (AIAC::GOColor)</li> <li>PURPLE_TRANSP07 (AIAC::GOColor)</li> <li>prevCaptureTimestamp (AIAC::LayerCameraCalib)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#r","title":"r","text":"<ul> <li>reprojErrs (AIAC::CameraCalibrator)</li> <li>rvecs (AIAC::CameraCalibrator)</li> <li>RadiusACIT (AIAC::CircularSawData, AIAC::DrillBitData)</li> <li>RECONSTRUCT_CONFIG_DEFAULT_FILE (AIAC::Config)</li> <li>RESOLUTION (AIAC::Config)</li> <li>RED (AIAC::GOColor)</li> <li>RED_TRANSP07 (AIAC::GOColor)</li> <li>RadiusSearch (AIAC::LayerUI::ReconstructParams)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#s","title":"s","text":"<ul> <li>s_Instance (AIAC::Application, AIAC::Config)</li> <li>squareSize (AIAC::CameraCalibrator)</li> <li>Size (AIAC::Character, AIAC::ImTexture)</li> <li>SAVE_DIR_MAPS (AIAC::Config)</li> <li>SCALE_FACTOR (AIAC::Config)</li> <li>SCANNED_MODEL (AIAC::Config)</li> <li>SEC_AIAC (AIAC::Config)</li> <li>SEC_TEST (AIAC::Config)</li> <li>SEC_TOUCH_MONITOR_SPECS (AIAC::Config)</li> <li>SEC_TSLAM (AIAC::Config)</li> <li>SEC_TTOOL (AIAC::Config)</li> <li>SEC_UTILS (AIAC::Config)</li> <li>STABILIZATION_FRAME_COUNT (AIAC::Config)</li> <li>size (AIAC::GLObject)</li> <li>Small (AIAC::GOTextSize)</li> <li>SaveFilename (AIAC::LayerCameraCalib)</li> <li>Slam (AIAC::LayerSlam)</li> <li>s_Logger (AIAC::Log)</li> <li>s_Initialized (AIAC::TextRenderer)</li> <li>s_Projection (AIAC::TextRenderer)</li> <li>s_ShaderProgram (AIAC::TextRenderer)</li> <li>s_VBO (AIAC::TextRenderer)</li> <li>s_instance (AIAC::TextRenderer)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#t","title":"t","text":"<ul> <li>totalAvgErr (AIAC::CameraCalibrator)</li> <li>tvecs (AIAC::CameraCalibrator)</li> <li>ThicknessACIT (AIAC::ChainSawData, AIAC::CircularSawData)</li> <li>TextureID (AIAC::Character)</li> <li>TTOOL_ROOT_PATH (AIAC::Config)</li> <li>ToleranceStartThreshold (AIAC::CutCircularSawPositionStartVisualizer)</li> <li>ToolbaseACIT (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>ToolbaseGO (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>TooltipACIT (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>TooltipGO (AIAC::DrillBitData, AIAC::SaberSawData)</li> <li>type (AIAC::GLObject)</li> <li>Thick (AIAC::GOWeight)</li> <li>ToShowCutPlane (AIAC::LayerFeedback)</li> <li>ToEnhance (AIAC::LayerSlam)</li> <li>ToProcess (AIAC::LayerSlam)</li> <li>ToShowTag (AIAC::LayerSlam)</li> <li>TTool (AIAC::LayerToolhead)</li> <li>ToolheadStateUI (AIAC::LayerToolhead)</li> <li>Title (AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>ToOptimizeMap (AIAC::LayerUI::MappingParams)</li> <li>ToSaveMap (AIAC::LayerUI::MappingParams)</li> <li>TagMapPath (AIAC::LayerUI::ReconstructParams)</li> <li>table (IGFD_Selection)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#u","title":"u","text":"<ul> <li>useFisheye (AIAC::CameraCalibrator)</li> <li>useFixedPoint (AIAC::CameraCalibrator)</li> <li>UTILS_PATH (AIAC::Config)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#v","title":"v","text":"<ul> <li>VSync (AIAC::ApplicationSpecification, AIAC::WindowProps, AIAC::Window::WindowData)</li> <li>VIDEO_PATH (AIAC::Config)</li> <li>VocFile (AIAC::Config)</li> <li>vertexBuf (AIAC::GLObject)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#w","title":"w","text":"<ul> <li>WinHeight (AIAC::ApplicationSpecification)</li> <li>WinWidth (AIAC::ApplicationSpecification)</li> <li>WindowBackColor (AIAC::ApplicationSpecification)</li> <li>winSize (AIAC::CameraCalibrator)</li> <li>writeExtrinsics (AIAC::CameraCalibrator)</li> <li>WidthACIT (AIAC::ChainSawData)</li> <li>WHITE (AIAC::GOColor)</li> <li>Width (AIAC::WindowProps, AIAC::Window::WindowData)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#x","title":"x","text":"<ul> <li>x (AIAC::CylinderPole, AIAC::Position)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#y","title":"y","text":"<ul> <li>YELLOW (AIAC::GOColor)</li> <li>YELLOW_TRANSP07 (AIAC::GOColor)</li> <li>y (AIAC::Position)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#z","title":"z","text":"<ul> <li>z (AIAC::CylinderPole)</li> </ul>"},{"location":"acdoxygen/class_member_variables/#_","title":"_","text":"<ul> <li>_buff (CircularBuffer)</li> <li>_head (CircularBuffer)</li> <li>_max_size (CircularBuffer)</li> <li>_mtx (CircularBuffer)</li> <li>_size (CircularBuffer)</li> <li>_tail (CircularBuffer)</li> <li>_index (CircularBuffer::BufferIterator)</li> <li>_offset (CircularBuffer::BufferIterator)</li> <li>_ptrToBuffer (CircularBuffer::BufferIterator)</li> <li>_reverse (CircularBuffer::BufferIterator)</li> <li>_error (inih::INIReader)</li> <li>_values (inih::INIReader)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"acdoxygen/class_member_typedefs/#c","title":"c","text":"<ul> <li>const_iterator (CircularBuffer)</li> <li>const_pointer (CircularBuffer)</li> <li>const_reference (CircularBuffer)</li> <li>cbuf_pointer (CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#d","title":"d","text":"<ul> <li>difference_type (CircularBuffer, CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#f","title":"f","text":"<ul> <li>Func (AIAC::PaneUI)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#i","title":"i","text":"<ul> <li>iterator (CircularBuffer)</li> <li>iterator_category (CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#p","title":"p","text":"<ul> <li>PrioriQueueListtyQueue (AIAC::EventPolicy)</li> <li>pointer (CircularBuffer, CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#r","title":"r","text":"<ul> <li>reference (CircularBuffer, CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#s","title":"s","text":"<ul> <li>size_type (CircularBuffer)</li> </ul>"},{"location":"acdoxygen/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (CircularBuffer, CircularBuffer::BufferIterator)</li> </ul>"},{"location":"acdoxygen/class_member_enums/","title":"Class Member Enums","text":""},{"location":"acdoxygen/class_member_enums/#a","title":"a","text":"<ul> <li>AdjustTarget (AIAC::LayerUI)</li> </ul>"},{"location":"acdoxygen/class_member_enums/#c","title":"c","text":"<ul> <li>CollapseState (AIAC::PaneUI)</li> <li>CameraFrameType (AIAC::Renderer)</li> </ul>"},{"location":"acdoxygen/class_member_enums/#p","title":"p","text":"<ul> <li>Pattern (AIAC::CameraCalibrator)</li> </ul>"},{"location":"acdoxygen/class_member_enums/#s","title":"s","text":"<ul> <li>StandardView (AIAC::Renderer)</li> </ul>"},{"location":"acdoxygen/namespace_members/","title":"Namespace Members","text":""},{"location":"acdoxygen/namespace_members/#a","title":"a","text":"<ul> <li>ACIMState (AIAC)</li> <li>ACToolHeadType (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#c","title":"c","text":"<ul> <li>CUT_EDGE_COLOR (AIAC)</li> <li>CUT_FACE_COLOR (AIAC)</li> <li>CaptureFramePixels (AIAC)</li> <li>CreateCircle (AIAC)</li> <li>CreateCylinder (AIAC)</li> <li>CreatePolyline (AIAC)</li> <li>CreateRef (AIAC)</li> <li>CreateScope (AIAC)</li> <li>CvtCvMat2GlTextureObj (AIAC)</li> <li>CvtCvMat2ImTexture (AIAC)</li> <li>CvtGlTextureObj2ImTexture (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#d","title":"d","text":"<ul> <li>DrawAllGOs (AIAC)</li> <li>DrawCircle (AIAC)</li> <li>DrawCircles (AIAC)</li> <li>DrawCylinder (AIAC)</li> <li>DrawCylinders (AIAC)</li> <li>DrawGO (AIAC)</li> <li>DrawLine (AIAC)</li> <li>DrawLines (AIAC)</li> <li>DrawMesh (AIAC)</li> <li>DrawMeshes (AIAC)</li> <li>DrawPoint (AIAC)</li> <li>DrawPoints (AIAC)</li> <li>DrawPolyline (AIAC)</li> <li>DrawPolylines (AIAC)</li> <li>DrawSlamMap (AIAC)</li> <li>DrawText (AIAC)</li> <li>DrawTexts (AIAC)</li> <li>DrawTriangle (AIAC)</li> <li>DrawTriangles (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#e","title":"e","text":"<ul> <li>EQ (AIAC)</li> <li>EventCategory (AIAC)</li> <li>EventPointer (AIAC)</li> <li>EventType (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#f","title":"f","text":"<ul> <li>find_chars_or_comment (inih)</li> </ul>"},{"location":"acdoxygen/namespace_members/#g","title":"g","text":"<ul> <li>GLFWErrorCallback (AIAC)</li> <li>GLFWMonitorCallback (AIAC)</li> <li>GLObjectType (AIAC)</li> <li>GOTypeFlags (AIAC)</li> <li>GetRigidTransformationMatrix (AIAC)</li> <li>GetRotationMatrix (AIAC)</li> <li>GetSectorNum (AIAC)</li> <li>GetTransformed (AIAC)</li> <li>GetTranslationMatrix (AIAC)</li> <li>glDrawLines3d (AIAC)</li> <li>glDrawPoints3d (AIAC)</li> <li>glDrawTriangles3d (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#h","title":"h","text":"<ul> <li>HOLE_AXIS_COLOR (AIAC)</li> <li>HOLE_CYLINDER_COLOR (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#i","title":"i","text":"<ul> <li>ImageFormat (AIAC)</li> <li>IsGlfwInitialized (AIAC)</li> <li>ini_handler (inih)</li> <li>ini_parse (inih)</li> <li>ini_parse_file (inih)</li> <li>ini_parse_stream (inih)</li> <li>ini_reader (inih)</li> </ul>"},{"location":"acdoxygen/namespace_members/#l","title":"l","text":"<ul> <li>lskip (inih)</li> </ul>"},{"location":"acdoxygen/namespace_members/#o","title":"o","text":"<ul> <li>OGL_BLACK (AIAC)</li> <li>OGL_BLUE (AIAC)</li> <li>OGL_CYAN (AIAC)</li> <li>OGL_GREEN (AIAC)</li> <li>OGL_MAGENTA (AIAC)</li> <li>OGL_RED (AIAC)</li> <li>OGL_WHITE (AIAC)</li> <li>OGL_YELLOW (AIAC)</li> <li>operator&gt;&gt; (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#r","title":"r","text":"<ul> <li>Ref (AIAC)</li> <li>rstrip (inih)</li> </ul>"},{"location":"acdoxygen/namespace_members/#s","title":"s","text":"<ul> <li>Scope (AIAC)</li> <li>StringToBool (AIAC)</li> <li>StringToSet (AIAC)</li> <li>StringToState (AIAC)</li> <li>StringToTokens (AIAC)</li> <li>StringToVec3 (AIAC)</li> <li>s_CursorPos (AIAC)</li> <li>s_GLFWWindowCount (AIAC)</li> <li>s_IsMouseButtonPressed (AIAC)</li> <li>strncpy0 (inih)</li> </ul>"},{"location":"acdoxygen/namespace_members/#v","title":"v","text":"<ul> <li>Vec3ToString (AIAC)</li> <li>VertexArrayID (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_members/#w","title":"w","text":"<ul> <li>WEIGHT_TO_CYLINDER_RADIUS_RATE (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"acdoxygen/namespace_member_functions/#c","title":"c","text":"<ul> <li>CaptureFramePixels (AIAC)</li> <li>CreateCircle (AIAC)</li> <li>CreateCylinder (AIAC)</li> <li>CreatePolyline (AIAC)</li> <li>CreateRef (AIAC)</li> <li>CreateScope (AIAC)</li> <li>CvtCvMat2GlTextureObj (AIAC)</li> <li>CvtCvMat2ImTexture (AIAC)</li> <li>CvtGlTextureObj2ImTexture (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#d","title":"d","text":"<ul> <li>DrawAllGOs (AIAC)</li> <li>DrawCircle (AIAC)</li> <li>DrawCircles (AIAC)</li> <li>DrawCylinder (AIAC)</li> <li>DrawCylinders (AIAC)</li> <li>DrawGO (AIAC)</li> <li>DrawLine (AIAC)</li> <li>DrawLines (AIAC)</li> <li>DrawMesh (AIAC)</li> <li>DrawMeshes (AIAC)</li> <li>DrawPoint (AIAC)</li> <li>DrawPoints (AIAC)</li> <li>DrawPolyline (AIAC)</li> <li>DrawPolylines (AIAC)</li> <li>DrawSlamMap (AIAC)</li> <li>DrawText (AIAC)</li> <li>DrawTexts (AIAC)</li> <li>DrawTriangle (AIAC)</li> <li>DrawTriangles (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#f","title":"f","text":"<ul> <li>find_chars_or_comment (inih)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#g","title":"g","text":"<ul> <li>GLFWErrorCallback (AIAC)</li> <li>GLFWMonitorCallback (AIAC)</li> <li>GetRigidTransformationMatrix (AIAC)</li> <li>GetRotationMatrix (AIAC)</li> <li>GetSectorNum (AIAC)</li> <li>GetTransformed (AIAC)</li> <li>GetTranslationMatrix (AIAC)</li> <li>glDrawLines3d (AIAC)</li> <li>glDrawPoints3d (AIAC)</li> <li>glDrawTriangles3d (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#i","title":"i","text":"<ul> <li>IsGlfwInitialized (AIAC)</li> <li>ini_parse (inih)</li> <li>ini_parse_file (inih)</li> <li>ini_parse_stream (inih)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#l","title":"l","text":"<ul> <li>lskip (inih)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator&gt;&gt; (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#r","title":"r","text":"<ul> <li>rstrip (inih)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#s","title":"s","text":"<ul> <li>StringToBool (AIAC)</li> <li>StringToSet (AIAC)</li> <li>StringToState (AIAC)</li> <li>StringToTokens (AIAC)</li> <li>StringToVec3 (AIAC)</li> <li>strncpy0 (inih)</li> </ul>"},{"location":"acdoxygen/namespace_member_functions/#v","title":"v","text":"<ul> <li>Vec3ToString (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"acdoxygen/namespace_member_variables/#c","title":"c","text":"<ul> <li>CUT_EDGE_COLOR (AIAC)</li> <li>CUT_FACE_COLOR (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_variables/#h","title":"h","text":"<ul> <li>HOLE_AXIS_COLOR (AIAC)</li> <li>HOLE_CYLINDER_COLOR (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_variables/#o","title":"o","text":"<ul> <li>OGL_BLACK (AIAC)</li> <li>OGL_BLUE (AIAC)</li> <li>OGL_CYAN (AIAC)</li> <li>OGL_GREEN (AIAC)</li> <li>OGL_MAGENTA (AIAC)</li> <li>OGL_RED (AIAC)</li> <li>OGL_WHITE (AIAC)</li> <li>OGL_YELLOW (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_variables/#s","title":"s","text":"<ul> <li>s_CursorPos (AIAC)</li> <li>s_GLFWWindowCount (AIAC)</li> <li>s_IsMouseButtonPressed (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_variables/#v","title":"v","text":"<ul> <li>VertexArrayID (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_variables/#w","title":"w","text":"<ul> <li>WEIGHT_TO_CYLINDER_RADIUS_RATE (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"acdoxygen/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>EQ (AIAC)</li> <li>EventPointer (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>ini_handler (inih)</li> <li>ini_reader (inih)</li> </ul>"},{"location":"acdoxygen/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>Ref (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>Scope (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"acdoxygen/namespace_member_enums/#a","title":"a","text":"<ul> <li>ACIMState (AIAC)</li> <li>ACToolHeadType (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_enums/#e","title":"e","text":"<ul> <li>EventCategory (AIAC)</li> <li>EventType (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_enums/#g","title":"g","text":"<ul> <li>GLObjectType (AIAC)</li> <li>GOTypeFlags (AIAC)</li> </ul>"},{"location":"acdoxygen/namespace_member_enums/#i","title":"i","text":"<ul> <li>ImageFormat (AIAC)</li> </ul>"},{"location":"acdoxygen/functions/","title":"Functions","text":""},{"location":"acdoxygen/functions/#c","title":"c","text":"<ul> <li>ConvertRotationMatrixToQuaternion (MatrixUtils.h)</li> <li>ConvertTransMatToTvecAndQvec (MatrixUtils.h)</li> <li>CvtCvMat2GlmMat (MatrixUtils.h)</li> <li>CvtGlmMat2CvMat (MatrixUtils.h)</li> <li>CopyFile (utils.h)</li> </ul>"},{"location":"acdoxygen/functions/#e","title":"e","text":"<ul> <li>ExtendLineSeg (GeometryUtils.h)</li> <li>ExecuteSystemCommand (SystemUtils.h)</li> </ul>"},{"location":"acdoxygen/functions/#f","title":"f","text":"<ul> <li>FormLongestLineSeg (GeometryUtils.h)</li> </ul>"},{"location":"acdoxygen/functions/#g","title":"g","text":"<ul> <li>GetLatestFilePath (LayerUI.cpp)</li> <li>GetAngleBetweenVectors (GeometryUtils.h)</li> <li>GetIntersectLineOf2Planes (GeometryUtils.h)</li> <li>GetIntersectPointOf2Lines (GeometryUtils.h)</li> <li>GetIntersectPointOfLineAndLineSeg (GeometryUtils.h)</li> <li>GetIntersectPointOfLineAndPlane (GeometryUtils.h)</li> <li>GetIntersectPointOfLineSegAndPlane (GeometryUtils.h)</li> <li>GetNearestPtOnLine (GeometryUtils.h)</li> <li>GetProjectionPointOnPlane (GeometryUtils.h)</li> <li>GetCurrentDateTime (utils.h)</li> <li>GetCurrentTimestamp (utils.h)</li> <li>GetFileNameFromPath (utils.h)</li> <li>GetFilePaths (utils.h)</li> <li>GetFolderPaths (utils.h)</li> </ul>"},{"location":"acdoxygen/functions/#i","title":"i","text":"<ul> <li>IGFD_ClearFilesStyle (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_CloseDialog (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_Create (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_Destroy (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_DisplayDialog (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetCurrentFileName (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetCurrentFilter (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetCurrentPath (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetFilePathName (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetFileStyle (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetSelection (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_GetUserDatas (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_IsKeyOpened (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_IsOk (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_IsOpened (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_OpenDialog (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_OpenDialog2 (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_OpenPaneDialog (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_OpenPaneDialog2 (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_Selection_DestroyContent (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_Selection_Get (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_Selection_Pair_DestroyContent (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_Selection_Pair_Get (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_SetFileStyle (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_SetFileStyle2 (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_WasKeyOpenedThisFrame (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IGFD_WasOpenedThisFrame (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> <li>IsPointBetweenLineSeg (GeometryUtils.h)</li> <li>IsSameDirection (GeometryUtils.h)</li> <li>IsFileExist (utils.h)</li> </ul>"},{"location":"acdoxygen/functions/#l","title":"l","text":"<ul> <li>LoadShaders (Shader.cpp, Shader.hpp)</li> </ul>"},{"location":"acdoxygen/functions/#m","title":"m","text":"<ul> <li>main (ACApp.cpp)</li> </ul>"},{"location":"acdoxygen/functions/#p","title":"p","text":"<ul> <li>ParseConfigFile (utils.h)</li> </ul>"},{"location":"acdoxygen/functions/#s","title":"s","text":"<ul> <li>SetLocales (ImGuiFileDialog.cpp, ImGuiFileDialog.h)</li> </ul>"},{"location":"acdoxygen/macros/","title":"Macros","text":""},{"location":"acdoxygen/macros/#a","title":"a","text":"<ul> <li>AIAC_APP (Application.h)</li> <li>AIAC_EBUS (Application.h)</li> <li>AIAC_GOREG (Application.h)</li> <li>AIAC_ASSERT (Assert.h)</li> <li>AIAC_BIND_EVENT_FN (Base.h)</li> <li>AIAC_EXPAND_MACRO (Base.h)</li> <li>AIAC_STRINGIFY_MACRO (Base.h)</li> <li>ASSIMP_LOAD_FLAGS (DLoader.cpp)</li> <li>AIAC_CRITICAL (Log.h)</li> <li>AIAC_ERROR (Log.h)</li> <li>AIAC_INFO (Log.h)</li> <li>AIAC_WARN (Log.h)</li> <li>AC_FF_COMP (FabFeedback.h)</li> <li>AC_FF_TOOL (FabFeedback.h)</li> <li>AIAC_UI_APRICOT_ORANGE (ClrPalette.h)</li> <li>AIAC_UI_BLACK (ClrPalette.h)</li> <li>AIAC_UI_BLUE (ClrPalette.h)</li> <li>AIAC_UI_BRONZE_ORANGE (ClrPalette.h)</li> <li>AIAC_UI_CARMINE_RED (ClrPalette.h)</li> <li>AIAC_UI_CINNAMON_RED (ClrPalette.h)</li> <li>AIAC_UI_CYAN (ClrPalette.h)</li> <li>AIAC_UI_DARK_GREEN (ClrPalette.h)</li> <li>AIAC_UI_DARK_GREY (ClrPalette.h)</li> <li>AIAC_UI_EGYPTIAN_BLUE (ClrPalette.h)</li> <li>AIAC_UI_GRAPE_PURPLE (ClrPalette.h)</li> <li>AIAC_UI_GREEN (ClrPalette.h)</li> <li>AIAC_UI_GREY (ClrPalette.h)</li> <li>AIAC_UI_HIBISCUS_RED (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_BLACK (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_BLUE (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_CYAN (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_GREEN (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_GREY (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_MAGENTA (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_RED (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_WHITE (ClrPalette.h)</li> <li>AIAC_UI_LIGHT_YELLOW (ClrPalette.h)</li> <li>AIAC_UI_LOLLIPOP_PURPLE (ClrPalette.h)</li> <li>AIAC_UI_MAGENTA (ClrPalette.h)</li> <li>AIAC_UI_PLUM_PURPLE (ClrPalette.h)</li> <li>AIAC_UI_PRUSSIAN_BLUE (ClrPalette.h)</li> <li>AIAC_UI_PURPLE (ClrPalette.h)</li> <li>AIAC_UI_RED (ClrPalette.h)</li> <li>AIAC_UI_ROYAL_PURPLE (ClrPalette.h)</li> <li>AIAC_UI_SAPPHIRE_BLUE (ClrPalette.h)</li> <li>AIAC_UI_SEA_GREEN (ClrPalette.h)</li> <li>AIAC_UI_SPARK_ORANGE (ClrPalette.h)</li> <li>AIAC_UI_WHITE (ClrPalette.h)</li> <li>AIAC_UI_YALE_BLUE (ClrPalette.h)</li> <li>AIAC_UI_YELLOW (ClrPalette.h)</li> <li>AIAC_LOGO_BLACK (CustomLogos.h)</li> <li>AIAC_LOGO_COLOR (CustomLogos.h)</li> <li>AIAC_LOGO_LIGHT_GRAY (CustomLogos.h)</li> <li>API (ImGuiFileDialog.h)</li> </ul>"},{"location":"acdoxygen/macros/#b","title":"b","text":"<ul> <li>BIT (Base.h)</li> </ul>"},{"location":"acdoxygen/macros/#g","title":"g","text":"<ul> <li>GLM_ENABLE_EXPERIMENTAL (Renderer.cpp)</li> </ul>"},{"location":"acdoxygen/macros/#h","title":"h","text":"<ul> <li>HANDLER (Ini.h)</li> </ul>"},{"location":"acdoxygen/macros/#i","title":"i","text":"<ul> <li>IMGUI_DEFINE_MATH_OPERATORS (ImGuiFileDialog.cpp)</li> <li>IMGUIFILEDIALOG_API (ImGuiFileDialog.h)</li> <li>IMGUIFILEDIALOG_VERSION (ImGuiFileDialog.h)</li> <li>INI_INITIAL_ALLOC (Ini.h)</li> <li>INI_INLINE_COMMENT_PREFIXES (Ini.h)</li> <li>INI_MAX_LINE (Ini.h)</li> <li>INI_START_COMMENT_PREFIXES (Ini.h)</li> <li>INI_STOP_ON_FIRST_ERROR (Ini.h)</li> </ul>"},{"location":"acdoxygen/macros/#m","title":"m","text":"<ul> <li>MAX_NAME (Ini.h)</li> <li>MAX_SECTION (Ini.h)</li> </ul>"},{"location":"acdoxygen/macros/#p","title":"p","text":"<ul> <li>PATH_BUF_SIZE (LayerUI.h)</li> </ul>"},{"location":"acdoxygen/macros/#s","title":"s","text":"<ul> <li>STB_IMAGE_IMPLEMENTATION (AIAC.h)</li> </ul>"},{"location":"acdoxygen/macros/#_","title":"_","text":"<ul> <li>_USE_MATH_DEFINES (Camera.cpp)</li> <li>__INIREADER_H__ (Ini.h)</li> <li>__INIREADER__ (Ini.h)</li> <li>__INIWRITER_H__ (Ini.h)</li> </ul>"},{"location":"acdoxygen/variables/","title":"Variables","text":""},{"location":"acdoxygen/variables/#i","title":"i","text":"<ul> <li>IGFD_FileStyleFlags (ImGuiFileDialog.h)</li> <li>IGFD_FileStyleFlags_ (ImGuiFileDialog.h)</li> <li>IGFD_PaneFun (ImGuiFileDialog.h)</li> <li>IGFD_Selection (ImGuiFileDialog.h)</li> <li>IGFD_Selection_Pair (ImGuiFileDialog.h)</li> <li>ImGuiFileDialog (ImGuiFileDialog.h)</li> <li>ImGuiFileDialogFlags (ImGuiFileDialog.h)</li> <li>ImGuiFileDialogFlags_ (ImGuiFileDialog.h)</li> </ul>"},{"location":"acdoxygen/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}