

# Namespace AIAC



[**Namespace List**](namespaces.md) **>** [**AIAC**](namespaceAIAC.md)


















## Namespaces

| Type | Name |
| ---: | :--- |
| namespace | [**Utils**](namespaceAIAC_1_1Utils.md) <br> |


## Classes

| Type | Name |
| ---: | :--- |
| class | [**ACInfoModel**](classAIAC_1_1ACInfoModel.md) <br> |
| class | [**ACInfoToolhead**](classAIAC_1_1ACInfoToolhead.md) <br>_the class holding the information of the toolhead (GOs, metadata, etc)_  |
| class | [**ACInfoToolheadManager**](classAIAC_1_1ACInfoToolheadManager.md) <br> |
| class | [**AppCloseEvent**](classAIAC_1_1AppCloseEvent.md) <br> |
| class | [**Application**](classAIAC_1_1Application.md) <br> |
| struct | [**ApplicationSpecification**](structAIAC_1_1ApplicationSpecification.md) <br> |
| class | [**Camera**](classAIAC_1_1Camera.md) <br> |
| class | [**CameraCalibrationLoadedEvent**](classAIAC_1_1CameraCalibrationLoadedEvent.md) <br> |
| class | [**CameraCalibrator**](classAIAC_1_1CameraCalibrator.md) <br> |
| class | [**ChainSawCutPlaneVisualizer**](classAIAC_1_1ChainSawCutPlaneVisualizer.md) <br> |
| struct | [**ChainSawData**](structAIAC_1_1ChainSawData.md) <br> |
| struct | [**Character**](structAIAC_1_1Character.md) <br> |
| class | [**CircularSawCutBladeThicknessVisualizer**](classAIAC_1_1CircularSawCutBladeThicknessVisualizer.md) <br>_This is an inherited class to show the thickness of the blade on circular saws._  |
| class | [**CircularSawCutPlaneVisualizer**](classAIAC_1_1CircularSawCutPlaneVisualizer.md) <br> |
| struct | [**CircularSawData**](structAIAC_1_1CircularSawData.md) <br> |
| class | [**Config**](classAIAC_1_1Config.md) <br> |
| class | [**CutBladeThicknessVisualizer**](classAIAC_1_1CutBladeThicknessVisualizer.md) <br>_The idea behind the_ [_**CutBladeThicknessVisualizer**_](classAIAC_1_1CutBladeThicknessVisualizer.md) _is to give a visual feedback on the thickness of the blade. We do this by intersecting the two neighbours faces of the current highlighted face._ |
| class | [**CutChainSawAngleFeedVisualizer**](classAIAC_1_1CutChainSawAngleFeedVisualizer.md) <br> |
| class | [**CutChainSawDepthFeedVisualizer**](classAIAC_1_1CutChainSawDepthFeedVisualizer.md) <br> |
| class | [**CutChainSawFeedVisualizer**](classAIAC_1_1CutChainSawFeedVisualizer.md) <br> |
| class | [**CutChainSawFeedback**](classAIAC_1_1CutChainSawFeedback.md) <br> |
| class | [**CutCircularOrientationVisualizer**](classAIAC_1_1CutCircularOrientationVisualizer.md) <br>_This visualizer ggdb ives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45\*. This way we can also have the direction towards which the blade needs to be tilted._  |
| class | [**CutCircularSawDepthVisualizer**](classAIAC_1_1CutCircularSawDepthVisualizer.md) <br>_Visualizer for showing the depth of the cut._  |
| class | [**CutCircularSawFeedback**](classAIAC_1_1CutCircularSawFeedback.md) <br> |
| class | [**CutCircularSawPositionStartVisualizer**](classAIAC_1_1CutCircularSawPositionStartVisualizer.md) <br>_This visualizer gives guidance on the start position of the lateral cuts for the circular saw._  |
| class | [**CutOrientationVisualizer**](classAIAC_1_1CutOrientationVisualizer.md) <br>_This visualizer gives a bit of guidance on the cut orientation. Although it is not possible to determine the exact orientation of the cut, this visualizer gives a rough idea of the pitch and roll. The way this is done is by projecting the blade normal onto the face normal, and then projecting the resulting vector onto the face normal. If we close the triangle of these two lines we can monitor the angle that must be 45\*. This way we can also have the direction towards which the blade needs to be tilted._  |
| class | [**CutPlaneVisualizer**](classAIAC_1_1CutPlaneVisualizer.md) <br> |
| struct | [**CylinderPole**](structAIAC_1_1CylinderPole.md) <br> |
| class | [**DLoader**](classAIAC_1_1DLoader.md) <br> |
| struct | [**DrillBitData**](structAIAC_1_1DrillBitData.md) <br> |
| class | [**Event**](classAIAC_1_1Event.md) <br> |
| class | [**EventBus**](classAIAC_1_1EventBus.md) <br> |
| struct | [**EventCompare**](structAIAC_1_1EventCompare.md) <br> |
| struct | [**EventPolicy**](structAIAC_1_1EventPolicy.md) <br> |
| class | [**FabFeedback**](classAIAC_1_1FabFeedback.md) <br> |
| class | [**FeedbackVisualizer**](classAIAC_1_1FeedbackVisualizer.md) <br> |
| class | [**GLLineObject**](classAIAC_1_1GLLineObject.md) <br> |
| class | [**GLMeshObject**](classAIAC_1_1GLMeshObject.md) <br> |
| class | [**GLObject**](classAIAC_1_1GLObject.md) <br> |
| class | [**GLPointObject**](classAIAC_1_1GLPointObject.md) <br> |
| class | [**GOCircle**](classAIAC_1_1GOCircle.md) <br> |
| struct | [**GOColor**](structAIAC_1_1GOColor.md) <br> |
| class | [**GOCylinder**](classAIAC_1_1GOCylinder.md) <br> |
| class | [**GOLine**](classAIAC_1_1GOLine.md) <br> |
| class | [**GOMesh**](classAIAC_1_1GOMesh.md) <br> |
| class | [**GOPoint**](classAIAC_1_1GOPoint.md) <br> |
| class | [**GOPolyline**](classAIAC_1_1GOPolyline.md) <br> |
| class | [**GOPrimitive**](classAIAC_1_1GOPrimitive.md) <br> |
| class | [**GORegistry**](classAIAC_1_1GORegistry.md) <br> |
| class | [**GOText**](classAIAC_1_1GOText.md) <br> |
| struct | [**GOTextSize**](structAIAC_1_1GOTextSize.md) <br> |
| class | [**GOTriangle**](classAIAC_1_1GOTriangle.md) <br> |
| struct | [**GOWeight**](structAIAC_1_1GOWeight.md) <br> |
| class | [**HoleFeedback**](classAIAC_1_1HoleFeedback.md) <br>_The UI widget for providing feedback on orientation Feeds (in chronological order):_  |
| class | [**HoleFeedbackPosition**](classAIAC_1_1HoleFeedbackPosition.md) <br>_The UI widget for providing feedback on position._  |
| class | [**HoleFeedbackRotation**](classAIAC_1_1HoleFeedbackRotation.md) <br>_The UI widget for providing feedback on rotation._  |
| class | [**HoleFeedbackText**](classAIAC_1_1HoleFeedbackText.md) <br>_The general visualizer for the info displayed as text._  |
| struct | [**ImTexture**](structAIAC_1_1ImTexture.md) <br>_Structure representing an ImGui texture._  |
| class | [**Image**](classAIAC_1_1Image.md) <br>_Class representing the main iamge object for AC._  |
| class | [**Layer**](classAIAC_1_1Layer.md) <br> |
| class | [**LayerCamera**](classAIAC_1_1LayerCamera.md) <br> |
| class | [**LayerCameraCalib**](classAIAC_1_1LayerCameraCalib.md) <br> |
| class | [**LayerFeedback**](classAIAC_1_1LayerFeedback.md) <br> |
| class | [**LayerLogRecorder**](classAIAC_1_1LayerLogRecorder.md) <br> |
| class | [**LayerModel**](classAIAC_1_1LayerModel.md) <br> |
| class | [**LayerSlam**](classAIAC_1_1LayerSlam.md) <br> |
| class | [**LayerToolhead**](classAIAC_1_1LayerToolhead.md) <br> |
| class | [**LayerUI**](classAIAC_1_1LayerUI.md) <br> |
| class | [**LayerUtils**](classAIAC_1_1LayerUtils.md) <br> |
| class | [**Log**](classAIAC_1_1Log.md) <br> |
| class | [**PaneUI**](classAIAC_1_1PaneUI.md) <br> |
| struct | [**Position**](structAIAC_1_1Position.md) <br> |
| class | [**Renderer**](classAIAC_1_1Renderer.md) <br> |
| class | [**SLAMCombineMapEvent**](classAIAC_1_1SLAMCombineMapEvent.md) <br> |
| class | [**SLAMMapLoadedEvent**](classAIAC_1_1SLAMMapLoadedEvent.md) <br> |
| class | [**SLAMStartMappingEvent**](classAIAC_1_1SLAMStartMappingEvent.md) <br> |
| class | [**SLAMStopMappingEvent**](classAIAC_1_1SLAMStopMappingEvent.md) <br> |
| class | [**SLAMVocabularyLoadedEvent**](classAIAC_1_1SLAMVocabularyLoadedEvent.md) <br> |
| struct | [**SaberSawData**](structAIAC_1_1SaberSawData.md) <br> |
| class | [**ScannedModel**](classAIAC_1_1ScannedModel.md) <br> |
| class | [**TextRenderer**](classAIAC_1_1TextRenderer.md) <br> |
| class | [**TimberInfo**](classAIAC_1_1TimberInfo.md) <br> |
| class | [**ToolHeadData**](classAIAC_1_1ToolHeadData.md) <br>_Class holding and parse and create data from the .acit file of the toolhead._  |
| class | [**TouchMonitor**](classAIAC_1_1TouchMonitor.md) <br> |
| class | [**Viewport**](classAIAC_1_1Viewport.md) <br> |
| class | [**Window**](classAIAC_1_1Window.md) <br> |
| struct | [**WindowProps**](structAIAC_1_1WindowProps.md) <br> |


## Public Types

| Type | Name |
| ---: | :--- |
| enum  | [**ACIMState**](#enum-acimstate)  <br> |
| enum  | [**ACToolHeadType**](#enum-actoolheadtype)  <br>_All the possible types of the toolheads in AC._  |
| typedef eventpp::EventQueue&lt; EventType, void(const EventPointer &), [**EventPolicy**](structAIAC_1_1EventPolicy.md) &gt; | [**EQ**](#typedef-eq)  <br> |
| enum  | [**EventCategory**](#enum-eventcategory)  <br> |
| typedef std::shared\_ptr&lt; [**Event**](classAIAC_1_1Event.md) &gt; | [**EventPointer**](#typedef-eventpointer)  <br> |
| enum  | [**EventType**](#enum-eventtype)  <br> |
| enum  | [**GLObjectType**](#enum-globjecttype)  <br> |
| enum  | [**GOTypeFlags**](#enum-gotypeflags)  <br> |
| enum  | [**ImageFormat**](#enum-imageformat)  <br>_Enum representing different image formats._  |
| typedef std::shared\_ptr&lt; T &gt; | [**Ref**](#typedef-ref)  <br> |
| typedef std::unique\_ptr&lt; T &gt; | [**Scope**](#typedef-scope)  <br> |




## Public Attributes

| Type | Name |
| ---: | :--- |
|  GLuint | [**VertexArrayID**](#variable-vertexarrayid)  <br> |


## Public Static Attributes

| Type | Name |
| ---: | :--- |
|  std::map&lt; ACIMState, glm::vec4 &gt; | [**CUT\_EDGE\_COLOR**](#variable-cut_edge_color)   = `/* multi line expression */`<br> |
|  std::map&lt; ACIMState, glm::vec4 &gt; | [**CUT\_FACE\_COLOR**](#variable-cut_face_color)   = `/* multi line expression */`<br> |
|  std::map&lt; ACIMState, glm::vec4 &gt; | [**HOLE\_AXIS\_COLOR**](#variable-hole_axis_color)   = `/* multi line expression */`<br> |
|  std::map&lt; ACIMState, glm::vec4 &gt; | [**HOLE\_CYLINDER\_COLOR**](#variable-hole_cylinder_color)   = `/* multi line expression */`<br> |
|  const glm::vec4 | [**OGL\_BLACK**](#variable-ogl_black)   = `glm::vec4(0, 0, 0, 1)`<br> |
|  const glm::vec4 | [**OGL\_BLUE**](#variable-ogl_blue)   = `glm::vec4(0, 0, 1, 1)`<br> |
|  const glm::vec4 | [**OGL\_CYAN**](#variable-ogl_cyan)   = `glm::vec4(0, 1, 1, 1)`<br> |
|  const glm::vec4 | [**OGL\_GREEN**](#variable-ogl_green)   = `glm::vec4(0, 1, 0, 1)`<br> |
|  const glm::vec4 | [**OGL\_MAGENTA**](#variable-ogl_magenta)   = `glm::vec4(1, 0, 1, 1)`<br> |
|  const glm::vec4 | [**OGL\_RED**](#variable-ogl_red)   = `glm::vec4(1, 0, 0, 1)`<br> |
|  const glm::vec4 | [**OGL\_WHITE**](#variable-ogl_white)   = `glm::vec4(1, 1, 1, 1)`<br> |
|  const glm::vec4 | [**OGL\_YELLOW**](#variable-ogl_yellow)   = `glm::vec4(1, 1, 0, 1)`<br> |
|  const float | [**WEIGHT\_TO\_CYLINDER\_RADIUS\_RATE**](#variable-weight_to_cylinder_radius_rate)   = `1.0f / 64.0f`<br> |
|  struct AIAC::Position | [**s\_CursorPos**](#variable-s_cursorpos)  <br> |
|  uint8\_t | [**s\_GLFWWindowCount**](#variable-s_glfwwindowcount)   = `0`<br> |
|  bool | [**s\_IsMouseButtonPressed**](#variable-s_ismousebuttonpressed)   = `false`<br> |














## Public Functions

| Type | Name |
| ---: | :--- |
|  std::vector&lt; GLubyte &gt; | [**CaptureFramePixels**](#function-captureframepixels) (const [**ApplicationSpecification**](structAIAC_1_1ApplicationSpecification.md) & appSpec) <br> |
|  std::vector&lt; std::shared\_ptr&lt; [**GLObject**](classAIAC_1_1GLObject.md) &gt; &gt; | [**CreateCircle**](#function-createcircle) (glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum) <br> |
|  std::vector&lt; std::shared\_ptr&lt; [**GLObject**](classAIAC_1_1GLObject.md) &gt; &gt; | [**CreateCylinder**](#function-createcylinder) (const glm::vec3 & baseCenter, const glm::vec3 & topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum) <br> |
|  std::vector&lt; std::shared\_ptr&lt; [**GLObject**](classAIAC_1_1GLObject.md) &gt; &gt; | [**CreatePolyline**](#function-createpolyline) (std::vector&lt; glm::vec3 &gt; vertices, bool isClosed, glm::vec4 color, float lineWidth) <br> |
|  constexpr Ref&lt; T &gt; | [**CreateRef**](#function-createref) (Args &&... args) <br> |
|  constexpr Scope&lt; T &gt; | [**CreateScope**](#function-createscope) (Args &&... args) <br> |
|  void | [**CvtCvMat2GlTextureObj**](#function-cvtcvmat2gltextureobj) (cv::Mat & cvMat, GLuint & glTextureObj, GLint glInternalFormat=GL\_RGB) <br>_Convert OpenCV matrix to OpenGL texture object._  |
|  void | [**CvtCvMat2ImTexture**](#function-cvtcvmat2imtexture) (cv::Mat & cvMat, [**ImTexture**](structAIAC_1_1ImTexture.md) & imTexture, GLuint & glTextureObj, GLint glInternalFormat) <br>_Convert cv::Mat to_ [_**ImTexture**_](structAIAC_1_1ImTexture.md) _, a glTextureObj is required as a texture holder._ |
|  void | [**CvtGlTextureObj2ImTexture**](#function-cvtgltextureobj2imtexture) (GLuint glTextureID, [**ImTexture**](structAIAC_1_1ImTexture.md) & imTexture, ImVec2 size=ImVec2(0, 0)) <br>_Convert OpenGL texture object to ImGui texture._  |
|  void | [**DrawAllGOs**](#function-drawallgos) (glm::mat4 projection=glm::mat4(1.0f), float textScale=1.0f) <br>_Draw all the GOs present in the_ [_**GORegistry**_](classAIAC_1_1GORegistry.md) _._ |
|  void | [**DrawCircle**](#function-drawcircle) (glm::vec3 center, glm::vec3 normal, float radius, glm::vec4 color, glm::vec4 edgeColor, float edgeWeight, int sectorNum=24) <br>_Draw a single circle._  |
|  void | [**DrawCircle**](#function-drawcircle) (const [**GOCircle**](classAIAC_1_1GOCircle.md) & goCircle) <br> |
|  void | [**DrawCircles**](#function-drawcircles) (const std::vector&lt; std::shared\_ptr&lt; [**GOCircle**](classAIAC_1_1GOCircle.md) &gt; &gt; & goCircles) <br> |
|  void | [**DrawCylinder**](#function-drawcylinder) (const glm::vec3 & baseCenter, const glm::vec3 & topCenter, GLfloat radius, glm::vec4 color, glm::vec4 edgeColor, int sectorNum=24) <br>_Draw a Cylinder, this is also used for drawing lines with heavy weight (&gt;1.0f)._  |
|  void | [**DrawCylinder**](#function-drawcylinder) (const [**GOCylinder**](classAIAC_1_1GOCylinder.md) & goCylinder) <br> |
|  void | [**DrawCylinders**](#function-drawcylinders) (const std::vector&lt; std::shared\_ptr&lt; [**GOCylinder**](classAIAC_1_1GOCylinder.md) &gt; &gt; & goCylinders) <br> |
|  void | [**DrawGO**](#function-drawgo) (const shared\_ptr&lt; [**GOPrimitive**](classAIAC_1_1GOPrimitive.md) &gt; & goPrimitive) <br>_Draw a_ [_**GOPrimitive**_](classAIAC_1_1GOPrimitive.md) _. (This function neglects the "isVisible" attribute of the object and will draw it anyway)_ |
|  void | [**DrawLine**](#function-drawline) (const glm::vec3 & p1, const glm::vec3 & p2, float weight=GOWeight::Default, const glm::vec4 & color=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f)) <br>_Draw a line on two glm::vec3._  |
|  void | [**DrawLine**](#function-drawline) (const [**GOLine**](classAIAC_1_1GOLine.md) & goLine) <br> |
|  void | [**DrawLines**](#function-drawlines) (const vector&lt; glm::vec3 &gt; & vertices, float weight, const glm::vec4 & color) <br>_Draw multiple lines._  |
|  void | [**DrawLines**](#function-drawlines) (const std::vector&lt; std::shared\_ptr&lt; [**GOLine**](classAIAC_1_1GOLine.md) &gt; &gt; & goLines) <br> |
|  void | [**DrawMesh**](#function-drawmesh) (const [**GOMesh**](classAIAC_1_1GOMesh.md) & goMesh) <br> |
|  void | [**DrawMeshes**](#function-drawmeshes) (const std::vector&lt; std::shared\_ptr&lt; [**GOMesh**](classAIAC_1_1GOMesh.md) &gt; &gt; & goMeshes) <br> |
|  void | [**DrawPoint**](#function-drawpoint) (const [**GOPoint**](classAIAC_1_1GOPoint.md) & goPoint) <br>_Draw a_ [_**GOPoint**_](classAIAC_1_1GOPoint.md) _._ |
|  void | [**DrawPoints**](#function-drawpoints) (const std::vector&lt; std::shared\_ptr&lt; [**GOPoint**](classAIAC_1_1GOPoint.md) &gt; &gt; & goPoints) <br> |
|  void | [**DrawPolyline**](#function-drawpolyline) (const [**GOPolyline**](classAIAC_1_1GOPolyline.md) & goPolyline) <br> |
|  void | [**DrawPolylines**](#function-drawpolylines) (const std::vector&lt; std::shared\_ptr&lt; [**GOPolyline**](classAIAC_1_1GOPolyline.md) &gt; &gt; & goPolylines) <br> |
|  void | [**DrawSlamMap**](#function-drawslammap) (const std::shared\_ptr&lt; tslam::Map &gt; & map, const glm::vec4 & color, float pointSize=1) <br>_Draw TSlam map._  |
|  void | [**DrawSlamMap**](#function-drawslammap) (const shared\_ptr&lt; tslam::Map &gt; & map, const glm::vec4 & color, float pointSize) <br>_Render Slam map on the current frame._  |
|  void | [**DrawText**](#function-drawtext) (const [**GOText**](classAIAC_1_1GOText.md) & goText, float scale, const glm::mat4 & projection) <br> |
|  void | [**DrawTexts**](#function-drawtexts) (const std::vector&lt; std::shared\_ptr&lt; [**GOText**](classAIAC_1_1GOText.md) &gt; &gt; & goTexts, float scale, const glm::mat4 & projection) <br> |
|  void | [**DrawTexts**](#function-drawtexts) (std::vector&lt; [**GOText**](classAIAC_1_1GOText.md) &gt; goTexts, float scale=1.0f, const glm::mat4 & projection=glm::mat4(1.0f)) <br> |
|  void | [**DrawTriangle**](#function-drawtriangle) (const [**GOTriangle**](classAIAC_1_1GOTriangle.md) & goTriangle) <br> |
|  void | [**DrawTriangles**](#function-drawtriangles) (const std::vector&lt; std::shared\_ptr&lt; [**GOTriangle**](classAIAC_1_1GOTriangle.md) &gt; &gt; & goTriangles) <br> |
|  glm::mat4x4 | [**GetRigidTransformationMatrix**](#function-getrigidtransformationmatrix) (std::vector&lt; glm::vec3 &gt; srcPts, std::vector&lt; glm::vec3 &gt; dstPts) <br>_Get the rigid transformation matrix from two correlated set of 3D points @praam srcPts The source points._  |
|  glm::mat3x3 | [**GetRotationMatrix**](#function-getrotationmatrix) (glm::vec3 axis, float theta) <br>_Get the rotation matrix associated with counterclockwise rotation about the given axis by theta radians._  |
|  int | [**GetSectorNum**](#function-getsectornum) (float radius) <br> |
|  glm::vec3 | [**GetTransformed**](#function-gettransformed) (glm::mat4 transformMat, float x, float y, float z) <br>_Combine 3 points into a glm::vec3 and transform it based on the given transformation matrix._  |
|  glm::mat4x4 | [**GetTranslationMatrix**](#function-gettranslationmatrix) (glm::vec3 translationVector) <br>_Get the translation matrix associated with the given translation vector._  |
|  bool | [**StringToBool**](#function-stringtobool) (std::string str) <br>_Convert a string to bool._  |
|  std::set&lt; std::string &gt; | [**StringToSet**](#function-stringtoset) (std::string str) <br>_Convert a string separated by space to a set of tokens._  |
|  ACIMState | [**StringToState**](#function-stringtostate) (std::string m\_State) <br>_Convert string m\_State to ACIMState._  |
|  std::vector&lt; std::string &gt; | [**StringToTokens**](#function-stringtotokens) (std::string str) <br>_Convert a string separated by space to a list of string._  |
|  glm::vec3 | [**StringToVec3**](#function-stringtovec3) (std::string str) <br>_Convert a string separated by space to glm::vec3._  |
|  std::string | [**Vec3ToString**](#function-vec3tostring) (glm::vec3 vec3) <br>_Convert a vec3 to String._  |
|  void | [**glDrawLines3d**](#function-gldrawlines3d) (const std::vector&lt; glm::vec3 &gt; & edges, const std::vector&lt; glm::vec4 &gt; & colors) <br>_Draw multiple points._  |
|  void | [**glDrawLines3d**](#function-gldrawlines3d) (const std::vector&lt; glm::vec3 &gt; & edges, const glm::vec4 & color) <br>_Draw multiple points._  |
|  void | [**glDrawPoints3d**](#function-gldrawpoints3d) (const std::vector&lt; glm::vec3 &gt; & vertices, const std::vector&lt; glm::vec4 &gt; & colors, GLfloat pointSize=1.0f) <br>_Draw multiple points._  |
|  void | [**glDrawPoints3d**](#function-gldrawpoints3d) (const std::vector&lt; glm::vec3 &gt; & vertices, const glm::vec4 & color, GLfloat pointSize=1.0f) <br>_Draw multiple points._  |
|  void | [**glDrawTriangles3d**](#function-gldrawtriangles3d) (const std::vector&lt; glm::vec3 &gt; & vertices, const std::vector&lt; uint32\_t &gt; & indices, const std::vector&lt; glm::vec4 &gt; & colors) <br>_Draw multiple Triangles._  |
|  void | [**glDrawTriangles3d**](#function-gldrawtriangles3d) (const std::vector&lt; glm::vec3 &gt; & vertices, const std::vector&lt; uint32\_t &gt; & indices, const glm::vec4 & colors) <br>_Draw multiple Triangles._  |
|  void | [**operator&gt;&gt;**](#function-operator) (cv::VideoCapture cap, [**AIAC::Image**](classAIAC_1_1Image.md) & img) <br> |


## Public Static Functions

| Type | Name |
| ---: | :--- |
|  void | [**GLFWErrorCallback**](#function-glfwerrorcallback) (int error, const char \* description) <br> |
|  void | [**GLFWMonitorCallback**](#function-glfwmonitorcallback) (GLFWmonitor \* monitor, int event) <br> |
|  bool | [**IsGlfwInitialized**](#function-isglfwinitialized) () <br> |


























## Public Types Documentation




### enum ACIMState 

```C++
enum AIAC::ACIMState {
    NOT_DONE,
    CURRENT,
    DONE
};
```




<hr>



### enum ACToolHeadType 

_All the possible types of the toolheads in AC._ 
```C++
enum AIAC::ACToolHeadType {
    DRILLBIT,
    CIRCULARSAW,
    SABERSAW,
    CHAINSAW
};
```



## holding the data of the toolheads from .acit and the corresponding GOs




        

<hr>



### typedef EQ 

```C++
using AIAC::EQ = typedef eventpp::EventQueue<EventType, void(const EventPointer&), EventPolicy>;
```




<hr>



### enum EventCategory 

```C++
enum AIAC::EventCategory {
    None = 0,
    EventCategoryApplication =              BIT(0),
    EventCategorySLAM =                     BIT(1),
    EventCategoryCamera =                   BIT(2)
};
```




<hr>



### typedef EventPointer 

```C++
using AIAC::EventPointer = typedef std::shared_ptr<Event>;
```




<hr>



### enum EventType 

```C++
enum AIAC::EventType {
    None = 0,
    AppClose,
    SLAMMapLoaded,
    SLAMVocabularyLoaded,
    SLAMStartMapping,
    SLAMStopMapping,
    SLAMCombineMapEvent,
    CameraCalibrationLoaded
};
```




<hr>



### enum GLObjectType 

```C++
enum AIAC::GLObjectType {
    POINTS,
    LINES,
    TRIANGLES
};
```




<hr>



### enum GOTypeFlags 

```C++
enum AIAC::GOTypeFlags {
    _GOPrimitive = 0,
    _GOPoint,
    _GOLine,
    _GOCircle,
    _GOCylinder,
    _GOPolyline,
    _GOTriangle,
    _GOMesh,
    _GOText
};
```




<hr>



### enum ImageFormat 

_Enum representing different image formats._ 
```C++
enum AIAC::ImageFormat {
    None = 0,
    RGB,
    RGBA,
    GRAYSCALE
};
```




<hr>



### typedef Ref 

```C++
using AIAC::Ref = typedef std::shared_ptr<T>;
```




<hr>



### typedef Scope 

```C++
using AIAC::Scope = typedef std::unique_ptr<T>;
```




<hr>
## Public Attributes Documentation




### variable VertexArrayID 

```C++
GLuint AIAC::VertexArrayID;
```




<hr>
## Public Static Attributes Documentation




### variable CUT\_EDGE\_COLOR 

```C++
std::map<ACIMState, glm::vec4> AIAC::CUT_EDGE_COLOR;
```




<hr>



### variable CUT\_FACE\_COLOR 

```C++
std::map<ACIMState, glm::vec4> AIAC::CUT_FACE_COLOR;
```




<hr>



### variable HOLE\_AXIS\_COLOR 

```C++
std::map<ACIMState, glm::vec4> AIAC::HOLE_AXIS_COLOR;
```




<hr>



### variable HOLE\_CYLINDER\_COLOR 

```C++
std::map<ACIMState, glm::vec4> AIAC::HOLE_CYLINDER_COLOR;
```




<hr>



### variable OGL\_BLACK 

```C++
const glm::vec4 AIAC::OGL_BLACK;
```




<hr>



### variable OGL\_BLUE 

```C++
const glm::vec4 AIAC::OGL_BLUE;
```




<hr>



### variable OGL\_CYAN 

```C++
const glm::vec4 AIAC::OGL_CYAN;
```




<hr>



### variable OGL\_GREEN 

```C++
const glm::vec4 AIAC::OGL_GREEN;
```




<hr>



### variable OGL\_MAGENTA 

```C++
const glm::vec4 AIAC::OGL_MAGENTA;
```




<hr>



### variable OGL\_RED 

```C++
const glm::vec4 AIAC::OGL_RED;
```




<hr>



### variable OGL\_WHITE 

```C++
const glm::vec4 AIAC::OGL_WHITE;
```




<hr>



### variable OGL\_YELLOW 

```C++
const glm::vec4 AIAC::OGL_YELLOW;
```




<hr>



### variable WEIGHT\_TO\_CYLINDER\_RADIUS\_RATE 

```C++
const float AIAC::WEIGHT_TO_CYLINDER_RADIUS_RATE;
```




<hr>



### variable s\_CursorPos 

```C++
struct AIAC::Position AIAC::s_CursorPos;
```




<hr>



### variable s\_GLFWWindowCount 

```C++
uint8_t AIAC::s_GLFWWindowCount;
```




<hr>



### variable s\_IsMouseButtonPressed 

```C++
bool AIAC::s_IsMouseButtonPressed;
```




<hr>
## Public Functions Documentation




### function CaptureFramePixels 

```C++
std::vector< GLubyte > AIAC::CaptureFramePixels (
    const ApplicationSpecification & appSpec
) 
```




<hr>



### function CreateCircle 

```C++
std::vector< std::shared_ptr< GLObject > > AIAC::CreateCircle (
    glm::vec3 center,
    glm::vec3 normal,
    float radius,
    glm::vec4 color,
    glm::vec4 edgeColor,
    float edgeWeight,
    int sectorNum
) 
```




<hr>



### function CreateCylinder 

```C++
std::vector< std::shared_ptr< GLObject > > AIAC::CreateCylinder (
    const glm::vec3 & baseCenter,
    const glm::vec3 & topCenter,
    GLfloat radius,
    glm::vec4 color,
    glm::vec4 edgeColor,
    int sectorNum
) 
```




<hr>



### function CreatePolyline 

```C++
std::vector< std::shared_ptr< GLObject > > AIAC::CreatePolyline (
    std::vector< glm::vec3 > vertices,
    bool isClosed,
    glm::vec4 color,
    float lineWidth
) 
```




<hr>



### function CreateRef 

```C++
template<typename T, typename ... Args>
constexpr Ref< T > AIAC::CreateRef (
    Args &&... args
) 
```




<hr>



### function CreateScope 

```C++
template<typename T, typename ... Args>
constexpr Scope< T > AIAC::CreateScope (
    Args &&... args
) 
```




<hr>



### function CvtCvMat2GlTextureObj 

_Convert OpenCV matrix to OpenGL texture object._ 
```C++
void AIAC::CvtCvMat2GlTextureObj (
    cv::Mat & cvMat,
    GLuint & glTextureObj,
    GLint glInternalFormat=GL_RGB
) 
```





**Parameters:**


* `cvMat` OpenCV matrix. 
* `glTextureObj` OpenGL texture object. 
* `glInternalFormat` Internal format of the OpenGL texture. 




        

<hr>



### function CvtCvMat2ImTexture 

_Convert cv::Mat to_ [_**ImTexture**_](structAIAC_1_1ImTexture.md) _, a glTextureObj is required as a texture holder._
```C++
void AIAC::CvtCvMat2ImTexture (
    cv::Mat & cvMat,
    ImTexture & imTexture,
    GLuint & glTextureObj,
    GLint glInternalFormat
) 
```



Convert OpenCV matrix to ImGui texture.




**Parameters:**


* `imTexture` The output [**ImTexture**](structAIAC_1_1ImTexture.md). 
* `glTextureObj` The texture holder. Remember to delete it with `glDeleteTextures(1, &glTextureObj)`
* `cvMat` OpenCV matrix. 
* `imTexture` ImGui texture. 
* `glTextureObj` OpenGL texture object. 
* `glInternalFormat` Internal format of the OpenGL texture. 




        

<hr>



### function CvtGlTextureObj2ImTexture 

_Convert OpenGL texture object to ImGui texture._ 
```C++
void AIAC::CvtGlTextureObj2ImTexture (
    GLuint glTextureID,
    ImTexture & imTexture,
    ImVec2 size=ImVec2(0, 0)
) 
```





**Parameters:**


* `glTextureID` OpenGL texture ID. 
* `imTexture` ImGui texture. 
* `size` Size of the texture. 




        

<hr>



### function DrawAllGOs 

_Draw all the GOs present in the_ [_**GORegistry**_](classAIAC_1_1GORegistry.md) _._
```C++
void AIAC::DrawAllGOs (
    glm::mat4 projection=glm::mat4(1.0f),
    float textScale=1.0f
) 
```





**Parameters:**


* `projection` OpenGL projection matrix. 




        

<hr>



### function DrawCircle 

_Draw a single circle._ 
```C++
void AIAC::DrawCircle (
    glm::vec3 center,
    glm::vec3 normal,
    float radius,
    glm::vec4 color,
    glm::vec4 edgeColor,
    float edgeWeight,
    int sectorNum=24
) 
```





**Parameters:**


* `center` Center of the circle. 
* `normal` The normal of plane on which the circle lays. 
* `radius` Radius of the circle. 
* `color` RGBA Color of the face. 
* `edgeColor` RGBA Color of the edge. 
* `edgeWeight` Weight of the edge. 
* `sectorNum` Number of sectors, can be derived from GetSectorNum(radius). 




        

<hr>



### function DrawCircle 

```C++
void AIAC::DrawCircle (
    const GOCircle & goCircle
) 
```




<hr>



### function DrawCircles 

```C++
void AIAC::DrawCircles (
    const std::vector< std::shared_ptr< GOCircle > > & goCircles
) 
```




<hr>



### function DrawCylinder 

_Draw a Cylinder, this is also used for drawing lines with heavy weight (&gt;1.0f)._ 
```C++
void AIAC::DrawCylinder (
    const glm::vec3 & baseCenter,
    const glm::vec3 & topCenter,
    GLfloat radius,
    glm::vec4 color,
    glm::vec4 edgeColor,
    int sectorNum=24
) 
```





**Parameters:**


* `baseCenter` Base center (bottom) of the cylinder. 
* `topCenter` Top center (top) of the cylinder. 
* `radius` Radius of the cylinder; For drawing line, radius = weight \* WEIGHT\_TO\_CYLINDER\_RADIUS\_RATE. 
* `color` Color of the cylinder. 
* `edgeColor` The color of the edges of the caps. 
* `sectorNum` Number of sectors of the cylinder. Can call `GetSectorNum(radius)` to get the default value. 




        

<hr>



### function DrawCylinder 

```C++
void AIAC::DrawCylinder (
    const GOCylinder & goCylinder
) 
```




<hr>



### function DrawCylinders 

```C++
void AIAC::DrawCylinders (
    const std::vector< std::shared_ptr< GOCylinder > > & goCylinders
) 
```




<hr>



### function DrawGO 

_Draw a_ [_**GOPrimitive**_](classAIAC_1_1GOPrimitive.md) _. (This function neglects the "isVisible" attribute of the object and will draw it anyway)_
```C++
void AIAC::DrawGO (
    const shared_ptr< GOPrimitive > & goPrimitive
) 
```





**Parameters:**


* `goPrimitive` Object to draw. 




        

<hr>



### function DrawLine 

_Draw a line on two glm::vec3._ 
```C++
void AIAC::DrawLine (
    const glm::vec3 & p1,
    const glm::vec3 & p2,
    float weight=GOWeight::Default,
    const glm::vec4 & color=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f)
) 
```





**Parameters:**


* `p1` First point. 
* `p2` Second point. 
* `weight` Weight of the line. 
* `color` RGBA Color of the line. 




        

<hr>



### function DrawLine 

```C++
void AIAC::DrawLine (
    const GOLine & goLine
) 
```




<hr>



### function DrawLines 

_Draw multiple lines._ 
```C++
void AIAC::DrawLines (
    const vector< glm::vec3 > & vertices,
    float weight,
    const glm::vec4 & color
) 
```





**Parameters:**


* `vertices` A vector of glm::vec3. If you have line [p1, p2] and [p2, p3], the vector should be construct as [p1, p2, p2, p3, ...] 
* `weight` Weight of the line. 
* `color` RGBA Color of the line. 




        

<hr>



### function DrawLines 

```C++
void AIAC::DrawLines (
    const std::vector< std::shared_ptr< GOLine > > & goLines
) 
```




<hr>



### function DrawMesh 

```C++
void AIAC::DrawMesh (
    const GOMesh & goMesh
) 
```




<hr>



### function DrawMeshes 

```C++
void AIAC::DrawMeshes (
    const std::vector< std::shared_ptr< GOMesh > > & goMeshes
) 
```




<hr>



### function DrawPoint 

_Draw a_ [_**GOPoint**_](classAIAC_1_1GOPoint.md) _._
```C++
void AIAC::DrawPoint (
    const GOPoint & goPoint
) 
```





**Parameters:**


* `goPoint` The point to draw. 




        

<hr>



### function DrawPoints 

```C++
void AIAC::DrawPoints (
    const std::vector< std::shared_ptr< GOPoint > > & goPoints
) 
```




<hr>



### function DrawPolyline 

```C++
void AIAC::DrawPolyline (
    const GOPolyline & goPolyline
) 
```




<hr>



### function DrawPolylines 

```C++
void AIAC::DrawPolylines (
    const std::vector< std::shared_ptr< GOPolyline > > & goPolylines
) 
```




<hr>



### function DrawSlamMap 

_Draw TSlam map._ 
```C++
void AIAC::DrawSlamMap (
    const std::shared_ptr< tslam::Map > & map,
    const glm::vec4 & color,
    float pointSize=1
) 
```





**Parameters:**


* `map` A TSlam map 
* `color` The color of the point cloud 




        

<hr>



### function DrawSlamMap 

_Render Slam map on the current frame._ 
```C++
void AIAC::DrawSlamMap (
    const shared_ptr< tslam::Map > & map,
    const glm::vec4 & color,
    float pointSize
) 
```





**Parameters:**


* `map` A tslam map to be rendered. 
* `color` PointCloud's color. 
* `pointSize` PointCloud's size. 




        

<hr>



### function DrawText 

```C++
void AIAC::DrawText (
    const GOText & goText,
    float scale,
    const glm::mat4 & projection
) 
```




<hr>



### function DrawTexts 

```C++
void AIAC::DrawTexts (
    const std::vector< std::shared_ptr< GOText > > & goTexts,
    float scale,
    const glm::mat4 & projection
) 
```




<hr>



### function DrawTexts 

```C++
void AIAC::DrawTexts (
    std::vector< GOText > goTexts,
    float scale=1.0f,
    const glm::mat4 & projection=glm::mat4(1.0f)
) 
```




<hr>



### function DrawTriangle 

```C++
void AIAC::DrawTriangle (
    const GOTriangle & goTriangle
) 
```




<hr>



### function DrawTriangles 

```C++
void AIAC::DrawTriangles (
    const std::vector< std::shared_ptr< GOTriangle > > & goTriangles
) 
```




<hr>



### function GetRigidTransformationMatrix 

_Get the rigid transformation matrix from two correlated set of 3D points @praam srcPts The source points._ 
```C++
glm::mat4x4 AIAC::GetRigidTransformationMatrix (
    std::vector< glm::vec3 > srcPts,
    std::vector< glm::vec3 > dstPts
) 
```





**Parameters:**


* `dstPts` The destination points 




        

<hr>



### function GetRotationMatrix 

_Get the rotation matrix associated with counterclockwise rotation about the given axis by theta radians._ 
```C++
glm::mat3x3 AIAC::GetRotationMatrix (
    glm::vec3 axis,
    float theta
) 
```





**Parameters:**


* `axis` The axis of rotation. 
* `theta` The angle of rotation in radians.



**Returns:**

The rotation matrix. 





        

<hr>



### function GetSectorNum 

```C++
int AIAC::GetSectorNum (
    float radius
) 
```




<hr>



### function GetTransformed 

_Combine 3 points into a glm::vec3 and transform it based on the given transformation matrix._ 
```C++
glm::vec3 AIAC::GetTransformed (
    glm::mat4 transformMat,
    float x,
    float y,
    float z
) 
```





**Parameters:**


* `transformMat` A 4x4 transformation matrix. 
* `x` X coordinate. 
* `y` Y coordinate. 
* `z` Z coordinate. 




        

<hr>



### function GetTranslationMatrix 

_Get the translation matrix associated with the given translation vector._ 
```C++
glm::mat4x4 AIAC::GetTranslationMatrix (
    glm::vec3 translationVector
) 
```





**Parameters:**


* `translationVector` The translation vector



**Returns:**

The translation matrix 





        

<hr>



### function StringToBool 

_Convert a string to bool._ 
```C++
bool AIAC::StringToBool (
    std::string str
) 
```





**Parameters:**


* `str` string 



**Returns:**

bool 





        

<hr>



### function StringToSet 

_Convert a string separated by space to a set of tokens._ 
```C++
std::set< std::string > AIAC::StringToSet (
    std::string str
) 
```





**Parameters:**


* `str` string separated by space 



**Returns:**

a std::set&lt;std::string&gt; 





        

<hr>



### function StringToState 

_Convert string m\_State to ACIMState._ 
```C++
ACIMState AIAC::StringToState (
    std::string m_State
) 
```





**Parameters:**


* `m_State` ACIMState 




        

<hr>



### function StringToTokens 

_Convert a string separated by space to a list of string._ 
```C++
std::vector< std::string > AIAC::StringToTokens (
    std::string str
) 
```





**Parameters:**


* `str` string separated by space 



**Returns:**

a std::vector&lt;std::string&gt; 





        

<hr>



### function StringToVec3 

_Convert a string separated by space to glm::vec3._ 
```C++
glm::vec3 AIAC::StringToVec3 (
    std::string str
) 
```





**Parameters:**


* `str` string separated by space 



**Returns:**

glm::vec3 





        

<hr>



### function Vec3ToString 

_Convert a vec3 to String._ 
```C++
std::string AIAC::Vec3ToString (
    glm::vec3 vec3
) 
```





**Parameters:**


* `vec3` vec3 



**Returns:**

string 





        

<hr>



### function glDrawLines3d 

_Draw multiple points._ 
```C++
void AIAC::glDrawLines3d (
    const std::vector< glm::vec3 > & edges,
    const std::vector< glm::vec4 > & colors
) 
```



Draw multiple lines


(0, 1, 0)  (1, 0, 0) 
||
|-----|
||



(0, 0, 0)  (0, 0, 1)


If you want to draw a square like this, you should construct the `edges` as: [ (0, 0, 0), (0, 0, 1), (0, 0, 1), (1, 0, 0), (1, 0, 0), (0, 1, 0), (0, 1, 0), (0, 0, 0) ]




**Parameters:**


* `vertices` A vector of 3d points, indicate the position of the vertices. 
* `colors` A RGBA(0~1.0) color, a vector with the same size of the `vertices`. 




        

<hr>



### function glDrawLines3d 

_Draw multiple points._ 
```C++
void AIAC::glDrawLines3d (
    const std::vector< glm::vec3 > & edges,
    const glm::vec4 & color
) 
```





**Parameters:**


* `vertices` A vector of 3d points, indicate the position of the vertices. 
* `colors` A RGBA(0~1.0) color. 




        

<hr>



### function glDrawPoints3d 

_Draw multiple points._ 
```C++
void AIAC::glDrawPoints3d (
    const std::vector< glm::vec3 > & vertices,
    const std::vector< glm::vec4 > & colors,
    GLfloat pointSize=1.0f
) 
```





**Parameters:**


* `vertices` A vector of 3d points, indicate the position of the vertices. 
* `colors` A RGBA(0~1.0) color, a vector with the same size of the `vertices`. 
* `pointSize` The size of the point. 




        

<hr>



### function glDrawPoints3d 

_Draw multiple points._ 
```C++
void AIAC::glDrawPoints3d (
    const std::vector< glm::vec3 > & vertices,
    const glm::vec4 & color,
    GLfloat pointSize=1.0f
) 
```





**Parameters:**


* `vertices` A vector of 3d points, indicate the position of the vertices. 
* `colors` A RGBA(0~1.0) color. 
* `pointSize` The size of the point. 




        

<hr>



### function glDrawTriangles3d 

_Draw multiple Triangles._ 
```C++
void AIAC::glDrawTriangles3d (
    const std::vector< glm::vec3 > & vertices,
    const std::vector< uint32_t > & indices,
    const std::vector< glm::vec4 > & colors
) 
```



P2(0, 1, 0)  P3(1, 0, 0) \| / \| \| / \| \| / \| \| / \| \| / \| P0(0, 0, 0)  P1(0, 0, 1)


If you want to draw a mesh of square like this, you should construct the `edges` as: [ (0, 0, 0), // P0 (0, 0, 1), // P1 (1, 0, 0), // P2 (0, 1, 0), // P3 ] with `indices`: [ 0, 1, 3, // Right-bottom triangle 3, 2, 0 // Left-top triangle ]




**Parameters:**


* `vertices` A vector of 3d points, indicate the position of the vertices. 
* `indices` A vector of all triangle's indices. 
* `colors` A RGBA(0~1.0) color, a vector with the same size of the vertices. 




        

<hr>



### function glDrawTriangles3d 

_Draw multiple Triangles._ 
```C++
void AIAC::glDrawTriangles3d (
    const std::vector< glm::vec3 > & vertices,
    const std::vector< uint32_t > & indices,
    const glm::vec4 & colors
) 
```





**Parameters:**


* `vertices` A vector of 3d points, indicate the position of the vertices. 
* `indices` A vector of all triangle's indices. 
* `colors` A RGBA(0~1.0) color, a vector with the same size of the vertices. 




        

<hr>



### function operator&gt;&gt; 

```C++
void AIAC::operator>> (
    cv::VideoCapture cap,
    AIAC::Image & img
) 
```




<hr>
## Public Static Functions Documentation




### function GLFWErrorCallback 

```C++
static void AIAC::GLFWErrorCallback (
    int error,
    const char * description
) 
```




<hr>



### function GLFWMonitorCallback 

```C++
static void AIAC::GLFWMonitorCallback (
    GLFWmonitor * monitor,
    int event
) 
```




<hr>



### function IsGlfwInitialized 

```C++
static bool AIAC::IsGlfwInitialized () 
```




<hr>

------------------------------
The documentation for this class was generated from the following file `src/AIAC/ACInfoModel.cpp`

